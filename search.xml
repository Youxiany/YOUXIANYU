<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2023我的创作纪念日</title>
      <link href="/2024/01/24/2023%E6%88%91%E7%9A%84%E5%88%9B%E4%BD%9C%E7%BA%AA%E5%BF%B5%E6%97%A5/"/>
      <url>/2024/01/24/2023%E6%88%91%E7%9A%84%E5%88%9B%E4%BD%9C%E7%BA%AA%E5%BF%B5%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/01/24/65Me4GPbJTd8S2i.png" alt="2023blog_6.png"></p><h2 id="机缘"><a href="#机缘" class="headerlink" title="机缘"></a>机缘</h2><ol><li><p>其实是为了记录学习笔记，但更多是为了和大家分享经验。</p></li><li><p>在创作的过程中激发我的开发热心，提高写作水平，</p></li><li><p>通过文章进行与其他博主或访客的技术交流我感到很快乐</p></li></ol><hr><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ol><li><p>起初我并不在意粉丝量和访问量的，但如果真和我想象中的那样，就说明我的文章质量不太好，所以后来我尽量避免文章水分，将文章写精细点，后来粉丝数和访问量就上来了。</p></li><li><p>我开始喜欢上CSDN平台上的勋章了，为了那几枚勋章，我创作了不少优质文章</p></li><li><p>因为新星计划，我永远不会忘记那个新星导师的名字，使我从Python基础入门到了网络爬虫，这是23年最值得提起的事情</p></li><li><p><img src="https://s2.loli.net/2024/01/24/ecNTy41howsr25K.png" alt="2023blog_1.png"><img src="https://s2.loli.net/2024/01/24/acfvdk1WlnPrj3u.png" alt="2023blog_2.png"><img src="https://s2.loli.net/2024/01/24/7fCA5PeRHSEMvpG.png" alt="2023blog_3.png"><img src="https://s2.loli.net/2024/01/24/6efUrz3ojGb4EpM.png" alt="2023blog_4.png"></p></li></ol><hr><h2 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h2><ol><li>现在处于高三阶段，创作的时间并不充裕，暑假一个月能写15篇文章，现在4个月都没有10篇了。</li><li>平时会看看极客资讯，看一下其他博主的写作风格。</li><li>每次做完一个项目的时候，我都会计划下一个任务。</li></ol><hr><h2 id="成就"><a href="#成就" class="headerlink" title="成就"></a>成就</h2><ol><li><p>我写的Python代码，连它的哲学理念：“优雅”都配不上了，用判断语句代替异常捕捉语句；从来不写类，继承和函数封装……</p></li><li><p>编程第一法则：“<strong>程序不论写的多么乱，能运行就对了</strong>”。这是我去年写的爬虫代码的一部分，全是if，但一个项目完成后，它是完全可以运行没有任何问题的。<img src="https://s2.loli.net/2024/01/24/vSgbjhCkDHOXNno.png" alt="2023blog_10.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  lists!= CANCEL:    </span><br><span class="line">        new_title = jsonpath.jsonpath(json_requests, <span class="string">&#x27;$..title&#x27;</span>)[<span class="built_in">int</span>(lists) - <span class="number">1</span>]</span><br><span class="line">        new_urls = jsonpath.jsonpath(json_requests, <span class="string">&#x27;$..url&#x27;</span>)[<span class="built_in">int</span>(lists) - <span class="number">1</span>]</span><br><span class="line">        new_author = jsonpath.jsonpath(json_requests, <span class="string">&#x27;$..author&#x27;</span>)[<span class="built_in">int</span>(lists) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        new_titles = re.sub(<span class="string">&#x27;[/;,/\&#x27;]&#x27;</span>, <span class="string">&#x27;&#x27;</span>,new_title)</span><br><span class="line">        local_name = <span class="string">f&#x27;<span class="subst">&#123;PATH_loacl&#125;</span><span class="subst">&#123;new_titles&#125;</span>.mp3&#x27;</span></span><br><span class="line">      </span><br><span class="line">        download_return = requests.get(new_urls, stream=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        content_size = <span class="built_in">int</span>(download_return.headers[<span class="string">&#x27;Content-Length&#x27;</span>]) / <span class="number">1024</span>      <span class="comment"># 获取文件的字节大小</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> os.path.exists(PATH_loacl) == <span class="literal">False</span>:</span><br><span class="line">            <span class="built_in">print</span>(os.path.exists)</span><br><span class="line">            os.mkdir(PATH_loacl)</span><br><span class="line"></span><br><span class="line">        files = <span class="built_in">open</span>(local_name, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> tqdm(iterable = download_return.iter_content(<span class="number">1024</span>),  <span class="comment"># 分段下载</span></span><br><span class="line">                      total = content_size,   <span class="comment"># 总大小</span></span><br><span class="line">                      unit = <span class="string">&#x27;k&#x27;</span>,         <span class="comment"># 单位为K</span></span><br><span class="line">                      desc = <span class="string">&#x27;文件大小：&#x27;</span>  <span class="comment"># 注释下载标题</span></span><br><span class="line">                      ):</span><br><span class="line">            files.write(j)</span><br></pre></td></tr></table></figure></li><li><p>2023年做的最具有成就意义的三件事：</p><ul><li><strong>使用Unity3D+C#开发出了我的第一款游戏：RezspairX</strong><br> <img src="https://s2.loli.net/2024/01/24/5e1sAv6SPRypKmw.png" alt="2023blog_8.png"><img src="https://s2.loli.net/2024/01/24/CHuxb2ymWSpZR1k.png" alt="2023blog_7.png"></li><li><strong>使用Python开发出了爬虫小程序：MufreePro</strong><img src="https://s2.loli.net/2024/01/24/wlYjZ7NWeshSRgy.png" alt="2023blog_5.png"></li><li><strong>使用Hexo+Anzhiyu发布了我目前最好的个人博客</strong><img src="https://s2.loli.net/2024/01/24/oAhVnzaLctbEuTi.png" alt="2023blog_9.png"></li></ul></li></ol><hr><h2 id="憧憬"><a href="#憧憬" class="headerlink" title="憧憬"></a>憧憬</h2><ol><li>希望高中毕业后，无论如何都要找个大学大专也好，攻读计算机。</li><li>此外，我还希望以后能开发一个项目，并开源。</li><li>前端工程师；数据分析师；软件开发或设计者；</li><li>未来愿如我所期……</li></ol><p><img src="https://s2.loli.net/2024/01/24/cKtkAaRL9zm3ofT.jpg" alt="2023blog_11.jpg"><img src="https://s2.loli.net/2024/01/24/SFTdzt9I6EBGK4v.jpg" alt="2023blog_12.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 周年 </category>
          
          <category> 2023 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> 2023 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的个人博客发布成功啦!!!</title>
      <link href="/2024/01/23/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B8%83%E6%88%90%E5%8A%9F%E5%95%A6/"/>
      <url>/2024/01/23/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B8%83%E6%88%90%E5%8A%9F%E5%95%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="我的个人博客发布成功啦！！！"><a href="#我的个人博客发布成功啦！！！" class="headerlink" title="我的个人博客发布成功啦！！！"></a>我的个人博客发布成功啦！！！</h1><blockquote><ol><li>这大概是两年前的是吧？我曾一直希望自己能搭建并上传自己的个人博客，但是受服务器和虚拟机的影响（太贵了，时间久了，对于我们学生党来说，确实是不小的开支）</li><li>此外，还受到框架因素的影响，原本是采用原生的H5+CSS+JavaScript搭建博客的，后来有去WordPress，都不太行（这样的网站框架只能上传到虚拟机中）最后选择了Hexo框架：纯静态框架（因为GitHub和Gitee听说是可以免费托管静态网站的）</li><li>时长两年半，我最最终还是在Gitee中发布了。（真的花了我不少时间，尤其是在高三段）</li></ol></blockquote><ul><li>网站框架采用：<a href="https://hexo.io/zh-cn/">Hexo</a> （Static Frame）</li><li>框架主题源自：<a href="https://github.com/anzhiyu-c/anzhiyu-docs/">Hexo-Theme-Anzhiyu</a>（开源项目）</li><li>托管平台：<a href="https://gitee.com/">Gitee</a>（码云）</li></ul><h3 id="博客网站正处于持续更新阶段……"><a href="#博客网站正处于持续更新阶段……" class="headerlink" title="博客网站正处于持续更新阶段……"></a>博客网站正处于持续更新阶段……</h3><ol><li>因为是基于Hexo-Theme-Butterfly主题，不管怎么样，我们都是要熟悉该主题项目的源码的，所以在魔改和更新的路上并不会很顺利，主要是耗时间……</li><li>Anzhiyu主题为我们提供了一本主题手册，这比原生的Butterfly好太多。</li></ol><h3 id="现在终于可以安心干其他事了"><a href="#现在终于可以安心干其他事了" class="headerlink" title="现在终于可以安心干其他事了"></a>现在终于可以安心干其他事了</h3><ol><li>因为搭建博客原因，我很多事情都被耽误，如我Python网络编程，网络爬虫，C#，还有TypeScript。</li><li>个人博客不仅我提供了一个任意处置的个人空间，还能够记录学习笔记，相当于CSDN还好不少</li><li>咱就是说，学就完了……</li></ol>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
          <category> 成就 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FydeOS17国产操作系统全过程安装【保姆级教程】</title>
      <link href="/2024/01/23/FydeOS17%E5%9B%BD%E4%BA%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A8%E8%BF%87%E7%A8%8B%E5%AE%89%E8%A3%85/"/>
      <url>/2024/01/23/FydeOS17%E5%9B%BD%E4%BA%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A8%E8%BF%87%E7%A8%8B%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h2 id="系统介绍"><a href="#系统介绍" class="headerlink" title="系统介绍"></a>系统介绍</h2><p><strong>什么是FydeOS ?</strong></p><blockquote><p>FydeOS （原名 Flint OS）是由燧炻科技创新（北京）有限责任公司基于开源项目 Chromium Project 二次开发，适配<br>x86 与 ARM 硬件平台，定位于中国版的 Google Chrome OS。<br>FydeOS提供包括操作系统产品定制化的技术咨询、解决方案以及商业授权服务。<br><img src="https://img-blog.csdnimg.cn/direct/20c93da2a92b4f378e9f244b1c29b78b.png" alt="在这里插入图片描述"></p></blockquote><blockquote><p>FydeOS 是一款基于Linux+Chromium Project开发的轻量级操作系统，它的和Google的Chrome OS极为相似，有着ChromeBook和MacOS类似的使用体验，能够在大部分主流硬件上平稳运行，并且兼容Android应用程序和Linux。<br>以浏览器平台为基础，加入更多符合国内用户习惯的本地化功能以提升用户体验。经过长期的技术积累，FydeOS 有能力运行在各种主流的硬件设备之中并提供围绕 FydeOS 展开的整体解决方案。</p></blockquote><blockquote><p>FydeOS适应了时代的发展，作为轻量级的操作系统，它能够轻松运行在老旧的计算机中，甚至是十几年前的电脑，从关机到桌面显示只需要几秒钟，正如它的价值观所说：“世间众生平等，硬件亦无高低贵贱之分。”</p></blockquote><h2 id="材料："><a href="#材料：" class="headerlink" title="材料："></a>材料：</h2><ul><li>一个至少空闲16GB的U盘</li><li>电脑运行内存至少4GB以上</li><li>USB 启动盘的辅助工具</li></ul><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><h3 id="FydeOS镜像下载"><a href="#FydeOS镜像下载" class="headerlink" title="FydeOS镜像下载"></a>FydeOS镜像下载</h3><ol><li><p>下载镜像首先登陆Fyde OS的官方网站 <a href="https://fydeos.com/download/">https://fydeos.com/download/</a></p></li><li><p>选择你所对应的设备。支持PC机，虚拟机，和定制系统，</p></li><li><p>我们选择 FydeOS For PC</p></li><li><p>FydeOS For PC有三个选项可选</p><p> 1.还在使用三代或七代的英特尔(Intel)处理器并且是集成显卡的老电脑可以选择，一般十多年前的老电脑就可以选择。<br> 2.八代到十二代的英特尔(Intel)处理器并且是集成显卡的新机可以选择。<br> 3.搭载的是AMD Radeon系列的集成显卡及处理器的电脑可以选择。</p></li></ol><p>我们选择第一个选项。</p><p><img src="https://img-blog.csdnimg.cn/direct/d6e2512bcc934356a226a9f328d0d2f6.png" alt="请添加图片描述"></p><ol start="5"><li>我们选择推荐下载：”通过OneDrive下载”。<br><img src="https://img-blog.csdnimg.cn/direct/3abef362634946a887244a87626afc8f.png" alt="在这里插入图片描述"></li><li>页面跳转后，直接点击下载。并等待下载完成。<br><img src="https://img-blog.csdnimg.cn/direct/c012e6e1564f46d2b20daae10ce30281.png" alt="在这里插入图片描述"></li></ol><h3 id="Rufus-U盘启动工具下载"><a href="#Rufus-U盘启动工具下载" class="headerlink" title="Rufus U盘启动工具下载"></a>Rufus U盘启动工具下载</h3><blockquote><p>Rufus 是一个开源免费的快速制作 U 盘系统启动盘和格式化 USB 的实用小工具，它可以快速把 ISO<br>格式的系统镜像文件快速制作成可引导的 USB 启动安装盘，支持 Windows 或 Linux 启动。Rufus 小巧玲珑，软件体积仅 7<br>百多 KB，然而麻雀虽小，它却五脏俱全……</p></blockquote><ol><li>前往Rufus中文官网：<a href="https://rufus.ie/zh/">https://rufus.ie/zh/</a></li><li>下拉找到最新版本，并点击标准版下载。</li></ol><p><img src="https://img-blog.csdnimg.cn/direct/5195471d0cab4c358a1f8890ea390fcd.png" alt="在这里插入图片描述"></p><h3 id="制作U盘系统启动盘"><a href="#制作U盘系统启动盘" class="headerlink" title="制作U盘系统启动盘"></a>制作U盘系统启动盘</h3><ol><li>FydeOS镜像和Rufus下载好后，会出现以下文件。<br><img src="https://img-blog.csdnimg.cn/direct/0f0e19482745417d979b561941d2251f.png" alt="在这里插入图片描述"></li><li>我们双击打开rufus。</li><li>制作U盘系统启动工具我们需要进行一下操作：<ol><li>选择可用的U盘设备（注意：如U盘内有重要文件，请及时备份！！！）</li><li>选择一下载好的FydeOS系统镜像文件</li><li>其他均默认</li><li>当状态显示准备就绪时，则开始制作</li></ol></li></ol><p><img src="https://img-blog.csdnimg.cn/direct/78f15c7b3fa84f96aa8bccf1aaa04266.png" alt="在这里插入图片描述"></p><ol start="4"><li>再次确认U盘内的数据备份，确认完毕后点击确定。</li></ol><p><img src="https://img-blog.csdnimg.cn/direct/6c1728ca602643189bfbb0622df75831.png" alt="在这里插入图片描述"></p><ol start="5"><li>最后等待镜像数据写入……<br><img src="https://img-blog.csdnimg.cn/direct/f16bb920526b461093669ce2852a3130.png" alt="在这里插入图片描述"></li><li>写入完成后点击关闭。<br><img src="https://img-blog.csdnimg.cn/direct/276acb5d5f7f45669747179ffd7afa78.png" alt="在这里插入图片描述"></li></ol><h2 id="安装FydeOS"><a href="#安装FydeOS" class="headerlink" title="安装FydeOS"></a>安装FydeOS</h2><h3 id="设置U盘UEFI模式启动"><a href="#设置U盘UEFI模式启动" class="headerlink" title="设置U盘UEFI模式启动"></a>设置U盘UEFI模式启动</h3><ol><li>我们将U盘插入到需要安装的电脑中，并点击开机</li><li>在进入到系统前，我们立即点击<kbd>ESC</kbd> 或 <kbd>F8</kbd>键进入到Bios面板。</li><li>选择到Boot界面，将Boot Option优先权设置为U盘启动，这样我们在启动时进入的就是U盘中的FydeOS系统。<br><img src="https://img-blog.csdnimg.cn/direct/5c77264840044c24abe24ba1e176fa93.png" alt="在这里插入图片描述"></li><li>选择到Save&amp;Exit界面，选择 “Save Changes and Exit” 保存并退出<img src="https://img-blog.csdnimg.cn/direct/f648974a119241e6a1ca5f7dd31ff704.png" alt="在这里插入图片描述"></li></ol><h3 id="FydeOS部署"><a href="#FydeOS部署" class="headerlink" title="FydeOS部署"></a>FydeOS部署</h3><ol><li><p>重启后它会自动进入U盘中的FydeOS系统，并出现开机图标。<br><img src="https://img-blog.csdnimg.cn/direct/1c3d307d848e45fab7194a3795a4ba69.png" alt="在这里插入图片描述"></p></li><li><p>显示欢迎界面后，选择好语言 [中文（简体）]<br><img src="https://img-blog.csdnimg.cn/direct/3d2f1dd39db041cf8183c127a642c16e.png" alt="在这里插入图片描述"></p></li><li><p>直接下一步<br><img src="https://img-blog.csdnimg.cn/direct/07e22d3f34f946d09ac8bcbe88ae19e5.png"></p></li><li><p>选择 “安装FydeOS” （正式地在电脑中安装FydeOS），选择好后就点击 “下一步”</p></li><li><p>如果你不想保留分区只保留一个FydeOS系统的话，就选择 “全盘安装” ，并 “下一步”<br><img src="https://img-blog.csdnimg.cn/direct/7a4ff07cb0054d39803506c64ac8d67c.png" alt="在这里插入图片描述"></p></li><li><p>安装需要要在有网络的环境下进行，所以在此之前你需要先连接一下网络，否则会卡在安装界面。在右下角时间栏内可配置网络。</p></li><li><p>完事之后点击安装即可。（大约会花个7-10分钟)<br><img src="https://img-blog.csdnimg.cn/direct/af6ff4b3515b4ca39f8eeabf5f04af35.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/direct/8b03133e1bb848979d8e68dac72f8b10.png" alt="在这里插入图片描述"></p></li><li><p>安装完成后，重启电脑。</p></li><li><p>重启后可能要重新配置语言，同意服务协议，配置网络信息，和注册本地账号。这里就不再赘述。</p></li></ol><h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><ol><li>配置完后即可进入桌面，如图：</li></ol><p><img src="https://img-blog.csdnimg.cn/direct/d3a1a0c631b746b8b8f2ecb313b12ac0.png" alt="请添加图片描述"><br>2. 我们打开任务正中间的蓝色图标（Chromium浏览器）看看是否能正常浏览网页，我们再下载个壁纸装上试试。一切都很正常！！！<br><img src="https://img-blog.csdnimg.cn/direct/0a5c81636b8942b1aebdfc63c5648b3c.png" alt="请添加图片描述"><br><img src="https://img-blog.csdnimg.cn/direct/b9dc316ba82249ffa523a92d84f2c53a.png" alt="请添加图片描述"><br><img src="https://img-blog.csdnimg.cn/direct/85eda9473bad4d5f8920b410ef91ea44.png" alt="请添加图片描述"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><ol><li>FydeOS给人第一感受就是非常非常的简约，轻便，和快速。十分适合用来创作，设计，和开发小项目。</li><li>我也是首次体验国产操作系统，它的使用效果还是令人出乎意料的，不过目前我对它的认知程度也只是像文章内容的那样。<br>如果后续有什么新的探索发现我们再分享。<br>小伙伴们赶紧去体验吧！！!</li></ol>]]></content>
      
      
      <categories>
          
          <category> 系统安装 </category>
          
          <category> 国产系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FydeOS </tag>
            
            <tag> 国产系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HarmonyOS4.0应用开发【学习笔记3：安装DevEco Studio开发环境】</title>
      <link href="/2024/01/14/HarmonyOS4.0%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%EF%BC%9A%E5%AE%89%E8%A3%85DevEco%20Studio%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%91/"/>
      <url>/2024/01/14/HarmonyOS4.0%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%EF%BC%9A%E5%AE%89%E8%A3%85DevEco%20Studio%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="DevEco-Studio"><a href="#DevEco-Studio" class="headerlink" title="DevEco Studio"></a>DevEco Studio</h2><blockquote><ol><li>HUAWEI DevEco Studio 是基于IntelliJ IDEA Community开源版本打造，为运行在HarmonyOS和OpenHarmony系统上的应用和服务（以下简称应用&#x2F;服务）提供一站式的开发平台。</li><li>是面向全场景多设备，提供一站式的分布式应用开发平台，支持分布式多端开发、分布式多端调测、多端模拟仿真，全方位的质量与安全保障。</li></ol></blockquote><blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>高效智能代码编辑：支持ArkTS、JS、C&#x2F;C++等语言的代码高亮、代码智能补齐、代码错误检查、代码自动跳转、代码格式化、代码查找等功能，提升代码编写效率。更多详细信息，请参考编辑器使用技巧。</li><li>低代码可视化开发：丰富的UI界面编辑能力，支持自由拖拽组件和可视化数据绑定，可快速预览效果，所见即所得；同时支持卡片的零代码开发，降低开发门槛和提升界面开发效率。更多详细信息，请参考使用低代码开发应用&#x2F;服务。</li><li>多端双向实时预览：支持UI界面代码的双向预览、实时预览、动态预览、组件预览以及多端设备预览，便于快速查看代码运行效果。更多详细信息，请参考使用预览器预览应用&#x2F;服务界面效果。</li><li>多端设备模拟仿真：提供HarmonyOS本地模拟器，支持手机等设备的模拟仿真，便捷获取调试环境。更多详细信息，请参考使用模拟器运行应用&#x2F;服务。</li></ul></blockquote><h2 id="安装DevEco-Studio"><a href="#安装DevEco-Studio" class="headerlink" title="安装DevEco Studio"></a>安装DevEco Studio</h2><ol><li>所谓工欲善其事，必先利其器。在学习开发HarmonyOS应用之前，我们需要安装套件之一DevEco Studio，前面我们也说了，我们可以把这个软件理解为一个总编辑器，相当于Unity引擎一样。</li><li>前往官网下载</li></ol><ul><li>HarmonyOS DevEco Studio官网下载：<a href="https://developer.harmonyos.com/cn/develop/deveco-studio/#download">https://developer.harmonyos.com/cn/develop/deveco-studio/#download</a></li></ul><ol start="3"><li>在下载安装之前 Windows和Mac操作系统分别需要需要符合以下条件（开发者慎重考虑）</li></ol><ul><li>操作系统：Windows 10&#x2F;11 64 位  ||  macOS(X86) 10.15&#x2F;11&#x2F;12&#x2F;13 macOS(ARM) 11&#x2F;12&#x2F;13</li><li>内存：8GB 及以上  ||  8GB 及以上</li><li>硬盘：100GB 及以上  || 100GB 及以上</li><li>分辨率：1280<em>800 像素及以上  ||  1280</em>800 像素及以上</li></ul><ol start="3"><li>选择好对应的系统版本</li></ol><p><img src="https://img-blog.csdnimg.cn/direct/c5e117588f0e43eab6144879290f4cf6.png" alt="在这里插入图片描述"><br>5. 下载完成后将安装包解压出来<br><img src="https://img-blog.csdnimg.cn/direct/675850efbb8b40718929a739097798da.png" alt="在这里插入图片描述"></p><h2 id="安装DevEco-Studio-1"><a href="#安装DevEco-Studio-1" class="headerlink" title="安装DevEco Studio"></a>安装DevEco Studio</h2><ol><li>选择好安装目录（需要3GB以上的空间)<br><img src="https://img-blog.csdnimg.cn/direct/0670f882955a4921ae7abfe8eba38e45.png" alt="在这里插入图片描述"></li><li>安装选项</li></ol><ul><li>勾选 “创建桌面快捷键” 选项（必选）</li><li>勾选 “添加环境变量” 选项（必选）</li><li>创建Vscode工程项目 可选可不选<br><img src="https://img-blog.csdnimg.cn/direct/c600f8e545004570bcad2d1bb2aa1be9.png" alt="在这里插入图片描述"></li></ul><ol start="3"><li>是否重启电脑，选择第二项，单击 “Finish” 完成安装<br><img src="https://img-blog.csdnimg.cn/direct/c8a79876c30c40e7be24485a4873286a.png" alt="在这里插入图片描述"></li></ol><h2 id="配置DevEco-Studio"><a href="#配置DevEco-Studio" class="headerlink" title="配置DevEco Studio"></a>配置DevEco Studio</h2><ol><li>是否导入已下载好的开发者工具，不导入选择第二项 并OK<img src="https://img-blog.csdnimg.cn/direct/2b127f1f6ecd46ba88e8ca475564e788.png" alt="在这里插入图片描述"></li><li>Basic Setup安装界面配置：</li></ol><ul><li>安装Node.JS（如果有则选择Local，没有则选择Install，并确定好选择好文件夹）</li><li>安装Ohpm环境 （一般都没有，所以选择Install选项，并确定好文件夹）</li></ul><p><strong>注意：如果你安装了Node.JS环境，一般版本不能大于或晚于所这支持的版本，如果显示了如图所示的提示，那么则说明你需要重新安装一个所需的版本</strong><br><img src="https://img-blog.csdnimg.cn/direct/6d1876a0d7634c93928cdc6b55cfb0ff.png" alt="在这里插入图片描述"></p><ul><li>“Next</li><li><img src="https://img-blog.csdnimg.cn/direct/e6b1eac79a1740f8aaeb426ae2e27318.png" alt="在这里插入图片描述"></li></ul><ol start="3"><li><p>SDK安装界面：选择好安装位置即可。<img src="https://img-blog.csdnimg.cn/direct/a22058f53a9d4bfcb14147dca59ce997.png" alt="在这里插入图片描述"></p></li><li><p>Summry协议界面：选择Accept，直接一路点击Next即可</p></li><li><p>最后会开始安装所有开发环境（安装可能会花比较长的时间，耐心等待……）。<img src="https://img-blog.csdnimg.cn/direct/527d4425acff426eab57ef201cb85d1c.png" alt="在这里插入图片描述"></p></li><li><p>出现这个界面，就说明安装完成了，你也可以在左下角的 “Help” &gt; “Diagnose Development Environment” 中检查环境是否完整，如果不完整可以在在里面补全。<br><img src="https://img-blog.csdnimg.cn/direct/42e46d13fed0405ea1d8a50aaec71ffa.png" alt="在这里插入图片描述"></p></li></ol><p><img src="https://img-blog.csdnimg.cn/direct/5a72bd389f88443eb3b91be9b8ef2902.png" alt="在这里插入图片描述"></p><ol start="7"><li>到这里，安装就完成了，总体来说还是比较简单的，唯独环境配置安装却是最有可能出错的，我们有可以通过HarmonyOS官方提供的文档指导安装：<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/deveco_overview-0000001053582387-V3?catalogVersion=V3">https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/deveco_overview-0000001053582387-V3?catalogVersion&#x3D;V3</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> HarmonyOS </category>
          
          <category> HarmonyOS应用开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HarmonyOS </tag>
            
            <tag> 应用开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章添加标签，封面，标题，日期（Hexo）</title>
      <link href="/2024/01/14/%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE%EF%BC%8C%E5%B0%81%E9%9D%A2%EF%BC%8C%E6%A0%87%E9%A2%98%EF%BC%8C%E6%97%A5%E6%9C%9F%EF%BC%88Hexo%EF%BC%89/"/>
      <url>/2024/01/14/%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE%EF%BC%8C%E5%B0%81%E9%9D%A2%EF%BC%8C%E6%A0%87%E9%A2%98%EF%BC%8C%E6%97%A5%E6%9C%9F%EF%BC%88Hexo%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="文章-导航页添加标签，封面，标题，日期（Hexo）"><a href="#文章-导航页添加标签，封面，标题，日期（Hexo）" class="headerlink" title="文章&#x2F;导航页添加标签，封面，标题，日期（Hexo）"></a>文章&#x2F;导航页添加标签，封面，标题，日期（Hexo）</h2><h4 id="我们只需要在写好的Markdown文本中的顶部加入这些代码即可"><a href="#我们只需要在写好的Markdown文本中的顶部加入这些代码即可" class="headerlink" title="我们只需要在写好的Markdown文本中的顶部加入这些代码即可"></a>我们只需要在写好的Markdown文本中的顶部加入这些代码即可</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`title: Python Socket TCP简单通信【二】 #  设置文章标题`</span></span><br><span class="line"></span><br><span class="line"><span class="code">`date: 2017-05-27 13:47:33       # 设置发布时间（默认不设）`</span></span><br><span class="line"></span><br><span class="line"><span class="code">`cover: img\post_ing\1.jpg       # 设置文章封面（包括标题封面）`</span></span><br><span class="line"></span><br><span class="line"><span class="code">`categories:              # 添加分类`</span></span><br><span class="line"></span><br><span class="line"><span class="code">`- Python`</span></span><br><span class="line"></span><br><span class="line"><span class="code">`- 编程语言`</span></span><br><span class="line"></span><br><span class="line"><span class="code">`- 网络编程`</span></span><br></pre></td></tr></table></figure><h3 id="1-文章添加分类"><a href="#1-文章添加分类" class="headerlink" title="1. 文章添加分类"></a>1. 文章添加分类</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:                           # 添加分类</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> 编程语言</span><br></pre></td></tr></table></figure><h3 id="2-文章添加标签"><a href="#2-文章添加标签" class="headerlink" title="2. 文章添加标签"></a>2. 文章添加标签</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tags:                           # 添加标签</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> 编程语言</span><br></pre></td></tr></table></figure><h3 id="1-导航页添加封面"><a href="#1-导航页添加封面" class="headerlink" title="1. 导航页添加封面"></a>1. 导航页添加封面</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: about               </span><br><span class="line">date: <span class="number">2024</span><span class="number">-01</span><span class="number">-01</span> <span class="number">22</span>:<span class="number">46</span>:<span class="number">09</span>       </span><br><span class="line">top_img: img/links.jpg         # 顶部封面</span><br><span class="line">comments: <span class="literal">false</span>                # 关闭 评论功能</span><br><span class="line">--- </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora编辑器 - 序列号破解</title>
      <link href="/2024/01/14/Typora%E7%BC%96%E8%BE%91%E5%99%A8%20-%20%E5%BA%8F%E5%88%97%E5%8F%B7%E7%A0%B4%E8%A7%A3/"/>
      <url>/2024/01/14/Typora%E7%BC%96%E8%BE%91%E5%99%A8%20-%20%E5%BA%8F%E5%88%97%E5%8F%B7%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora编辑器-序列号破解"><a href="#Typora编辑器-序列号破解" class="headerlink" title="Typora编辑器 - 序列号破解"></a>Typora编辑器 - 序列号破解</h1><h6 id=""><a href="#" class="headerlink" title=""></a></h6><blockquote><p>Typora 是一款由 Abner Lee 开发的<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7/10002835?fromModule=lemma_inlink">轻量级</a> Markdown 编辑器，与其他 Markdown 编辑器不同的是，Typora 没有采用<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969?fromModule=lemma_inlink">源代码</a>和预览双栏显示的方式，而是采用所见即所得的编辑方式，实现了即时预览的功能，但也可切换至源代码编辑模式</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>因为最近写博客文章的需求多了，所以对于需要一个好一点的面向Markdown的编辑工具，为什么选Markdown呢？这还是因为它本身就是一种独立的文本格式，又因为Markdown其强大的文本编辑功能所以就选择了Markdown。</li><li>而Typora是一款面向Md的专业，简洁，快速的Markdown编辑器，对于md博主来说是个很不错的选择。</li><li>Typora并不是免费的，所以……</li><li>破解就完了！！！</li></ol><h3 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h3><ul><li><p>官网：<a href="https://typora.io/">https://typora.io/</a></p></li><li><p>中文官网：<a href="https://typoraio.cn/%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89">https://typoraio.cn/（推荐）</a></p></li></ul><h3 id="安装（省略）"><a href="#安装（省略）" class="headerlink" title="安装（省略）"></a>安装（省略）</h3><h3 id="序列号破解"><a href="#序列号破解" class="headerlink" title="序列号破解"></a>序列号破解</h3><ol><li>将node_inject.exe和license-gen.exe文件移入到Typora的根目录中</li></ol><p><img src="https://s2.loli.net/2024/01/24/2l83DhW9eBvToUb.png" alt="tyopra_1.png"></p><ol><li><p>按住<kbd>Shift</kbd>鼠标右键Typora的目录，”以PowerShell的方式打开”。</p></li><li><p>先后直接将node_inject.exe和license-gen.exe鼠标拖入到Shell窗口中并运行。</p></li><li><p>运行后会得到一串序列号，将它复制并粘贴到Typora的序列号激活界面中激活即可。</p></li></ol><p><img src="https://s2.loli.net/2024/01/24/NsGWzryPdCg2Heo.png" alt="tyopra_2.png"></p><ol start="4"><li>回到激活界面：“以序列号的方式激活“，输入邮箱再把生成的序列号输入进去，点击激活即可！！</li><li>这样我们就成功地永久激活了Typora。</li></ol><p><img src="https://s2.loli.net/2024/01/24/KTHhu8xUy5JO21X.png" alt="tyora_3.png"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>祝您使用Typora创作愉快</p>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
          <category> 破解白嫖 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/01/14/hello-world/"/>
      <url>/2024/01/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python Socket TCP多线程通信【四】</title>
      <link href="/2024/01/01/Python%20Socket%20TCP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%90%E5%9B%9B%E3%80%91/"/>
      <url>/2024/01/01/Python%20Socket%20TCP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%90%E5%9B%9B%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-Socket-TCP多线程通信"><a href="#Python-Socket-TCP多线程通信" class="headerlink" title="Python Socket TCP多线程通信"></a>Python Socket TCP多线程通信</h1><h2 id="一-创建客户端连接"><a href="#一-创建客户端连接" class="headerlink" title="一.创建客户端连接"></a>一.创建客户端连接</h2><h3 id="一-开启多线程通信"><a href="#一-开启多线程通信" class="headerlink" title="一.开启多线程通信"></a>一.开启多线程通信</h3><ol><li>前面说到，因为单线程原因，客户端与服务器无法做到自由对话，则需要用到多线程来处理。我们现在的服务端和客户端最多也就是发送消息和接收消息两种行为，所以我们采用双线程。</li><li>或许我们可以新建一个Client.py的客户端和Server.py的服务端，代码照搬第一期的。</li><li>首先编写客户端代码。导入内置的线程模块，随后调用模块内置函数threading.Thread( )，因为有两个行为（发送消息和接收消息）所以需要定义并启动双线程。</li></ol><ul><li>target：与目标函数对接使得目标函数开启一个线程。</li><li>args：向目标函数传入一个参数。这里两个线程同时将socket传入，可以使得socket获得两个线程的处理。</li><li>.start：启动线程。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading  <span class="comment"># 导入线程模块</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动多线程（多个线程共用一个Socket）</span></span><br><span class="line">threading.Thread(target=send_msg, args=(Client,)).start()</span><br><span class="line">threading.Thread(target=recv_msg, args=(Client,)).start()</span><br></pre></td></tr></table></figure><h3 id="二-建立多线程任务"><a href="#二-建立多线程任务" class="headerlink" title="二.建立多线程任务"></a>二.建立多线程任务</h3><ol><li>当多线程开启后，就可以写入发送消息和接收消息的行为了，我们称它为多线程要完成的任务，它会被写在自定义函数的循环语句内。</li><li>while循环的作用不必多说：无条件，保持持续的通信（当然后期可以添加条件以跳出循环）</li><li>要注意的是，<strong>这两个函数在线程启动后会被同时运行，也就是说，在任何时候，不管是对方有没有发送消息，我们都可以直接向对方发送消息或者说接收消息，这就完美的解决了像单线程一对一的受限通信。起到自由对话的效果。</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多线程任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_msg</span>(<span class="params">Client</span>):     <span class="comment"># 发送消息（任务线程）</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        send = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">        Client.send(send.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv_msg</span>(<span class="params">Client</span>):     <span class="comment"># 接收消息（任务线程）</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        recvv = Client.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;服务器：&quot;</span> + <span class="string">f&#x27;<span class="subst">&#123;recvv&#125;</span>&#x27;</span>)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="二-建立服务器连接"><a href="#二-建立服务器连接" class="headerlink" title="二.建立服务器连接"></a>二.建立服务器连接</h2><h3 id="一-开启多线程通信-1"><a href="#一-开启多线程通信-1" class="headerlink" title="一.开启多线程通信"></a>一.开启多线程通信</h3><p>1.服务端也一样，直接套用第一期代码，重复和客户端一样的操作给它定义两个线程，但与前者不同的是，服务端的线程需要写在监听列队的内在循环语句内，这样每次有客户端连接服务器时，accept( )会创建一个新的socket并传给多线程任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 循环接纳客户端</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    socket, addr_info = Server.accept()  <span class="comment"># 返回值传参赋值</span></span><br><span class="line">    threading.Thread(target=send_msg, args=(socket,)).start()</span><br><span class="line">    threading.Thread(target=recv_msg, args=(socket,)).start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;addr_info&#125;</span>&#x27;</span> + <span class="string">&quot;断开了与服务器的连接...&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="二-建立多线程任务-1"><a href="#二-建立多线程任务-1" class="headerlink" title="二.建立多线程任务"></a>二.建立多线程任务</h3><ol><li>和客户端一样，任务写在定义的双线程之上。</li><li>if条件不写也没事。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多线程任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_msg</span>(<span class="params">socket</span>):          <span class="comment"># 发送消息（任务线程）</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = <span class="built_in">input</span>(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">        socket.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv_msg</span>(<span class="params">socket</span>):          <span class="comment"># 接收消息（任务线程）</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        remsg = socket.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;客户端：&quot;</span> + <span class="string">f&#x27;<span class="subst">&#123;remsg&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(remsg) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br></pre></td></tr></table></figure><h2 id="三-通信测试"><a href="#三-通信测试" class="headerlink" title="三. 通信测试"></a>三. 通信测试</h2><h3 id="一-通信效果"><a href="#一-通信效果" class="headerlink" title="一.通信效果"></a>一.通信效果</h3><ol><li>效果还不错的，可以进行自由通信。<br><img src="https://img-blog.csdnimg.cn/2286eadfbd72417f92f5fd69a783dafa.png" alt="在这里插入图片描述"></li></ol><h2 id="四-整体代码与总结"><a href="#四-整体代码与总结" class="headerlink" title="四. 整体代码与总结"></a>四. 整体代码与总结</h2><h3 id="一-整体代码"><a href="#一-整体代码" class="headerlink" title="一.整体代码"></a>一.整体代码</h3><ol><li>Client.py：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Socket TCP对象</span></span><br><span class="line">Client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定目标服务器端地址</span></span><br><span class="line">Client_address = ((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">2023</span>))  <span class="comment"># IP地址为需要连接服务器的IP</span></span><br><span class="line"><span class="comment"># 连接目标服务器</span></span><br><span class="line">Client.connect(Client_address)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------------------------客户端--------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_msg</span>(<span class="params">Client</span>):     <span class="comment"># 发送消息（任务线程）</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        send = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">        Client.send(send.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv_msg</span>(<span class="params">Client</span>):     <span class="comment"># 接收消息（任务线程）</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        recvv = Client.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;服务器：&quot;</span> + <span class="string">f&#x27;<span class="subst">&#123;recvv&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动多线程（多个线程共用一个Socket</span></span><br><span class="line">threading.Thread(target=send_msg, args=(Client,)).start()</span><br><span class="line">threading.Thread(target=recv_msg, args=(Client,)).start()</span><br></pre></td></tr></table></figure>2.Server.py：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是服务器端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Socket TCP对象</span></span><br><span class="line">Server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">Server.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">2023</span>))   <span class="comment"># 绑定本地端口</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------------------------服务器端--------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动监听列队</span></span><br><span class="line">Server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_msg</span>(<span class="params">socket</span>):          <span class="comment"># 发送消息（任务线程）</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = <span class="built_in">input</span>(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">        socket.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv_msg</span>(<span class="params">socket</span>):          <span class="comment"># 接收消息（任务线程）</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        remsg = socket.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;客户端：&quot;</span> + <span class="string">f&#x27;<span class="subst">&#123;remsg&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(remsg) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环接纳客户端</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    socket, addr_info = Server.accept()  <span class="comment"># 返回值传参赋值</span></span><br><span class="line">    threading.Thread(target=send_msg, args=(socket,)).start()</span><br><span class="line">    threading.Thread(target=recv_msg, args=(socket,)).start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;addr_info&#125;</span>&#x27;</span> + <span class="string">&quot;客户端与与服务器连接成功...&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="二-总结"><a href="#二-总结" class="headerlink" title="二. 总结"></a>二. 总结</h3><ol><li>本次应用到了Python的多线程模块，解决了Socket通信的局部问题。</li><li>本次的Python Socket TCP通信目前仅局限于局域网，还无法于外网进行通信，往后会进行补充。</li><li>说实话，我也才刚学到这里，真的是学一步做一个笔记，以免下次忘记。这个端午过的很充实呢！写了大半天的博客，让我深感体会到创作的不易，但收获却是满满当当的…</li><li>最后再这端午节最后的几小时内祝大家幸福安康！！！</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> Python </tag>
            
            <tag> 网络通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Socket TCP简单通信【二】</title>
      <link href="/2017/05/27/Python%20Socket%20TCP%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1%E3%80%90%E4%BA%8C%E3%80%91/"/>
      <url>/2017/05/27/Python%20Socket%20TCP%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1%E3%80%90%E4%BA%8C%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><ol><li>接着上期的介绍，现在我们开始利用现有的代码让客户端对服务器发出请求并完成简单的通信。</li></ol><h2 id="二-TCP协议通信流程"><a href="#二-TCP协议通信流程" class="headerlink" title="二.TCP协议通信流程"></a>二.TCP协议通信流程</h2><ol start="2"><li>在开始这项工作之前，我们认识一下客户端向服务器发送请求并完成连接的一个Socket TCP通信执行流程。</li></ol><h3 id="1-‘三次握手’"><a href="#1-‘三次握手’" class="headerlink" title="1.‘三次握手’"></a>1.‘三次握手’</h3><ol start="3"><li>当客户端向服务器发送连接请求时，两者之前会发送三次文段，也就是我们俗话说的“三次握手”。<blockquote><ol start="4"><li>它的具体过程是：</li></ol><ul><li><ol><li>客户端主动向服务器发送连接请求（文段1）。</li></ol></li><li><ol start="2"><li>处于监听状态的服务器被动的接收了来自客户端的请求，并将确认的连接请求返回给客户端（文段2）。</li></ol></li><li><ol start="3"><li>最后客户端也将确认的连接请求返回给了服务器（文段3）   表示客户端完成了与服务器的连接。两端建立连接即可进行通信。</li></ol></li></ul></blockquote></li></ol><p><img src="https://img-blog.csdnimg.cn/d4855c73be54404e9330b4c634a8c34b.png" alt="请添加图片描述"></p><blockquote></blockquote><h3 id="2-‘四次挥手’"><a href="#2-‘四次挥手’" class="headerlink" title="2. ‘四次挥手’"></a>2. ‘四次挥手’</h3><ol start="5"><li>当想要断开服务器连接时，也是客户端主动地发出断连请求，两者之前会发送四次文段。这就是我们所说的“四次挥手”。具体过程：</li></ol><blockquote><ul><li><ol><li>客户端首先向服务器发送离线请求，客户端进入FIN_WAIT1状态（文段1）。</li></ol></li><li><ol start="2"><li>服务器接收到请求后并将确认返回给客户端，服务器进入CLOSE_WAIT状态。收到回应的客户端进入FIN_WAIT2状态，等待服务器的FIN。（文段2）。</li></ol></li><li><ol start="3"><li>接着服务器将FIN发送给客户端，并进入了LAST_ACK状态，等待客户端的确认。（文段3）</li></ol></li><li><ol start="4"><li>最后客户端将ACK发送给服务器并进入TIME_WAIT状态，服务器则做出回应CLOSE断开了与客户端的连接…（文段4）</li></ol></li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/b69a20a042ca4cdfbf79c8f85dd29581.jpeg" alt="请添加图片描述"></p><blockquote></blockquote><blockquote><p>理解了Socket TCP通信协议的工作流程后，有利于轻易地掌握网络通信的关键。对往后的开发将也会变得更加灵活。</p></blockquote><h2 id="二-客户端发送信息"><a href="#二-客户端发送信息" class="headerlink" title="二.客户端发送信息"></a>二.客户端发送信息</h2><ol><li>在客户端文件中调用Socket对象，并写入send( )函数，用于向服务器发送信息。</li></ol><ul><li>send( )内可直接输入需要发送的信息。 send( )内参数必须是bytes字节类型，也就是说，需要将内容转化为utf-8的编码格式，可以利用encode( )进行转化。</li></ul><ol start="2"><li>在发送完数据后需要将套接字close掉。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送文字信息</span></span><br><span class="line">Client.send(<span class="string">&#x27;你好，世界！！！&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 断开字节流</span></span><br><span class="line">Client.close()</span><br></pre></td></tr></table></figure></li></ol><h2 id="三-服务器接收信息"><a href="#三-服务器接收信息" class="headerlink" title="三. 服务器接收信息"></a>三. 服务器接收信息</h2><ol><li>客户端发送消息后，服务器就可以接收消息，需要用到内置函数recv( )来读取信息。</li></ol><ul><li>recv( )内参数为容器的大小，也就是可容纳多大的客户端发来的数据，同时也包含了数据。</li><li>​recv( )内容纳的数据需要再一次用到decode( )进行转化。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接收消息</span></span><br><span class="line">data_info = socket.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出该消息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;addr_info[<span class="number">0</span>]&#125;</span>&#x27;</span> + <span class="string">&#x27;发来消息&gt;&gt;&gt;&#x27;</span> + <span class="string">f&#x27;<span class="subst">&#123;data_info&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>我们运行一下客户端和服务器，运行效果如下，服务器将会输出客户端发来的信息。</li></ol><p><img src="https://img-blog.csdnimg.cn/4dffc8aa1e24485689891ea1db9c0c26.png" alt="在这里插入图片描述"><br>4. 代码解释：</p><blockquote><p>addr_info是个元组类型，里面包含了两个数据，一个是地址，一个是端口，所以我们可以直接用addr_info[0]来获取地址，而端口直接省略掉。</p></blockquote><h2 id="四-整体代码"><a href="#四-整体代码" class="headerlink" title="四.整体代码"></a>四.整体代码</h2><ol><li>Client.py：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Socket TCP对象</span></span><br><span class="line">Client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定客户端地址</span></span><br><span class="line">Client_address = ((<span class="string">&#x27;192.168.0.193&#x27;</span>, <span class="number">2023</span>))</span><br><span class="line">Client.connect(Client_address)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送文字信息</span></span><br><span class="line">Client.send(<span class="string">&#x27;你好，世界！！！&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 断开字节流</span></span><br><span class="line">Client.close()</span><br></pre></td></tr></table></figure><ol start="2"><li>Server.py：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是服务器端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Socket TCP对象</span></span><br><span class="line">Server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">Server.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">2023</span>))   <span class="comment"># 绑定本地端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动监听</span></span><br><span class="line">Server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环接纳客户端</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    socket, addr_info = Server.accept()  <span class="comment"># 返回值传参赋值</span></span><br><span class="line">    <span class="comment"># 接收消息</span></span><br><span class="line">    data_info = socket.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># 输出该消息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;addr_info[<span class="number">0</span>]&#125;</span>&#x27;</span> + <span class="string">&#x27;发来消息&gt;&gt;&gt;&#x27;</span> + <span class="string">f&#x27;<span class="subst">&#123;data_info&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    socket.close()  <span class="comment"># 断开现有的连接...</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;addr_info&#125;</span>&#x27;</span> + <span class="string">&quot;断开了与服务器的连接...&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h2><ol><li>以上内容完成了客户端和服务器之间简单的Socket TCP通信。</li><li>祝大家端午节安康！</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 编程语言 </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
