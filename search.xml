<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>主系表</title>
      <link href="/2025/08/16/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E4%B8%BB%E7%B3%BB%E8%A1%A8/"/>
      <url>/2025/08/16/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E4%B8%BB%E7%B3%BB%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="主系表"><a href="#主系表" class="headerlink" title="主系表"></a>主系表</h1><p>主谓宾（特殊）&#x3D;主系表<br>Look&#x3D;看起来<br>This girl looks pretty.<br>这个女孩看起来很漂亮。<br>Smell&#x3D;闻起来<br>This flower smells good.<br>这朵花闻起来很不错。<br>Taste&#x3D;尝起来<br>This candy tastes sweet.</p><p>主语 (Subject)：句子描述的核心对象（人、事、物、抽象概念等）。</p><p>示例：He, The book, Her smile, This city</p><p>系动词 (Linking Verb)：连接主语和表语的动词，本身无实际动作含义，仅起 “连接” 和 “表述状态” 的作用。</p><p>核心系动词：be 动词（am, is, are, was, were）</p><p>其他常见系动词：</p><p>表 “变化”：become（变得）、get（变得）、turn（变成）<br>表 “感官”：look（看起来）、sound（听起来）、taste（尝起来）、smell（闻起来）、feel（摸起来 &#x2F; 感觉）<br>表 “保持”：keep（保持）、stay（维持）、remain（仍然是）<br>表语 (Predicate Complement)：位于系动词后，用来 “补充说明主语” 的成分，可由名词、形容词、介词短语等充当。</p><h2 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h2><p>这张软地毯摸起来很舒服。<br>This soft blanket feels every comfortable.<br>她大胆的想法被证明是空洞的。<br>She bold idea proves empty.<br>这张纸一下就变黄了。<br>This paper turns yellow in a second.</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>及物动词和不及物动词</title>
      <link href="/2025/08/12/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E5%8F%8A%E7%89%A9%E5%8A%A8%E8%AF%8D%E5%92%8C%E4%B8%8D%E5%8F%8A%E7%89%A9%E5%8A%A8%E8%AF%8D/"/>
      <url>/2025/08/12/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E5%8F%8A%E7%89%A9%E5%8A%A8%E8%AF%8D%E5%92%8C%E4%B8%8D%E5%8F%8A%E7%89%A9%E5%8A%A8%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>及物动词和不及物动词<br>及物动词：触及物体（宾语·）<br>及物动词必须要接宾语！<br>1.eat 吃 I eat a pear.我吃一个梨子。<br>2.watch 观看 I watch TV. 我看电视。<br>3.see看到 He sees a monkey. 他看到一只猴子。</p><p>不及物动词：不触及物体（宾语·），介词（当桥梁）<br>1.look 看 I look at a person. 我看着一个人。<br>2.run 跑 I run on the ground. 我在地上跑。<br>3.sleep 睡觉 Marry sleeps in her bedroom. Marry在卧室睡觉。<br>不及物动词可不接任何成分，单独成句<br>4.die 死亡 He died. 他死了<br>5.win&#x2F;lose 胜利&#x2F;失败 You win&#x2F;lose. 你赢&#x2F;输了<br>6.arrive&#x2F;come&#x2F;go He has arrived&#x2F;come&#x2F;gone 他到了&#x2F;来了&#x2F;走了。</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册MediatR，添加工作单元过滤器</title>
      <link href="/2025/08/11/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/%E6%B3%A8%E5%86%8CMediatR%EF%BC%8C%E6%B7%BB%E5%8A%A0%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/"/>
      <url>/2025/08/11/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/%E6%B3%A8%E5%86%8CMediatR%EF%BC%8C%E6%B7%BB%E5%8A%A0%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83/</url>
      
        <content type="html"><![CDATA[<h1 id="注册MediatR"><a href="#注册MediatR" class="headerlink" title="注册MediatR"></a>注册MediatR</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 MediatR，用于领域事件和命令处理</span></span><br><span class="line">services.AddMediatR(assemblies);</span><br></pre></td></tr></table></figure><p>把指定程序集（assemblies）里实现的 MediatR 处理程序注册到依赖注入容器，这样你就可以用 MediatR 的领域事件和命令模式了。<br>AddMediatR是自定义扩展方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MediatorExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 扩展IServiceCollection以批量注册MediatR相关服务。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;services&quot;&gt;</span>依赖注入服务集合。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;assemblies&quot;&gt;</span>包含MediatR处理程序的程序集集合。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>服务集合本身，便于链式调用。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection <span class="title">AddMediatR</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services, IEnumerable&lt;Assembly&gt; assemblies</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将指定程序集中的MediatR服务注册到依赖注入容器</span></span><br><span class="line">        <span class="keyword">return</span> services.AddMediatR(assemblies.ToArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 派发当前DbContext中所有聚合根的领域事件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;mediator&quot;&gt;</span>MediatR中介者实例。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;ctx&quot;&gt;</span>当前的EF Core DbContext实例。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>异步任务。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">DispatchDomainEventsAsync</span>(<span class="params"><span class="keyword">this</span> IMediator mediator, DbContext ctx</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取所有实现了IDomainEvents接口且包含领域事件的实体</span></span><br><span class="line">        <span class="keyword">var</span> domainEntities = ctx.ChangeTracker</span><br><span class="line">            .Entries&lt;IDomainEvents&gt;()</span><br><span class="line">            .Where(x =&gt; x.Entity.GetDomainEvents().Any());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集所有领域事件</span></span><br><span class="line">        <span class="keyword">var</span> domainEvents = domainEntities</span><br><span class="line">            .SelectMany(x =&gt; x.Entity.GetDomainEvents())</span><br><span class="line">            .ToList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空实体上的领域事件，避免重复派发</span></span><br><span class="line">        domainEntities.ToList()</span><br><span class="line">            .ForEach(entity =&gt; entity.Entity.ClearDomainEvents());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐个通过MediatR发布领域事件</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> domainEvent <span class="keyword">in</span> domainEvents)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> mediator.Publish(domainEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>AddMediatR批量注册MediatR服务。<br>DispatchDomainEventsAsync派发 EF Core 聚合根的领域事件</p></blockquote><ol><li>找出有领域事件的实体<br>ctx.ChangeTracker.Entries&lt;IDomainEvents&gt;() 会获取当前跟踪的、实现了 IDomainEvents 接口的实体。<br>过滤出 GetDomainEvents().Any() 的实体，说明它们确实有未发布的领域事件。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDomainEvents</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取当前已注册的所有领域事件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>领域事件的只读集合。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function">IEnumerable&lt;INotification&gt; <span class="title">GetDomainEvents</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>/<span class="number">8589</span>+<span class="number">0l</span>kmmnbgfvcdx5`      <span class="number">8</span>\-<span class="number">-098765</span></span><br><span class="line"><span class="string">&#x27;;L&#x27;</span>;LK<span class="string">&#x27;;LK/.,ML,KMJNHBGV;LOKIUHGFDIUY&#x27;</span>    <span class="comment"><span class="doctag">///</span> 添加一个新的领域事件到集合中。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventItem&quot;&gt;</span>要添加的领域事件。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddDomainEvent</span>(<span class="params">INotification eventItem</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 如果集合中不存在该事件，则添加一个新的领域事件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用于避免重复添加相同的事件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventItem&quot;&gt;</span>要添加的领域事件。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddDomainEventIfAbsent</span>(<span class="params">INotification eventItem</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 清空当前所有已注册的领域事件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ClearDomainEvents</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>收集所有领域事件<br>SelectMany 把所有实体的事件扁平化成一个 List&lt;IDomainEvent&gt;。</p></li><li><p>清空实体的事件集合<br>避免同一个事件被重复发布。</p></li><li><p>逐个发布事件<br>mediator.Publish(domainEvent) 让 MediatR 找到对应的 INotificationHandler&lt;T&gt; 来处理事件。</p></li></ol><h1 id="添加工作单元过滤器"><a href="#添加工作单元过滤器" class="headerlink" title="添加工作单元过滤器"></a>添加工作单元过滤器</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 MVC 选项，添加工作单元过滤器</span></span><br><span class="line">services.Configure&lt;MvcOptions&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Filters.Add&lt;UnitOfWorkFilter&gt;();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>ASP.NET Core 的 MVC 管道全局加了一个“工作单元（Unit of Work）过滤器”，让所有控制器&#x2F;Action 执行时自动启用一个工作单元逻辑。</p></blockquote><p>services.Configure&lt;MvcOptions&gt;<br>这是对 MVC 框架的配置入口，可以修改 MVC 的行为，比如格式化器、模型绑定、过滤器等。</p><p>options.Filters.Add&lt;UnitOfWorkFilter&gt;()<br>给 全局过滤器集合 添加了一个 UnitOfWorkFilter，所有 Controller Action 执行前后都会经过它。<br>这和在每个 Controller 上 [ServiceFilter(typeof(UnitOfWorkFilter))] 一样，但这是全局生效。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitOfWorkFilter</span> : <span class="title">IAsyncActionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取应用于控制器或方法的 UnitOfWorkAttribute 特性。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 优先获取控制器上的特性，如果没有则获取方法上的特性。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;actionDesc&quot;&gt;</span>当前 Action 的描述信息。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>UnitOfWorkAttribute 实例或 null。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UnitOfWorkAttribute? GetUoWAttr(ActionDescriptor actionDesc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> caDesc = actionDesc <span class="keyword">as</span> ControllerActionDescriptor;</span><br><span class="line">        <span class="keyword">if</span> (caDesc == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不是控制器 Action，直接返回 null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 优先获取控制器上的 UnitOfWorkAttribute</span></span><br><span class="line">        <span class="keyword">var</span> uowAttr = caDesc.ControllerTypeInfo</span><br><span class="line">            .GetCustomAttribute&lt;UnitOfWorkAttribute&gt;();</span><br><span class="line">        <span class="keyword">if</span> (uowAttr != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> uowAttr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果控制器上没有，则获取方法上的 UnitOfWorkAttribute</span></span><br><span class="line">            <span class="keyword">return</span> caDesc.MethodInfo</span><br><span class="line">                .GetCustomAttribute&lt;UnitOfWorkAttribute&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 拦截 Action 执行过程，实现工作单元事务控制。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;context&quot;&gt;</span>Action 执行上下文。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;next&quot;&gt;</span>委托，执行下一个中间件或 Action。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>异步任务。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取当前 Action 或控制器上的 UnitOfWorkAttribute</span></span><br><span class="line">        <span class="keyword">var</span> uowAttr = GetUoWAttr(context.ActionDescriptor);</span><br><span class="line">        <span class="keyword">if</span> (uowAttr == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 未标记 UnitOfWorkAttribute，直接执行下一个中间件</span></span><br><span class="line">            <span class="keyword">await</span> next();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启用支持异步流的事务作用域</span></span><br><span class="line">        <span class="keyword">using</span> TransactionScope txScope = <span class="keyword">new</span> TransactionScope(TransactionScopeAsyncFlowOption.Enabled);</span><br><span class="line">        List&lt;DbContext&gt; dbCtxs = <span class="keyword">new</span> List&lt;DbContext&gt;();</span><br><span class="line">        <span class="comment">// 遍历特性中声明的所有 DbContext 类型</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> dbCtxType <span class="keyword">in</span> uowAttr.DbContextTypes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 通过依赖注入获取 DbContext 实例</span></span><br><span class="line">            <span class="keyword">var</span> sp = context.HttpContext.RequestServices;</span><br><span class="line">            DbContext dbCtx = (DbContext)sp.GetRequiredService(dbCtxType);</span><br><span class="line">            dbCtxs.Add(dbCtx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行 Action</span></span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">await</span> next();</span><br><span class="line">        <span class="keyword">if</span> (result.Exception == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果没有异常，依次保存所有 DbContext 的更改</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> dbCtx <span class="keyword">in</span> dbCtxs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> dbCtx.SaveChangesAsync();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 提交事务</span></span><br><span class="line">            txScope.Complete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有异常，事务会自动回滚</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>GetUoWAttr查找UnitOfWorkAttribute</li></ol><p>UnitOfWorkAttribute自定义的特性类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 用于标记需要工作单元（Unit of Work）支持的类或方法的特性（Attribute）。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 通过指定一个或多个 DbContext 类型，实现对数据库操作的自动事务管理。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitOfWorkAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取需要参与工作单元的 DbContext 类型数组。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> Type[] DbContextTypes &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 构造函数，初始化 UnitOfWorkAttribute 实例，并校验传入的类型是否为 DbContext 的子类。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;dbContextTypes&quot;&gt;</span>需要参与工作单元的 DbContext 类型列表。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;ArgumentException&quot;&gt;</span>如果传入的类型不是 DbContext 的子类，则抛出异常。<span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnitOfWorkAttribute</span>(<span class="params"><span class="keyword">params</span> Type[] dbContextTypes</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.DbContextTypes = dbContextTypes;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> type <span class="keyword">in</span> dbContextTypes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 校验每个类型是否为 DbContext 或其子类</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">typeof</span>(DbContext).IsAssignableFrom(type))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">$&quot;Type <span class="subst">&#123;type.FullName&#125;</span> is not a DbContext type.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OnActionExecutionAsync拦截 Action 方法执行，自动开启事务，确保多个 DbContext 操作要么全部成功，要么全部回滚。</p>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>名词性从句</title>
      <link href="/2025/08/10/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E5%90%8D%E8%AF%8D%E6%80%A7%E4%BB%8E%E5%8F%A5/"/>
      <url>/2025/08/10/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E5%90%8D%E8%AF%8D%E6%80%A7%E4%BB%8E%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="名词性从句"><a href="#名词性从句" class="headerlink" title="名词性从句"></a>名词性从句</h1><p>主语从句+宾语从句  主语、宾语&#x3D;&#x3D;名词<br>介词短语（介宾）&#x3D;介词+名词<br>1,I look at you.<br>我看着你。<br>You是名词,可以改成我所喜欢的东西。<br>I look at what I like thing.<br>2.我进入这栋房子。<br>I get into the house.<br>我进入他所住的地方。<br>I get into where he lives.<br>3.我对这本书很感兴趣。<br>I am very interested in this book.<br>我对他啥时候来我家很感兴趣。<br>I am very interested in when he will come to my home.<br>4.我对这个问题很困惑。<br>I am confused with the question.<br>我对他这么做的原因很困惑。<br>I am confused with why he did this.<br>5.我不知道这件事。<br>I have no idea of this.<br>我不知道他是否会来。<br>I have no idea of whether he will come.<br>我不知道她是怎么解出这道问题的。<br>I have no idea of how he solved this question.<br>6.原因在于他的懒惰。<br>The reason lies in his laziness.<br>That引导陈述句<br>原因在于他很懒。<br>The reason lies in that his is lazy.</p><h2 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h2><p>1.我担心她是否会接受这份工作。<br>I am worried about whether she will accept this job.</p><p>2.他正在考虑如何解决这个问题。<br>He is thinking of how he solved this question.</p><p>3.我们正在讨论何时启动这个项目。<br>We are discussing when we start this project.</p><p>4.他很好奇他为什么突然离开。<br>He is curios about why she suddenly leave.</p><p>5.他的成功取决于他学习的方法。<br>His success depends on how him studies.  </p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置 JWT 认证 和 Swagger 的认证支持</title>
      <link href="/2025/08/09/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/%E9%85%8D%E7%BD%AE%20JWT%20%E8%AE%A4%E8%AF%81%20%E5%92%8C%20Swagger%20%E7%9A%84%E8%AE%A4%E8%AF%81%E6%94%AF%E6%8C%81/"/>
      <url>/2025/08/09/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/%E9%85%8D%E7%BD%AE%20JWT%20%E8%AE%A4%E8%AF%81%20%E5%92%8C%20Swagger%20%E7%9A%84%E8%AE%A4%E8%AF%81%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h1 id="配置认证与授权"><a href="#配置认证与授权" class="headerlink" title="配置认证与授权"></a>配置认证与授权</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 添加认证服务</span><br><span class="line">builder.Services.AddAuthentication();</span><br><span class="line"></span><br><span class="line">// 添加授权服务</span><br><span class="line">builder.Services.AddAuthorization();</span><br></pre></td></tr></table></figure><p>AddAuthentication()：注册认证系统，用JWT认证。<br>AddAuthorization()：注册授权系统，用于在 [Authorize] 等特性中判断用户是否有权限访问。</p><h1 id="读取并绑定-JWT-配置-注册-JWT-认证方案"><a href="#读取并绑定-JWT-配置-注册-JWT-认证方案" class="headerlink" title="读取并绑定 JWT 配置,注册 JWT 认证方案"></a>读取并绑定 JWT 配置,注册 JWT 认证方案</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从配置中获取 JWT 相关配置</span></span><br><span class="line">JWTOptions jwtOpt = configuration.GetSection(<span class="string">&quot;JWT&quot;</span>).Get&lt;JWTOptions&gt;();</span><br></pre></td></tr></table></figure><p>从配置源读取JWT节点，并绑定到 JWTOptions 对象里。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JWTOptions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 令牌颁发者（Issuer）。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Issuer &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 令牌接收者（Audience）。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Audience &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用于签名 JWT 的密钥。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Key &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 令牌过期时间（秒）。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ExpireSeconds &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 JWT 选项绑定</span></span><br><span class="line">services.Configure&lt;JWTOptions&gt;(configuration.GetSection(<span class="string">&quot;JWT&quot;</span>));</span><br></pre></td></tr></table></figure><p>services<br>依赖注入容器（IServiceCollection）实例。这里我们往容器中添加配置绑定。<br>Configure&lt;TOptions&gt;<br>来自 Microsoft.Extensions.Options.ConfigurationExtensions，用于把配置文件里的某个部分绑定到 TOptions 类型，并注册成 Options 模式 对象。<br>注册后，你可以在任何地方通过 IOptions&lt;JWTOptions&gt;来获取这个对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加 JWT 认证服务</span></span><br><span class="line">builder.Services.AddJWTAuthentication(jwtOpt);</span><br></pre></td></tr></table></figure><p>注册JWT服务需要配置JWT令牌验证参数,这里自定义了AddJWTAuthentication扩张方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">AuthenticationExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 向服务集合中添加JWT认证。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;services&quot;&gt;</span>服务集合。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;jwtOpt&quot;&gt;</span>JWT配置选项。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>认证生成器。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AuthenticationBuilder <span class="title">AddJWTAuthentication</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services, JWTOptions jwtOpt</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</span><br><span class="line">        .AddJwtBearer(x =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 配置JWT令牌验证参数</span></span><br><span class="line">            x.TokenValidationParameters = <span class="keyword">new</span>()</span><br><span class="line">            &#123;</span><br><span class="line">                ValidateIssuer = <span class="literal">true</span>, <span class="comment">// 验证签发者</span></span><br><span class="line">                ValidateAudience = <span class="literal">true</span>, <span class="comment">// 验证接收者</span></span><br><span class="line">                ValidateLifetime = <span class="literal">true</span>, <span class="comment">// 验证有效期</span></span><br><span class="line">                ValidateIssuerSigningKey = <span class="literal">true</span>, <span class="comment">// 验证签名密钥</span></span><br><span class="line">                ValidIssuer = jwtOpt.Issuer, <span class="comment">// 有效签发者</span></span><br><span class="line">                ValidAudience = jwtOpt.Audience, <span class="comment">// 有效接收者</span></span><br><span class="line">                IssuerSigningKey = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtOpt.Key)), <span class="comment">// 签名密钥</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AuthenticationBuilder —— 方便你后面继续链式配置认证</p><p>AddAuthentication(JwtBearerDefaults.AuthenticationScheme)<br>告诉 ASP.NET Core 默认使用 Bearer Token（即 Authorization: Bearer &lt;token&gt;）来认证。<br>AddJwtBearer(…)<br>注册 JWT Bearer 认证处理器，并配置如何验证 token。<br>TokenValidationParameters<br>ValidateIssuer &#x2F; ValidIssuer：检查 token 里 iss 声明是否和配置一致。<br>ValidateAudience &#x2F; ValidAudience：检查 token 里 aud 声明是否和配置一致。<br>ValidateLifetime：检查 token 是否过期（取决于 exp 和 nbf 字段）。<br>ValidateIssuerSigningKey：检查 token 签名是否有效（防篡改）。<br>IssuerSigningKey：签名用的密钥（这里用 HMACSHA256 对称加密）。</p><h1 id="配置-Swagger-支持-JWT-调试"><a href="#配置-Swagger-支持-JWT-调试" class="headerlink" title="配置 Swagger 支持 JWT 调试"></a>配置 Swagger 支持 JWT 调试</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.Configure&lt;SwaggerGenOptions&gt;(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.AddAuthenticationHeader();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>给 Swagger UI 添加一个 “Authorize” 按钮，可以输入 Bearer Token，在接口调试时自动带上 Authorization 头。<br>AddAuthenticationHeader是自定义扩张方法，向 Swagger 配置中添加认证头（Authorization Header）， 使得在 Swagger UI 中可以输入 JWT Token 进行接口测试。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SwaggerGenOptionsExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 向 Swagger 配置中添加认证头（Authorization Header），</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 使得在 Swagger UI 中可以输入 JWT Token 进行接口测试。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c&quot;&gt;</span>SwaggerGenOptions 实例。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddAuthenticationHeader</span>(<span class="params"><span class="keyword">this</span> SwaggerGenOptions c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 添加安全定义，指定名称为 &quot;Authorization&quot;，类型为 ApiKey，位置在 Header。</span></span><br><span class="line">        <span class="comment">// 这样在 Swagger UI 中会出现一个输入框用于填写 Token。</span></span><br><span class="line">        c.AddSecurityDefinition(<span class="string">&quot;Authorization&quot;</span>, <span class="keyword">new</span> OpenApiSecurityScheme</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 描述信息，指导用户如何填写 Token。</span></span><br><span class="line">            Description = <span class="string">&quot;Authorization header .\r\n Example:&#x27;Bearer 12345abcdef&#x27;&quot;</span>,</span><br><span class="line">            <span class="comment">// 指定参数在 HTTP Header 中传递。</span></span><br><span class="line">            In = ParameterLocation.Header,</span><br><span class="line">            <span class="comment">// 安全方案类型为 ApiKey。</span></span><br><span class="line">            Type = SecuritySchemeType.ApiKey,</span><br><span class="line">            <span class="comment">// 方案名称，通常为 &quot;Authorization&quot;。</span></span><br><span class="line">            Scheme = <span class="string">&quot;Authorization&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加安全需求，指定所有接口都需要携带 &quot;Authorization&quot; 头部。</span></span><br><span class="line">        c.AddSecurityRequirement(<span class="keyword">new</span> OpenApiSecurityRequirement()</span><br><span class="line">            &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">new</span> OpenApiSecurityScheme</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 引用上面定义的安全方案。</span></span><br><span class="line">                        Reference = <span class="keyword">new</span> OpenApiReference</span><br><span class="line">                        &#123;</span><br><span class="line">                            Type = ReferenceType.SecurityScheme,</span><br><span class="line">                            Id=<span class="string">&quot;Authorization&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">// 方案类型为 oauth2（虽然实际类型为 ApiKey，这里用于兼容性）。</span></span><br><span class="line">                        Scheme = <span class="string">&quot;oauth2&quot;</span>,</span><br><span class="line">                        <span class="comment">// 头部名称。</span></span><br><span class="line">                        Name=<span class="string">&quot;Authorization&quot;</span>,</span><br><span class="line">                        <span class="comment">// 参数位置为 Header。</span></span><br><span class="line">                        In=ParameterLocation.Header,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">// 作用域列表，这里为空表示不限定作用域。</span></span><br><span class="line">                    <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Swagger UI 顶部加一个 “Authorize” 按钮。<br>让所有 API 请求都自动带上 Authorization HTTP 头。</p>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主语从句</title>
      <link href="/2025/08/08/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E4%B8%BB%E8%AF%AD%E4%BB%8E%E5%8F%A5/"/>
      <url>/2025/08/08/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E4%B8%BB%E8%AF%AD%E4%BB%8E%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h1><p>I know that you are right.&#x3D;&gt;可以当主语<br>我知道你是对的。<br>主语和宾语都是名词，名词可以当主语</p><p>That you are right is known to everyone.<br>你是对的是众所周知的。</p><p>I know where he lives.&#x3D;&gt;当主语<br>我知道他住在哪里（他住在的位置）。</p><p>Where he lives is unknown.<br>他住的位置没人知道。</p><p>It&#x3D;形式主语（傀儡主语）<br>To do sth(带名词性)<br>英语习惯 先说重点 因为大多都是后置修饰</p><p>去解决这个复杂的大问题实在太难了。<br>To solve this big complex problem is very hard.</p><p>It is very hard to solve this big complex problem.(这个是真正的主语)</p><p>比如：</p><p>见到你很高兴。<br>To see you is nice<br>主语可以放到后面用It代替<br>It is nice to see you.</p><p>doing sth.也有名词性<br>Seeing you is nice.<br>Seeing 就可用放后面<br>It is nice seeing you.</p><h2 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h2><p>他回来我家是确定的。<br>It is certain that he will come to my home.<br>谁会赢这场游戏仍然是个谜。<br>It is a still a mystery who will win this game.<br>他说的是真的。<br>It is true what he talk.<br>Marry 到达的时间仍然是不确定的<br>It is uncertain when Marry arrive time.<br>我们应该努力学习这点很重要。<br>It is every important that we should study hard.</p><h1 id="the要怎么加"><a href="#the要怎么加" class="headerlink" title="the要怎么加"></a>the要怎么加</h1><p>一、特指双方都知道的人或事物<br>当所指的人、物或概念是对话双方都明确了解的，需要用 the。</p><p>•例：Close the door, please.（请关上门 —— 双方都知道指的是当前所在房间的门）<br>•例：Did you see the movie last night?（你看了昨晚的电影吗？—— 双方都知道指哪部）<br>二、指前文提到过的人或事物<br>第一次提到时用不定冠词（a&#x2F;an），再次提到时用 the。</p><p>•例：I bought a book. The book is about history.（我买了一本书。这本书是关于历史的。）<br>•例：There’s a cat in the garden. The cat is black.（花园里有一只猫。这只猫是黑色的。）<br>三、用于独一无二的事物前<br>世界上唯一存在的事物，需要用 the 限定。</p><p>•常见例子：<br>othe sun（太阳）<br>othe moon（月亮）<br>othe earth（地球）<br>othe sky（天空）<br>othe world（世界）<br>•例：The earth goes around the sun.（地球绕着太阳转。）<br>四、用于单数可数名词前，表示一类人或事物<br>用 “the + 单数名词” 代表整个类别，区别于 “a&#x2F;an + 单数名词” 或 “复数名词”（后两者更侧重泛指）。</p><p>•例：The tiger is a dangerous animal.（老虎是危险的动物 —— 指所有老虎这一类）<br>•例：The computer has changed our life.（电脑改变了我们的生活 —— 指电脑这一类事物）<br>五、用于形容词或分词前，表示一类人<br>“the + 形容词” 指代具有该特征的一类人，看作复数。</p><p>•常见例子：<br>othe poor（穷人）<br>othe rich（富人）<br>othe old（老人）<br>othe young（年轻人）<br>othe sick（病人）<br>othe wounded（伤员）<br>•例：We should help the poor.（我们应该帮助穷人。）<br>•例：The old need more care.（老人需要更多照顾。）<br>六、用于方位名词、乐器、江河湖海、山脉群岛等前<br>1.方位名词：<br>othe east（东方）、the west（西方）、the left（左边）、the right（右边）<br>o例：The sun rises in the east.（太阳从东方升起。）<br>2.乐器：<br>o演奏某种乐器时，乐器前加 the<br>o例：She plays the piano very well.（她钢琴弹得很好。）<br>o注意：球类、棋类前不加（play basketball, play chess）。<br>3.江河湖海、山脉群岛、运河、沙漠等：<br>o例：the Yangtze River（长江）、the Pacific Ocean（太平洋）、the Himalayas（喜马拉雅山脉）、the Sahara（撒哈拉沙漠）、the Suez Canal（苏伊士运河）<br>七、用于序数词、形容词最高级前<br>1.序数词（first, second, third…）：<br>o例：He was the first to arrive.（他是第一个到的。）<br>o例：This is the third time I’ve told you.（这是我第三次告诉你了。）<br>2.形容词最高级（best, tallest, most…）：<br>o例：This is the best book I’ve ever read.（这是我读过的最好的书。）<br>o例：She is the tallest in her class.（她是班上最高的。）<br>八、用于姓氏复数前，表示 “一家人” 或 “夫妇俩”<br>•例：The Greens are having dinner.（格林一家正在吃晚饭。）<br>•例：I met the Smiths at the party.（我在派对上遇到了史密斯夫妇。）<br>九、用于某些固定短语中<br>英语中有许多固定搭配必须用 the，需要积累。</p><p>•例：in the morning（在早上）、on the way（在路上）、at the moment（此刻）、by the way（顺便说一下）、in the end（最后）、the same as（和…… 一样）等。<br>总结<br>the 的核心功能是 “特指”，判断是否需要加 the，可先问自己：“所指的对象是确定的、唯一的，还是双方都明确的？” 若是，则大概率需要用 the。日常使用中，除了记住规则，多积累例句和固定搭配能更熟练掌握。</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何自动扫描并注册多个程序集中的所有 DbContext 类型</title>
      <link href="/2025/08/07/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%E6%89%80%E6%9C%89%20DbContext/"/>
      <url>/2025/08/07/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%E6%89%80%E6%9C%89%20DbContext/</url>
      
        <content type="html"><![CDATA[<h1 id="批量注册DbContext"><a href="#批量注册DbContext" class="headerlink" title="批量注册DbContext"></a>批量注册DbContext</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services.AddAllDbContexts(ctx =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> connStr = configuration.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;DefaultDB:ConnStr&quot;</span>);</span><br><span class="line">    ctx.UseSqlServer(connStr);</span><br><span class="line">&#125;, assemblies);</span><br></pre></td></tr></table></figure><p>AddAllDbContexts是自定义扩展方法，作用是自动注册所有DbContext 类型到依赖注入容器中。<br>configuration.GetValue&lt;string&gt;(“DefaultDB:ConnStr”)从配置系统中读取连接字符串，我是配置到环境变量。<br>assemblies 中所有实现了 DbContext 的类，并使用提供的委托配置它们。</p><h1 id="AddAllDbContexts"><a href="#AddAllDbContexts" class="headerlink" title="AddAllDbContexts"></a>AddAllDbContexts</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">EFCoreInitializerHelper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 批量注册指定程序集中的所有 DbContext 类型到依赖注入容器中。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;services&quot;&gt;</span>依赖注入服务容器。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;builder&quot;&gt;</span>用于配置 DbContext 选项的委托。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;assemblies&quot;&gt;</span>包含 DbContext 类型的程序集集合。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>返回服务容器本身，便于链式调用。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection <span class="title">AddAllDbContexts</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services, Action&lt;DbContextOptionsBuilder&gt; builder,</span></span></span><br><span class="line"><span class="params"><span class="function">        IEnumerable&lt;Assembly&gt; assemblies</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义 AddDbContext 泛型扩展方法的参数类型数组</span></span><br><span class="line">        Type[] types = <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(IServiceCollection), <span class="keyword">typeof</span>(Action&lt;DbContextOptionsBuilder&gt;), <span class="keyword">typeof</span>(ServiceLifetime), <span class="keyword">typeof</span>(ServiceLifetime) &#125;;</span><br><span class="line">        <span class="comment">// 通过反射获取 EntityFrameworkServiceCollectionExtensions.AddDbContext&lt;TContext&gt; 泛型方法信息</span></span><br><span class="line">        <span class="keyword">var</span> methodAddDbContext = <span class="keyword">typeof</span>(EntityFrameworkServiceCollectionExtensions)</span><br><span class="line">            .GetMethod(<span class="keyword">nameof</span>(EntityFrameworkServiceCollectionExtensions.AddDbContext), <span class="number">1</span>, types);</span><br><span class="line">        <span class="comment">// 遍历所有传入的程序集</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> asmToLoad <span class="keyword">in</span> assemblies)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取程序集中的所有类型</span></span><br><span class="line">            Type[] typesInAsm = asmToLoad.GetTypes();</span><br><span class="line">            <span class="comment">// 查找所有非抽象且继承自 DbContext 的类型</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> dbCtxType <span class="keyword">in</span> typesInAsm</span><br><span class="line">                .Where(t =&gt; !t.IsAbstract &amp;&amp; <span class="keyword">typeof</span>(DbContext).IsAssignableFrom(t)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 构造 AddDbContext&lt;TContext&gt; 泛型方法</span></span><br><span class="line">                <span class="keyword">var</span> methodGenericAddDbContext = methodAddDbContext.MakeGenericMethod(dbCtxType);</span><br><span class="line">                <span class="comment">// 调用 AddDbContext&lt;TContext&gt; 方法，将 DbContext 注册到服务容器</span></span><br><span class="line">                methodAddDbContext.Invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">object</span>[]</span><br><span class="line">                &#123;</span><br><span class="line">                    services,                <span class="comment">// 依赖注入服务容器</span></span><br><span class="line">                    builder,                 <span class="comment">// DbContext 配置委托</span></span><br><span class="line">                    ServiceLifetime.Scoped,  <span class="comment">// DbContext 生命周期为 Scoped</span></span><br><span class="line">                    ServiceLifetime.Singleton<span class="comment">// 选项生命周期为 Singleton</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回服务容器本身</span></span><br><span class="line">        <span class="keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你这段代码实现了一个 批量注册所有 DbContext 的工具方法 AddAllDbContexts，用于自动扫描并注册多个程序集中的所有 DbContext 类型，避免了手动一个一个写 services.AddDbContext&amp;ltMyContext&gt;()。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="反射查找-AddDbContext-方法"><a href="#反射查找-AddDbContext-方法" class="headerlink" title="反射查找 AddDbContext&lt;TContext&gt;() 方法"></a>反射查找 AddDbContext&lt;TContext&gt;() 方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type[] types = <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(IServiceCollection), <span class="keyword">typeof</span>(Action&lt;DbContextOptionsBuilder&gt;), <span class="keyword">typeof</span>(ServiceLifetime), <span class="keyword">typeof</span>(ServiceLifetime) &#125;;</span><br><span class="line"><span class="keyword">var</span> methodAddDbContext = <span class="keyword">typeof</span>(EntityFrameworkServiceCollectionExtensions)</span><br><span class="line">    .GetMethod(<span class="keyword">nameof</span>(EntityFrameworkServiceCollectionExtensions.AddDbContext), <span class="number">1</span>, types);</span><br></pre></td></tr></table></figure><p>目标是找到 EF Core 中的泛型方法 <code>AddDbContext&lt;TContext&gt;(this IServiceCollection, Action&lt;DbContextOptionsBuilder&gt;, ServiceLifetime, ServiceLifetime)</code><br>GetMethod 的参数 1 表示这个方法有 1 个泛型类型参数。</p><p>方法签名中参数为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AddDbContext&lt;TContext&gt;(</span><br><span class="line">  <span class="keyword">this</span> IServiceCollection services,</span><br><span class="line">  Action&lt;DbContextOptionsBuilder&gt; optionsAction,</span><br><span class="line">  ServiceLifetime contextLifetime,</span><br><span class="line">  ServiceLifetime optionsLifetime</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="扫描所有程序集中的类型并筛选-DbContext"><a href="#扫描所有程序集中的类型并筛选-DbContext" class="headerlink" title="扫描所有程序集中的类型并筛选 DbContext"></a>扫描所有程序集中的类型并筛选 DbContext</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> asmToLoad <span class="keyword">in</span> assemblies)</span><br><span class="line">&#123;</span><br><span class="line">    Type[] typesInAsm = asmToLoad.GetTypes();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> dbCtxType <span class="keyword">in</span> typesInAsm</span><br><span class="line">        .Where(t =&gt; !t.IsAbstract &amp;&amp; <span class="keyword">typeof</span>(DbContext).IsAssignableFrom(t)))</span><br></pre></td></tr></table></figure><p>找出当前程序集中所有继承自 DbContext 且不是抽象类的类型。</p><h3 id="调用泛型方法-AddDbContext"><a href="#调用泛型方法-AddDbContext" class="headerlink" title="调用泛型方法 AddDbContext&lt;TContext&gt;"></a>调用泛型方法 AddDbContext&lt;TContext&gt;</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> methodGenericAddDbContext = methodAddDbContext.MakeGenericMethod(dbCtxType);</span><br><span class="line">methodGenericAddDbContext.Invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">object</span>[]</span><br><span class="line">&#123;</span><br><span class="line">    services,</span><br><span class="line">    builder,</span><br><span class="line">    ServiceLifetime.Scoped,</span><br><span class="line">    ServiceLifetime.Singleton</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>先构造泛型方法：比如 AddDbContext&lt;MyDbContext&gt;()<br>然后反射调用它，传入四个参数。</p><p>services依赖注入容器<br>builder    用户传入的 ctx &#x3D;&gt; ctx.UseSqlServer(…) 委托<br>Scoped    DbContext 实例的生命周期（推荐使用 Scoped）<br>Singleton配置选项的生命周期（通常 Singleton 就可以）</p>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宾语从句</title>
      <link href="/2025/08/07/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E5%AE%BE%E8%AF%AD%E4%BB%8E%E5%8F%A5/"/>
      <url>/2025/08/07/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E5%AE%BE%E8%AF%AD%E4%BB%8E%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h1><p>宾语从句是名词性从句的一种，在句子中充当宾语，通常位于及物动词、介词或某些形容词之后，用来表达一个完整的意义。</p><p>1.我说了一个词。   陈述句<br>I said a word.<br>我说你是对的。<br>I said that you are right. That可以省略。（能省而不省表强调）<br>That引导<br>用于陈述句作宾语，此时 that 在从句中不充当成分，也无实际意义，常可省略（但在以下情况不可省略：多个宾语从句并列时，第一个 that 可省，后面的 that 不能省；that 引导的宾语从句作介词宾语时）。</p><p>2.我想问一个问题。        疑问句<br>I want to ask a question.<br>我想问你啥时候来我家。<br>I want to ask that when you come to my home<br>3.我不知道这个故事。&#x3D;&gt;换成一个句子就是宾语从句<br>I don’t know this story.<br>我不知道他是怎么学习英语的。<br>I don’t know how he studies English.<br>4.我认为他能解决这个问题。<br>I think that he can solve the problem.</p><p>5.我想知道我是否能做到这件事情。 疑问句做宾语<br>I want to know whether I can do this.<br>6.他告诉了我他住在哪里。<br>He told me where he lives.<br>7.我不理解这个问题-&gt;他为什么想去图书馆。<br>I don’t understand why he wants to go to the library.<br>8.我想知道你喜欢哪个苹果。<br>I want to know which apple you like.</p><h2 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h2><p>我不知道他是否会来。<br>I don’t know whether he will come.</p><p>她问我为啥我还没写完作业。<br>She asked me why I have not finished my homework.</p><p>他们相信地球绕着太阳转。<br>They believe the Earth goes around the Sun.</p><p>我理解她这么做的原因。<br>I understand why he did this.</p><p>我不记得我放钥匙的地方。<br>I don’t remember where I put the key </p><h1 id="需要加-“to”-的常见情况"><a href="#需要加-“to”-的常见情况" class="headerlink" title="需要加 “to” 的常见情况"></a>需要加 “to” 的常见情况</h1><p>一、表示 “计划、打算、决定” 的动词<br>这类动词后接不定式，说明具体的计划或目标：</p><p>•plan to：计划做某事<br>例：We plan to visit the museum tomorrow.（我们计划明天去博物馆。）<br>•decide to：决定做某事<br>例：She decided to study abroad.（她决定出国留学。）<br>•intend to：打算做某事<br>例：I intend to finish the report by Friday.（我打算周五前完成报告。）<br>二、表示 “希望、期望、渴望” 的动词<br>后接不定式表达对未来的愿望或期待：</p><p>•hope to：希望做某事<br>例：He hopes to pass the exam.（他希望通过考试。）<br>•expect to：期待做某事<br>例：They expect to arrive at 6 PM.（他们预计下午 6 点到达。）<br>•wish to：渴望做某事（较正式）<br>例：I wish to speak with the manager.（我想和经理谈谈。）<br>•long to：渴望做某事（语气较强）<br>例：She longs to see her family again.（她渴望再次见到家人。）<br>三、表示 “努力、尝试、设法” 的动词<br>后接不定式说明具体的行动或努力的目标：</p><p>•try to：尝试做某事<br>例：He tried to open the door, but it was locked.（他试着开门，但门锁了。）<br>•attempt to：试图做某事（较正式，强调努力过程）<br>例：They attempted to climb the mountain in winter.（他们试图在冬天爬山。）<br>•manage to：设法做成某事（强调结果成功）<br>例：She managed to solve the problem alone.（她设法独自解决了问题。）<br>四、表示 “需要、必须、应该” 的动词 &#x2F; 短语<br>后接不定式说明需要完成的动作：</p><p>•need to：需要做某事<br>例：You need to drink more water.（你需要多喝水。）<br>•have to：必须做某事（强调客观要求）<br>例：We have to wear uniforms at school.（我们在学校必须穿校服。）<br>•ought to：应该做某事（语气较委婉的建议）<br>例：You ought to apologize for your mistake.（你应该为你的错误道歉。）<br>五、表示 “同意、拒绝、承诺” 的动词<br>后接不定式说明具体的态度或承诺的内容：</p><p>•agree to：同意做某事<br>例：He agreed to help me with the project.（他同意帮我做这个项目。）<br>•refuse to：拒绝做某事<br>例：She refused to answer the question.（她拒绝回答这个问题。）<br>•promise to：承诺做某事<br>例：He promised to be on time.（他承诺会准时到。）<br>六、其他常用动词短语<br>•forget to：忘记做某事（事情未做）<br>例：Don’t forget to turn off the lights.（别忘了关灯。）<br>•remember to：记得做某事（事情需要做）<br>例：Remember to call your mom.（记得给你妈妈打电话。）<br>•seem to：似乎 &#x2F; 好像做某事<br>例：He seems to know the answer.（他好像知道答案。）<br>•appear to：看起来做某事<br>例：The sun appears to rise in the east.（太阳看起来从东方升起。）<br>•offer to：主动提出做某事<br>例：She offered to carry my bag.（她主动提出帮我拿包。）<br>•afford to：有能力做某事（常与 can&#x2F;can’t 连用）<br>例：We can’t afford to buy a new car.（我们买不起新车。）</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行所有模块的初始化方法</title>
      <link href="/2025/08/06/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/%E6%89%A7%E8%A1%8C%E6%89%80%E6%9C%89%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/"/>
      <url>/2025/08/06/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/%E6%89%A7%E8%A1%8C%E6%89%80%E6%9C%89%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要执行模块初始化"><a href="#为什么要执行模块初始化" class="headerlink" title="为什么要执行模块初始化"></a>为什么要执行模块初始化</h1><p>每个模块可能有自己的依赖服务（比如仓储、服务类、配置等），初始化时统一注册到依赖注入（DI）容器。</p><p>之前我们创建ReflectionHelper方法进行程序集的获取。<br>获取之后得让他们准备好运行起来。</p><p>好处：传统写法把所有服务注册写在 Program.cs，随着模块增多代码会非常混乱。而用初始化器，每个模块只管自己，清晰明了，职责单一。</p><h2 id="找到所有实现初始化接口的类"><a href="#找到所有实现初始化接口的类" class="headerlink" title="找到所有实现初始化接口的类"></a>找到所有实现初始化接口的类</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IModuleInitializer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 初始化模块，将所需服务注册到 <span class="doctag">&lt;see cref=&quot;IServiceCollection&quot;/&gt;</span> 中。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;services&quot;&gt;</span>服务集合，用于注册依赖项。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params">IServiceCollection services</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口的核心目的是为每个独立模块提供一个注册依赖注入服务的统一入口点。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyModuleA</span> : <span class="title">IModuleInitializer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册服务</span></span><br><span class="line">        services.AddSingleton&lt;IMyService, MyService&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口的模块初始化器"><a href="#接口的模块初始化器" class="headerlink" title="接口的模块初始化器"></a>接口的模块初始化器</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ModuleInitializerExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 执行指定程序集中的所有实现 <span class="doctag">&lt;see cref=&quot;IModuleInitializer&quot;/&gt;</span> 接口的模块初始化器。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;services&quot;&gt;</span>服务集合。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;assemblies&quot;&gt;</span>要扫描的程序集集合。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>服务集合本身，便于链式调用。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;ApplicationException&quot;&gt;</span>无法创建模块初始化器实例时抛出。<span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection <span class="title">RunModuleInitializers</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services,</span></span></span><br><span class="line"><span class="params"><span class="function">      IEnumerable&lt;Assembly&gt; assemblies</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> asm <span class="keyword">in</span> assemblies)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取程序集中的所有类型</span></span><br><span class="line">            Type[] types = asm.GetTypes();</span><br><span class="line">            <span class="comment">// 查找所有非抽象且实现了 IModuleInitializer 接口的类型</span></span><br><span class="line">            <span class="keyword">var</span> moduleInitializerTypes = types.Where(t =&gt; !t.IsAbstract &amp;&amp; <span class="keyword">typeof</span>(IModuleInitializer).IsAssignableFrom(t));</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> implType <span class="keyword">in</span> moduleInitializerTypes)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 创建模块初始化器实例</span></span><br><span class="line">                <span class="keyword">var</span> initializer = (IModuleInitializer?)Activator.CreateInstance(implType);</span><br><span class="line">                <span class="keyword">if</span> (initializer == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationException(<span class="string">$&quot;Cannot create $<span class="subst">&#123;implType&#125;</span>&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 调用初始化方法</span></span><br><span class="line">                initializer.Initialize(services);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection <span class="title">RunModuleInitializers</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services, IEnumerable&lt;Assembly&gt; assemblies</span>)</span></span><br></pre></td></tr></table></figure><p>是一个扩展方法：挂在IServiceCollection上，可以<code>链式调用</code>。<br>接收一组程序集参数assembies，用于模块扫描。</p><p><b>什么是链式调用：</b>链式调用（Fluent Interface 或叫 Method Chaining）是一种编程风格，其特点是连续调用多个方法，每个方法调用之后都返回当前对象或其他对象，以便继续调用下一个方法。<br>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.Services</span><br><span class="line">    .AddControllers()</span><br><span class="line">    .AddSwaggerGen()</span><br><span class="line">    .RunModuleInitializers(assemblies);</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> asm <span class="keyword">in</span> assemblies)</span><br><span class="line">&#123;</span><br><span class="line">    Type[] types = asm.GetTypes();</span><br></pre></td></tr></table></figure><p>遍历每个程序集，取出所有类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleInitializerTypes = types.Where(t =&gt; !t.IsAbstract &amp;&amp; <span class="keyword">typeof</span>(IModuleInitializer).IsAssignableFrom(t));</span><br></pre></td></tr></table></figure><p>找出所有非抽象类，实现了IModuleInitializer接口类型（包括继承的）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> implType <span class="keyword">in</span> moduleInitializerTypes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> initializer = (IModuleInitializer?)Activator.CreateInstance(implType);</span><br><span class="line">    <span class="keyword">if</span> (initializer == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationException(<span class="string">$&quot;Cannot create $<span class="subst">&#123;implType&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>利用反射创建模块初始化实例。<br>如果创建失败（返回ull）,抛出异常。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    initializer.Initialize(services);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用模块初始化逻辑，让模块把自己的服务注入进来。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> services;</span><br></pre></td></tr></table></figure><p>返回自身，便于链式调用。</p>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何获取所有引用的程序集，用于后续模块初始化和依赖注入</title>
      <link href="/2025/08/04/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E5%BC%95%E7%94%A8%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%9B%86%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%90%8E%E7%BB%AD%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2025/08/04/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E5%BC%95%E7%94%A8%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%9B%86%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%90%8E%E7%BB%AD%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="自动获取所有引用的有效程序集（程序集反射辅助类）"><a href="#自动获取所有引用的有效程序集（程序集反射辅助类）" class="headerlink" title="自动获取所有引用的有效程序集（程序集反射辅助类）"></a>自动获取所有引用的有效程序集（程序集反射辅助类）</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.Commons</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 提供反射相关的辅助方法，如程序集查找、加载、判断等。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ReflectionHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 根据产品名称获取当前应用域中所有匹配的程序集。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;productName&quot;&gt;</span>产品名称（公司名）。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>所有匹配的程序集集合。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;Assembly&gt; <span class="title">GetAssembliesByProductName</span>(<span class="params"><span class="built_in">string</span> productName</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> asms = AppDomain.CurrentDomain.GetAssemblies(); <span class="comment">// 获取当前应用域中的所有已加载程序集</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> asm <span class="keyword">in</span> asms) <span class="comment">//遍历每个程序集</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取程序集的公司属性</span></span><br><span class="line">                <span class="keyword">var</span> asmCompanyAttr = asm.GetCustomAttribute&lt;AssemblyCompanyAttribute&gt;();</span><br><span class="line">                <span class="keyword">if</span> (asmCompanyAttr != <span class="literal">null</span> &amp;&amp; asmCompanyAttr.Company == productName)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">yield</span> <span class="keyword">return</span> asm; <span class="comment">// 如果公司名匹配，则返回该程序集</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 判断程序集是否为系统程序集（通过公司名是否包含&quot;Microsoft&quot;）。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;asm&quot;&gt;</span>程序集对象。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>是系统程序集返回true，否则false。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsSystemAssembly</span>(<span class="params">Assembly asm</span>) <span class="comment">// 判断程序集是否为系统程序集</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> asmCompanyAttr = asm.GetCustomAttribute&lt;AssemblyCompanyAttribute&gt;(); <span class="comment">// 获取程序集的公司属性</span></span><br><span class="line">            <span class="keyword">if</span> (asmCompanyAttr == <span class="literal">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果没有公司属性，则认为不是系统程序集</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> companyName = asmCompanyAttr.Company; <span class="comment">// 获取公司名</span></span><br><span class="line">                <span class="keyword">return</span> companyName.Contains(<span class="string">&quot;Microsoft&quot;</span>); <span class="comment">// 如果公司名包含&quot;Microsoft&quot;，则认为是系统程序集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 判断指定路径的程序集文件是否为系统程序集。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;asmPath&quot;&gt;</span>程序集文件路径。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>是系统程序集返回true，否则false。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsSystemAssembly</span>(<span class="params"><span class="built_in">string</span> asmPath</span>) <span class="comment">// 判断指定路径的程序集文件是否为系统程序集</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> moduleDef = AsmResolver.DotNet.ModuleDefinition.FromFile(asmPath); <span class="comment">// 加载程序集文件</span></span><br><span class="line">            <span class="keyword">var</span> assembly = moduleDef.Assembly; <span class="comment">// 获取程序集定义</span></span><br><span class="line">            <span class="keyword">if</span> (assembly == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果没有程序集定义，则认为不是系统程序集</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> asmCompanyAttr = assembly.CustomAttributes.FirstOrDefault(c =&gt; c.Constructor?.DeclaringType?.FullName == <span class="keyword">typeof</span>(AssemblyCompanyAttribute).FullName); <span class="comment">// 获取程序集的公司属性</span></span><br><span class="line">            <span class="keyword">if</span> (asmCompanyAttr == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果没有公司属性，则认为不是系统程序集</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> companyName = ((AsmResolver.Utf8String)asmCompanyAttr.Signature?.FixedArguments[<span class="number">0</span>]?.Element)?.Value;<span class="comment">// 获取公司名</span></span><br><span class="line">            <span class="keyword">if</span> (companyName == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 如果公司名为空，则认为不是系统程序集</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> companyName.Contains(<span class="string">&quot;Microsoft&quot;</span>); <span class="comment">// 如果公司名包含&quot;Microsoft&quot;，则认为是系统程序集</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 判断指定文件是否为托管程序集（.NET程序集）。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;file&quot;&gt;</span>文件路径。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>是托管程序集返回true，否则false。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsManagedAssembly</span>(<span class="params"><span class="built_in">string</span> file</span>)  <span class="comment">// 判断指定文件是否为托管程序集</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fs = File.OpenRead(file);<span class="comment">// 打开文件流</span></span><br><span class="line">            <span class="keyword">using</span> PEReader peReader = <span class="keyword">new</span> PEReader(fs);<span class="comment">// 创建PEReader对象读取PE文件</span></span><br><span class="line">            <span class="keyword">return</span> peReader.HasMetadata &amp;&amp; peReader.GetMetadataReader().IsAssembly; <span class="comment">// 如果PE文件有元数据且是程序集，则认为是托管程序集</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 尝试加载指定路径的程序集。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;asmPath&quot;&gt;</span>程序集文件路径。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>加载成功返回程序集对象，否则返回null。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Assembly? TryLoadAssembly(<span class="built_in">string</span> asmPath)</span><br><span class="line">        &#123;</span><br><span class="line">            AssemblyName asmName = AssemblyName.GetAssemblyName(asmPath);</span><br><span class="line">            Assembly? asm = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                asm = Assembly.Load(asmName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BadImageFormatException ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.WriteLine(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (FileLoadException ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.WriteLine(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (asm == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    asm = Assembly.LoadFile(asmPath);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BadImageFormatException ex)</span><br><span class="line">                &#123;</span><br><span class="line">                    Debug.WriteLine(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (FileLoadException ex)</span><br><span class="line">                &#123;</span><br><span class="line">                    Debug.WriteLine(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> asm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取所有引用的程序集（可选跳过系统程序集），包括当前目录下的所有托管程序集。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;skipSystemAssemblies&quot;&gt;</span>是否跳过系统程序集。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>所有引用的程序集集合。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;Assembly&gt; <span class="title">GetAllReferencedAssemblies</span>(<span class="params"><span class="built_in">bool</span> skipSystemAssemblies = <span class="literal">true</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Assembly? rootAssembly = Assembly.GetEntryAssembly();</span><br><span class="line">            <span class="keyword">if</span> (rootAssembly == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rootAssembly = Assembly.GetExecutingAssembly();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> returnAssemblies = <span class="keyword">new</span> HashSet&lt;Assembly&gt;(<span class="keyword">new</span> AssemblyEquality());</span><br><span class="line">            <span class="keyword">var</span> loadedAssemblies = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">            <span class="keyword">var</span> assembliesToCheck = <span class="keyword">new</span> Queue&lt;Assembly&gt;();</span><br><span class="line">            assembliesToCheck.Enqueue(rootAssembly);</span><br><span class="line">            <span class="comment">// 检查根程序集是否需要加入</span></span><br><span class="line">            <span class="keyword">if</span> (skipSystemAssemblies &amp;&amp; IsSystemAssembly(rootAssembly) != <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!IsValid(rootAssembly))</span><br><span class="line">                &#123;</span><br><span class="line">                    returnAssemblies.Add(rootAssembly);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 广度优先遍历所有引用的程序集</span></span><br><span class="line">            <span class="keyword">while</span> (assembliesToCheck.Any())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> assemblyToCheck = assembliesToCheck.Dequeue();</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> reference <span class="keyword">in</span> assemblyToCheck.GetReferencedAssemblies())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!loadedAssemblies.Contains(reference.FullName))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> assembly = Assembly.Load(reference);</span><br><span class="line">                        <span class="keyword">if</span> (skipSystemAssemblies &amp;&amp; IsSystemAssembly(assembly))</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        assembliesToCheck.Enqueue(assembly);</span><br><span class="line">                        loadedAssemblies.Add(reference.FullName);</span><br><span class="line">                        <span class="keyword">if</span> (IsValid(assembly))</span><br><span class="line">                        &#123;</span><br><span class="line">                            returnAssemblies.Add(assembly);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 扫描当前目录下所有托管程序集</span></span><br><span class="line">            <span class="keyword">var</span> asmsInBaseDir = Directory.EnumerateFiles(AppContext.BaseDirectory,</span><br><span class="line">                <span class="string">&quot;*.dll&quot;</span>, <span class="keyword">new</span> EnumerationOptions &#123; RecurseSubdirectories = <span class="literal">true</span> &#125;);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> asmPath <span class="keyword">in</span> asmsInBaseDir)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!IsManagedAssembly(asmPath))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                AssemblyName asmName = AssemblyName.GetAssemblyName(asmPath);</span><br><span class="line">                <span class="keyword">if</span> (returnAssemblies.Any(x =&gt; AssemblyName.ReferenceMatchesDefinition(x.GetName(), asmName)))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (skipSystemAssemblies &amp;&amp; IsSystemAssembly(asmPath))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Assembly? asm = TryLoadAssembly(asmPath);</span><br><span class="line">                <span class="keyword">if</span> (asm == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!IsValid(asm))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (skipSystemAssemblies &amp;&amp; IsSystemAssembly(asm))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                returnAssemblies.Add(asm);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> returnAssemblies.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 判断程序集是否有效（能否正常获取类型信息）。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;asm&quot;&gt;</span>程序集对象。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>有效返回true，否则false。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsValid</span>(<span class="params">Assembly asm</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                asm.GetTypes();</span><br><span class="line">                asm.DefinedTypes.ToList();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (ReflectionTypeLoadException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用于比较程序集是否相等的辅助类（通过程序集名称）。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">AssemblyEquality</span> : <span class="title">EqualityComparer</span>&lt;<span class="title">Assembly</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">Assembly? x, Assembly? y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="literal">null</span> &amp;&amp; y == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> AssemblyName.ReferenceMatchesDefinition(x.GetName(), y.GetName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>(<span class="params">[DisallowNull] Assembly obj</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> obj.GetName().FullName.GetHashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总体结构说明"><a href="#总体结构说明" class="headerlink" title="总体结构说明"></a>总体结构说明</h2><p>这个类提供了：</p><p><b>GetAssembliesByProductName</b>：获取当前已经加载的程序集中，公司名等于指定的程序集。<br><b>IsSystemAssembly(Assembly)&#x2F;IsSystemAssembly(string)</b>:判断是否为系统程序集（通过公司名判断）<br><b>IsManagedAssembly</b>:判断某.dll文件是否为托管程序集。<br><b>TryLoadAssembly</b>:安全加载一个程序集。<br><b>GetAllReferencedAssemblies</b>:主方法：递归获取所有引用程序集，并加载当前目录中有效.dll文件。<br><b>IsValid</b>:判断程序集是否有效（能否获取类型）。<br><b>AssemblyEquality</b>:对程序集进行比较，避免重复添加。</p><h2 id="分析每个部分功能与逻辑"><a href="#分析每个部分功能与逻辑" class="headerlink" title="分析每个部分功能与逻辑"></a>分析每个部分功能与逻辑</h2><h3 id="GetAssembliesByProductName"><a href="#GetAssembliesByProductName" class="headerlink" title="GetAssembliesByProductName"></a>GetAssembliesByProductName</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;Assembly&gt; <span class="title">GetAssembliesByProductName</span>(<span class="params"><span class="built_in">string</span> productName</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> asms = AppDomain.CurrentDomain.GetAssemblies(); <span class="comment">// 获取当前应用域中的所有已加载程序集</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> asm <span class="keyword">in</span> asms) <span class="comment">//遍历每个程序集</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取程序集的公司属性</span></span><br><span class="line">        <span class="keyword">var</span> asmCompanyAttr = asm.GetCustomAttribute&lt;AssemblyCompanyAttribute&gt;();</span><br><span class="line">        <span class="keyword">if</span> (asmCompanyAttr != <span class="literal">null</span> &amp;&amp; asmCompanyAttr.Company == productName)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> asm; <span class="comment">// 如果公司名匹配，则返回该程序集</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Enumerable&lt;Assembly&gt; 是一个泛型可枚举类型，表示一个 可以遍历的程序集（System.Reflection.Assembly）集合，通常用于反射操作中，比如加载、筛选、注册程序集等场景。<br>从当前应用域中获取所有已加载的程序集（AppDomain.CurrentDomain.GetAssembles()）<br>检查每个程序集的[AssemblyCompany]特性（公司名）<br>返回公司名等于指定值的程序集<br>用于过滤出“公司内开发”的程序集。</p></blockquote><h3 id="IsSystemAssembly-重载方法"><a href="#IsSystemAssembly-重载方法" class="headerlink" title="IsSystemAssembly(重载方法)"></a>IsSystemAssembly(重载方法)</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsSystemAssembly</span>(<span class="params">Assembly asm</span>) <span class="comment">// 判断程序集是否为系统程序集</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> asmCompanyAttr = asm.GetCustomAttribute&lt;AssemblyCompanyAttribute&gt;(); <span class="comment">// 获取程序集的公司属性</span></span><br><span class="line">    <span class="keyword">if</span> (asmCompanyAttr == <span class="literal">null</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果没有公司属性，则认为不是系统程序集</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> companyName = asmCompanyAttr.Company; <span class="comment">// 获取公司名</span></span><br><span class="line">        <span class="keyword">return</span> companyName.Contains(<span class="string">&quot;Microsoft&quot;</span>); <span class="comment">// 如果公司名包含&quot;Microsoft&quot;，则认为是系统程序集</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IsSystemAssembly(Assembly asm)通过AssemblyCompanyAttribute判断是否包含“Microsoft”.</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsSystemAssembly</span>(<span class="params"><span class="built_in">string</span> asmPath</span>) <span class="comment">// 判断指定路径的程序集文件是否为系统程序集</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> moduleDef = AsmResolver.DotNet.ModuleDefinition.FromFile(asmPath); <span class="comment">// 加载程序集文件</span></span><br><span class="line">    <span class="keyword">var</span> assembly = moduleDef.Assembly; <span class="comment">// 获取程序集定义</span></span><br><span class="line">    <span class="keyword">if</span> (assembly == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果没有程序集定义，则认为不是系统程序集</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> asmCompanyAttr = assembly.CustomAttributes.FirstOrDefault(c =&gt; c.Constructor?.DeclaringType?.FullName == <span class="keyword">typeof</span>(AssemblyCompanyAttribute).FullName); <span class="comment">// 获取程序集的公司属性</span></span><br><span class="line">    <span class="keyword">if</span> (asmCompanyAttr == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果没有公司属性，则认为不是系统程序集</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> companyName = ((AsmResolver.Utf8String)asmCompanyAttr.Signature?.FixedArguments[<span class="number">0</span>]?.Element)?.Value;<span class="comment">// 获取公司名</span></span><br><span class="line">    <span class="keyword">if</span> (companyName == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 如果公司名为空，则认为不是系统程序集</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> companyName.Contains(<span class="string">&quot;Microsoft&quot;</span>); <span class="comment">// 如果公司名包含&quot;Microsoft&quot;，则认为是系统程序集</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IsSystemAssembly(string asmPath)使用AsmResolver读取.dll元数据，再检查是否是系统程序集。<br><b>assembly.CustomAttributes</b>:获取程序集定义上的所有自定义特性（如 [AssemblyCompany], [AssemblyTitle] 等）<br><b>.FirstOrDefault(…)</b>:从中取出第一个符合条件的特性，找不到就返回null<br><b>c.Constructor?.DeclaringType?.FullName</b>:获取特性的构造函数所属类型的完整名称（及特性类型本身的FullName）<br><b>typeof(AssemblyCompanyAattribute).FullName</b>:获取AssemblyCompanyAttribute的完整名称，即 “System.Reflection.AssemblyCompanyAttribute”</p></blockquote><p><b>asmCompanyAttr.Signature</b>:这是一个 CustomAttributeSignature 对象，表示这个特性的构造函数签名，包括参数类型、值等。<br><b>.FixedArguments[0]</b>:这是获取第一个固定参数。对于 [AssemblyCompany(“OpenAI”)]，这个第一个参数就是 “OpenAI”。<br><b>.Element</b>:FixedArguments[0].Element 是这个参数的值，类型是 ICustomAttributeType，但在字符串特性的场景下，它其实就是 Utf8String 类型的对象。<br><b>(AsmResolver.Utf8String)…</b>:将 Element 显式转换为 Utf8String，这是 AsmResolver 用来表示字符串的一种类型（和 .NET 的 string 类似，但内部是 UTF-8 编码结构）。<br><b>?.Value</b>:取出字符串的值。</p><blockquote><p>这两个方法允许你在这两种场景下都判断程序集是否为“系统提供”（避免处理不必要的系统程序集）</p></blockquote><h3 id="IsManagedAssembly"><a href="#IsManagedAssembly" class="headerlink" title="IsManagedAssembly"></a>IsManagedAssembly</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsManagedAssembly</span>(<span class="params"><span class="built_in">string</span> file</span>)  <span class="comment">// 判断指定文件是否为托管程序集</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> fs = File.OpenRead(file);<span class="comment">// 打开文件流</span></span><br><span class="line">    <span class="keyword">using</span> PEReader peReader = <span class="keyword">new</span> PEReader(fs);<span class="comment">// 创建PEReader对象读取PE文件</span></span><br><span class="line">    <span class="keyword">return</span> peReader.HasMetadata &amp;&amp; peReader.GetMetadataReader().IsAssembly; <span class="comment">// 如果PE文件有元数据且是程序集，则认为是托管程序集</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 System.Reflection.PortableExecutable.PEReader 判断 .dll 是否是托管程序集<br>核心判断是：是否有元数据 (peReader.HasMetadata) 且为程序集 (IsAssembly)</p></blockquote><p><b>peReader.HasMetadata</b>:文件中包含 .NET 元数据（说明是托管代码的一部分）<br><b>IsAssembly</b>:文件表示的是一个 程序集（即 .dll 或 .exe 中包含 Assembly 清单）</p><blockquote><p>这样可以避免尝试加载本地DLL、C++DLL等非.NET程序集。</p></blockquote><h3 id="TryLoadAssembly"><a href="#TryLoadAssembly" class="headerlink" title="TryLoadAssembly"></a>TryLoadAssembly</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Assembly? TryLoadAssembly(<span class="built_in">string</span> asmPath) <span class="comment">//尝试从指定路径加载一个 .NET 程序集</span></span><br><span class="line">&#123;</span><br><span class="line">    AssemblyName asmName = AssemblyName.GetAssemblyName(asmPath);<span class="comment">//读取程序集的元信息</span></span><br><span class="line">    Assembly? asm = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        asm = Assembly.Load(asmName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BadImageFormatException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (FileLoadException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (asm == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            asm = Assembly.LoadFile(asmPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BadImageFormatException ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (FileLoadException ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> asm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 Assembly.Load(AssemblyName) 加载<br>若失败，则尝试 Assembly.LoadFile 加载<br>捕获并记录常见错误，如 BadImageFormatException 和 FileLoadException</p></blockquote><p><b>AssemblyName.GetAssemblyName(asmPath)</b>:这一步尝试从文件中读取程序集的元信息，比如它的名称、版本、文化、公钥等。不会真正加载程序集，只是获取它的标识。<br><b>Assembly.Load(asmName)</b>:这是根据程序集名称（而不是文件路径）尝试从 当前 AppDomain 的探测路径中加载程序集。如果已经加载过，它会直接返回。<br>BadImageFormatException: 文件不是有效的 .NET 程序集（可能是原生 DLL）<br>FileLoadException: 可能是文件锁定、权限问题、版本冲突等<br><b>Assembly.LoadFile(asmPath)</b>:如果第一次加载失败（返回 null），就使用 Assembly.LoadFile 直接从绝对路径加载程序集。</p><blockquote><p>避免程序因为一个非法的 .dll 崩溃，同时仍尽可能加载更多程序集。</p></blockquote><h3 id="IsValid"><a href="#IsValid" class="headerlink" title="IsValid"></a>IsValid</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsValid</span>(<span class="params">Assembly asm</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        asm.GetTypes();              <span class="comment">// 尝试获取程序集中的所有类型</span></span><br><span class="line">        asm.DefinedTypes.ToList();   <span class="comment">// 尝试枚举所有类型定义</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                 <span class="comment">// 没异常，就说明有效</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ReflectionTypeLoadException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.WriteLine(<span class="string">$&quot;程序集加载失败: <span class="subst">&#123;asm.FullName&#125;</span> - <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                <span class="comment">// 如果无法加载某些类型，说明程序集可能不完整或有依赖问题</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过调用 GetTypes 和 DefinedTypes 来确保程序集中的类型是可访问的<br>捕获 ReflectionTypeLoadException 以处理不完整的程序集</p></blockquote><h3 id="AssemblyEquality"><a href="#AssemblyEquality" class="headerlink" title="AssemblyEquality"></a>AssemblyEquality</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">AssemblyEquality</span> : <span class="title">EqualityComparer</span>&lt;<span class="title">Assembly</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">Assembly? x, Assembly? y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> &amp;&amp; y == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> AssemblyName.ReferenceMatchesDefinition(x.GetName(), y.GetName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>(<span class="params">[DisallowNull] Assembly obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.GetName().FullName.GetHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>比较两个程序集是否相等，使用 AssemblyName.ReferenceMatchesDefinition 来确保版本等信息一致<br>用 AssemblyName.ReferenceMatchesDefinition 判断两个程序集是否“等价”，并且基于 AssemblyName.FullName 提供稳定的 HashCode。<br>用于 HashSet&lt;Assembly&gt; 去重时，自定义判断逻辑。</p></blockquote><h3 id="GetAllReferencedAssemblies"><a href="#GetAllReferencedAssemblies" class="headerlink" title="GetAllReferencedAssemblies"></a>GetAllReferencedAssemblies</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;Assembly&gt; <span class="title">GetAllReferencedAssemblies</span>(<span class="params"><span class="built_in">bool</span> skipSystemAssemblies = <span class="literal">true</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Assembly? rootAssembly = Assembly.GetEntryAssembly();</span><br><span class="line">    <span class="keyword">if</span> (rootAssembly == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rootAssembly = Assembly.GetExecutingAssembly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> returnAssemblies = <span class="keyword">new</span> HashSet&lt;Assembly&gt;(<span class="keyword">new</span> AssemblyEquality());</span><br><span class="line">    <span class="keyword">var</span> loadedAssemblies = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">var</span> assembliesToCheck = <span class="keyword">new</span> Queue&lt;Assembly&gt;();</span><br><span class="line">    assembliesToCheck.Enqueue(rootAssembly);</span><br><span class="line">    <span class="comment">// 检查根程序集是否需要加入</span></span><br><span class="line">    <span class="keyword">if</span> (skipSystemAssemblies &amp;&amp; IsSystemAssembly(rootAssembly) != <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!IsValid(rootAssembly))</span><br><span class="line">        &#123;</span><br><span class="line">            returnAssemblies.Add(rootAssembly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 广度优先遍历所有引用的程序集</span></span><br><span class="line">    <span class="keyword">while</span> (assembliesToCheck.Any())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> assemblyToCheck = assembliesToCheck.Dequeue();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> reference <span class="keyword">in</span> assemblyToCheck.GetReferencedAssemblies())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!loadedAssemblies.Contains(reference.FullName))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> assembly = Assembly.Load(reference);</span><br><span class="line">                <span class="keyword">if</span> (skipSystemAssemblies &amp;&amp; IsSystemAssembly(assembly))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                assembliesToCheck.Enqueue(assembly);</span><br><span class="line">                loadedAssemblies.Add(reference.FullName);</span><br><span class="line">                <span class="keyword">if</span> (IsValid(assembly))</span><br><span class="line">                &#123;</span><br><span class="line">                    returnAssemblies.Add(assembly);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描当前目录下所有托管程序集</span></span><br><span class="line">    <span class="keyword">var</span> asmsInBaseDir = Directory.EnumerateFiles(AppContext.BaseDirectory,</span><br><span class="line">        <span class="string">&quot;*.dll&quot;</span>, <span class="keyword">new</span> EnumerationOptions &#123; RecurseSubdirectories = <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> asmPath <span class="keyword">in</span> asmsInBaseDir)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!IsManagedAssembly(asmPath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        AssemblyName asmName = AssemblyName.GetAssemblyName(asmPath);</span><br><span class="line">        <span class="keyword">if</span> (returnAssemblies.Any(x =&gt; AssemblyName.ReferenceMatchesDefinition(x.GetName(), asmName)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (skipSystemAssemblies &amp;&amp; IsSystemAssembly(asmPath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Assembly? asm = TryLoadAssembly(asmPath);</span><br><span class="line">        <span class="keyword">if</span> (asm == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!IsValid(asm))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (skipSystemAssemblies &amp;&amp; IsSystemAssembly(asm))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        returnAssemblies.Add(asm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnAssemblies.ToArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>初始化<br>取入口程序集Assembly.GetEntryAssembly()，找不到就用当前正在执行的程序集。<br>创建 returnAssemblies 集合用于去重和存放结果<br>创建队列 assembliesToCheck 广度优先遍历依赖关系</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnAssemblies = <span class="keyword">new</span> HashSet&lt;Assembly&gt;(<span class="keyword">new</span> AssemblyEquality()); <span class="comment">// 结果集合，去重</span></span><br><span class="line"><span class="keyword">var</span> loadedAssemblies = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;(); <span class="comment">// 已加载的程序集名，防重复加载</span></span><br><span class="line"><span class="keyword">var</span> assembliesToCheck = <span class="keyword">new</span> Queue&lt;Assembly&gt;(); <span class="comment">// 广度优先队列</span></span><br><span class="line">assembliesToCheck.Enqueue(rootAssembly);</span><br></pre></td></tr></table></figure><p><b>assembliesToCheck.Enqueue(rootAssembly)</b>:把根程序集放入队列 assembliesToCheck 中，作为后续要处理的第一个程序集。</p></li><li><p>检查程序集是否加入</p></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (skipSystemAssemblies &amp;&amp; IsSystemAssembly(rootAssembly) != <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsValid(rootAssembly))</span><br><span class="line">    &#123;</span><br><span class="line">        returnAssemblies.Add(rootAssembly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果启用了跳过系统程序集（skipSystemAssemblies &#x3D; true），并且 rootAssembly 被识别为系统程序集，但它又是“无效”的，那就强制加入这个程序集。</p></blockquote><ol start="3"><li>递归加载引用程序集</li></ol><p>遍历当前队列中的程序集引用，加载未加载的引用程序集。<br>使用 Assembly.Load(AssemblyName) 加载引用。<br>加入队列继续递归。<br>判断是否为系统程序集、是否有效。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (assembliesToCheck.Any())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> assemblyToCheck = assembliesToCheck.Dequeue();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> reference <span class="keyword">in</span> assemblyToCheck.GetReferencedAssemblies())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loadedAssemblies.Contains(reference.FullName))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> assembly = Assembly.Load(reference);</span><br><span class="line">            <span class="keyword">if</span> (skipSystemAssemblies &amp;&amp; IsSystemAssembly(assembly))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            assembliesToCheck.Enqueue(assembly);</span><br><span class="line">            loadedAssemblies.Add(reference.FullName);</span><br><span class="line">            <span class="keyword">if</span> (IsValid(assembly))</span><br><span class="line">            &#123;</span><br><span class="line">                returnAssemblies.Add(assembly);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>while (assembliesToCheck.Any())</b>:<br>这是 广度优先遍历 的主循环条件：<br>assembliesToCheck 是一个 Queue&lt;Assembly&gt;，存储待处理的程序集；只要队列不为空，就继续处理。<br><b>var assemblyToCheck &#x3D; assembliesToCheck.Dequeue();</b>:从队列中取出一个待检查的程序集。<br><b>assemblyToCheck.GetReferencedAssemblies()</b>:获取当前程序集引用的所有其他程序集.<br><b>if (!loadedAssemblies.Contains(reference.FullName))</b>:判断当前引用程序集是否已处理过：<br>loadedAssemblies 是一个 HashSet&lt;string&gt;；<br>避免重复加载和无限循环。<br><b>var assembly &#x3D; Assembly.Load(reference)</b>:尝试根据名称加载程序集：<br>使用 Assembly.Load(AssemblyName) 会从当前的应用域中加载已有的，或从 probing path 中查找。<br><b>if (skipSystemAssemblies &amp;&amp; IsSystemAssembly(assembly))</b>:跳过系统程序集的条件判断：<br>如果用户设置了 skipSystemAssemblies &#x3D; true；<br>并且当前程序集是系统程序集（比如 Microsoft、System 开头）；<br>那就 continue，直接跳过不处理。<br><b>assembliesToCheck.Enqueue(assembly)</b>:将新加载的程序集加入待处理队列，递归处理它的引用程序集。<br><b><br><b>loadedAssemblies.Add(reference.FullName)</b>:标记这个程序集已经处理过。<br><b>if (IsValid(assembly)) { returnAssemblies.Add(assembly); }</b>:最后判断这个程序集是否是“有效”的（没有类型加载错误等），是的话加入最终结果集中。</p><ol start="4"><li>额外加载当前目录下的 DLL 文件</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asmsInBaseDir = Directory.EnumerateFiles(AppContext.BaseDirectory,</span><br><span class="line">    <span class="string">&quot;*.dll&quot;</span>, <span class="keyword">new</span> EnumerationOptions &#123; RecurseSubdirectories = <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> asmPath <span class="keyword">in</span> asmsInBaseDir)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsManagedAssembly(asmPath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AssemblyName asmName = AssemblyName.GetAssemblyName(asmPath);</span><br><span class="line">    <span class="keyword">if</span> (returnAssemblies.Any(x =&gt; AssemblyName.ReferenceMatchesDefinition(x.GetName(), asmName)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (skipSystemAssemblies &amp;&amp; IsSystemAssembly(asmPath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Assembly? asm = TryLoadAssembly(asmPath);</span><br><span class="line">    <span class="keyword">if</span> (asm == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!IsValid(asm))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (skipSystemAssemblies &amp;&amp; IsSystemAssembly(asm))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    returnAssemblies.Add(asm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnAssemblies.ToArray();</span><br></pre></td></tr></table></figure><blockquote><p>遍历当前应用目录的所有 .dll<br>判断是否为托管程序集<br>判断是否为系统程序集<br>判断是否已经加载<br>通过 TryLoadAssembly 尝试加载<br>判断是否有效（能否访问类型定义）</p></blockquote><p>这是为了把那些没有被主动引用，但仍在部署目录中的程序集加载进来。<br>使用 AppContext.BaseDirectory 获取运行目录，递归查找子目录中所有 .dll 文件<br>用 PEReader 判断是不是托管程序集<br>if (returnAssemblies.Any(x &#x3D;&gt;：防止重复加载同一个程序集（即使路径不同，只要 AssemblyName 一致，就视为相同）</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><table border="1" cellspacing="0"><tr><td>场景</td><td>示例</td></tr><tr><td>模块化注册</td><td>自动扫描实现了 IModuleInitializer 的类型并初始化</td></tr><tr><td>插件系统</td><td>加载插件目录的所有 .NET 程序集</td></tr><tr><td>自动依赖注入</td><td>根据命名空间、接口特征批量注册服务</td></tr><tr><td>动态发现服务</td><td>分布式架构中加载远程/本地服务模块</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebApplication 和 WebApplicationBuilder</title>
      <link href="/2025/08/03/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/WebApplication%20%E5%92%8C%20WebApplicationBuilder/"/>
      <url>/2025/08/03/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/WebApplication%20%E5%92%8C%20WebApplicationBuilder/</url>
      
        <content type="html"><![CDATA[<h1 id="WebAppliction"><a href="#WebAppliction" class="headerlink" title="WebAppliction"></a>WebAppliction</h1><p><b>用途</b>:是实际运行的ASP.NET Core应用实例。通过它我们可以<code>注册中间件[Use()]</code>、<code>映射终节点[Map()]</code>、<code>最终调用[Run()]启动服务监视器</code>。</p><p>类比：真正盖好并运行的房子，住人、供电、供水的阶段。</p><h2 id="核心组成"><a href="#核心组成" class="headerlink" title="核心组成"></a><b>核心组成</b></h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line">app.MapGet(<span class="string">&quot;/&quot;</span>, () =&gt; <span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">app.Run();</span><br></pre></td></tr></table></figure><table border="1" cellspacing="0"><tr><td>成员</td><td>类型</td><td>说明</td></tr><tr><td>app.UseXxx()</td><td>中间件添加方法</td><td>用于处理请求的中间件管道</td></tr><tr><td>apapp.UseXxx()</td><td>终结点注册</td><td>定义请求的路由逻辑</td></tr><tr><td>app.Run()</td><td>启动方法</td><td>启动HTTP服务监听请求</td></tr><tr><td>app.Environment</td><td>IHostEnvironment</td><td>当前环境</td></tr><tr><td>app.Services</td><td>IServiceProvider</td><td>访问服务容器中的服务</td></tr></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">app.Map(<span class="string">&quot;/test&quot;</span>, <span class="keyword">async</span> (pipeBuilder) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    pipeBuilder.Use(<span class="keyword">async</span> (context, next) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        context.Response.ContentType = <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;1 start&lt;br/&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">await</span> next.Invoke();</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;1 end&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pipeBuilder.Use(<span class="keyword">async</span> (context, next) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;2 start&lt;br/&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">await</span> next.Invoke();</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;2 end&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pipeBuilder.UseMiddleware&lt;TestIMddleware&gt;();</span><br><span class="line">    pipeBuilder.Run(<span class="keyword">async</span> context =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;Run&lt;br/&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">dynamic</span> obj = context.Items[<span class="string">&quot;BodyJson&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">$&quot;BodyJson: <span class="subst">&#123;obj&#125;</span>&lt;br/&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    pipeBuilder.Run(<span class="keyword">async</span> context =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;Run&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li><p>app.Map(“&#x2F;test”, async (pipeBuilder) &#x3D;&gt; { … })<br>这里将&#x2F;test路径映射到一个新的中间件分支中。<br>Map()是条件分支（类似if）,只当路径以&#x2F;test开头时才执行内部管道。<br>pipeBuilder就是新的IApplicationBuilder，你可以在里面Use、Run中间件，彼此不会影响主管道。</p></li><li><p>context.Response.ContentType &#x3D; “text&#x2F;html”;<br>context.Response是Httponse对象，代表服务器要发回的响应。<br>ContentType是设置响应头Content-Type.<br>设置为“text&#x2F;html”，意味着：浏览器将按HTML格式渲染内容。写入的字符串将被当作HTML解析，而不是普通文本。<br>next.Invoke();进入下一个中间件</p></li></ol><p>常见 Content-Type 类型</p><p>ContentType            说明</p><p>text&#x2F;html            返回 HTML 网页内容<br>text&#x2F;plain            纯文本（无格式）<br>application&#x2F;json    JSON 数据（常用于 API）<br>application&#x2F;xmlXML     数据<br>text&#x2F;css            CSS 样式表<br>application&#x2F;javascriptJavaScript 脚本</p><p>如果没设置 ContentType，默认是 text&#x2F;plain，浏览器不会解析为 HTML，而是直接把 &lt;h1&gt;Hello&lt;&#x2F;h1&gt; 当作纯文本显示。</p><p>3.pipeBuilder.UseMiddleware&lt;TestIMddleware&gt;();自定义中间件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestIMddleware</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> RequestDelegate next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestIMddleware</span>(<span class="params">RequestDelegate next</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">InvokeAsync</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;TestIMddleware start&lt;br/&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">await</span> next.Invoke(context);</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;TestIMddleware end&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>为什么第二个Run()不执行？<br>中间件管道是单挑链表结构，从上到下依次调用。<br>Run()相当于Use()的最后一环，他不会调用next()，所以执行到第一个Run()后，后面的中间件被跳过了。<br>规则:只能有一个Run()，如果写多了，只有第一个生效，其他被忽略。</li></ol><h1 id="WebApplicationBuilder"><a href="#WebApplicationBuilder" class="headerlink" title="WebApplicationBuilder"></a>WebApplicationBuilder</h1><p><b>用途</b>:<code>WebApplicationBuilder是用于构建WebApplication的工厂类，她负责配置服务、配置应用环境、日志、配置文件、主机设置等内容。</p><p>类比：他是建房子的阶段：备材料、设计圈、准备工人。</p><h2 id="核心组成-1"><a href="#核心组成-1" class="headerlink" title="核心组成"></a>核心组成</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br></pre></td></tr></table></figure><table border="1" cellspacing="0"><tr><td>成员</td><td>类型</td><td>说明</td></tr><tr><td>builder.Services</td><td>IServiceCollection</td><td>注册DI容器中的服务</td></tr><tr><td>builder.Configuration</td><td>ICongiguration</td><td>加载配置文件（appsettings.json、环境变量等）</td></tr><tr><td>builder.Logging</td><td>ILoggingBuilder</td><td>配置日志</td></tr><tr><td>builder.Environment</td><td>IHostEnvironment</td><td>当前运行环境（开发、生产）</td></tr><tr><td>builder.Host</td><td>IHostBuilder</td><td>配置主机设置，如添加 HostedService</td></tr><tr><td>builder.WebHost</td><td>IWebHostBuilder</td><td>主要配置 WebServer（Kestrel）、监听端口等</td></table><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置服务</span></span><br><span class="line">builder.Services.AddControllers();</span><br><span class="line">builder.Services.AddDbContext&lt;AppDbContext&gt;();</span><br><span class="line">builder.Services.AddSwaggerGen();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置日志</span></span><br><span class="line">builder.Logging.ClearProviders();</span><br><span class="line">builder.Logging.AddConsole();</span><br></pre></td></tr></table></figure><p>AddControllers();配置服务（注册到 DI 容器）</p><p>AddDbContext&lt;AppDbContext&gt;();注册你的数据库上下文 AppDbContext。<br>通常你会配合指定数据库类型，例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddDbContext&lt;AppDbContext&gt;(options =&gt;</span><br><span class="line">    options.UseSqlServer(builder.Configuration.GetConnectionString(<span class="string">&quot;Default&quot;</span>)));</span><br></pre></td></tr></table></figure><p>AddSwaggerGen();注册 Swagger 文档生成器，用于自动生成 OpenAPI 接口文档。<br>会启用 /swagger/v1/swagger.json 及 /swagger 的 UI 页面。<br>配合 app.UseSwagger() 和 app.UseSwaggerUI() 使用。</p><p>Logging.ClearProviders()清除所有默认注册的日志记录器（例如 Debug、EventLog 等）。<br>AddConsole() 启用控制台日志输出（运行时输出到终端）。</p><h1 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h1><ol><li><p>WebApplicationBuilder 是对 HostApplicationBuilder 的包装，提供默认配置，并集成 IHostBuilder 和 IWebHostBuilder。</p></li><li><p>WebApplication 实现了 IApplicationBuilder 接口，是一个扩展了 Web 中间件构建和执行的类型。</p></li><li><p>构建过程本质上还是走 Host.CreateDefaultBuilder()，再添加了 Kestrel、日志、配置等默认配置。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>to do主动表被动+非谓语词性</title>
      <link href="/2025/08/03/asp.net%20core/%E8%8B%B1%E8%AF%AD/to%20do%E4%B8%BB%E5%8A%A8%E8%A1%A8%E8%A2%AB%E5%8A%A8/"/>
      <url>/2025/08/03/asp.net%20core/%E8%8B%B1%E8%AF%AD/to%20do%E4%B8%BB%E5%8A%A8%E8%A1%A8%E8%A2%AB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="to-do主动表被动-非谓语词性"><a href="#to-do主动表被动-非谓语词性" class="headerlink" title="to do主动表被动+非谓语词性"></a>to do主动表被动+非谓语词性</h1><p>1.我有很多工作要（去&#x2F;被）做。 体现：主观能动性。<br>I have much work to do.</p><p>2.这个问题很难（去&#x2F;被）解决。<br>This problem is hard to solve.&#x2F;to be solved.</p><p>3.有许多衣服要（去&#x2F;被）洗<br>There be&#x3D;有（存在）表什么地方有。Be工具人，there副词，倒装句<br>There are many clothes to wash.&#x2F;to be washed.</p><p>有现句子主动表被动一定要分清楚。<br>4.明天将要举行的会议取消了。<br>The meeting to be held tomorrow is canceled.<br>会议就是被举行的，就一定要用to be.</p><h1 id="非谓语词性"><a href="#非谓语词性" class="headerlink" title="非谓语词性"></a>非谓语词性</h1><p>1.我喜欢跑步。 动名词&#x3D;表示动作含义的名词<br>I like running.    doing&#x3D;名词性</p><p>+ing变名词就可也做文章</p><p>2.跑步是一项很好的运动。<br>Running is a good sport.<br>Doing sth.&#x3D;名词(做某件事情)<br>3.我喜欢制作蛋糕。<br>I like making cakes.<br>4.看电视是我的习惯。<br>Watching TV is my habit.</p><p>to do目的或将来</p><p>1.我喜欢去跑步。<br>I like to run.<br>To do&#x3D;名词性<br>2.要解决这个问题是很困难的。<br>要解决这个问题表目的用 to do<br>To solve the problem is so hard.</p><p>浅浅了解：介词短语&#x3D;in the house（介宾短语）<br>Done&#x3D;形容词<br>The house 是名词 这样也可以换成doing sth.<br>3.我很擅长英语。<br>I am good at(介词) studying English。</p><p>4.这个花瓶被打破了。<br>This vase is broken. Broken&#x3D;被打破了adj.形容词<br>5.这项任务完成了。<br>This task is finished. Finished&#x3D;被完成的。</p><p>6.这个漂亮的女孩是我女朋友。<br>This beautiful girl is my girlfriend.<br>形容词可以放在前置做修饰。<br>7.这个被打破的花瓶是红色的。<br>This broken vase is red.   Done&#x3D;表示被动含义的形容词</p><p>doing&#x3D;名词、形容词</p><p>This problem is confusing.(confusing是形容词可以做修饰)<br>这个问题令人困惑。<br>This confusing problem interests me.<br>这个令人困惑的问题激发了我的兴趣。<br>This confusing problem interests the excited boy and the exciting girl.<br>这个令人困惑的问题激发了这个感到兴奋的男孩以及这个令人兴奋的女孩的兴趣。</p><p>改被动<br>The excited boy and the exciting girl are interested by&#x2F;in this confusing problem.<br>这个感到兴奋的男孩与这个令人兴奋的女孩对这个令人困惑的问题感兴趣。</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>吸烟是有害的。<br>Smoing is harmful.</p><p>Marry开始学习钢琴。<br>Marry starts learning piano.</p><p>每天喝水是很有必要的。<br>To drink water every day is necessary.</p><p>我很喜欢听音乐。<br>I like to listen to music very much.</p><p>这位被咬的男孩是他哥哥。<br>This bitten boy is his brother.</p><ol start="2"><li>doing</li></ol><p>这个无聊的男孩正在看着无聊的电视。<br>This bored boy is watching boreing TV.<br>我对这份累人的工作感到厌倦。<br>I got tired of the tiring job.<br>这部令我们所有同学兴奋的电影其实很无聊。<br>This movies excites all our students is actually very boring</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET依赖注入(三种生命周期)</title>
      <link href="/2025/08/02/asp.net%20core/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2025/08/02/asp.net%20core/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="NET依赖注入"><a href="#NET依赖注入" class="headerlink" title=".NET依赖注入"></a>.NET依赖注入</h1><h3 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入"></a>什么是依赖注入</h3><p>依赖注入是一种设计模式，它让类的依赖项（比如服务、数据库、日志组件等）由外部系统（比如框架）提供，而不是类自己创建。</p><h3 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h3><p>Service：被注入的服务（类、接口）</p><p>Container：注册和管理服务的容器</p><p>Lifetime：服务的生命周期（Scoped、Singleton、Transient）</p><h2 id="服务生命周期"><a href="#服务生命周期" class="headerlink" title="服务生命周期"></a>服务生命周期</h2><p>依赖注入容器管理服务的生命周期（Lifetime），决定了服务实例的创建和销毁时机。</p><h3 id="Scoped-作用域"><a href="#Scoped-作用域" class="headerlink" title="Scoped(作用域)"></a>Scoped(作用域)</h3><p>定义：在<strong>一个请求（Scope）</strong>中创建一个实例。通常在 Web 应用中表示一次 HTTP 请求周期。</p><p>注册方式：services.AddScoped&lt;TService, TImplementation&gt;()</p><p>适用场景：适用于需要在一个请求中保持状态，但请求之间不共享的服务，例如工作单元（Unit of Work）。</p><p>比喻：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddScoped&lt;IMyService, MyService&gt;();</span><br></pre></td></tr></table></figure><p>说明：在同一次 HTTP 请求中注入的都是同一个 MyService 实例，不同请求是不同实例。</p><p>想象你是一个饭店老板：</p><p>每进来一个顾客（表示一次 HTTP 请求）：</p><p>给他分配一个【托盘】（表示一个作用域 Scope）。</p><p>然后在托盘上放饮料、菜单（服务对象）。</p><p>Scoped 生命周期就像【每个顾客都有自己的托盘，托盘里的服务对这个顾客是一样的】：</p><p>顾客 A（HTTP 请求 1）来了，系统给他一个新的 MyService 实例。</p><p>顾客 A 用了一整顿饭（这个请求过程中），无论 Controller &#x2F; Service 层调用几次，拿到的都是这个实例。</p><p>顾客 B（HTTP 请求 2）又来了，他也分配了一个新的 MyService 实例，跟 A 的不同。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在 ASP.NET Core Web 项目中使用它来验证“同一个请求用同一个实例”的效果。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMyScopedService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Guid <span class="title">GetOperationId</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyScopedService</span> : <span class="title">IMyScopedService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Guid _operationId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyScopedService</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _operationId = Guid.NewGuid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Guid <span class="title">GetOperationId</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _operationId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册服务到容器中 Program.cs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddScoped&lt;IMyScopedService, MyScopedService&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;[controller]&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMyScopedService _service1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMyScopedService _service2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestController</span>(<span class="params">IMyScopedService service1, IMyScopedService service2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _service1 = service1;</span><br><span class="line">        _service2 = service2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;check&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">CheckScoped</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> id1 = _service1.GetOperationId();</span><br><span class="line">        <span class="keyword">var</span> id2 = _service2.GetOperationId();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="keyword">new</span></span><br><span class="line">        &#123;</span><br><span class="line">            Service1Id = id1,</span><br><span class="line">            Service2Id = id2,</span><br><span class="line">            AreSame = id1 == id2</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果</p><p>启动项目，访问 &#x2F;test&#x2F;check</p><p>会看到输出如下（两个 ID 一样，说明是同一个实例）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Service1Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0b6a22e2-2a8d-4896-9d59-82452f7032e6&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Service2Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0b6a22e2-2a8d-4896-9d59-82452f7032e6&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;AreSame&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>刷新页面（即另一个请求），会得到新的 ID：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Service1Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2e191177-c94a-42ce-b274-1faad4f5a5e2&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Service2Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2e191177-c94a-42ce-b274-1faad4f5a5e2&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;AreSame&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>说明：</p><p>每次请求都会创建新的 MyScopedService 实例。</p><p>同一个请求内的多个注入是同一个实例 </p><h3 id="Singleton-单例"><a href="#Singleton-单例" class="headerlink" title="Singleton(单例)"></a>Singleton(单例)</h3><p>定义：整个应用程序生命周期中只创建一个实例，并被所有请求共享。</p><p>注册方式：services.AddSingleton&lt;TService, TImplementation&gt;()</p><p>适用场景：线程安全、无状态服务，或有状态但共享全局状态的服务。</p><p>比喻理解 Singleton 生命周期（单例）<br>饭店老板的例子（继续）<br>还记得之前说的“每个顾客一个托盘”是 Scoped 吗？<br>现在换成 Singleton：<br>就像你饭店里有一台共享的饮水机（或菜单看板）☕，所有顾客都用同一个，不会为每个顾客新建一个。<br>技术上：Singleton 就是 “只创建一次服务实例”，并在整个程序中共享。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddSingleton&lt;IMyService, MyService&gt;();</span><br></pre></td></tr></table></figure><p>说明：第一次请求时创建 MyService 的实例，之后每次都使用同一个实例。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>和之前的 Scoped 示例相比，我们只改注册方式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMySingletonService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Guid <span class="title">GetOperationId</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MySingletonService</span> : <span class="title">IMySingletonService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Guid _operationId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySingletonService</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _operationId = Guid.NewGuid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Guid <span class="title">GetOperationId</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _operationId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册为 Singleton（Program.cs）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddSingleton&lt;IMySingletonService, MySingletonService&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;[controller]&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMySingletonService _service1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMySingletonService _service2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestController</span>(<span class="params">IMySingletonService service1, IMySingletonService service2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _service1 = service1;</span><br><span class="line">        _service2 = service2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;singleton&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">CheckSingleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> id1 = _service1.GetOperationId();</span><br><span class="line">        <span class="keyword">var</span> id2 = _service2.GetOperationId();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="keyword">new</span></span><br><span class="line">        &#123;</span><br><span class="line">            Service1Id = id1,</span><br><span class="line">            Service2Id = id2,</span><br><span class="line">            AreSame = id1 == id2</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问测试：<br>打开浏览器访问 &#x2F;test&#x2F;singleton：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Service1Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;f8e3a16e-1c6f-4531-9ed3-2bb89f4f750a&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Service2Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;f8e3a16e-1c6f-4531-9ed3-2bb89f4f750a&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;AreSame&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>再次刷新页面，你会发现输出的还是同一个 ID → 说明所有请求用的是同一个服务实例</p><h3 id="Transient-瞬态"><a href="#Transient-瞬态" class="headerlink" title="Transient(瞬态)"></a>Transient(瞬态)</h3><p>定义：每次请求都会创建新的实例。</p><p>注册方式：services.AddTransient&lt;TService, TImplementation&gt;()</p><p>适用场景：轻量级、无状态服务；适合短生命周期的对象。其缺点是生成的对象比较多，会浪费内存。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddTransient&lt;IMyService, MyService&gt;();</span><br></pre></td></tr></table></figure><p>说明：每次注入时都创建一个新的 MyService 实例。</p><p>生命周期的适配策略</p><p>场景                   推荐生命周期<br>全局配置服务            Singleton<br>数据库上下文（DbContext）Scoped<br>工具类&#x2F;轻量服务            Transient<br>缓存服务（如 Redis 缓存）Singleton<br>日志记录器               Singleton<br>用户请求上下文相关服务    Scoped</p><blockquote><p>注意事项<br>不要在 Singleton 中注入 Scoped 或 Transient<br>会导致作用域错误或内存泄漏。<br>如果一定要这么做，可以使用 IServiceScopeFactory 手动创建作用域。</p></blockquote><p>EF Core 的 DbContext 默认是 Scoped 生命周期<br>所以应避免把 DbContext 注入到 Singleton 服务中。</p><p>比喻理解 Transient（瞬态）<br>继续用饭店的例子：</p><p>Transient 就像你给顾客倒水时每次都换一个一次性纸杯，谁要用水，立即临时给他一个新的杯子，用完就扔掉，永远不会复用</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMyTransientService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Guid <span class="title">GetOperationId</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyTransientService</span> : <span class="title">IMyTransientService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Guid _operationId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTransientService</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _operationId = Guid.NewGuid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Guid <span class="title">GetOperationId</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _operationId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册为 Transient（Program.cs）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddTransient&lt;IMyTransientService, MyTransientService&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;[controller]&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMyTransientService _service1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMyTransientService _service2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestController</span>(<span class="params">IMyTransientService service1, IMyTransientService service2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _service1 = service1;</span><br><span class="line">        _service2 = service2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;transient&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">CheckTransient</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> id1 = _service1.GetOperationId();</span><br><span class="line">        <span class="keyword">var</span> id2 = _service2.GetOperationId();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="keyword">new</span></span><br><span class="line">        &#123;</span><br><span class="line">            Service1Id = id1,</span><br><span class="line">            Service2Id = id2,</span><br><span class="line">            AreSame = id1 == id2</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;Service1Id&quot;</span>: <span class="string">&quot;a12b1234-bbcd-4f9a-81a3-f93dabc56ab1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Service2Id&quot;</span>: <span class="string">&quot;9f334b12-fada-4873-bc6d-ff3455c68e92&quot;</span>,</span><br><span class="line">  <span class="string">&quot;AreSame&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：同一个请求中注入两次服务，拿到的是两个不同实例！<br>再刷新页面，ID 还会变 → 说明每次请求都会 new。</p><p>三种生命周期对比总结</p><p>生命周期     创建频率           使用范围             举例类比</p><p>Singleton    应用启动时创建一次   所有地方都复用      饮水机 &#x2F; 菜单看板</p><p>Scoped        每次请求创建一次   当前请求中复用      每人托盘</p><p>Transient    每次注入都创建新实例    无复用，每次都 new   一次性纸杯</p>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非谓语3+如何使用to do</title>
      <link href="/2025/08/01/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E9%9D%9E%E8%B0%93%E8%AF%AD3,to%20do/"/>
      <url>/2025/08/01/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E9%9D%9E%E8%B0%93%E8%AF%AD3,to%20do/</url>
      
        <content type="html"><![CDATA[<h1 id="非谓语3-如何使用to-do"><a href="#非谓语3-如何使用to-do" class="headerlink" title="非谓语3+如何使用to do"></a>非谓语3+如何使用to do</h1><p>to go表示目的或将来<br>1.明天将要举行的会议取消了。<br>独立名词前面要+the this that a an<br>主干：The meeting is canceled.<br>The meeting to be held tomorrow is canceled.</p><p>2.我用笔来写文章。<br>用和写都是谓语，一句一谓，写做非谓语。<br>写表目的，用to  do。<br>I use the pen to write an article.</p><ol start="3"><li>为了写篇好文章，我读了很多书。<br>写篇好文章是目的，用to do.<br>我读了很多书:现在完成时。<br>I have read many books.<br>To write a good article, I have read many books.</li></ol><p>4.我去健身房锻炼。<br>I go to the gym to exercise</p><p>5.下一列到站的火车是从纽约来的。<br>主干：the train is from New York。<br>The next train to arrive is from New York.</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>我去市场买苹果。<br>I go to the market to buy apples.</p><p>这是一封将在下周发送的信件。<br>This is a letter to be sent next week.</p><p>为获得奖品，Tom努力学习。<br>Tom studies hard, to get the prize.</p><p>Marry存了很多钱买房子。<br>Marry has saved much money to a house.</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建英语网站第一阶段</title>
      <link href="/2025/07/31/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%991%E9%98%B6%E6%AE%B5/"/>
      <url>/2025/07/31/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%991%E9%98%B6%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="网站结构说明"><a href="#网站结构说明" class="headerlink" title="网站结构说明"></a>网站结构说明</h1><p><b>学习杨中科老师开源项目在线英语网站微服务</b></p><ol><li>功能：听力练习。</li><li>业务概念：类别（Category）、专辑（Album）、片段（Episode）。</li><li>听力原文字幕文件查看。</li><li>网站后台允许进行资源的CRUD。</li><li>其他格式的音频的追踪在部分浏览器上有问题，统一用M4A。</li><li>音频文件放到单独的文件服务器上。</li><li>原文的搜素。</li></ol><p><img src="/img%5Cwz.png"></p><h1 id="项目结构说明"><a href="#项目结构说明" class="headerlink" title="项目结构说明"></a>项目结构说明</h1><p>为了便于管理，我们把不同服务的项目放到不同的解决方案文件夹下，解决方案文件夹Commons下的项目是一些公用的类库。<br>各服务的解决方案文件夹下都包含Domain、Infrastucture、WebAPI这3个项目，它们分别对应领域层、基础设施层、应用服务层。听力网站前台和听力网站后台共享相同的领域层和基础设施层，因此在解决方案文件夹Listening下有4个项目。<br>因为所有的项目都用到了领域事件、集成事件、中心配置服务器、JWT、工作单元、CORS、FluentValidation等，创建Commonlnitializer项目来复用这些组件的初始化代码。</p><p>有一点需要特别注意，如果我们创建的是ASP.NET Core项目，在项目中我们可以使用WebApplicationBuilder、IApplicationBuilder、IWebHostEnvironment等类型，但是在类库项目中我们则不能直接使用这些类型。这些类型都定义在Microsoft.AspNetCore.Hosting.Abstractions、Microsoft.AspNetCore等程序集中，版本非常低，ASP.NET Core的包不在单独发布到NuGet中，而是直接内建在.NET Core SDK中。如果想在ASP.NET Core中引用这些ASP.NET Core的类型，请在csproj中添加&lt;FrameworkReference Include&#x3D;”Microsoft.AspNetCore.App”&#x2F;&gt;。</p><h1 id="项目运行环境搭建"><a href="#项目运行环境搭建" class="headerlink" title="项目运行环境搭建"></a>项目运行环境搭建</h1><p>这个项目使用Microsoft SQL Server作为数据库服务器、用Nginx作为网关、用Redis实现分布式缓存、用RabbitMQ实现领域事件、用Elasticsearch作为搜索引擎服务器。</p><p>第一步，在生产环境下，我们一般会把不同的服务放到不同的服务器上，因此不会出现多个ASP.NET Core网站同时运行造成的端口冲突问题，但是如果我们需要在Visual Studio中同时运行多个ASP.NET Core项目，就可能会遇到这些项目的端口冲突的问题。如果我们用Visual Studio中的IIS Express来运行网站的话，可以修改ASP.NET Core项目的Properties文件夹下的launchSettings.json文件，在iisExpress节点下配置指定项目运行的端口。<br><img src="/img%5C%E7%BD%91%E5%9D%80%5C15.png"></p><p>我们分别让FileService.WebAPI、IdentityService.WebAPI、Listening.Admin.WebAPI、Listening.Main.WebAPI、MediaEncoder.WebAPI、SearchService.WebAPI运行在44339、44392、44352、44375、44353、44310端口下。</p><p>第二步，为了统一前端访问后端的不同服务的接口，我们配置Nginx来反向代理后端的接口。我们在nginx的nginx.conf文件中的server节点下增加代码。</p><p><img src="/img%5C%E7%BD%91%E5%9D%80%5C16.png"></p><p><b>配置nginx,这里端口号一定要和你的swagger端口号统一，因为你不是用iis，其次就是跨域的话，默认swagger的url有2个,只能留一个<b><br>假设你的 Swagger 服务运行在127.0.0.1:8080，Nginx 配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;  <span class="comment"># 对外暴露的端口，可根据需要修改</span></span><br><span class="line">    <span class="attribute">server_name</span> localhost;  <span class="comment"># 你的域名或服务器IP</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 代理到Swagger服务，确保端口一致</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;  <span class="comment"># 与Swagger服务端口保持一致</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location /FileService/&#123;</span><br><span class="line">            proxy_pass http://localhost:44339/;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Real-PORT $remote_port;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">            client_max_body_size 100m;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /IdentityService/&#123;</span><br><span class="line">            proxy_pass http://localhost:44392/;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Real-PORT $remote_port;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /Listening.Admin/&#123;</span><br><span class="line">            proxy_pass http://localhost:44352/;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Real-PORT $remote_port;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">            proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        localhost /Listening.Main/&#123;</span><br><span class="line">            proxy_pass http://localhost:44375/;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Real-PORT $remote_port;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        localhost /MediaEncoder/&#123;</span><br><span class="line">            proxy_pass http://localhost:44353/;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Real-PORT $remoto_port;</span><br><span class="line">            proxy_set_header X-For-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /SearchService/&#123;</span><br><span class="line">            proxy_pass http://localhost:44310/;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Real-PORT $remote_port;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面配置的proxy_set_header是用来方便我们在ASP.NET Core中获取客户端IP地址的，需要配合ForwardedHeaders中间件使用。<br>配置完Nginx后，只要重启Nginx服务器即可让配置生效，然后我们访问<a href="https://localhost/IdentityService/%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEIdentityService%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%BA%86%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%89%8D%E7%AB%AF%E5%B0%B1%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E7%BB%9F%E4%B8%80%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%9D%A5%E8%AE%BF%E9%97%AE%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E3%80%82">https://localhost/IdentityService/就可以访问IdentityService的接口了，这样前端就可以通过统一的端口来访问后端服务。</a></p><p>第三步，CommonInitializer中的初始化代码是设定从“DefaultDB:ConnStr”路径中读取数据库的连接字符串，因此请在环境变量中配置名字为DefaultDB:ConnStr的数据库连接字符串，然后在各个项目中运行EF Core数据库迁移来生成数据库表。<br><img src="/img%5C%E7%BD%91%E5%9D%80%5C17.png"></p><p>第四步，我们在数据库中增加一个名字为T_Configs的表，并且在表中增加如下配置。<br><img src="/img%5C%E7%BD%91%E5%9D%80%5C18.png"></p><p>Cors的配置项为项目的跨域设置。<br>FileService:SMB的配置项为文件备份服务器的根目录。<br>Redis的配置项为Redis服务器的连接配置。<br>RabbitMQ的配置项为集成事件相关RabbitMQ的配置，HostName属性为服务器的地址，ExchangeName属性为集成事件的交换机名字。<br>ElasticSearch的配置项为ElasticSearch服务器的配置，其中的用户名、密码需要和读者安装的ElasticSearch服务器的配置一致。<br>JWT的配置项为登录令牌的JWT配置。</p><h1 id="Commons"><a href="#Commons" class="headerlink" title="Commons"></a>Commons</h1><p>一些项目初始化的代码放到这里，项目里通用的东西放到Commons解决方案文件夹下</p><p><img src="/img%5C%E7%BD%91%E5%9D%80%5CCommons.png"></p><h3 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h3><table border="1" cellspacing="0"><tr><td>项目</td><td>类</td><td>说明</td></tr><tr><td>YU.ASPNETCore</td><td>DistributedCacheHelper</td><td>分布式缓存帮助类</td></tr><tr><td>YU.Commons</td><td>验证器文件夹</td><td>FluentValidation的扩展类</td></tr><tr><td>YU.DomainCommons</td><td>IAggregateRoot</td><td>聚合根标识接口</td></tr><tr><td>YU.EventBus</td><td>订阅、撤销、发布事件</td><td>集成事件总线</td></tr><tr><td>YU.Infrastructure</td><td>BaseDbContext</td><td>领域事件的发布</td></tr><tr><td>YU.JWT</td><td>Token</td><td>使用JWT实现登录令牌</td></tr></table><h2 id="所用到的NuGet包"><a href="#所用到的NuGet包" class="headerlink" title="所用到的NuGet包"></a>所用到的NuGet包</h2><p><img src="/img%5C%E7%BD%91%E5%9D%80%5C19.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemGroup&gt;</span><br><span class="line"> &lt;FrameworkReference Include=<span class="string">&quot;Microsoft.AspNetCore.App&quot;</span> /&gt;</span><br><span class="line"> &lt;PackageReference Include=<span class="string">&quot;FluentValidation&quot;</span> Version=<span class="string">&quot;12.0.0&quot;</span> /&gt;</span><br><span class="line"> &lt;PackageReference Include=<span class="string">&quot;FluentValidation.DependencyInjectionExtensions&quot;</span> Version=<span class="string">&quot;12.0.0&quot;</span> /&gt;</span><br><span class="line"> &lt;PackageReference Include=<span class="string">&quot;MediatR&quot;</span> Version=<span class="string">&quot;8.1.0&quot;</span> /&gt;</span><br><span class="line">  &lt;PackageReference Include=<span class="string">&quot;Microsoft.AspNetCore.Http.Abstractions&quot;</span> Version=<span class="string">&quot;2.3.0&quot;</span> /&gt;</span><br><span class="line">  &lt;PackageReference Include=<span class="string">&quot;Microsoft.EntityFrameworkCore&quot;</span> Version=<span class="string">&quot;8.0.18&quot;</span> /&gt;</span><br><span class="line">  &lt;PackageReference Include=<span class="string">&quot;Microsoft.EntityFrameworkCore.SqlServer&quot;</span> Version=<span class="string">&quot;8.0.18&quot;</span> /&gt;</span><br><span class="line">  &lt;PackageReference Include=<span class="string">&quot;Microsoft.Extensions.DependencyInjection&quot;</span> Version=<span class="string">&quot;9.0.7&quot;</span> /&gt;</span><br><span class="line">  &lt;PackageReference Include=<span class="string">&quot;Serilog.AspNetCore&quot;</span> Version=<span class="string">&quot;8.0.3&quot;</span> /&gt;</span><br><span class="line">  &lt;PackageReference Include=<span class="string">&quot;StackExchange.Redis&quot;</span> Version=<span class="string">&quot;2.8.58&quot;</span> /&gt;</span><br><span class="line">  &lt;PackageReference Include=<span class="string">&quot;Swashbuckle.AspNetCore.SwaggerGen&quot;</span> Version=<span class="string">&quot;8.1.4&quot;</span> /&gt;</span><br><span class="line">  &lt;PackageReference Include=<span class="string">&quot;Zack.AnyDBConfigProvider&quot;</span> Version=<span class="string">&quot;1.1.4&quot;</span> /&gt;</span><br><span class="line">&lt;/ItemGroup&gt;</span><br></pre></td></tr></table></figure><h2 id="ApplicationBuilderExtensions"><a href="#ApplicationBuilderExtensions" class="headerlink" title="ApplicationBuilderExtensions"></a>ApplicationBuilderExtensions</h2><p>首现我们创建一个Commonlnitializer类库项目，在csproj中添加&lt;FrameworkReference Include&#x3D;”Microsoft.AspNetCore.App”&#x2F;&gt;这个类库把我们所有需要用到的配置领域事件、集成事件、中心配置服务器、JWT、工作单元、CORS、FluentValidation等，用来复用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Commonlnitializer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 提供对IApplicationBuilder的扩展方法，用于配置应用的默认中间件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ApplicationBuilderExtensions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 配置应用的默认中间件，包括事件总线、CORS、转发头、认证和授权。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;app&quot;&gt;</span>IApplicationBuilder 实例。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>配置后的 IApplicationBuilder 实例。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IApplicationBuilder <span class="title">UseZackDefault</span>(<span class="params"><span class="keyword">this</span> IApplicationBuilder app</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            app.UseEventBus(); <span class="comment">// 启用事件总线</span></span><br><span class="line">            app.UseCors(); <span class="comment">// 启用跨域资源共享（CORS）</span></span><br><span class="line">            app.UseForwardedHeaders(); <span class="comment">// 处理代理服务器转发的头信息</span></span><br><span class="line">            <span class="comment">//app.UseHttpsRedirection();//不能与ForwardedHeaders很好的工作，而且webapi项目也没必要配置这个</span></span><br><span class="line">            app.UseAuthentication(); <span class="comment">// 启用认证</span></span><br><span class="line">            app.UseAuthorization(); <span class="comment">// 启用授权</span></span><br><span class="line">            <span class="keyword">return</span> app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UseEventBus在应用程序中启用事件总线，是我们给IApplicationBuilder类扩展的方法，是检查是否事件总线服务是否注册如果未注册，将抛出异常提醒开发者。<br>app.UseForwardedHeaders(); 获取Nignx的原始客户端的 IP 地址，原始请求的协议（HTTP 或 HTTPS），原始主机地址</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.EventBus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 提供扩展方法，用于在应用程序中启用事件总线功能。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ApplicationBuilderExtensions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 启用事件总线功能。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 该方法会检查事件总线服务（IEventBus）是否已注册。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 如果未注册，将抛出异常提醒开发者。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;appBuilder&quot;&gt;</span>应用程序构建器对象。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>返回原始的应用程序构建器对象，便于链式调用。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;ApplicationException&quot;&gt;</span>如果未找到IEventBus的实现，则抛出异常。<span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IApplicationBuilder <span class="title">UseEventBus</span>(<span class="params"><span class="keyword">this</span> IApplicationBuilder appBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 尝试从依赖注入容器中获取IEventBus服务</span></span><br><span class="line">            <span class="built_in">object</span>? eventBus = appBuilder.ApplicationServices.GetService(<span class="keyword">typeof</span>(IEventBus));</span><br><span class="line">            <span class="keyword">if</span> (eventBus == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果没有找到IEventBus的实现，抛出异常，提示开发者需要注册服务</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationException(<span class="string">&quot;找不到IEventBus的实现，请确保已正确注册EventBus服务。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回appBuilder，支持链式调用</span></span><br><span class="line">            <span class="keyword">return</span> appBuilder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此扩展方法允许应用程序构建器使用事件总线功能。</span></span><br></pre></td></tr></table></figure><p>其中的object? eventBus &#x3D; appBuilder.ApplicationServices.GetService(typeof(IEventBus));在 ASP.NET Core 中从依赖注入（DI）容器获取一个类型为 IEventBus 的事件接口，并赋值给一个 object? 类型的变量 eventBus。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.EventBus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 事件总线接口，定义了事件的发布与订阅相关操作。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEventBus</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 发布事件。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventName&quot;&gt;</span>事件名称。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventData&quot;&gt;</span>事件数据，可以为 null。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">publish</span>(<span class="params"><span class="built_in">string</span> eventName, <span class="built_in">object</span>? eventData</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 订阅指定事件。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventName&quot;&gt;</span>事件名称。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;handlerType&quot;&gt;</span>处理该事件的处理器类型。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params"><span class="built_in">string</span> eventName, Type handlerType</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 取消订阅指定事件。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventName&quot;&gt;</span>事件名称。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;handlerType&quot;&gt;</span>要移除的处理器类型。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Unsubscribe</span>(<span class="params"><span class="built_in">string</span> eventName, Type handlerType</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app.UseCors();<br>app.UseForwardedHeaders();<br>app.UseAuthentication();<br>app.UseAuthorization();<br>是Microsoft.AspNetCore.BuilderNuGet包，安装后可直接配置扩展方法，后面的项目可以直接引用。</p><h2 id="CorsSettings"><a href="#CorsSettings" class="headerlink" title="CorsSettings"></a>CorsSettings</h2><p>CorsSettings类用于配置 跨域资源共享（CORS）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Commonlnitializer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 表示跨域资源共享（CORS）相关的配置设置。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CorsSettings</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 允许的跨域来源地址列表。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>[] Origins &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Origins 表示允许跨域请求的来源地址列表（如 <a href="http://localhost:3000/">http://localhost:3000</a> ）</p><h2 id="DbContextOptionsBuilderFactory"><a href="#DbContextOptionsBuilderFactory" class="headerlink" title="DbContextOptionsBuilderFactory"></a>DbContextOptionsBuilderFactory</h2><p>我们创建一个DbContextOptionsBuilderFactory的实用工厂类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Commonlnitializer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 提供用于创建 <span class="doctag">&lt;see cref=&quot;DbContextOptionsBuilder&#123;TContext&#125;&quot;/&gt;</span> 的工厂方法。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DbContextOptionsBuilderFactory</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 创建并配置 <span class="doctag">&lt;see cref=&quot;DbContextOptionsBuilder&#123;TDbContext&#125;&quot;/&gt;</span> 实例，使用环境变量 &quot;DefaultDB:ConnStr&quot; 作为连接字符串。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;TDbContext&quot;&gt;</span>要配置的 DbContext 类型。<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>配置好的 <span class="doctag">&lt;see cref=&quot;DbContextOptionsBuilder&#123;TDbContext&#125;&quot;/&gt;</span> 实例。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">DbContextOptionsBuilder</span>&lt;<span class="title">TDbContext</span>&gt; <span class="title">Create</span>&lt;<span class="title">TDbContext</span>&gt;()</span></span><br><span class="line"><span class="function">            <span class="keyword">where</span> TDbContext : DbContext</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从环境变量获取数据库连接字符串</span></span><br><span class="line">            <span class="keyword">var</span> connStr = Environment.GetEnvironmentVariable(<span class="string">&quot;DefaultDB:ConnStr&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrWhiteSpace(connStr))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;Environment variable &#x27;DefaultDB:ConnStr&#x27; is not set.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查连接字符串是否有效</span></span><br><span class="line">            <span class="comment">// 创建 DbContextOptionsBuilder 实例</span></span><br><span class="line">            <span class="keyword">var</span> optionsBuilder = <span class="keyword">new</span> DbContextOptionsBuilder&lt;TDbContext&gt;();</span><br><span class="line">            <span class="comment">// 配置使用 SQL Server 数据库</span></span><br><span class="line">            optionsBuilder.UseSqlServer(connStr);</span><br><span class="line">            <span class="keyword">return</span> optionsBuilder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DbContextOptionsBuilder&lt;TDbContext&gt; 实例，用于统一创建并配置。<br>var connStr &#x3D; Environment.GetEnvironmentVariable(“DefaultDB:ConnStr”);从环境变量中读取数据库连接字符串，不在appsettings.json，是防止信息的泄露。<br>new DbContextOptionsBuilder&lt;TDbContext&gt;();创建并配置一个DbContextOptionsBuilder 实例。<br>UseSqlServer();指定使用SQL Server数据库。</p><h2 id="InitializerOptions"><a href="#InitializerOptions" class="headerlink" title="InitializerOptions"></a>InitializerOptions</h2><p>InitializerOptions类，用于集中配置一些初始化相关的参数，例如日志路径和 EventBus 队列名称。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Commonlnitializer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 初始化选项配置类。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InitializerOptions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 日志文件路径。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> LogFilePath &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 用于 EventBus 的队列名称。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 需保证同一项目值保持一致，不同项目不能冲突。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> EventBusQueueName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebApplicationBuilderExtensions"><a href="#WebApplicationBuilderExtensions" class="headerlink" title="WebApplicationBuilderExtensions"></a>WebApplicationBuilderExtensions</h2><p>给WebApplicationBuilder提供扩展方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Commonlnitializer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 提供 WebApplicationBuilder 的扩展方法。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">WebApplicationBuilderExtensions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 配置数据库配置源，将数据库中的配置信息添加到应用配置中。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;builder&quot;&gt;</span>WebApplicationBuilder 实例。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ConfigureDbConfiguration</span>(<span class="params"><span class="keyword">this</span> WebApplicationBuilder builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 配置主机构建器的应用配置</span></span><br><span class="line">            builder.Host.ConfigureAppConfiguration((hostCtx, configBuilder) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 从应用配置中获取数据库连接字符串，键为 &quot;DefaultDB:ConnStr&quot;</span></span><br><span class="line">                <span class="built_in">string</span> connStr = builder.Configuration.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;DefaultDB:ConnStr&quot;</span>);</span><br><span class="line">                <span class="comment">// 添加自定义的数据库配置源，支持自动刷新，刷新间隔为5秒</span></span><br><span class="line">                configBuilder.AddDbConfiguration(() =&gt; <span class="keyword">new</span> SqlConnection(connStr), reloadOnChange: <span class="literal">true</span>, reloadInterval: TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 配置应用所需的额外服务，包括数据库、认证、授权、日志、CORS、Redis、事件总线等。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;builder&quot;&gt;</span>WebApplicationBuilder 实例。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;initOptions&quot;&gt;</span>初始化选项，包含日志路径和事件总线队列名等。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ConfigureExtraServices</span>(<span class="params"><span class="keyword">this</span> WebApplicationBuilder builder, InitializerOptions initOptions</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取服务集合</span></span><br><span class="line">            IServiceCollection services = builder.Services;</span><br><span class="line">            <span class="comment">// 获取应用配置</span></span><br><span class="line">            IConfiguration configuration = builder.Configuration;</span><br><span class="line">            <span class="comment">// 获取所有引用的程序集，用于后续模块初始化和依赖注入</span></span><br><span class="line">            <span class="keyword">var</span> assemblies = ReflectionHelper.GetAllReferencedAssemblies();</span><br><span class="line">            <span class="comment">// 执行所有模块的初始化方法</span></span><br><span class="line">            services.RunModuleInitializers(assemblies);</span><br><span class="line">            <span class="comment">// 注册所有数据库上下文，使用 SQL Server，连接字符串从配置中获取</span></span><br><span class="line">            services.AddAllDbContexts(ctx =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> connStr = configuration.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;DefaultDB:ConnStr&quot;</span>);</span><br><span class="line">                ctx.UseSqlServer(connStr);</span><br><span class="line">            &#125;, assemblies);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加认证服务</span></span><br><span class="line">            builder.Services.AddAuthentication();</span><br><span class="line">            <span class="comment">// 添加授权服务</span></span><br><span class="line">            builder.Services.AddAuthorization();</span><br><span class="line">            <span class="comment">// 从配置中获取 JWT 相关配置</span></span><br><span class="line">            JWTOptions jwtOpt = configuration.GetSection(<span class="string">&quot;JWT&quot;</span>).Get&lt;JWTOptions&gt;();</span><br><span class="line">            <span class="comment">// 添加 JWT 认证服务</span></span><br><span class="line">            builder.Services.AddJWTAuthentication(jwtOpt);</span><br><span class="line">            <span class="comment">// 配置 Swagger，添加认证头部</span></span><br><span class="line">            builder.Services.Configure&lt;SwaggerGenOptions&gt;(c =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                c.AddAuthenticationHeader();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册 MediatR，用于领域事件和命令处理</span></span><br><span class="line">            services.AddMediatR(assemblies);</span><br><span class="line">            <span class="comment">// 配置 MVC 选项，添加工作单元过滤器</span></span><br><span class="line">            services.Configure&lt;MvcOptions&gt;(options =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                options.Filters.Add&lt;UnitOfWorkFilter&gt;();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 配置 JSON 选项，添加自定义的 DateTime 序列化转换器</span></span><br><span class="line">            services.Configure&lt;JsonOptions&gt;(options =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                options.JsonSerializerOptions.Converters.Add(<span class="keyword">new</span> DateTimeJsonConverter(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配置跨域资源共享（CORS）策略</span></span><br><span class="line">            services.AddCors(options =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 从配置中获取 CORS 设置</span></span><br><span class="line">                <span class="keyword">var</span> corsOpt = configuration.GetSection(<span class="string">&quot;Cors&quot;</span>).Get&lt;CorsSettings&gt;();</span><br><span class="line">                <span class="comment">// 获取允许的来源列表</span></span><br><span class="line">                <span class="built_in">string</span>[] urls = corsOpt.Origins;</span><br><span class="line">                <span class="comment">// 添加默认策略，允许指定来源、任意头、任意方法，并允许携带凭据</span></span><br><span class="line">                options.AddDefaultPolicy(builder =&gt; builder.WithOrigins(urls)</span><br><span class="line">                    .AllowAnyHeader()</span><br><span class="line">                    .AllowAnyMethod()</span><br><span class="line">                    .AllowCredentials());</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 配置日志服务，使用 Serilog，日志输出到控制台和文件</span></span><br><span class="line">            services.AddLogging(builder =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 配置 Serilog 日志记录器</span></span><br><span class="line">                Log.Logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">                .WriteTo.Console()</span><br><span class="line">                .WriteTo.File(initOptions.LogFilePath)</span><br><span class="line">                .CreateLogger();</span><br><span class="line">                <span class="comment">// 将 Serilog 集成到日志系统</span></span><br><span class="line">                builder.AddSerilog();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 获取应用程序主程序集，用于注册 FluentValidation 验证器</span></span><br><span class="line">            <span class="keyword">var</span> applicationAssembly = <span class="keyword">typeof</span>(UserModelValidator).Assembly;</span><br><span class="line">            <span class="comment">// 注册所有验证器</span></span><br><span class="line">            services.AddValidatorsFromAssembly(applicationAssembly);</span><br><span class="line">            <span class="comment">// 配置 JWT 选项绑定</span></span><br><span class="line">            services.Configure&lt;JWTOptions&gt;(configuration.GetSection(<span class="string">&quot;JWT&quot;</span>));</span><br><span class="line">            <span class="comment">// 配置 RabbitMQ 事件总线选项绑定</span></span><br><span class="line">            services.Configure&lt;IntegrationEventRabbitMQOptions&gt;(configuration.GetSection(<span class="string">&quot;RabbitMQ&quot;</span>));</span><br><span class="line">            <span class="comment">// 注册事件总线服务</span></span><br><span class="line">            services.AddEventBus(initOptions.EventBusQueueName, assemblies);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从配置中获取 Redis 连接字符串</span></span><br><span class="line">            <span class="built_in">string</span> redisConnStr = configuration.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Redis:ConnStr&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建 Redis 连接多路复用器</span></span><br><span class="line">            IConnectionMultiplexer redisConnMultiplexer = ConnectionMultiplexer.Connect(redisConnStr);</span><br><span class="line">            <span class="comment">// 注册 Redis 连接为单例服务</span></span><br><span class="line">            services.AddSingleton(<span class="keyword">typeof</span>(IConnectionMultiplexer), redisConnMultiplexer);</span><br><span class="line">            <span class="comment">// 配置转发头部选项，支持所有转发头</span></span><br><span class="line">            services.Configure&lt;ForwardedHeadersOptions&gt;(Options =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Options.ForwardedHeaders = ForwardedHeaders.All;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConfigureDbConfiguration"><a href="#ConfigureDbConfiguration" class="headerlink" title="ConfigureDbConfiguration"></a>ConfigureDbConfiguration</h3><p>我们创建了一个对WebApplicationBuilder的扩展方法,读取数据库配置源。<br>将数据库作为配置源，并将其配置加载到 WebApplicationBuilder.Configuration 中，支持自动刷新。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 配置数据库配置源，将数据库中的配置信息添加到应用配置中。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;builder&quot;&gt;</span>WebApplicationBuilder 实例。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ConfigureDbConfiguration</span>(<span class="params"><span class="keyword">this</span> WebApplicationBuilder builder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 配置主机构建器的应用配置</span></span><br><span class="line">    builder.Host.ConfigureAppConfiguration((hostCtx, configBuilder) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从应用配置中获取数据库连接字符串，键为 &quot;DefaultDB:ConnStr&quot;</span></span><br><span class="line">        <span class="built_in">string</span> connStr = builder.Configuration.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;DefaultDB:ConnStr&quot;</span>);</span><br><span class="line">        <span class="comment">// 添加自定义的数据库配置源，支持自动刷新，刷新间隔为5秒</span></span><br><span class="line">        configBuilder.AddDbConfiguration(() =&gt; <span class="keyword">new</span> SqlConnection(connStr), reloadOnChange: <span class="literal">true</span>, reloadInterval: TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中builder.Host.ConfigureAppConfiguration((hostCtx, configBuilder) &#x3D;&gt;是修改应用的主机（IHostBuilder）的配置构建逻辑。<br>这是对应用配置系统进行扩展（而不是仅仅修改运行时服务）。<br><b>hostCtx 是当前主机的上下文；configBuilder 是正在构建的配置。</b></p><p>而configBuilder.AddDbConfiguration中的<b>AddDbConfiguration</b>是作用是从数据库中读取配置项，作为应用配置源之一添加到 Configuration 中。<br><b>() &#x3D;&gt; new SqlConnection(connStr)</b>是一个延迟执行的委托，当配置系统需要刷新或初始化时才会创建连接对象，<b>避免启动时立即连接数据库</b>。<br><b>reloadOnChange: true</b>启用自动刷新配置功能，意思是当<b>数据库中的配置值发生变更时，可以自动重新加载，不重启服务</b>。<br><b>reloadInterval: TimeSpan.FromSeconds(5)</b>配置刷新周期为 5 秒，即配置系统每隔 5 秒去检查数据库配置是否有变更，如果有则刷新。</p><p><b>数据库变成了应用的一个配置源，优先级可能比 appsettings.json 高（取决于添加顺序）。</b></p><h3 id="ConfigureExtraServices"><a href="#ConfigureExtraServices" class="headerlink" title="ConfigureExtraServices"></a>ConfigureExtraServices</h3><p>ConfigureExtraServices配置了配置应用所需的额外服务，包括数据库、认证、授权、日志、CORS、Redis、事件总线等。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ConfigureExtraServices</span>(<span class="params"><span class="keyword">this</span> WebApplicationBuilder builder, InitializerOptions initOptions</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取服务集合</span></span><br><span class="line">    IServiceCollection services = builder.Services;</span><br><span class="line">    <span class="comment">// 获取应用配置</span></span><br><span class="line">    IConfiguration configuration = builder.Configuration;</span><br><span class="line">    <span class="comment">// 获取所有引用的程序集，用于后续模块初始化和依赖注入</span></span><br><span class="line">    <span class="keyword">var</span> assemblies = ReflectionHelper.GetAllReferencedAssemblies();</span><br><span class="line">    <span class="comment">// 执行所有模块的初始化方法</span></span><br><span class="line">    services.RunModuleInitializers(assemblies);</span><br><span class="line">    <span class="comment">// 注册所有数据库上下文，使用 SQL Server，连接字符串从配置中获取</span></span><br><span class="line">    services.AddAllDbContexts(ctx =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> connStr = configuration.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;DefaultDB:ConnStr&quot;</span>);</span><br><span class="line">        ctx.UseSqlServer(connStr);</span><br><span class="line">    &#125;, assemblies);</span><br></pre></td></tr></table></figure><p>IServiceCollection services &#x3D; builder.Services从 WebApplicationBuilder 中获取服务注册容器（IServiceCollection），用于注册依赖后续所有的依赖注入（AddScoped、AddDbContext 等）都会往这个集合中注册。</p><p>IConfiguration configuration &#x3D; builder.Configuration获取应用程序的配置系统接口（例如 appsettings.json、环境变量、命令行等）后续可通过 configuration.GetValue&lt;string&gt;(“xxx”) 方式读取配置值</p><p>var assemblies &#x3D; ReflectionHelper.GetAllReferencedAssemblies()中的ReflectionHelper.GetAllReferencedAssemblies()是用于通过反射获取当前项目引用的所有程序集（Assembly）</p><p>services.RunModuleInitializers(assemblies)这是一个模块化系统的入口，会从传入的 assemblies 中寻找实现了某个约定接口（例如 IModuleInitializer）的类，并调用其初始化方法。</p><p>services.AddAllDbContexts(ctx &#x3D;&gt;从配置中读取数据库连接字符串，在多个程序集内查找所有继承自 DbContext 的类，自动为这些 DbContext 注册到 DI 容器中，统一使用 UseSqlServer(…) 进行数据库配置。</p><p>而ReflectionHelper.GetAllReferencedAssemblies()、RunModuleInitializers()、AddAllDbContexts,都是自定义的扩展方法。</p><h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加认证服务</span></span><br><span class="line">builder.Services.AddAuthentication();</span><br><span class="line"><span class="comment">// 添加授权服务</span></span><br><span class="line">builder.Services.AddAuthorization();</span><br><span class="line"><span class="comment">// 从配置中获取 JWT 相关配置</span></span><br><span class="line">JWTOptions jwtOpt = configuration.GetSection(<span class="string">&quot;JWT&quot;</span>).Get&lt;JWTOptions&gt;();</span><br><span class="line"><span class="comment">// 添加 JWT 认证服务</span></span><br><span class="line">builder.Services.AddJWTAuthentication(jwtOpt);</span><br><span class="line"><span class="comment">// 配置 Swagger，添加认证头部</span></span><br><span class="line">builder.Services.Configure&lt;SwaggerGenOptions&gt;(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.AddAuthenticationHeader();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中的JWTOptions是JWT 配置选项类，用于存储生成和验证 JWT 所需的参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.JWT</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> JWT 配置选项类，用于存储生成和验证 JWT 所需的参数。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JWTOptions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 令牌颁发者（Issuer）。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Issuer &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 令牌接收者（Audience）。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Audience &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 用于签名 JWT 的密钥。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Key &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 令牌过期时间（秒）。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> ExpireSeconds &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而配置JWT还要配置配置JWT令牌验证和添加在 Swagger 文档中添加认证头部信息，分别对这两个配置封装为AddJWTAuthentication、AddAuthenticationHeader扩展方法。</p><p><b>AddJWTAuthentication</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.JWT</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 提供JWT认证相关的扩展方法。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">AuthenticationExtensions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 向服务集合中添加JWT认证。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;services&quot;&gt;</span>服务集合。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;jwtOpt&quot;&gt;</span>JWT配置选项。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>认证生成器。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AuthenticationBuilder <span class="title">AddJWTAuthentication</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services, JWTOptions jwtOpt</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</span><br><span class="line">            .AddJwtBearer(x =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 配置JWT令牌验证参数</span></span><br><span class="line">                x.TokenValidationParameters = <span class="keyword">new</span>()</span><br><span class="line">                &#123;</span><br><span class="line">                    ValidateIssuer = <span class="literal">true</span>, <span class="comment">// 验证签发者</span></span><br><span class="line">                    ValidateAudience = <span class="literal">true</span>, <span class="comment">// 验证接收者</span></span><br><span class="line">                    ValidateLifetime = <span class="literal">true</span>, <span class="comment">// 验证有效期</span></span><br><span class="line">                    ValidateIssuerSigningKey = <span class="literal">true</span>, <span class="comment">// 验证签名密钥</span></span><br><span class="line">                    ValidIssuer = jwtOpt.Issuer, <span class="comment">// 有效签发者</span></span><br><span class="line">                    ValidAudience = jwtOpt.Audience, <span class="comment">// 有效接收者</span></span><br><span class="line">                    IssuerSigningKey = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtOpt.Key)), <span class="comment">// 签名密钥</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>AddAuthenticationHeader</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.JWT</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> SwaggerGenOptions 的扩展方法，用于在 Swagger 文档中添加认证头部信息。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SwaggerGenOptionsExtensions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 向 Swagger 配置中添加认证头（Authorization Header），</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 使得在 Swagger UI 中可以输入 JWT Token 进行接口测试。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c&quot;&gt;</span>SwaggerGenOptions 实例。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddAuthenticationHeader</span>(<span class="params"><span class="keyword">this</span> SwaggerGenOptions c</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 添加安全定义，指定名称为 &quot;Authorization&quot;，类型为 ApiKey，位置在 Header。</span></span><br><span class="line">            <span class="comment">// 这样在 Swagger UI 中会出现一个输入框用于填写 Token。</span></span><br><span class="line">            c.AddSecurityDefinition(<span class="string">&quot;Authorization&quot;</span>, <span class="keyword">new</span> OpenApiSecurityScheme</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 描述信息，指导用户如何填写 Token。</span></span><br><span class="line">                Description = <span class="string">&quot;Authorization header .\r\n Example:&#x27;Bearer 12345abcdef&#x27;&quot;</span>,</span><br><span class="line">                <span class="comment">// 指定参数在 HTTP Header 中传递。</span></span><br><span class="line">                In = ParameterLocation.Header,</span><br><span class="line">                <span class="comment">// 安全方案类型为 ApiKey。</span></span><br><span class="line">                Type = SecuritySchemeType.ApiKey,</span><br><span class="line">                <span class="comment">// 方案名称，通常为 &quot;Authorization&quot;。</span></span><br><span class="line">                Scheme = <span class="string">&quot;Authorization&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加安全需求，指定所有接口都需要携带 &quot;Authorization&quot; 头部。</span></span><br><span class="line">            c.AddSecurityRequirement(<span class="keyword">new</span> OpenApiSecurityRequirement()</span><br><span class="line">                &#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">new</span> OpenApiSecurityScheme</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// 引用上面定义的安全方案。</span></span><br><span class="line">                            Reference = <span class="keyword">new</span> OpenApiReference</span><br><span class="line">                            &#123;</span><br><span class="line">                                Type = ReferenceType.SecurityScheme,</span><br><span class="line">                                Id=<span class="string">&quot;Authorization&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            <span class="comment">// 方案类型为 oauth2（虽然实际类型为 ApiKey，这里用于兼容性）。</span></span><br><span class="line">                            Scheme = <span class="string">&quot;oauth2&quot;</span>,</span><br><span class="line">                            <span class="comment">// 头部名称。</span></span><br><span class="line">                            Name=<span class="string">&quot;Authorization&quot;</span>,</span><br><span class="line">                            <span class="comment">// 参数位置为 Header。</span></span><br><span class="line">                            In=ParameterLocation.Header,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">// 作用域列表，这里为空表示不限定作用域。</span></span><br><span class="line">                        <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 JWT 选项绑定</span></span><br><span class="line">services.Configure&lt;JWTOptions&gt;(configuration.GetSection(<span class="string">&quot;JWT&quot;</span>));</span><br></pre></td></tr></table></figure><p>这行代码的作用是将应用配置文件中的 JWT 配置节绑定到 JWTOptions 类型，并注册到依赖注入容器，方便后续通过依赖注入获取配置信息。</p><h4 id="MediatR"><a href="#MediatR" class="headerlink" title="MediatR"></a>MediatR</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 MediatR，用于领域事件和命令处理</span></span><br><span class="line">services.AddMediatR(assemblies);</span><br></pre></td></tr></table></figure><p>而AddMediatR是对注册MediatR服务的配置和派发领域事件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.Infrastructure.EFCore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 提供与MediatR相关的扩展方法。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MediatorExtensions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 扩展IServiceCollection以批量注册MediatR相关服务。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;services&quot;&gt;</span>依赖注入服务集合。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;assemblies&quot;&gt;</span>包含MediatR处理程序的程序集集合。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>服务集合本身，便于链式调用。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection <span class="title">AddMediatR</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services, IEnumerable&lt;Assembly&gt; assemblies</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将指定程序集中的MediatR服务注册到依赖注入容器</span></span><br><span class="line">            <span class="keyword">return</span> services.AddMediatR(assemblies.ToArray());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 派发当前DbContext中所有聚合根的领域事件。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;mediator&quot;&gt;</span>MediatR中介者实例。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;ctx&quot;&gt;</span>当前的EF Core DbContext实例。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>异步任务。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">DispatchDomainEventsAsync</span>(<span class="params"><span class="keyword">this</span> IMediator mediator, DbContext ctx</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取所有实现了IDomainEvents接口且包含领域事件的实体</span></span><br><span class="line">            <span class="keyword">var</span> domainEntities = ctx.ChangeTracker</span><br><span class="line">                .Entries&lt;IDomainEvents&gt;()</span><br><span class="line">                .Where(x =&gt; x.Entity.GetDomainEvents().Any());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 收集所有领域事件</span></span><br><span class="line">            <span class="keyword">var</span> domainEvents = domainEntities</span><br><span class="line">                .SelectMany(x =&gt; x.Entity.GetDomainEvents())</span><br><span class="line">                .ToList();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清空实体上的领域事件，避免重复派发</span></span><br><span class="line">            domainEntities.ToList()</span><br><span class="line">                .ForEach(entity =&gt; entity.Entity.ClearDomainEvents());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 逐个通过MediatR发布领域事件</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> domainEvent <span class="keyword">in</span> domainEvents)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> mediator.Publish(domainEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现IDomainEvents接口且包含领域事件的实体</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.DomainCommons.Models</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 定义领域事件集合的接口。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 该接口用于聚合根或实体中管理领域事件的添加、去重、获取和清理操作。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 领域事件用于在领域模型内部或外部传播重要的业务状态变化。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDomainEvents</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取当前已注册的所有领域事件。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>领域事件的只读集合。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function">IEnumerable&lt;INotification&gt; <span class="title">GetDomainEvents</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 添加一个新的领域事件到集合中。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventItem&quot;&gt;</span>要添加的领域事件。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AddDomainEvent</span>(<span class="params">INotification eventItem</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 如果集合中不存在该事件，则添加一个新的领域事件。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 用于避免重复添加相同的事件。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventItem&quot;&gt;</span>要添加的领域事件。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AddDomainEventIfAbsent</span>(<span class="params">INotification eventItem</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 清空当前所有已注册的领域事件。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ClearDomainEvents</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="筛选器（过滤器）"><a href="#筛选器（过滤器）" class="headerlink" title="筛选器（过滤器）"></a>筛选器（过滤器）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 MVC 选项，添加工作单元过滤器</span></span><br><span class="line">services.Configure&lt;MvcOptions&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Filters.Add&lt;UnitOfWorkFilter&gt;();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>options.Filters.Add&lt;UnitOfWorkFilter&gt;()给所有的控制器动作方法添加一个全局过滤器。<br>UnitOfWorkFilter 是自定义的类，实现了IAsyncActionFilter。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.ASPNETCore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 实现基于特性（UnitOfWorkAttribute）的工作单元过滤器。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用于在 ASP.NET Core 控制器或方法上自动管理事务和 DbContext 的 SaveChanges。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitOfWorkFilter</span> : <span class="title">IAsyncActionFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取应用于控制器或方法的 UnitOfWorkAttribute 特性。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 优先获取控制器上的特性，如果没有则获取方法上的特性。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;actionDesc&quot;&gt;</span>当前 Action 的描述信息。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>UnitOfWorkAttribute 实例或 null。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> UnitOfWorkAttribute? GetUoWAttr(ActionDescriptor actionDesc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> caDesc = actionDesc <span class="keyword">as</span> ControllerActionDescriptor;</span><br><span class="line">            <span class="keyword">if</span> (caDesc == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 不是控制器 Action，直接返回 null</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 优先获取控制器上的 UnitOfWorkAttribute</span></span><br><span class="line">            <span class="keyword">var</span> uowAttr = caDesc.ControllerTypeInfo</span><br><span class="line">                .GetCustomAttribute&lt;UnitOfWorkAttribute&gt;();</span><br><span class="line">            <span class="keyword">if</span> (uowAttr != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> uowAttr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果控制器上没有，则获取方法上的 UnitOfWorkAttribute</span></span><br><span class="line">                <span class="keyword">return</span> caDesc.MethodInfo</span><br><span class="line">                    .GetCustomAttribute&lt;UnitOfWorkAttribute&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 拦截 Action 执行过程，实现工作单元事务控制。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;context&quot;&gt;</span>Action 执行上下文。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;next&quot;&gt;</span>委托，执行下一个中间件或 Action。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>异步任务。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取当前 Action 或控制器上的 UnitOfWorkAttribute</span></span><br><span class="line">            <span class="keyword">var</span> uowAttr = GetUoWAttr(context.ActionDescriptor);</span><br><span class="line">            <span class="keyword">if</span> (uowAttr == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 未标记 UnitOfWorkAttribute，直接执行下一个中间件</span></span><br><span class="line">                <span class="keyword">await</span> next();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启用支持异步流的事务作用域</span></span><br><span class="line">            <span class="keyword">using</span> TransactionScope txScope = <span class="keyword">new</span> TransactionScope(TransactionScopeAsyncFlowOption.Enabled);</span><br><span class="line">            List&lt;DbContext&gt; dbCtxs = <span class="keyword">new</span> List&lt;DbContext&gt;();</span><br><span class="line">            <span class="comment">// 遍历特性中声明的所有 DbContext 类型</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> dbCtxType <span class="keyword">in</span> uowAttr.DbContextTypes)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 通过依赖注入获取 DbContext 实例</span></span><br><span class="line">                <span class="keyword">var</span> sp = context.HttpContext.RequestServices;</span><br><span class="line">                DbContext dbCtx = (DbContext)sp.GetRequiredService(dbCtxType);</span><br><span class="line">                dbCtxs.Add(dbCtx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行 Action</span></span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">await</span> next();</span><br><span class="line">            <span class="keyword">if</span> (result.Exception == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果没有异常，依次保存所有 DbContext 的更改</span></span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> dbCtx <span class="keyword">in</span> dbCtxs)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> dbCtx.SaveChangesAsync();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 提交事务</span></span><br><span class="line">                txScope.Complete();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有异常，事务会自动回滚</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="序列化转换器"><a href="#序列化转换器" class="headerlink" title="序列化转换器"></a>序列化转换器</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 JSON 选项，添加自定义的 DateTime 序列化转换器</span></span><br><span class="line">services.Configure&lt;JsonOptions&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置时间格式。而非“2008-08-08T08:08:08”这样的格式,而是&quot;2008-08-08 08:08:08&quot;</span></span><br><span class="line">    options.JsonSerializerOptions.Converters.Add(<span class="keyword">new</span> DateTimeJsonConverter(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>会替换默认的 DateTime 序列化规则。<br>options.JsonSerializerOptions.Converters.Add(…)添加一个自定义的JsonConverter&lt;DateTime&amp;gt，DateTimeJsonConverter</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.Commons.JsonConverters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 自定义的 DateTime 类型 JSON 序列化与反序列化转换器。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 支持指定日期时间格式进行序列化与反序列化。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DateTimeJsonConverter</span> : <span class="title">JsonConverter</span>&lt;<span class="title">DateTime</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 日期时间格式字符串。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _dateFormatString;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 默认构造函数，使用 &quot;yyyy-MM-dd HH:mm:ss&quot; 作为日期时间格式。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DateTimeJsonConverter</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            _dateFormatString = <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>; <span class="comment">// 默认日期格式</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 构造函数，允许自定义日期时间格式。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;dateformatString&quot;&gt;</span>自定义的日期时间格式字符串<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DateTimeJsonConverter</span>(<span class="params"><span class="built_in">string</span> dateformatString</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _dateFormatString = dateformatString; <span class="comment">// 使用自定义日期格式</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 反序列化：将 JSON 字符串转换为 DateTime 对象。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;reader&quot;&gt;</span>JSON 读取器<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;typeToConvert&quot;&gt;</span>要转换的类型<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;options&quot;&gt;</span>序列化选项<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>反序列化得到的 DateTime 对象<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DateTime <span class="title">Read</span>(<span class="params"><span class="keyword">ref</span> Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>? str = reader.GetString();</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果 JSON 字符串为 null，则返回默认值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">default</span>(DateTime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将字符串解析为 DateTime 对象</span></span><br><span class="line">                <span class="keyword">return</span> DateTime.Parse(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 序列化：将 DateTime 对象转换为指定格式的 JSON 字符串。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;writer&quot;&gt;</span>JSON 写入器<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span>要序列化的 DateTime 值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;options&quot;&gt;</span>序列化选项<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Write</span>(<span class="params">Utf8JsonWriter writer, DateTime <span class="keyword">value</span>, JsonSerializerOptions options</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 按指定格式将 DateTime 写入为字符串</span></span><br><span class="line">            writer.WriteStringValue(<span class="keyword">value</span>.ToString(_dateFormatString));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cors"><a href="#Cors" class="headerlink" title="Cors"></a>Cors</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置跨域资源共享（CORS）策略</span></span><br><span class="line">services.AddCors(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从配置中获取 CORS 设置</span></span><br><span class="line">    <span class="keyword">var</span> corsOpt = configuration.GetSection(<span class="string">&quot;Cors&quot;</span>).Get&lt;CorsSettings&gt;();</span><br><span class="line">    <span class="comment">// 获取允许的来源列表</span></span><br><span class="line">    <span class="built_in">string</span>[] urls = corsOpt.Origins;</span><br><span class="line">    <span class="comment">// 添加默认策略，允许指定来源、任意头、任意方法，并允许携带凭据</span></span><br><span class="line">    options.AddDefaultPolicy(builder =&gt; builder.WithOrigins(urls)</span><br><span class="line">        .AllowAnyHeader()</span><br><span class="line">        .AllowAnyMethod()</span><br><span class="line">        .AllowCredentials());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：AllowCredentials() 和 WithOrigins(…) 必须一起使用，不能搭配 AllowAnyOrigin()，否则会抛出异常。</p><h4 id="日志服务"><a href="#日志服务" class="headerlink" title="日志服务"></a>日志服务</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置日志服务，使用 Serilog，日志输出到控制台和文件</span></span><br><span class="line">services.AddLogging(builder =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 配置 Serilog 日志记录器</span></span><br><span class="line">    Log.Logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">    .WriteTo.Console()</span><br><span class="line">    .WriteTo.File(initOptions.LogFilePath)</span><br><span class="line">    .CreateLogger();</span><br><span class="line">    <span class="comment">// 将 Serilog 集成到日志系统</span></span><br><span class="line">    builder.AddSerilog();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="验证器"><a href="#验证器" class="headerlink" title="验证器"></a>验证器</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取应用程序主程序集，用于注册 FluentValidation 验证器</span></span><br><span class="line"><span class="keyword">var</span> applicationAssembly = <span class="keyword">typeof</span>(UserModelValidator).Assembly;</span><br><span class="line"><span class="comment">// 注册所有验证器</span></span><br><span class="line">services.AddValidatorsFromAssembly(applicationAssembly);</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.ASPNETCore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用户模型验证器，使用FluentValidation对UserValidation对象进行属性校验。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserModelValidator</span> : <span class="title">AbstractValidator</span>&lt;<span class="title">UserValidation</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 构造函数，定义了对UserValidation属性的校验规则。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserModelValidator</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 校验用户名不能为空</span></span><br><span class="line">            RuleFor(x =&gt; x.Name)</span><br><span class="line">                .NotEmpty()</span><br><span class="line">                .WithMessage(<span class="string">&quot;用户名不能为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 校验年龄必须在0到100之间</span></span><br><span class="line">            RuleFor(x =&gt; x.Age)</span><br><span class="line">                .InclusiveBetween(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">                .WithMessage(<span class="string">&quot;年龄必须在0到100之间&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.DomainCommons.Models</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用户验证信息模型。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserValidation</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 用户名。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 用户年龄。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过某个验证器类型 UserModelValidator 获取它所在的程序集（Assembly）。<br>这样就能知道“应用程序的主要代码程序集”，用于后续自动扫描和注册。</p><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 RabbitMQ 事件总线选项绑定</span></span><br><span class="line">services.Configure&lt;IntegrationEventRabbitMQOptions&gt;(configuration.GetSection(<span class="string">&quot;RabbitMQ&quot;</span>));</span><br></pre></td></tr></table></figure><p>将配置文件中 “RabbitMQ” 节点的内容绑定到 IntegrationEventRabbitMQOptions 类，并注入到依赖注入容器中。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.EventBus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 表示用于配置RabbitMQ集成事件的选项。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IntegrationEventRabbitMQOptions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> RabbitMQ 主机名或 IP 地址。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> HostName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 交换机名称。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> ExchangeName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 用于连接 RabbitMQ 的用户名（可选）。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? UserName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 用于连接 RabbitMQ 的密码（可选）。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Password &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册事件总线服务</span></span><br><span class="line">services.AddEventBus(initOptions.EventBusQueueName, assemblies);</span><br></pre></td></tr></table></figure><p>注册事件总线（EventBus）服务，并初始化事件处理器扫描、队列名称等设置。</p><p>initOptions.EventBusQueueName<br>当前服务的事件队列名，例如 “user-service”。<br>不同服务应该有不同的队列名，防止消费互串。</p><p>assemblies<br>所有需要扫描的程序集（Assembly[]），用于从中找出所有实现了 IIntegrationEventHandler&lt;T&gt; 的事件处理器。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.EventBus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 扩展 IServiceCollection，提供事件总线（EventBus）相关的依赖注入注册方法。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ServicesCollectionExtensions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 注册事件总线服务，自动扫描指定程序集中的事件处理器类型。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;services&quot;&gt;</span>依赖注入服务集合。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;queueName&quot;&gt;</span>RabbitMQ 队列名称。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;assemblies&quot;&gt;</span>要扫描的程序集列表。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>服务集合本身，便于链式调用。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection <span class="title">AddEventBus</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services, <span class="built_in">string</span> queueName,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">params</span> Assembly[] assemblies</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将 params 形式的程序集数组转换为 List 形式，调用重载方法</span></span><br><span class="line">            <span class="keyword">return</span> AddEventBus(services, queueName, assemblies.ToList());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 注册事件总线服务，自动扫描指定程序集中的事件处理器类型。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;services&quot;&gt;</span>依赖注入服务集合。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;queueName&quot;&gt;</span>RabbitMQ 队列名称。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;assemblies&quot;&gt;</span>要扫描的程序集集合。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>服务集合本身，便于链式调用。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection <span class="title">AddEventBus</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services, <span class="built_in">string</span> queueName,</span></span></span><br><span class="line"><span class="params"><span class="function">            IEnumerable&lt;Assembly&gt; assemblies</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 用于存储所有扫描到的事件处理器类型</span></span><br><span class="line">            List&lt;Type&gt; eventHandlers = <span class="keyword">new</span> List&lt;Type&gt;();</span><br><span class="line">            <span class="comment">// 遍历每个程序集</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> asm <span class="keyword">in</span> assemblies)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 查找所有非抽象且实现了 IIntegrationEventHandler 接口的类型</span></span><br><span class="line">                <span class="keyword">var</span> types = asm.GetTypes().Where(t =&gt; t.IsAbstract == <span class="literal">false</span> &amp;&amp; t.IsAssignableTo(<span class="keyword">typeof</span>(IIntegrationEventHandler)));</span><br><span class="line">                <span class="comment">// 添加到事件处理器类型列表</span></span><br><span class="line">                eventHandlers.AddRange(types);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用重载方法，注册事件处理器类型</span></span><br><span class="line">            <span class="keyword">return</span> AddEventBus(services, queueName, eventHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 注册事件总线服务，并将指定的事件处理器类型注册到依赖注入容器。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;services&quot;&gt;</span>依赖注入服务集合。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;queueName&quot;&gt;</span>RabbitMQ 队列名称。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventHandlerTypes&quot;&gt;</span>事件处理器类型集合。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>服务集合本身，便于链式调用。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection <span class="title">AddEventBus</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services, <span class="built_in">string</span> queueName,</span></span></span><br><span class="line"><span class="params"><span class="function">            IEnumerable&lt;Type&gt; eventHandlerTypes</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遍历所有事件处理器类型</span></span><br><span class="line">            <span class="keyword">foreach</span> (Type type <span class="keyword">in</span> eventHandlerTypes)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将事件处理器类型注册为 Scoped 生命周期</span></span><br><span class="line">                services.AddScoped(type, type);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注册 IEventBus 单例服务</span></span><br><span class="line">            services.AddSingleton&lt;IEventBus&gt;(sp =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取 RabbitMQ 配置选项</span></span><br><span class="line">                <span class="keyword">var</span> optionMQ = sp.GetRequiredService&lt;IOptions&lt;IntegrationEventRabbitMQOptions&gt;&gt;().Value;</span><br><span class="line">                <span class="comment">// 创建 RabbitMQ 连接工厂</span></span><br><span class="line">                <span class="keyword">var</span> factory = <span class="keyword">new</span> ConnectionFactory()</span><br><span class="line">                &#123;</span><br><span class="line">                    HostName = optionMQ.HostName, <span class="comment">// 设置主机名</span></span><br><span class="line">                    DispatchConsumersAsync = <span class="literal">true</span> <span class="comment">// 启用异步消费者</span></span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 如果配置了用户名，则设置用户名</span></span><br><span class="line">                <span class="keyword">if</span> (optionMQ.UserName != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    factory.UserName = optionMQ.UserName;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果配置了密码，则设置密码</span></span><br><span class="line">                <span class="keyword">if</span> (optionMQ.Password != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    factory.Password = optionMQ.Password;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 创建 RabbitMQ 持久连接对象</span></span><br><span class="line">                RabbitMQConnection mqConnection = <span class="keyword">new</span> RabbitMQConnection(factory);</span><br><span class="line">                <span class="comment">// 获取服务作用域工厂，用于事件处理器的依赖注入</span></span><br><span class="line">                <span class="keyword">var</span> serviceScopeFactory = sp.GetRequiredService&lt;IServiceScopeFactory&gt;();</span><br><span class="line">                <span class="comment">// 创建 RabbitMQEventBus 实例</span></span><br><span class="line">                <span class="keyword">var</span> eventBus = <span class="keyword">new</span> RabbitMQEventBus(mqConnection, serviceScopeFactory, optionMQ.ExchangeName, queueName);</span><br><span class="line">                <span class="comment">// 返回事件总线实例</span></span><br><span class="line">                <span class="keyword">return</span> eventBus;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 返回服务集合本身</span></span><br><span class="line">            <span class="keyword">return</span> services;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IIntegrationEventHandler定义集成事件处理程序的接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.EventBus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 定义集成事件处理程序的接口。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IIntegrationEventHandler</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 处理集成事件的方法。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventName&quot;&gt;</span>事件名称。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventData&quot;&gt;</span>事件数据（序列化后的字符串）。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>表示异步操作的任务。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function">Task <span class="title">Handle</span>(<span class="params"><span class="built_in">string</span> eventName, <span class="built_in">string</span> eventData</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IntegrationEventRabbitMQOptions接口自定义用于配置RabbitMQ集成事件的选项。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YU.EventBus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 表示用于配置RabbitMQ集成事件的选项。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IntegrationEventRabbitMQOptions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> RabbitMQ 主机名或 IP 地址。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> HostName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 交换机名称。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> ExchangeName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 用于连接 RabbitMQ 的用户名（可选）。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? UserName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 用于连接 RabbitMQ 的密码（可选）。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Password &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从配置中获取 Redis 连接字符串</span></span><br><span class="line"><span class="built_in">string</span> redisConnStr = configuration.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Redis:ConnStr&quot;</span>);</span><br><span class="line"><span class="comment">// 创建 Redis 连接多路复用器</span></span><br><span class="line">IConnectionMultiplexer redisConnMultiplexer = ConnectionMultiplexer.Connect(redisConnStr);</span><br><span class="line"><span class="comment">// 注册 Redis 连接为单例服务</span></span><br><span class="line">services.AddSingleton(<span class="keyword">typeof</span>(IConnectionMultiplexer), redisConnMultiplexer);</span><br><span class="line"><span class="comment">// 配置转发头部选项，支持所有转发头</span></span><br><span class="line">services.Configure&lt;ForwardedHeadersOptions&gt;(Options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Options.ForwardedHeaders = ForwardedHeaders.All;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非谓语2+独立主格</title>
      <link href="/2025/07/30/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E9%9D%9E%E8%B0%93%E8%AF%AD2%EF%BC%8C%E7%8B%AC%E7%AB%8B%E4%B8%BB%E6%A0%BC/"/>
      <url>/2025/07/30/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E9%9D%9E%E8%B0%93%E8%AF%AD2%EF%BC%8C%E7%8B%AC%E7%AB%8B%E4%B8%BB%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="非谓语2-独立主格"><a href="#非谓语2-独立主格" class="headerlink" title="非谓语2+独立主格"></a>非谓语2+独立主格</h1><p>非谓语&#x3D;to do ,doing主动（持续进行），done被动（完成）</p><p>1.站在树下的Tom看着天空。<br>主干：Tom looks at the sky.<br>Tom standing under the tree looks at the sky.<br>可以变为非限定性定语从句(状语)：<br>Tom, who is standing under the tree, looks at the sky.<br>状语&#x3D;随便放（只要说得通）<br>Standing under the tree, Tom looks at the sky.<br>这句话还可以变为：Tom站在树下,看着天空。(用and连词)<br>Tom stands under the tree and looks at the sky.<br>And连接两个句子可以有两个谓语（stands, looks）<br>And&#x3D;&gt; , 变成一句话只能有一个谓语<br>Tom standing under the tree, looks at the sky.</p><p>2.Tom站在树下，Marry看着天空。<br>Tom stands under the tree and Marry looks at the sky.<br>Tom standing under the tree, Marry looks at the sky.<br>不加and的就是独立主格。<br>一个用谓语充当主要，非谓语充当次要。</p><p>2.一个男孩哭着向我走来。<br>有两个动作：哭，走<br>用and: A boy cries and comes to me.<br>非谓语做状语：A boy, crying, comes to me.</p><p>3.这条河从远处看很漂亮。<br>非谓语：<br>主干：This river is very beautiful.<br>This river seen from the distance is very beautiful.<br>非谓语做状语：<br>This river ,seen from the distance, is very beautiful.</p><p>习题</p><p>1.Tom拿着花跟我聊天。<br>Tom ,holding the flower, chats with me</p><p>2.他走在街上，听着音乐。<br>He walks on the street, listening to the music.</p><p>3.Marry被很多粉丝包围着，很开心。<br>Marry , surrounded by many fans, is very many</p><p>4.她身后跟着一条狗，走进房间。<br>She , followed by a dog , walks into the room</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非谓语一</title>
      <link href="/2025/07/28/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E9%9D%9E%E8%B0%93%E8%AF%AD%E4%B8%80/"/>
      <url>/2025/07/28/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E9%9D%9E%E8%B0%93%E8%AF%AD%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="非谓语1"><a href="#非谓语1" class="headerlink" title="非谓语1"></a>非谓语1</h1><p><b>非谓语&#x3D;to do, doing主动（持续进行），done被动（完成）<b></p><p>1.正站在树下的男还是我哥哥<br>站&#x3D;主动站在树下<br>Stand&#x3D;standing<br>主干：This boy is my brother standing修饰男孩boy+ standing<br>This boy standing under the tree is my brother</p><p>也可以：This boy who is standing under the tree is my brother.<br>加 引+be&#x3D;定语从句<br>非谓语&#x3D;简化版的定语从句</p><p>2.被狗咬的女孩是我姐姐。<br>主干：This girl is my sister. Bite&#x3D;bitten&#x3D;咬<br>This girl bitten by a dog is my sister    一句一谓</p><p>3.我喜欢这个戴着帽子的女孩。<br>主干：I like this girl. Wear&#x3D;wearing&#x3D;戴<br>I like this girl wearing a cap.<br>4.这个被Tom打破了的花瓶是红色的。<br>主干：This vase is red. Break&#x3D;broken&#x3D;打破<br>This vase broken by Tom is red.</p><p>5.这匹马在草地上喝水的马是棕色的。<br>主干：This horse is brown. Drink&#x3D;drinking&#x3D;喝<br>This horse drinking water on the grass is brown.</p><p>6.这是一栋政府修建的房子。<br>主干：This is a house.  Build&#x3D;built&#x3D;修建<br>This is a house built by the government</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>这是一部在沙漠上拍摄的电影。<br>This is a movie shot on the desert.</p><p>这个喝水的女孩是我女朋友。<br>This girl drinking the water is my girlfriend.</p><p>我收到Tom送的礼物。<br>I received a gift sent by Tom.</p><p>Marry拿着的花很漂亮。<br>The flower held by Marry is very beautiful.</p><p>我认识这位打篮球的男孩。<br>I know this boy playing basketball.</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一般、特殊疑问句</title>
      <link href="/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E4%B8%80%E8%88%AC%E3%80%81%E7%89%B9%E6%AE%8A%E7%96%91%E9%97%AE%E5%8F%A5/"/>
      <url>/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E4%B8%80%E8%88%AC%E3%80%81%E7%89%B9%E6%AE%8A%E7%96%91%E9%97%AE%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>疑问句其一（一般疑问句）<br>一般疑问句只回答：是否<br>“疑问句”的底层原理<br>You like me.<br>你喜欢我。<br>Do you like me?<br>你喜欢我吗？</p><p>Do &#x3D; 助动词<br>英语忌重复 若重复：1.删除其中一个 2.替换其中一个（助动词&gt;普通动词）<br>He likes me.<br>他喜欢我。<br>（用2）Do he likes me? -&gt;Does he like me?<br>他喜欢我吗？<br>一句,一谓<br>一个句子有且只有一个谓语<br>Do不算谓语<br>This apple very big.（缺少谓语）<br>这个苹果很大。<br>遇事不决补“be”动词&#x3D;工具人(是动词那就是谓语)<br>“be”动词本身不表示任何意思，也相当于助动词<br>This apple is very big.<br>这个苹果很大。<br>（用1）Does this apple is very big?<br>这个苹果很大吗？<br>Is this apple very big?<br>这个苹果很大吗？<br>注意：“be”动词兼备“助动词”的功能但本质依然是“谓语”。<br>“be”动词额外具备“助动词”属性，故可直接顶替do而do只有助动词属性，功能重复了。</p><p>陈述句—&gt;疑问句<br>1.有be&#x3D;be提前，其他照抄<br>2.没be&#x3D;开头+do(正确形式，如单三则变does),其他照抄</p><p>These workers are very busy.<br>这些工人很忙。<br>Are these workers very busy?<br>这些工人很忙吗？<br>He sits down.<br>他坐下了。<br>Does he sit down?<br>他坐下来吗？<br>这女孩很漂亮吗？<br>Is this girl very beautiful?<br>你们喝水吗？<br>Do you drink water?<br>这只猪很肥吗？<br>Is this pig very fat?</p><p>特殊疑问句<br>要具体回答<br>You like me.<br>你喜欢我。<br>Do you like me?<br>你喜欢我吗？<br>Why do you like me?<br>你为什么喜欢我？ </p><p>You go to school.      go不及物动词<br>你去学校。<br>Do you go to school?<br>你去学校吗？<br>When do you go to school?<br>你啥时候去学校？<br>How do you go to school?<br>你怎么去的学校？<br>Why do you go to school?<br>你为什么去学校？</p><p>He watches TV.<br>他看电视。<br>Does he watches TV？<br>他看电视吗？<br>Where does he watch TV?<br>他在哪里看电视？<br>What does he watch?<br>他在看什么？</p><p>This boy is my brother.<br>这个男孩是我哥哥。<br>Is this boy my brother?<br>这个男孩是我哥哥吗？<br>Who is this boy?<br>这个男孩是谁？</p><p>You like red color<br>你喜欢红色。<br>Do you like red color?<br>你喜欢红色吗？<br>Which color do you like?<br>你喜欢哪个颜色？</p><p>This is your book.<br>这是你的书。<br>Is this your book?<br>这是你的书吗？<br>Whose book is this?<br>这是谁的书？</p><p>为什么&#x3D;why<br>啥时候&#x3D;when<br>怎么&#x3D;how<br>哪里&#x3D;where<br>什么&#x3D;what<br>谁&#x3D;who<br>那个&#x3D;which<br>谁的&#x3D;whose</p><p>你为什么打他？<br>Why do you hit him?<br>Tom在哪儿打篮球？<br>Where does Tom play basketball?<br>他在画什么？<br>What does he draw?<br>Marry怎么来的我家？<br>How does Marry come to home?<br>他们啥时候吃的早餐？<br>When do they eat breakfast?<br>这些是谁的自行车？<br>Whose bikes are these?<br>这位英俊的男子是谁？<br>Who is this handsome man? </p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你我他，be动词</title>
      <link href="/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E4%BD%A0%E6%88%91%E4%BB%96%EF%BC%8Cbe%E5%8A%A8%E8%AF%8D/"/>
      <url>/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E4%BD%A0%E6%88%91%E4%BB%96%EF%BC%8Cbe%E5%8A%A8%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>第一课</p><p>他&#x3D;he、him(主、宾) </p><p>He likes me.<br>他喜欢我<br>I like him.<br>我喜欢他<br>我&#x3D;I，me(主、宾) 你&#x3D;you(主、宾)</p><p>She likes me.<br>她喜欢我<br>I like her.<br>我喜欢她<br>她&#x3D;she、her(主、宾)</p><p>它&#x3D;it(主、宾)</p><p>It likes me.<br>它喜欢我<br>I like it.<br>我喜欢它</p><p>单数<br>他&#x3D;he、him(主、宾)<br>我&#x3D;I，me(主、宾) 你&#x3D;you(主、宾)<br>她&#x3D;she、her(主、宾)<br>它&#x3D;it(主、宾)</p><p>复数<br>我们&#x3D;we、us(主、宾)</p><p>We like you.<br>我们喜欢你</p><p>You like us.<br>你喜欢我们</p><p>你们&#x3D;You</p><p>You like me.<br>你们喜欢我</p><p>I like you.<br>我喜欢你们</p><p>ta们&#x3D;they、them(主、宾)</p><p>They like him.<br>他们喜欢他</p><p>He likes them.<br>我喜欢你们</p><p>Like likes </p><p>he, she, it 他&#x3D;谓+s</p><p>狗&#x3D;dog<br>The dogs like me.<br>The dog likes me</p><p>第一人称：我，我们<br>第二人称：你，你们<br>第三人称：非第一，第二人称，第三人称单数&#x3D;谓+s,绝大多数的规律（&gt;90%）</p><p>第二课<br>我的、你的、它的（形容词）</p><p>我的&#x3D;my<br>This is my apple.<br>这是我的苹果。</p><p>你的&#x3D;your<br>This is your pear.<br>这是你的梨。</p><p>他的&#x3D;his<br>This is his bananan.</p><p>这是他的香蕉。</p><p>她的&#x3D;her<br>This is her orange.<br>这是她的桔子</p><p>它的&#x3D;its<br>This is its fish.<br>这是它的鱼。</p><p>复数</p><p>我们的&#x3D;our<br>This is our song.<br>这是我们的歌。</p><p>你们的&#x3D;your<br>This is your bed.<br>这是你们的床。</p><p>ta们的&#x3D;their<br>This is their job.<br>这是他们的工作。</p><p>Apple&#x3D;苹果 pear&#x3D;梨 bananan&#x3D;香蕉 orange&#x3D;桔子 fish&#x3D;鱼 song&#x3D;歌 bed&#x3D;床 job&#x3D;工作 bird&#x3D;鸟</p><p>你的、我的、他的（东西）（名词）<br>This book is mine.<br>这本书是我的。<br>That book is your.<br>那本书是你的。<br>Your book is red ,and mine is blue.<br>你的书是红色的，而我的是蓝色的</p><p>我的&#x3D;my  我的（东西）&#x3D;mine<br>他的&#x3D;his  他的（东西）&#x3D;his<br>她的&#x3D;her  她的（东西）&#x3D;hers<br>它的&#x3D;its  它的（东西）&#x3D;its<br>我们的&#x3D;our&#x2F;ours<br>你们的&#x3D;your&#x2F;yours<br>Ta们的&#x3D;their&#x2F;theirs</p><p>His apple is small ,but I like hers.<br>他的苹果很小，但是我却喜欢她的。<br>第三课<br>“be动词”的基本用法<br>Be动词&#x3D;“是”<br>I am a teacher.<br>我是一名老师。<br>You are a student.<br>你是一名学生。</p><p>他&#x2F;她&#x2F;它是歌手<br>He&#x2F;she&#x2F;It is a singer.</p><p>Sing&#x3D;唱（歌） singer&#x3D;歌手<br>er 做…的人&#x2F;机器<br>Rice&#x3D;米饭 cook&#x3D;动词（煮，烹饪）<br>Rice cooker&#x3D;米饭烹饪者&#x3D;电饭锅</p><p>We are dancers.    名词+s&#x3D;复数&gt;&#x3D;2个<br>我们是舞者。</p><p>You are workers.<br>你们是工人。 工作&#x3D;做工作的人 工作&#x3D;work(动词) 工人&#x3D;worker</p><p>They are hunters.<br>Ta们是猎人   猎捕&#x3D;hunt  猎人&#x3D;hunter</p><p>This apple is red.<br>这个苹果是红色的。</p><p>These apples are red.<br>这些苹果是红色的。</p><p>Be动词&#x3D;is，am，are<br>我&#x3D;am<br>单三&#x3D;is<br>其他&#x3D;are<br>I am your teacher.<br>我是你的老师。<br>This dog is white.<br>这只狗是白色的。<br>They are friend<br>他们是朋友。</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一般过去时、将来时、现在时</title>
      <link href="/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E4%B8%80%E8%88%AC%E8%BF%87%E5%8E%BB%E6%97%B6%E3%80%81%E5%B0%86%E6%9D%A5%E6%97%B6%E3%80%81%E7%8E%B0%E5%9C%A8%E6%97%B6/"/>
      <url>/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E4%B8%80%E8%88%AC%E8%BF%87%E5%8E%BB%E6%97%B6%E3%80%81%E5%B0%86%E6%9D%A5%E6%97%B6%E3%80%81%E7%8E%B0%E5%9C%A8%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<p>一般过去时<br>I play basketball.<br>我打篮球。<br>I played basketball.<br>我曾经打过篮球。<br>He works in the school.<br>它在学校工作。<br>He worked in the school.<br>他以前在学校工作过。<br>in代表在什么…东西里面<br>the&#x3D;this(这个)，that(哪个)，these(这些)，those（哪些）<br>You like me.<br>你喜欢我。<br>You liked me.<br>你喜欢过我。<br>She saves my life.<br>她救我的命。<br>She saved my life.<br>她救过我的命。<br>You go to a market.<br>你去一家市场。<br>You went to a market.<br>你去过一家市场。<br>Did you go to the market?<br>你去过这家市场吗？<br>Why did you go to the market?<br>你为什么去过这家市场？<br>You do home work.<br>你做功课。<br>You did homework.<br>你做过功课。<br>do 当助动词（无含义）或当动词“做”，过去式均为did.<br>Do you did homework?-&gt;Did you do homework?<br>你做过功课吗？<br>When did you do homework?<br>你啥时候做过功课？</p><p>Be动词<br>I am a teacher.<br>我曾是一名老师。        Was&#x3D;am&#x2F;is   were&#x3D;are<br>I was a teacher.<br>我曾经是一名老师。<br>This boy is very smart.<br>这个男孩很聪明。<br>This boy was very smart.<br>这个男孩曾经很聪明。<br>Was this boy very smart?<br>这个男孩曾经很聪明。<br>Why was this boy very smart?<br>为什么这个男孩曾经很聪明？</p><p>I have a dream.<br>我曾经有一个梦想。<br>I had a dream.<br>我曾经有一个梦想。</p><p>Break 打破：broke<br>Strike 打击：stroke<br>Freeze 冰冻：froze<br>Hit 打：hit<br>Put 放：put<br>Set 设置：set<br>Sing 唱：sang<br>Drink 喝：drank<br>Sink 沉没：sank<br>Come 来：came<br>Become 成为：became</p><p>I was a student.<br>我曾是一名学生。<br>Jerry played the piano.<br>Jerry弹过钢琴。<br>The teacher told the story.<br>老师以前讲过这个故事。<br>Wusong hit the tiger.<br>Wusong曾经打过老虎。<br>Those candies were my favorite.<br>那些糖果曾是我的最爱。</p><p>一般现在时<br>表示事物当前具有的属性或特点。</p><p>The water boils at 100℃.    At&#x3D;在某个点<br>水在100℃沸腾。<br>The water boils. 水沸腾了。不及物动词：单独成句。<br>The earth is round.<br>地球是圆的。<br>Tom gets up at 8 a.m.<br>Tom早上8点起床。</p><p>一般将来时<br>加一个词，动词被打回原形<br>He goes to the market.-&gt;He will go to the market.<br>他将要去市场。<br>Will he go to the market?       英语忌重复<br>他将要去市场吗？<br>When will he go to the market?<br>他将在啥时候去市场？<br>Will&#x3D;（情态）助动词<br>She is my teacher.<br>她是我的老师。<br>She will be my teacher.<br>他将会是我的老师。<br>情态助动词&gt;其他所有动词<br>Will she be my teacher?<br>他将会是我的老师吗？</p><p>你明天能来我家吗？<br>Can you come to my home tomorrow?<br>这只猫将会吃掉这条鱼？<br>The cat will eat this fish?<br>你会去参加我们的婚礼吗？<br>Will you attend our wedding?<br>Tom将会留在这栋房子里。<br>Tom Will stay in the house .<br>没人会加入这个队伍。<br>Nobody will join the team.</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>否定句的底层原理</title>
      <link href="/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E5%90%A6%E5%AE%9A%E5%8F%A5%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E5%90%A6%E5%AE%9A%E5%8F%A5%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>否定句的底层原理<br>助动词+not<br>I （do）like you.<br>我喜欢你。<br>否定：I do not like you. 我不喜欢你<br>Do you like me?<br>Yes ,I do like you.(可以省略)<br>No ,I don’t like you.<br>能省而不省&#x3D;&#x3D;强调<br>I don’t like you.</p><p>Do&#x3D;&#x3D;don’t<br>Does&#x3D;&#x3D;doesn’t<br>Did&#x3D;&#x3D;didn’t</p><p>He is a teacher.<br>他是一个老师。<br>否定：He is not a teacher. 他不是一个老师<br>He isn’t a teacher.</p><p>Is&#x3D; isn’t<br>Am&#x3D;&#x3D;am not<br>Are&#x3D;&#x3D;aren’t<br>Was&#x3D;&#x3D;wasn’t<br>Were&#x3D;&#x3D;weren’t</p><p>Marry will go to school.<br>Marry将要去上学。<br>否定：Marry will not go to school. Marry不会去上学。<br>Marry won’t go to school.</p><p>Will&#x3D;&#x3D;won’t<br>Would&#x3D;&#x3D;wouldn’t</p><p>May&#x3D;&#x3D;may not<br>Might&#x3D;&#x3D;might not</p><p>Can&#x3D;&#x3D;cannot, can’t<br>Could&#x3D;&#x3D;couldn’t</p><p>Should&#x3D; shouldn’t<br>Shall&#x3D;&#x3D;shall not</p><p>Must&#x3D;&#x3D;mustn’t</p><p>He has finished his homework.<br>他已经做完作业了。<br>否定：He has not finished his homework. 他还没写完作业。<br>缩合：助动词+n’t<br>He hasn’t finished his homework.</p><p>Have&#x3D;&#x3D;haven’t<br>Has&#x3D;&#x3D;hasn’t<br>Had&#x3D;&#x3D;hadn’t</p><p>他没有打你。<br>He hits you&#x3D;&gt;he doesn’t hit you.</p><p>我不能做这份工作。<br>I can’t do this job.</p><p>小明还没回答这个问题。<br>Xiaoming hasn’t answered the question.<br>他没在看电视。（用过去式）<br>He wasn’t watching TV.<br>他没在看电视吗？<br>Wasn’t he watching TV?<br>带否定的疑问句：助动词一定要用“缩合形式”</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定语从句2</title>
      <link href="/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A52/"/>
      <url>/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A52/</url>
      
        <content type="html"><![CDATA[<p>定语从句2<br>Where ,when<br>她所住的房子很大。<br>1.房子很大。<br>The house is very big.<br>2.她住在这栋房子里。<br>She lives in the house.&#x3D;&gt;which&#x2F;that she lives in.<br>The house which she lives in is very big.<br>The house in which she lives is very big.<br>In which&#x3D;&gt;where<br>Where&#x3D;介词+which(表地点)<br>Which&#x2F;that 前面带介词，有代表地点就可用where<br>Inhabit&#x3D;居住（及物动词）<br>She inhabits the house.&#x3D;&gt;which&#x2F;that she inhabits.</p><p>When&#x3D;介词+which(表时间)<br>我们打篮球的日子就是我无法忘记的日子。<br>1.日子就是日子。<br>The days are the days.<br>2.我们在那些日子里打篮球。<br>We played basketball on those days.&#x3D;&gt;which&#x2F;that<br>The days which we played basketball on is the days.<br>介词on提前which之前&#x3D;&gt;when<br>3.我无法忘记那些日子。<br>I can’t forget those days.&#x3D;&gt;which&#x2F;that(做宾语可以省略)<br>The days when we played basketball is the days which I can’t forget.</p><p>Why&#x3D;介词+which （表原因）<br>这就是我打你的原因。<br>1.这就是原因。<br>This is the reason.<br>2.我由于这个原因打你。<br>I hit you for the reason.&#x3D;&gt;which&#x2F;that&#x3D;&gt;for which I hit you.&#x3D;&gt;why I hit you.<br>This is the reason why I hit you.</p><p>Whose&#x3D;谁的(人或非人都可以用)<br>我喜欢窗户大的房子。<br>1.我喜欢房子。<br>2.I like the house.<br>3.这个房子窗户很大。<br>4.The house’s&#x3D;&gt;whose windows are very big.<br>5.I like the house whose windows are very big.</p><p>限定性 定语从句<br>非限定性 定语从句<br>1.This is my brother who lives in Shanghai.<br>2.这是我住在上海的哥哥。限定<br>3.This is my brother ,who lives in Shanghai.<br>4.这是我的哥哥，她现在住在上海。 非限定</p><p>That在定从不能用的情况：<br>1.前面带介词<br>2.非限定从</p><p>非限定从的引导词不能省略<br>1.Tom is very smart ,which（表带前面一整句话） everybody knows.<br>2.Tom非常的聪明，这件事是所有人都知道的<br>Tom is very smart, as everybody knows.</p><p>Which&#x2F;as  as额外表示“正如”的意思</p><p>As everybody knows.&#x3D;&gt;状语<br>状语：随便放（只要读得通）<br>As everybody knows, Tom is very smart.<br>Tom ,which everybody knows, is very smart.<br>The apple, which everybody knows, is red.<br>Which everybody knows ,the apple is red. 错<br>记少不记多：which不能放开头</p><p>你所对话的那个人是我哥哥。<br>You talk to the people ,The person is my brother.<br>The person whom you talk to is my brother.<br>我们打篮球的操场很大。<br>We play basketball on the playground ,The playground is very big.<br>The playground which we play basketball is very big<br>Marry昨天看到的那个操场很小。<br>Marry saw the playground yesterday ,the playground is very small.<br>The playground which Marry saw yesterday is very small.<br>你与其交朋友的那个是我姐姐。<br>You make friends with the person ,The person is my sister.<br>The person with whom you make friends is my sister.</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现在进行时、过去进行时</title>
      <link href="/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E7%8E%B0%E5%9C%A8%E8%BF%9B%E8%A1%8C%E6%97%B6%E3%80%81%E8%BF%87%E5%8E%BB%E8%BF%9B%E8%A1%8C%E6%97%B6/"/>
      <url>/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E7%8E%B0%E5%9C%A8%E8%BF%9B%E8%A1%8C%E6%97%B6%E3%80%81%E8%BF%87%E5%8E%BB%E8%BF%9B%E8%A1%8C%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<p>现在进行时<br>进行时：说话的同时，一个动作正在进行之中。<br>非谓语：doing，to do<br>一句一谓<br>他正在看电视。<br>He is watching TV.<br>这个女孩很漂亮。<br>This girl is very beautiful.<br>Tom正在打篮球。<br>Tom is playing basketball.<br>Marry正在跳舞。<br>Marry is dancing.<br>Jack正座在椅子上。<br>Jack is sitting on the chair.</p><p>They are coming to my home.<br>他们将要来我家。<br>Come&#x3D;短暂（非延续性）动词<br>短暂动词ing&#x3D;将来<br>They are going to ride a bike.<br>他们打算骑自行车。<br>Be going to do sth.表示将来与will互换即可。<br>过去进行时<br>昨晚7点，Jeerry正在做功课。<br>At7:00 last night,Jery was doing homework.<br>They were leaving their country.<br>他们曾经打算离开他们的国家。</p><p>我正在看书。<br>I am reading a book.<br>他们正在操场上跑步。<br>They are running on the playground.<br>她正在教室里画画。<br>She is drawing a picture in the classroom.<br>They are arriving in the airport.<br>它们正在到达机场上。<br>昨天下午3点，jerry和marry正在打乒乓球。<br>At 3:00 p.m. yesterday , jerry and marry were playing the ping pong.<br>那个时候，她正在卧室里睡觉。<br>At that time, she was sleeping in the bedroom.</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现在完成时、过去完成时</title>
      <link href="/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E7%8E%B0%E5%9C%A8%E5%AE%8C%E6%88%90%E6%97%B6%E3%80%81%E8%BF%87%E5%8E%BB%E5%AE%8C%E6%88%90%E6%97%B6/"/>
      <url>/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E7%8E%B0%E5%9C%A8%E5%AE%8C%E6%88%90%E6%97%B6%E3%80%81%E8%BF%87%E5%8E%BB%E5%AE%8C%E6%88%90%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<p>现在完成时<br>done&#x3D;过去分词（完成）非谓语<br>doing(表示一个动作正在进行)<br>你已经做完功课了。<br>You have done homework.<br>单三&#x3D;have-&gt;has<br>He has done homework.<br>Tom已经锁门了。<br>Tom has locked the door.</p><p>过去完成时<br>Have-&gt;had<br>他们已经把水喝了。<br>They have done drunk the water.<br>昨天，他们已经把水喝了。<br>Yesterday ,they had drunk the water.</p><p>变一般疑问句<br>Has Tom locked the door?</p><p>特殊疑问句<br>Why has Tom locked the door?</p><p>be 动词<br>be的过去分词&#x3D;been<br>她是一名老师。<br>She is a teacher.<br>她已经是一名老师了。<br>She has been a teacher.</p><p>过去式，过去分词</p><p>Go&#x3D;went, gone  do&#x3D;did&#x3D;done<br>Be&#x3D;was&#x2F;were&#x3D;been  see&#x3D;saw&#x3D;seen<br>Sleep&#x3D;slept&#x3D;slept</p><p>Break 打破：broke ,broken<br>Strike 打击：stroke ,stricken<br>Freeze 冰冻：froze .frozen<br>Eat 吃：ate ,eaten</p><p>Hit 打：hit ,hit<br>Set 设置：set ,set<br>Put 放：put ,put<br>Drink 喝：drank ,drunk<br>Sing 唱：sang ,sung<br>Sink 沉没：sank ,sunk</p><p>Come 来：came ,come<br>Become: 成为：became ,become<br>Stand 站立：stood ,stood<br>Understand 懂：understood ,understood</p><p>这只猫已经睡了3小时了。<br>The cat has slept for 3 hours.<br>Marry 已经把这个苹果吃了吗？<br>Has Marry eaten the apple?<br>这些人昨天7点就来到我办公室了。<br>At 7 o’clock yesterday, these people had come to my office.<br>她把我的书拿走了。<br>She has taken my book.</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语的构成、定语从句</title>
      <link href="/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E8%8B%B1%E8%AF%AD%E7%9A%84%E6%9E%84%E6%88%90%E3%80%81%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5/"/>
      <url>/2025/07/25/asp.net%20core/%E8%8B%B1%E8%AF%AD/%E8%8B%B1%E8%AF%AD%E7%9A%84%E6%9E%84%E6%88%90%E3%80%81%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>英语的构成、定语从句<br>六大修饰成分：<br>名词、形容词、介词短语、非谓语、各种从句、副词</p><p>英语&#x3D;主干+修饰</p><p>这个我昨天在市场买的小苹果基本上是深红色的。<br>This small apple that I bought from the market yesterday basically is dee p red.<br>From&#x3D;从<br>英语的句子&#x3D;主句+从句<br>英语修饰成分&#x3D;定语+状语<br>定语&#x3D;修饰名词<br>状语&#x3D;修饰其他（形容词、动词、整个句子、副词<br>）<br>定语从句&#x3D;充当定语的从句<br>后置修饰</p><p>定于从句<br>这个我昨天在市场买的苹果是红色的。<br>1.这个苹果是红色的。</p><ol><li>This apple is red.<br>2.我昨天在市场买的+苹果&#x3D;我昨天在市场买了个苹果。</li><li>I bought an apple from the market yesterday<br>引导词：which ,that ,who&#x2F;whom<br>Who&#x2F;whom(主&#x2F;宾)&#x3D;指代“人”<br>Which&#x3D;指代“物”、“句子（非人）”<br>That&#x3D;万能（除了“句子”都可以指代）<br>that I bought from the market yesterday.</li></ol><p>This apple that(可省略)（能省而不省） I bought from the market yesterday is red.<br>2. 这个站在树下的男还是我哥哥</p><ol><li>这个男孩是我哥哥。<br>This boy is my brother.</li><li>站在树下的+男孩&#x3D;这个男孩站在树下。<br>This boy stands under the tree.&#x3D;&gt;who&#x2F;that stands under the tree.</li></ol><p>This boy who&#x2F;that stands under the tree is my brother.</p><p>Tom 昨天吃的苹果是黄色的。</p><ol><li>the apple is yellow.<br>2.tom昨天吃了苹果<br>Tom ate the apple yesterday.<br>The apple that tom ate yesterday is yellow.<br>Marry就是你所爱的人。<br>1.marry 就是人<br>Marry is the person<br>2.你爱的+人<br>You love person.<br>Marry is the person who you love<br>你明天去见面的那个人是我姐姐。<br>1.那个人是我姐姐<br>There person is my sister.</li><li>你明天去见面的+那个人<br>You to meet there person tomorrow<br>That you to meet tomorrow there person is my sister.<br>我认识这条正座在地上的狗。<br>1.我认识这条狗。<br>I know this dog.</li><li>正座在地上的+狗。&#x3D;&gt;狗坐在地上<br>Dog is siting on the ground.<br>I know this dog that is siting on the ground.</li></ol>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch</title>
      <link href="/2025/07/17/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/Elasticsearch/"/>
      <url>/2025/07/17/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/Elasticsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是ElasticSearch"><a href="#什么是ElasticSearch" class="headerlink" title="什么是ElasticSearch"></a>什么是ElasticSearch</h1><p>Elasticsearch 是一个分布式的搜索与分析引擎，专门用于处理大规模数据的全文搜索、结构化查询、日志分析和实时数据可视化等场景。它是 Elasticsearch Stack（原 ELK Stack） 的核心组件，和 Logstash、Kibana 一起广泛应用于日志收集和分析系统中。</p><h2 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h2><p>全文搜索支持分词、模糊匹配、相关性打分等强大的全文检索功能。</p><p>分布式架构可以横向扩展，支持亿级数据的快速读写和查询。</p><p>实时分析支持对数据的实时聚合、过滤、统计分析。<br>RESTful API操作基于 HTTP 的 JSON 请求，易于集成。</p><p>强大的查询 DSL提供基于 JSON 的查询语法，支持布尔、范围、模糊、地理、聚合等多种查询方式。</p><h2 id="Elasticsearch工作原理"><a href="#Elasticsearch工作原理" class="headerlink" title="Elasticsearch工作原理"></a>Elasticsearch工作原理</h2><p>数据写入流程:            搜索查询流程:<br>┌──────────┐             ┌────────────┐<br>│  客户端   │             │   客户端    │<br>└────┬─────┘             └─────┬──────┘<br>     │ HTTP&#x2F;JSON                │ HTTP&#x2F;JSON<br>     ▼                          ▼<br>┌────────────┐            ┌─────────────┐<br>│ Elasticsearch│           │ Elasticsearch │<br>└────┬───────┘            └─────┬────────┘<br>     │ 分片分发                    │ 查询路由<br>     ▼                            ▼<br>┌────────────┐              ┌────────────┐<br>│ 倒排索引构建│              │ 倒排索引查找│<br>└────────────┘              └────────────┘</p><h2 id="核心概念先掌握"><a href="#核心概念先掌握" class="headerlink" title="核心概念先掌握"></a>核心概念先掌握</h2><p>文档（Document）Elasticsearch 中的最小数据单元（如一条商品信息），JSON格式<br>索引（Index）一组类似文档的集合，相当于数据库中的表<br>分片（Shard）索引被分成的物理存储单位，分布在不同节点<br>倒排索引实现全文搜索的关键数据结构<br>节点（Node）Elasticsearch 集群中的单个服务器实例<br>集群（Cluster）一组 Elasticsearch 节点组成，提供统一服务</p><h2 id="数据写入（索引）过程"><a href="#数据写入（索引）过程" class="headerlink" title="数据写入（索引）过程"></a>数据写入（索引）过程</h2><p>客户端提交 JSON 数据（Document）</p><p>选择目标索引（如：products）</p><p>路由算法决定写入哪个主分片（Primary Shard）</p><p>字段经过分析器（Analyzer）处理 → 分词、去停用词</p><p>构建倒排索引：词 → 文档 ID 映射</p><p>主分片写入完成后，同步写入副本分片（Replica）</p><h2 id="数据查询（搜索）过程"><a href="#数据查询（搜索）过程" class="headerlink" title="数据查询（搜索）过程"></a>数据查询（搜索）过程</h2><p>客户端发起查询（DSL &#x2F; REST）</p><p>协调节点（通常是接收请求的节点）解析查询</p><p>路由到所有涉及的分片（主分片或副本分片）执行查询</p><p>每个分片执行倒排索引搜索，计算匹配度</p><p>汇总所有分片的结果，按相关性排序</p><p>将最终结果返回给客户端</p><h2 id="倒排索引机制（全文搜索核心）"><a href="#倒排索引机制（全文搜索核心）" class="headerlink" title="倒排索引机制（全文搜索核心）"></a>倒排索引机制（全文搜索核心）</h2><p>示例：<br>我们有三个文档：</p><p>ID内容<br>1我喜欢苹果手机<br>2苹果手机很好用<br>3华为手机也不错</p><p>分词后：<br>苹果 → [1, 2]<br>手机 → [1, 2, 3]<br>华为 → [3]</p><p>这就形成了“关键词 → 文档列表”的倒排索引结构，搜索“苹果 手机”时可快速定位文档 1 和 2。</p><h2 id="分布式架构的工作方式"><a href="#分布式架构的工作方式" class="headerlink" title="分布式架构的工作方式"></a>分布式架构的工作方式</h2><p>每个索引由若干个 主分片（Primary Shard） 和 副本分片（Replica Shard） 组成。</p><p>查询请求可以由主分片或副本分片任意响应，写入只能到主分片。</p><p>分片分布在不同节点上，支持高可用和水平扩展。</p><p>示例（products 索引）：</p><p>分片类型分片编号所在节点<br>主分片shard-0Node-A<br>副本分片shard-0Node-B</p><h2 id="近实时特性（NRT）"><a href="#近实时特性（NRT）" class="headerlink" title="近实时特性（NRT）"></a>近实时特性（NRT）</h2><p>Elasticsearch 是<strong>近实时（Near Real Time）</strong>系统：</p><p>文档写入后，不是立即可搜索的。</p><p>默认每隔 1 秒 会刷新（refresh），使新数据可见。</p><p>可手动调用 POST &#x2F;index&#x2F;_refresh 强制刷新。</p><p>总结关键点<br>环节技术原理<br>写入分片路由 + 分词 + 倒排索引构建<br>查询分片并行 + 倒排索引搜索 + 聚合汇总<br>扩展多节点多分片自动负载均衡<br>实时性默认 1 秒刷新，近实时可查</p><h1 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h1><p>打开浏览器访问官方下载页面：<br><a href="https://www.elastic.co/downloads/elasticsearch">https://www.elastic.co/downloads/elasticsearch</a></p><p>找到最新版（如 9.0.3），点击 Windows zip (x86_64) 版本下载。<br>文件示例：elasticsearch-9.0.3-windows-x86_64.zip</p><p><img src="/img%5C%E7%BD%91%E5%9D%80%5C6.png"></p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p><img src="/img%5C%E7%BD%91%E5%9D%80%5C12.png"></p><h2 id="启动-Elasticsearch-服务"><a href="#启动-Elasticsearch-服务" class="headerlink" title="启动 Elasticsearch 服务"></a>启动 Elasticsearch 服务</h2><p>方法 1：命令行启动（推荐用于开发）<br>打开 PowerShell 或 CMD（以管理员身份）</p><p><img src="/img%5C%E7%BD%91%E5%9D%80%5C7.png"><br>进入 bin 目录：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> E:\elastic<span class="built_in">search-9</span>.<span class="number">0.3</span><span class="literal">-windows-x86_64</span>\elastic<span class="built_in">search-9</span>.<span class="number">0.3</span>\bin</span><br></pre></td></tr></table></figure><p><img src="/!%5B%5D(img%5C%E7%BD%91%E5%9D%80%5C8.png)"></p><p>执行启动命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.\elasticsearch.bat</span><br></pre></td></tr></table></figure><p>启动过程提示（首次运行可能显示）：<br>生成默认密码</p><p>自动启用安全性（Elastic 用户名是 elastic，密码会显示在控制台）<br>一定要复制保存好初始密码！</p><h2 id="验证服务是否启动成功"><a href="#验证服务是否启动成功" class="headerlink" title="验证服务是否启动成功"></a>验证服务是否启动成功</h2><p>方法 1：浏览器访问测试<br>打开浏览器，输入：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:9200</span></span><br></pre></td></tr></table></figure><p>你应该会看到如下 JSON：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DESKTOP-ABC123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;elasticsearch&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;number&quot;</span><span class="punctuation">:</span> <span class="string">&quot;9.0.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tagline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>方法 2：命令行测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -u elastic http://localhost:9200</span><br></pre></td></tr></table></figure><h2 id="查看默认用户名和密码"><a href="#查看默认用户名和密码" class="headerlink" title="查看默认用户名和密码"></a>查看默认用户名和密码</h2><p>Elasticsearch 9.x 默认启用安全认证，初始用户为：</p><p>用户名密码<br>elastic启动时在控制台生成（或 logs 中找）</p><p>可通过如下文件查看密码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\elasticsearch<span class="number">-9.0</span><span class="number">.3</span>-windows-x86_64\elasticsearch<span class="number">-9.0</span><span class="number">.3</span>\<span class="built_in">log</span>\elasticsarch.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>搜索关键词 generated password。</p><h2 id="配置文件路径说明（可选修改）"><a href="#配置文件路径说明（可选修改）" class="headerlink" title="配置文件路径说明（可选修改）"></a>配置文件路径说明（可选修改）</h2><p>路径：E:\elasticsearch-9.0.3-windows-x86_64\elasticsearch-9.0.3\config\elasticsearch.yml</p><p>可配置内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-cluster</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-1</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">D:\esdata</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">D:\eslogs</span></span><br><span class="line"></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>     <span class="comment"># 允许外部访问</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"></span><br><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="关闭服务的方法"><a href="#关闭服务的方法" class="headerlink" title="关闭服务的方法"></a>关闭服务的方法</h2><p>在控制台按下：</p><p>Ctrl + C<br>或关闭 PowerShell 窗口即可。</p><h2 id="ElasticSearch一些问题"><a href="#ElasticSearch一些问题" class="headerlink" title="ElasticSearch一些问题"></a>ElasticSearch一些问题</h2><h3 id="一个异常received-plaintext-http-traffic-on-an-https"><a href="#一个异常received-plaintext-http-traffic-on-an-https" class="headerlink" title="一个异常received plaintext http traffic on an https"></a>一个异常received plaintext http traffic on an https</h3><p><img src="/img%5C%E7%BD%91%E5%9D%80%5C10.png"></p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>日志级别为WARN，表示有异常情况<br>日志来自o.e.h.n.<br>Netty4HttpServerTransport，即Elasticsearch的HTTP服务器组件<br>日志内容提示”received plaintext http traffic on an https channel”，即在HTTPS通道上接收到了明文HTTP流量<br>Elasticsearch的应对措施是”closing connection”，即关闭了这个连接<br>所以可以判断，Elasticsearch服务器期望客户端使用HTTPS发送请求，但实际收到的是明文HTTP请求，因此拒绝了这些请求。</p><p>同时日志中也提到了请求的源地址和目标地址，这里都是[0:0:0:0:0:0:0:1]，即IPv6环回地址，相当于IPv4的127.0.0.1，表示请求来自本机。目标端口为9200，即Elasticsearch的默认端口。</p><h2 id="方案一（使用HTTPS）"><a href="#方案一（使用HTTPS）" class="headerlink" title="方案一（使用HTTPS）"></a>方案一（使用HTTPS）</h2><p>使用HTTPS协议访问Elasticsearch而不是HTTP。<br>之前你PUT访问的是<a href="http://localhost:9200，现在将设你如将请求的URL改为https://localhost:9200，并确保Elasticsearch配置了正确的SSL证书。开发环境下可以直接请求。">http://localhost:9200，现在将设你如将请求的URL改为https://localhost:9200，并确保Elasticsearch配置了正确的SSL证书。开发环境下可以直接请求。</a></p><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>但是用https会弹出elasticSearch省份验证。</p><p>Elasticsearch 9.0.3 的内置用户包括：</p><p>elastic：超级管理员用户，拥有所有权限。<br>kibana_system：Kibana 用于与 Elasticsearch 通信的用户。<br>logstash_system：Logstash 用于与 Elasticsearch 通信的用户。<br>beats_system：Beats 用于与 Elasticsearch 通信的用户。</p><p>使用 elasticsearch-reset-password 工具（推荐）<br>若要重置 elastic 用户的密码，可执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入Elasticsearch bin目录</span></span><br><span class="line"><span class="built_in">cd</span> /path/to/elasticsearch/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互式重置密码（会提示输入新密码）</span></span><br><span class="line">./elasticsearch-reset-password -u elastic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或自动生成随机密码并显示（非交互式）</span></span><br><span class="line">./elasticsearch-reset-password -u elastic --batch</span><br></pre></td></tr></table></figure><p><img src="/img%5C%E7%BD%91%E5%9D%80%5C13.png"></p><p>浏览器测试<a href="https://localhost:9200/">https://localhost:9200</a><br><img src="/img%5C%E7%BD%91%E5%9D%80%5C14.png"></p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/2025/07/15/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/Nginx/"/>
      <url>/2025/07/15/asp.net%20core/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/Nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>第一步：</p><p>下载Nginx: <a href="https://nginx.p2hp.com/">https://nginx.p2hp.com/</a></p><p><img src="/img%5C%E7%BD%91%E5%9D%80%5C1.png"><br>选择对应版本</p><p>第二步：</p><p>Nginx的使用</p><p>我们的常用配置只需要在nginx.conf中。</p><p><img src="/img%5C%E7%BD%91%E5%9D%80%5C2.png"></p><p><img src="/img%5C%E7%BD%91%E5%9D%80%5C3.png"><br>可以看到Nginx默认配置的端口号是 80</p><p>第三步：</p><p>Nginx启动方式</p><p>通过命令行启动</p><p>在nginx安装目录的绝对路径的框框内输入 cmd，直接输入 nginx 或者 start nginx，然后回车，就可以启动nginx了。</p><p>！windows防火墙要允许nginx访问网络。</p><p><img src="/img%5C%E7%BD%91%E5%9D%80%5C4.png"></p><p>然后在浏览器地址栏输入 localhost</p><p><img src="/img%5C%E7%BD%91%E5%9D%80%5C5.png"><br>如果能看到这个页面，那么nginx启动就成功了。<br>关闭nginx的命令：nginx -s stop</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用</title>
      <link href="/2025/07/03/git/"/>
      <url>/2025/07/03/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h1><p>Git 是一个分布式版本控制系统，用来管理代码或任何文件的版本历史。</p><p>常用于协作开发，支持分支、合并、回滚等操作。</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>再Windows上安装Git。<br>官网下载：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a><br>安装之后，就可以使用命令行git工具了。<br>在开始菜单里找到 “Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。</p><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><h3 id="基本身份配置"><a href="#基本身份配置" class="headerlink" title="基本身份配置"></a>基本身份配置</h3><p>在第一次使用 Git 时，先配置用户名和邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的名字&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的邮箱@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>这会把配置写入 ~&#x2F;.gitconfig 文件，并对所有仓库生效。如果只想对当前仓库有效，去掉 –global。</p><h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><p>查看所有当前生效的配置项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><h2 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h2><p>初始化一个新仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><p>克隆远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;仓库地址&gt;</span><br></pre></td></tr></table></figure><h2 id="文件追踪"><a href="#文件追踪" class="headerlink" title="文件追踪"></a>文件追踪</h2><h3 id="查看当前状态"><a href="#查看当前状态" class="headerlink" title="查看当前状态"></a>查看当前状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h3 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;文件或目录&gt;</span><br></pre></td></tr></table></figure><h3 id="添加全部改动："><a href="#添加全部改动：" class="headerlink" title="添加全部改动："></a>添加全部改动：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><h3 id="从暂存区移除文件"><a href="#从暂存区移除文件" class="headerlink" title="从暂存区移除文件"></a>从暂存区移除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;文件&gt;</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="提交到本地仓库"><a href="#提交到本地仓库" class="headerlink" title="提交到本地仓库"></a>提交到本地仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;提交信息&quot;</span></span><br></pre></td></tr></table></figure><h3 id="修改上一次提交（比如漏文件、改信息）"><a href="#修改上一次提交（比如漏文件、改信息）" class="headerlink" title="修改上一次提交（比如漏文件、改信息）"></a>修改上一次提交（比如漏文件、改信息）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h2 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h2><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><h3 id="简洁单行显示："><a href="#简洁单行显示：" class="headerlink" title="简洁单行显示："></a>简洁单行显示：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><h3 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="创建并切换新分支"><a href="#创建并切换新分支" class="headerlink" title="创建并切换新分支"></a>创建并切换新分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h2 id="合并与变基"><a href="#合并与变基" class="headerlink" title="合并与变基"></a>合并与变基</h2><h3 id="合并分支到当前分支"><a href="#合并分支到当前分支" class="headerlink" title="合并分支到当前分支"></a>合并分支到当前分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="交互式变基（整理提交历史）"><a href="#交互式变基（整理提交历史）" class="headerlink" title="交互式变基（整理提交历史）"></a>交互式变基（整理提交历史）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~N</span><br></pre></td></tr></table></figure><h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;仓库地址&gt;</span><br></pre></td></tr></table></figure><h3 id="查看远程地址"><a href="#查看远程地址" class="headerlink" title="查看远程地址"></a>查看远程地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h3 id="推送到远程分支"><a href="#推送到远程分支" class="headerlink" title="推送到远程分支"></a>推送到远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="拉取远程更新并合并"><a href="#拉取远程更新并合并" class="headerlink" title="拉取远程更新并合并"></a>拉取远程更新并合并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="获取远程更新但不合并"><a href="#获取远程更新但不合并" class="headerlink" title="获取远程更新但不合并"></a>获取远程更新但不合并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><h2 id="撤销与恢复"><a href="#撤销与恢复" class="headerlink" title="撤销与恢复"></a>撤销与恢复</h2><h3 id="丢弃工作区改动（慎用）"><a href="#丢弃工作区改动（慎用）" class="headerlink" title="丢弃工作区改动（慎用）"></a>丢弃工作区改动（慎用）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;文件&gt;</span><br></pre></td></tr></table></figure><h3 id="回到最近一次提交状态"><a href="#回到最近一次提交状态" class="headerlink" title="回到最近一次提交状态"></a>回到最近一次提交状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure><h3 id="撤销最近的提交（保留改动在工作区）"><a href="#撤销最近的提交（保留改动在工作区）" class="headerlink" title="撤销最近的提交（保留改动在工作区）"></a>撤销最近的提交（保留改动在工作区）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure><h1 id="Git创建仓库"><a href="#Git创建仓库" class="headerlink" title="Git创建仓库"></a>Git创建仓库</h1><ol><li><p>把工作目录切换到项目所在位置，要是项目目录不存在，就先创建一个。</p></li><li><p>执行git init命令，对 Git 仓库进行初始化。</p></li><li><p>把文件添加到暂存区，使用git add命令。</p></li><li><p>进行首次提交，使用git commit -m “Initial commit”命令。</p></li><li><p>查看仓库状态，使用git status</p></li></ol><p>以下是具体的操作示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建项目目录（若目录已存在则跳过此步）</span></span><br><span class="line"><span class="built_in">mkdir</span> myproject</span><br><span class="line"><span class="built_in">cd</span> myproject</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化Git仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件并添加内容</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, Git!&quot;</span> &gt; README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加文件到暂存区</span></span><br><span class="line">git add README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交到本地仓库</span></span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看仓库状态</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><h2 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h2><p>若要将本地仓库与远程仓库（例如 GitHub）进行关联，可按以下步骤操作：</p><ol><li>在远程平台上创建一个空仓库。</li><li>在本地仓库中添加远程仓库地址。</li><li>将本地分支推送到远程仓库。</li></ol><p>具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加远程仓库地址</span></span><br><span class="line">git remote add origin https://github.com/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送本地master分支到远程仓库</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h2><p>当需要获取远程仓库的副本时，可以使用git clone命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/</span><br></pre></td></tr></table></figure><p>这些都是 Git 的基础操作，在实际的开发流程中，还会涉及分支管理、拉取更新等更多操作。</p><p><img src="/img%5Cgit-2.png"></p><p>workspace：工作区<br>staging area：暂存区&#x2F;缓存区<br>local repository：版本库或本地仓库<br>remote repository：远程仓库</p><h1 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h1><p>Git 的分支管理是其核心功能之一，它允许开发者在同一仓库中并行开发多个特性或修复 bug，而不影响主分支的代码。以下是关于 Git 分支管理的详细介绍：</p><ol><li>分支的基本概念</li></ol><p>什么是分支？</p><p>分支是指向提交对象的可变指针。Git 的默认分支名为master（或main），每次提交时，当前分支指针会向前移动。<br>分支本质：一个轻量级的可移动引用，存储在.git&#x2F;refs&#x2F;heads&#x2F;目录下。<br>分支的优势<br>并行开发：同时进行多个特性开发或 bug 修复。<br>隔离风险：在分支上的修改不会影响主分支，直到合并完成。<br>简化协作：团队成员可以在独立分支上工作，减少冲突。<br>2. 分支的基本操作</p><p>查看分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch            <span class="comment"># 查看本地分支</span></span><br><span class="line">git branch -r         <span class="comment"># 查看远程分支</span></span><br><span class="line">git branch -a         <span class="comment"># 查看所有分支（本地+远程）</span></span><br><span class="line">git branch -vv        <span class="comment"># 查看分支关联的远程分支及最后提交信息</span></span><br></pre></td></tr></table></figure><p>创建分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;分支名&gt;   <span class="comment"># 创建新分支（不切换）</span></span><br><span class="line">git checkout -b &lt;分支名&gt;  <span class="comment"># 创建并切换到新分支</span></span><br><span class="line">git checkout -b &lt;分支名&gt; &lt;提交哈希&gt;  <span class="comment"># 从指定提交创建分支</span></span><br></pre></td></tr></table></figure><p>切换分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;分支名&gt;  <span class="comment"># 切换到已存在的分支</span></span><br><span class="line">git switch &lt;分支名&gt;    <span class="comment"># Git 2.23+ 推荐的切换命令</span></span><br></pre></td></tr></table></figure><p>删除分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;分支名&gt;  <span class="comment"># 删除已合并的分支（安全删除）</span></span><br><span class="line">git branch -D &lt;分支名&gt;  <span class="comment"># 强制删除未合并的分支</span></span><br></pre></td></tr></table></figure><p>重命名分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;旧分支名&gt; &lt;新分支名&gt;  <span class="comment"># 重命名当前分支</span></span><br></pre></td></tr></table></figure><ol start="3"><li>分支合并<br>合并分支的两种方式<br>Fast-forward（快进合并）：当分支没有分叉时，直接将指针向前移动。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge feature-branch  <span class="comment"># 无冲突时直接快进</span></span><br></pre></td></tr></table></figure><p>三方合并（Three-way Merge）：当分支有分叉时，Git 会找到两个分支的共同祖先，创建一个新的合并提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge feature-branch  <span class="comment"># 创建合并提交</span></span><br></pre></td></tr></table></figure><p>合并冲突</p><p>当两个分支修改了同一文件的同一部分时，会发生冲突。解决方法：</p><p>手动编辑文件：打开冲突文件，根据标记（&lt;&lt;&lt;&lt;&lt;&lt;&lt;、&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;、&gt;&gt;&gt;&gt;&gt;&gt;&gt;）修改内容。<br>使用合并工具：如git mergetool。<br>提交合并结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;冲突文件&gt;</span><br><span class="line">git commit -m <span class="string">&quot;解决合并冲突&quot;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>分支管理策略<br>Git Flow</li></ol><p>主分支：master（生产环境）和develop（开发主分支）。<br>辅助分支：<br>Feature 分支：<br>从develop创建，完成后合并回develop。<br>Release 分支：<br>准备发布时从develop创建，测试后合并到master和develop。<br>Hotfix 分支：<br>紧急修复生产问题，从master创建，完成后合并回master和develop。</p><p>GitHub Flow</p><p>单一主分支：main始终保持可部署状态。<br>流程：<br>从main创建新分支。<br>提交修改并推送到远程。<br>创建 Pull Request（PR）进行代码审查。<br>测试通过后合并到main。<br>立即部署到生产环境。<br>GitLab Flow<br>基于 GitHub Flow，增加了环境分支（如staging、production），适合多环境部署。<br>5. 远程分支操作</p><p>推送本地分支到远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin &lt;本地分支名&gt;  <span class="comment"># 首次推送并关联上游分支</span></span><br><span class="line">git push origin &lt;本地分支名&gt;:&lt;远程分支名&gt;  <span class="comment"># 推送到不同名的远程分支</span></span><br></pre></td></tr></table></figure><p>跟踪远程分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;本地分支名&gt; origin/&lt;远程分支名&gt;  <span class="comment"># 创建并跟踪远程分支</span></span><br><span class="line">git checkout --track origin/&lt;远程分支名&gt;  <span class="comment"># 简化命令（本地分支名与远程一致）</span></span><br></pre></td></tr></table></figure><p>拉取远程分支更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull  <span class="comment"># 拉取并合并远程分支</span></span><br><span class="line">git fetch <span class="comment"># 仅获取远程分支更新，不合并</span></span><br></pre></td></tr></table></figure><p>删除远程分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>分支的高级用法</li></ol><p>变基（Rebase）</p><p>将一系列提交应用到另一个基准点，使提交历史更线性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature-branch</span><br><span class="line">git rebase main  <span class="comment"># 将feature-branch的提交变基到main</span></span><br></pre></td></tr></table></figure><p>** cherry-pick**<br>将指定提交应用到当前分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;提交哈希&gt;  <span class="comment"># 复制特定提交到当前分支</span></span><br></pre></td></tr></table></figure><p>暂存（Stash）<br>临时保存未完成的修改，用于切换分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash  <span class="comment"># 保存当前修改</span></span><br><span class="line">git stash pop  <span class="comment"># 恢复最近一次stash</span></span><br><span class="line">git stash list  <span class="comment"># 查看所有stash</span></span><br></pre></td></tr></table></figure><ol start="7"><li>分支管理最佳实践</li></ol><p>保持主分支稳定：main&#x2F;master只包含经过测试的代码。</p><p>小而专注的分支：每个分支只做一件事（如新特性或 bug 修复）。</p><p>定期同步分支：通过git pull –rebase保持分支更新，减少冲突。</p><p>使用 PR&#x2F;MR 进行代码审查：合并前确保代码质量。</p><p>删除已合并的分支：保持仓库整洁。<br>示例工作流程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建并切换到新分支</span></span><br><span class="line">git checkout -b feature/new-feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 开发并提交</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;新功能代码&quot;</span> &gt; feature.txt</span><br><span class="line">git add feature.txt</span><br><span class="line">git commit -m <span class="string">&quot;添加新功能&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 同步主分支（可选）</span></span><br><span class="line">git checkout main</span><br><span class="line">git pull origin main</span><br><span class="line">git checkout feature/new-feature</span><br><span class="line">git rebase main  <span class="comment"># 或 git merge main</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 推送到远程</span></span><br><span class="line">git push -u origin feature/new-feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 创建PR并合并到main</span></span><br><span class="line"><span class="comment"># 6. 删除本地和远程分支</span></span><br><span class="line">git branch -d feature/new-feature</span><br><span class="line">git push origin --delete feature/new-feature</span><br></pre></td></tr></table></figure><p>通过合理使用分支管理，开发者可以高效地组织代码、隔离风险，并简化团队协作。Git 的分支操作非常轻量，因此鼓励频繁创建和使用分支！</p><h1 id="Git-查看提交历史"><a href="#Git-查看提交历史" class="headerlink" title="Git 查看提交历史"></a>Git 查看提交历史</h1><p>常用选项</p><p>限制显示的提交数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n &lt;number&gt;</span><br></pre></td></tr></table></figure><p>例如，显示最近的 5 次提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n 5</span><br></pre></td></tr></table></figure><p>显示自指定日期之后的提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;2024-01-01&quot;</span></span><br></pre></td></tr></table></figure><p>显示指定日期之前的提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --<span class="keyword">until</span>=<span class="string">&quot;2024-07-01&quot;</span></span><br></pre></td></tr></table></figure><p>只显示某个作者的提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;Author Name&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Git标签"><a href="#Git标签" class="headerlink" title="Git标签"></a>Git标签</h1><p>Git 标签（Tag）是用于标记版本历史中特定提交的指针，常用于标记发布点（如v1.0.0）或重要里程碑。与分支不同，标签是不可变的，一旦创建就不会移动。</p><ol><li>标签的基本概念</li></ol><p>标签的作用</p><p>版本标记：标记发布版本（如v1.0.0、v2.3.1）。<br>重要里程碑：标记关键提交（如架构重构、重大功能发布）。<br>快速定位：通过标签名快速切换到历史版本。</p><p>标签的类型</p><p>轻量标签（Lightweight）：<br>简单指向特定提交的引用，无额外元数据。<br>存储在.git&#x2F;refs&#x2F;tags&#x2F;目录下。<br>附注标签（Annotated）：<br>完整的 Git 对象，包含标签名、标签人、日期、注释信息。<br>可签名（GPG），用于验证版本。</p><ol start="2"><li>标签的基本操作<br>创建标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建轻量标签（指向当前提交）</span></span><br><span class="line">git tag &lt;标签名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建轻量标签（指向特定提交）</span></span><br><span class="line">git tag &lt;标签名&gt; &lt;提交哈希&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建附注标签（带注释）</span></span><br><span class="line">git tag -a &lt;标签名&gt; -m <span class="string">&quot;标签说明&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建带签名的附注标签（需GPG密钥）</span></span><br><span class="line">git tag -s &lt;标签名&gt; -m <span class="string">&quot;签名标签说明&quot;</span></span><br></pre></td></tr></table></figure></li></ol><p>查看标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag               <span class="comment"># 列出所有标签</span></span><br><span class="line">git tag -l <span class="string">&quot;v1.0.*&quot;</span>   <span class="comment"># 按模式筛选标签</span></span><br><span class="line">git show &lt;标签名&gt;     <span class="comment"># 查看标签详细信息</span></span><br></pre></td></tr></table></figure><p>切换到标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;标签名&gt;  <span class="comment"># 切换到标签（处于“分离HEAD”状态）</span></span><br><span class="line">git checkout -b &lt;分支名&gt; &lt;标签名&gt;  <span class="comment"># 从标签创建新分支</span></span><br></pre></td></tr></table></figure><p>删除标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;标签名&gt;  <span class="comment"># 删除本地标签</span></span><br></pre></td></tr></table></figure><ol start="3"><li>远程标签操作</li></ol><p>推送标签到远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;标签名&gt;  <span class="comment"># 推送单个标签</span></span><br><span class="line">git push origin --tags   <span class="comment"># 推送所有未推送的标签</span></span><br></pre></td></tr></table></figure><p>删除远程标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;标签名&gt;  <span class="comment"># Git 2.8+</span></span><br><span class="line"><span class="comment"># 或旧版语法</span></span><br><span class="line">git push origin :refs/tags/&lt;标签名&gt;</span><br></pre></td></tr></table></figure><p>获取远程标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin --tags  <span class="comment"># 获取所有远程标签</span></span><br></pre></td></tr></table></figure><ol start="4"><li>标签命名规范</li></ol><p>常见的标签命名规范：</p><p>语义化版本：v&lt;主版本&gt;.&lt;次版本&gt;.&lt;修订号&gt;（如v1.0.0、v2.3.1）。<br>发布类型：<br>正式版：v1.0.0<br>预发布版：v1.0.0-alpha、v1.0.0-beta.1、v1.0.0-rc.1<br>特殊标记：v1.0.0-hotfix、v2.0.0-20230615</p><ol start="5"><li>标签的最佳实践</li></ol><p>使用附注标签：建议在发布版本时使用附注标签，保留完整元数据。<br>及时打标签：在发布或重要提交后立即打标签。<br>避免修改标签：标签是不可变的，如需修改需删除后重新创建（可能影响协作）。<br>定期清理标签：删除不再需要的本地 &#x2F; 远程标签。</p><p>标签与分支的区别：</p><p>分支：用于开发，指针会随提交移动。<br>标签：用于标记历史版本，指针固定不变。</p><p>示例工作流程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 提交代码到主分支</span></span><br><span class="line">git checkout main</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;完成v1.0.0功能开发&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建附注标签</span></span><br><span class="line">git tag -a v1.0.0 -m <span class="string">&quot;首个正式版本发布&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 推送标签到远程</span></span><br><span class="line">git push origin v1.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 后续发现bug，修复后创建补丁版本</span></span><br><span class="line">git checkout -b hotfix/v1.0.1 main</span><br><span class="line"><span class="comment"># 修复bug...</span></span><br><span class="line">git commit -m <span class="string">&quot;修复登录验证问题&quot;</span></span><br><span class="line">git checkout main</span><br><span class="line">git merge hotfix/v1.0.1</span><br><span class="line">git tag -a v1.0.1 -m <span class="string">&quot;修复登录验证问题&quot;</span></span><br><span class="line">git push origin v1.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 查看历史标签</span></span><br><span class="line">git tag -l</span><br></pre></td></tr></table></figure><p>Git 标签是版本管理的重要工具，通过合理使用标签，可以清晰地标记项目的关键节点，便于回溯和发布管理。</p><h1 id="Git进阶操作"><a href="#Git进阶操作" class="headerlink" title="Git进阶操作"></a>Git进阶操作</h1><ol><li>交互式暂存（Interactive Staging）<br>作用：逐块选择要暂存的更改，精细控制提交内容。<br>场景：当一次修改包含多个逻辑更改，需要拆分为多个提交时。</li></ol><p>基本用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -p  <span class="comment"># 交互式暂存（-p 是 --patch 的缩写）</span></span><br></pre></td></tr></table></figure><p>交互命令<br>y：暂存当前区块<br>n：跳过当前区块<br>s：拆分当前区块（如果区块较大）<br>e：手动编辑当前区块<br>d：查看 diff<br>q：退出</p><p>示例</p><p>假设修改了两个功能（用户认证和支付），但想分开提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入交互式暂存模式</span></span><br><span class="line">git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统会逐块显示更改：</span></span><br><span class="line"><span class="comment"># 1. 用户认证相关更改 -&gt; 选择 y 暂存</span></span><br><span class="line"><span class="comment"># 2. 支付相关更改 -&gt; 选择 n 跳过</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交已暂存的用户认证更改</span></span><br><span class="line">git commit -m <span class="string">&quot;完善用户认证逻辑&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次执行 git add -p 暂存剩余的支付更改</span></span><br><span class="line">git add -p  <span class="comment"># 暂存支付相关更改</span></span><br><span class="line">git commit -m <span class="string">&quot;优化支付流程&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Git Stash</li></ol><p>作用：临时保存工作进度，方便切换任务。<br>场景：需要紧急切换分支，但当前工作未完成。</p><p>基本操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git stash save <span class="string">&quot;临时保存未完成的功能&quot;</span>  <span class="comment"># 保存当前进度</span></span><br><span class="line">git stash list                         <span class="comment"># 查看所有stash</span></span><br><span class="line">git stash apply stash@&#123;0&#125;              <span class="comment"># 恢复指定stash（默认最新）</span></span><br><span class="line">git stash drop stash@&#123;0&#125;               <span class="comment"># 删除指定stash</span></span><br><span class="line">git stash pop                          <span class="comment"># 恢复并删除最新stash</span></span><br></pre></td></tr></table></figure><p>高级用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash branch new-feature  <span class="comment"># 从stash创建新分支并自动应用</span></span><br><span class="line">git stash show -p             <span class="comment"># 查看stash的详细更改</span></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前在feature分支开发未完成，需要紧急修复bug</span></span><br><span class="line">git stash save <span class="string">&quot;未完成的新功能&quot;</span>  <span class="comment"># 保存当前进度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到master分支修复bug</span></span><br><span class="line">git checkout master</span><br><span class="line">git checkout -b hotfix</span><br><span class="line"><span class="comment"># 修复bug...</span></span><br><span class="line">git commit -m <span class="string">&quot;修复登录崩溃问题&quot;</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge hotfix</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回feature分支恢复工作</span></span><br><span class="line">git checkout feature</span><br><span class="line">git stash pop  <span class="comment"># 恢复之前的工作进度</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Git Rebase<br>作用：将一个分支上的更改移到另一个分支之上，保持提交历史线性。<br>场景：在推送到远程前整理本地提交，或同步最新主分支。</li></ol><p>基本用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将feature分支的提交变基到main</span></span><br><span class="line">git checkout feature</span><br><span class="line">git rebase main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化操作（直接在main上执行）</span></span><br><span class="line">git rebase main feature</span><br></pre></td></tr></table></figure><p>交互式变基<br>合并、修改或删除历史提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3  <span class="comment"># 编辑最近3次提交</span></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 从main创建新分支并提交两次</span></span><br><span class="line">git checkout -b feature main</span><br><span class="line"><span class="comment"># 开发...</span></span><br><span class="line">git commit -m <span class="string">&quot;添加用户列表&quot;</span></span><br><span class="line"><span class="comment"># 开发...</span></span><br><span class="line">git commit -m <span class="string">&quot;优化用户列表样式&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 此时main分支已更新，需要同步</span></span><br><span class="line">git fetch origin</span><br><span class="line">git rebase origin/main  <span class="comment"># 将feature的提交变基到最新main</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 使用交互式变基合并两个提交</span></span><br><span class="line">git rebase -i HEAD~2</span><br><span class="line"><span class="comment"># 在编辑器中将第二行的pick改为squash，保存退出</span></span><br><span class="line"><span class="comment"># 编辑合并后的提交信息</span></span><br></pre></td></tr></table></figure><ol start="4"><li>Git Cherry-Pick<br>作用：选择特定提交并应用到当前分支。<br>场景：将其他分支的某个提交引入当前分支，而非合并整个分支。<br>基本用法</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;提交哈希&gt;  <span class="comment"># 应用单个提交</span></span><br><span class="line">git cherry-pick A^..B      <span class="comment"># 应用从A（不含）到B的所有提交</span></span><br></pre></td></tr></table></figure><p>示例<br>假设在feature分支上有一个修复提交abc123，需要应用到main分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 切换到main分支</span></span><br><span class="line">git checkout main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 应用指定提交</span></span><br><span class="line">git cherry-pick abc123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 如果有冲突，解决后继续</span></span><br><span class="line">git add .</span><br><span class="line">git cherry-pick --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>最佳实践建议</p><ol><li>交互式暂存：<br>每次提交只包含一个逻辑更改<br>使用git add -p避免提交无关修改</li><li>Git Stash：<br>定期清理不再需要的 stash<br>使用描述性的 stash 消息</li><li>Git Rebase：<br>只对未推送到远程的提交使用 rebase<br>复杂变基前先备份分支（git branch backup-feature）</li><li>Git Cherry-Pick：<br>避免跨分支频繁 cherry-pick，优先使用合并<br>注意提交作者信息是否需要保留（-x选项）</li></ol><p>这些高级技巧能显著提升代码管理效率，但需谨慎使用，尤其是在团队协作环境中。建议先在个人分支练习，熟悉后再应用到实际开发流程中。</p><h1 id="Git远程Github"><a href="#Git远程Github" class="headerlink" title="Git远程Github"></a>Git远程Github</h1><h2 id="在-GitHub-上创建远程仓库"><a href="#在-GitHub-上创建远程仓库" class="headerlink" title="在 GitHub 上创建远程仓库"></a>在 GitHub 上创建远程仓库</h2><ol><li><p>登录 GitHub官网。</p></li><li><p>点击页面右上角 ➕ → New repository。</p></li><li><p>填写：</p><pre><code>Repository name：比如 my-awesome-projectDescription（可选）：项目描述Public / Private：公开或私有</code></pre></li><li><p>可以不用勾选「Initialize this repository with a README」—— 方便后面和本地仓库关联。</p></li><li><p>点击 Create repository。</p></li></ol><p>此时 GitHub 会给你显示一页命令提示，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/用户名/仓库名.git</span><br></pre></td></tr></table></figure><h2 id="在本地创建并初始化-Git-仓库"><a href="#在本地创建并初始化-Git-仓库" class="headerlink" title="在本地创建并初始化 Git 仓库"></a>在本地创建并初始化 Git 仓库</h2><p>进入你的项目目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 路径/你的项目目录</span><br></pre></td></tr></table></figure><p>初始化仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>添加文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>提交到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br></pre></td></tr></table></figure><h2 id="将本地仓库关联到-GitHub-远程仓库"><a href="#将本地仓库关联到-GitHub-远程仓库" class="headerlink" title="将本地仓库关联到 GitHub 远程仓库"></a>将本地仓库关联到 GitHub 远程仓库</h2><p>将 GitHub 上刚刚创建的仓库 URL（HTTPS 或 SSH）添加到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/用户名/仓库名.git</span><br></pre></td></tr></table></figure><h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><p>第一次推送时，通常需要 -u 参数建立本地分支与远程分支的关联：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p>如果你本地分支是 master，GitHub 创建的新仓库默认分支是 main，需要先重命名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><h2 id="从远程仓库克隆代码"><a href="#从远程仓库克隆代码" class="headerlink" title="从远程仓库克隆代码"></a>从远程仓库克隆代码</h2><p>如果是其他人要获取你的项目，或者你在其他机器上工作，可以直接克隆：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/用户名/仓库名.git</span><br></pre></td></tr></table></figure><h2 id="常用远程操作命令"><a href="#常用远程操作命令" class="headerlink" title="常用远程操作命令"></a>常用远程操作命令</h2><p>功能              命令<br>查看当前远程仓库地址    git remote -v<br>修改远程仓库地址    git remote set-urlorigin 新地址<br>拉取远程仓库更新    git pull origin main<br>推送到远程仓库        git push origin main<br>删除远程仓库关联    git remote remove origin<br>查看远程仓库分支    git branch -r</p><h2 id="HTTPS-和-SSH-的区别"><a href="#HTTPS-和-SSH-的区别" class="headerlink" title="HTTPS 和 SSH 的区别"></a>HTTPS 和 SSH 的区别</h2><p>HTTPS：</p><p>使用方便，直接用 GitHub 提供的 HTTPS 链接。</p><p>缺点是每次推送&#x2F;拉取可能会提示你输入 GitHub 账号和密码（或 token）。</p><p>SSH：</p><p>配置一次 SSH Key 后，再推送&#x2F;拉取都不会需要输入密码。</p><p>适合经常操作。</p><h2 id="如何配置-SSH-Key-以使用-SSH"><a href="#如何配置-SSH-Key-以使用-SSH" class="headerlink" title="如何配置 SSH Key 以使用 SSH"></a>如何配置 SSH Key 以使用 SSH</h2><ol><li>在终端生成 SSH Key：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>按提示一直回车即可，会在 <del>&#x2F;.ssh&#x2F;id_ed25519 生成私钥、</del>&#x2F;.ssh&#x2F;id_ed25519.pub 生成公钥。</p><ol start="2"><li>复制公钥内容：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_ed25519.pub</span><br></pre></td></tr></table></figure><ol start="3"><li><p>登录 GitHub → 点击右上角头像 → Settings → 左侧菜单 SSH and GPG keys → New SSH key，把上一步复制的公钥内容粘贴进去。</p></li><li><p>以后你就可以用 SSH 形式克隆仓库，比如：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:用户名/仓库名.git</span><br></pre></td></tr></table></figure><h2 id="其他常见问题"><a href="#其他常见问题" class="headerlink" title="其他常见问题"></a>其他常见问题</h2><ol><li>如何修改 Git 用户名&#x2F;邮箱？</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的名字&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>如何只对当前项目设置用户名&#x2F;邮箱？</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name <span class="string">&quot;你的名字&quot;</span></span><br><span class="line">git config user.email <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>如何切换到其他分支？</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure><ol start="4"><li>如何从远程拉取其他分支？</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git checkout -b 本地分支名 origin/远程分支名</span><br></pre></td></tr></table></figure><h2 id="常见完整操作流程"><a href="#常见完整操作流程" class="headerlink" title="常见完整操作流程"></a>常见完整操作流程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建本地仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加所有文件</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 提交</span></span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 关联远程</span></span><br><span class="line">git remote add origin https://github.com/用户名/仓库名.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 推送</span></span><br><span class="line">git branch -M main       <span class="comment"># 可选，重命名为 main</span></span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整洁架构</title>
      <link href="/2025/07/01/DDD/DDD%E5%AE%9E%E6%88%98-%E9%A1%B9%E7%9B%AE%E5%88%86%E5%B1%82/"/>
      <url>/2025/07/01/DDD/DDD%E5%AE%9E%E6%88%98-%E9%A1%B9%E7%9B%AE%E5%88%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="实现整洁架构项目分层"><a href="#实现整洁架构项目分层" class="headerlink" title="实现整洁架构项目分层"></a>实现整洁架构项目分层</h1><p>这个案例分为Users.Domain、Users.Infrastructure、Users.WebAPI这三个项目。</p><p>Users.Domain是领域层项目，主要包含实体类、值对象、领域事件数据类、领域服务、仓储接口、防腐层接口等；</p><p>Users.Infrastructure是基础设施项目，主要包含实体类的配置、上下文类的定义、仓储服务、防腐层接口的实现、基础工具类等；</p><p>Users.WebAPI是ASP.NET Web API项目，主要包含应用服务、Controller类、领域事件处理者、数据校验、权限校验、工作单元、事务处理等代码。</p><p>Users.Domain项目对应的是整洁架构中的领域模型和领域服务，Users.Infrastructure项目对应的是整洁架构中的基础设施、数据库、外部服务，Users.WebAPI项目对应的是整洁架构中的用户界面和应用服务。</p><p><img src="/img%5CDDD%5C22.png"></p><p>Users.Domain不依赖任何项目，Users.Infrastructure依赖于Users.Domain，而Users.WebAPI同时依赖于Users.Domain和Users.Infrastructure。因此Users.WebAPI既可以调用Users.Domain中的领域服务，也可以直接调用Users.Infrastucture。因此Users.WebAPI既可以调用Users.Domain中的领域服务，也可以直接调用Users.Infrastructure中上下文的代码，而Users.Domain则不可以直接调用Users.Infrastructure中上下文的代码，而Users.Domain则不可以直接访问Users.Infrastructure，但是Users.Domain可以通过访问IUsersDomainRepository接口来间接调用Users.Infrastructure中的服务。</p><h1 id="领域模型的实现"><a href="#领域模型的实现" class="headerlink" title="领域模型的实现"></a>领域模型的实现</h1><p>我们将实现实体类、值对象等基础的领域模型，并且识别和定义出聚合及聚合根，这是DDD的战术起点。这些代码都位于Users.Domain项目中。</p><p>作为一个用户管理系统，“用户（User）”是我们识别出的第一个实体类；“用户登录失败次数过多则锁定”这个需求并不属于“用户”这个实体类中的一个常用的特征，我们应当把它拆分到一个单独的实体类中，因此我们识别出一个单独的“用户登录失败”（UserAccessFail）实体类：“用户登陆记录”（UserLoginHistory）也应该识别为一个单独的实体类。User和UserAccessFail的关系是非常紧密的，UserAccessFail，因此该User和UserAccessFail不会独立于User存在，而且我们只有访问到User的时候才会访问UserAccessFail，因此该User和UserAccessFail设计为同一个聚合，并且把User设置为聚合根；由于我没有可能单独查询一段时间内的登录记录等独立与某个用户的需求，因此我们把UserLoginHistory设计为一个单独的聚合。</p><h2 id="PhoneNumber"><a href="#PhoneNumber" class="headerlink" title="PhoneNumber"></a>PhoneNumber</h2><p>我们的系统中需要保存手机号，由于该系统可能被海外用户访问，而海外用户的手机号还需要包含“国家&#x2F;地区码”，因此我们设计了用来表示手机号的值对象PhoneNumber。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//海外手机号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">PhoneNumber</span>(<span class="params"><span class="built_in">int</span> RegionCode, <span class="built_in">int</span> Number</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Zack.Commons</p><p>为了区别聚合根实体类和普通实体类，我们定义了不包含任何成员的标识接口IAggregateRoot，并且让所有的聚合根实体类实现这个接口。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAggregateRoot</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写UserAccessFail类"><a href="#编写UserAccessFail类" class="headerlink" title="编写UserAccessFail类"></a>编写UserAccessFail类</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Users.Domain.Entities</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用户访问失败记录类，用于管理用户登录失败次数和锁定状态</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">UserAccessFail</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 主键Id</span></span><br><span class="line">        <span class="keyword">public</span> Guid Id &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="comment">// 关联的用户Id</span></span><br><span class="line">        <span class="keyword">public</span> Guid UserId &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="comment">// 关联的用户对象</span></span><br><span class="line">        <span class="keyword">public</span> User User &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="comment">// 是否被锁定</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> lockOut;</span><br><span class="line">        <span class="comment">// 锁定结束时间</span></span><br><span class="line">        <span class="keyword">public</span> DateTime? LockoutEnd &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="comment">// 连续失败次数</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> AccessFailCount &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 私有构造函数，防止外部直接创建</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">UserAccessFail</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过用户对象创建访问失败记录</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserAccessFail</span>(<span class="params">User user</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Id = Guid.NewGuid();</span><br><span class="line">            UserId = user.Id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置失败次数和锁定状态</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            lockOut = <span class="literal">false</span>;</span><br><span class="line">            LockoutEnd = <span class="literal">null</span>;</span><br><span class="line">            AccessFailCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前是否处于锁定状态</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsLockOut</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (lockOut)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果锁定还未到期，返回true</span></span><br><span class="line">                <span class="keyword">if</span> (LockoutEnd &gt;= DateTime.Now)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 锁定已过期，重置状态</span></span><br><span class="line">                    AccessFailCount = <span class="number">0</span>;</span><br><span class="line">                    LockoutEnd = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 登录失败时调用，增加失败次数，超过5次则锁定5分钟</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fail</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            AccessFailCount++;</span><br><span class="line">            <span class="keyword">if</span> (AccessFailCount &gt;= <span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lockOut = <span class="literal">true</span>;</span><br><span class="line">                LockoutEnd = DateTime.Now.AddMinutes(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserAccessFail类同样是充血模型，当用户登陆失败一次时，我们就调用Fail方法来记录因此登录失败，如果发现登陆失败超过3次，我们就锁定这个用户5min；我们通过IsLockOut方法判断这个账户是否已经被锁定；一旦登陆成功一次，我们就调用Reset方法来重置登录失败信息。由于实体类中进行的都是抽象操作，并不会直接进行数据库操作，因此我们编写的实体类中的Fail、Reset等方法都只是修改实体类的属性，并没有写入数据库的操作。</p><h2 id="User"><a href="#User" class="headerlink" title="User"></a>User</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User聚合根，表示系统中的用户实体</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">User</span> : <span class="title">IAggregateRoot</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用户唯一标识</span></span><br><span class="line">    <span class="keyword">public</span> Guid Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户手机号（值对象），只允许内部修改</span></span><br><span class="line">    <span class="keyword">public</span> PhoneNumber PhoneNumber &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户密码的哈希值，私有字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>? passwordHash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户访问失败信息（如登录失败次数、锁定状态等）</span></span><br><span class="line">    <span class="keyword">public</span> UserAccessFail AccessFail &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造函数，供ORM或序列化使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过手机号创建用户，同时初始化访问失败信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span>(<span class="params">PhoneNumber phoneNumber</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Id = Guid.NewGuid();</span><br><span class="line">        PhoneNumber = phoneNumber;</span><br><span class="line">        AccessFail = <span class="keyword">new</span> UserAccessFail(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断用户是否设置了密码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">HasPassword</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">string</span>.IsNullOrEmpty(passwordHash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改用户密码，密码长度必须大于3位，内部存储为MD5哈希</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangePassword</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span>.Length &lt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;密码长度不能小于等于3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        passwordHash = HashHelper.ComputeMd5Hash(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查输入的密码是否正确（与存储的哈希值比对）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CheckPassword</span>(<span class="params"><span class="built_in">string</span> password</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> passwordHash == HashHelper.ComputeMd5Hash(password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改用户手机号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangePhoneNumber</span>(<span class="params">PhoneNumber phoneNumber</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PhoneNumber = phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，作为聚合根，User类实现了IAggregateRoot接口，而且它是一个充血模型。密码的哈希值不应该被外界访问到，因此passwordHash被定义为私有的成员变量。由于用户可以不设置密码，而使用手机号加短信验证码登录，因此passwordHash被定义为可空的string类型，并且提供了HasPassword方法用于判断用户是否设置了密码。ChangePassword、CheckPassword两个方法分别用于修改密码和检查用户输入的密码是否正确，由于“密码采用哈希值保存”属于User类的内部实现细节，因此计算明文密码的哈希值的操作在ChangePassword、CheckPasswrod两个方法中完成。</p><h2 id="UserAccessFail"><a href="#UserAccessFail" class="headerlink" title="UserAccessFail"></a>UserAccessFail</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 用户登录历史记录实体，表示用户每次登录的相关信息。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">UserLoginHistory</span> : <span class="title">IAggregateRoot</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 主键，自增ID。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用户ID，可能为null（如未注册用户）。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> Guid? UserId &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用户登录时使用的手机号。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> PhoneNumber PhoneNumber &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 登录时间。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> DateTime LoginTime &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 登录相关消息或描述。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Messsage &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> ORM或序列化使用的无参构造函数。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UserLoginHistory</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ORM或序列化使用的无参构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 创建用户登录历史记录的新实例。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;userId&quot;&gt;</span>用户ID<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span>手机号<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;loginTime&quot;&gt;</span>登录时间<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;message&quot;&gt;</span>登录消息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserLoginHistory</span>(<span class="params">Guid? userId, PhoneNumber phoneNumber, DateTime loginTime, <span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        UserId = userId;</span><br><span class="line">        PhoneNumber = phoneNumber;</span><br><span class="line">        LoginTime = loginTime;</span><br><span class="line">        Messsage = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户输入一个系统中不存在的手机号，我们也要把他记录到日志中，因此UserId属性为可空的Guid类型。由于UserLoginHistory类是独立的聚合，而在DDD中，聚合之间只通过聚合根实体类的标识来引用，因此UserLoginHistory类中只定义UserId属性，而不是定义User属性，这样我们就把聚合之间的耦合度降低了。从逻辑上来讲，UserLoginHistory类的UserId属性是一个指向User实体类的外键，但是在物理上，我们并没有创建它们的外键关系，这不符合经典的数据库范式理论，但是这样做有利于分库分表、数据库迁移并且性能更好，因此这种不键物理外键的做法越来越常见。</p><h1 id="领域服务的实现"><a href="#领域服务的实现" class="headerlink" title="领域服务的实现"></a>领域服务的实现</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 表示用户访问结果的枚举。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> UserAccessResult</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 访问成功。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    OK,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 未找到手机号。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    PhoneNumberNotFound,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用户被锁定。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Lockout,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 未设置密码。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    NoPassword,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 密码错误。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    PasswordError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 用户访问结果事件。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 用于在用户访问（如登录、注册等）后，发布访问结果信息。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;PhoneNumber&quot;&gt;</span>用户手机号。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;Result&quot;&gt;</span>访问结果。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="keyword">class</span> <span class="title">UserAccessResultEvent</span>(<span class="params">PhoneNumber PhoneNumber, UserAccessResult Result</span>) : INotification</span>;</span><br></pre></td></tr></table></figure><h2 id="IUserDomainRepository"><a href="#IUserDomainRepository" class="headerlink" title="IUserDomainRepository"></a>IUserDomainRepository</h2><p>领域服务需要使用仓储接口来通过持久层读写数据，因此我们需要在Users.Domain项目中编写仓储接口IUserDomainRepository，这些代码都位于Users.Domain项目中。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Users.Domain</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用户领域仓储接口，定义用户相关的数据访问操作。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUserDomainRepository</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 根据手机号查找用户。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span>用户手机号。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>找到的用户对象，找不到返回null。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        Task&lt;User?&gt; FindOneAsync(PhoneNumber phoneNumber);</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 根据用户唯一标识查找用户。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;userId&quot;&gt;</span>用户唯一标识（Guid）。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>找到的用户对象，找不到返回null。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        Task&lt;User?&gt; FindOneAsync(Guid userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 新增一条用户登录历史记录。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span>用户手机号。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;msg&quot;&gt;</span>登录相关信息（如登录结果、时间等）。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function">Task <span class="title">AddNewLoginHistoryAsync</span>(<span class="params">PhoneNumber phoneNumber, <span class="built_in">string</span> msg</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 发布用户访问结果领域事件（如登录成功、失败等），用于领域事件通知。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventData&quot;&gt;</span>用户访问结果事件数据。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function">Task <span class="title">PublishEventAsync</span>(<span class="params">UserAccessResultEvent eventData</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 保存手机验证码（如短信验证码），用于后续校验。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span>用户手机号。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;code&quot;&gt;</span>验证码内容。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function">Task <span class="title">SavePhoneCodeAsync</span>(<span class="params">PhoneNumber phoneNumber, <span class="built_in">string</span> code</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取指定手机号最近保存的验证码。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span>用户手机号。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>验证码内容。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function">Task&lt;<span class="built_in">string</span>&gt; <span class="title">RetrievePhoneCodeAsync</span>(<span class="params">PhoneNumber phoneNumber</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个FindOneAsync方法分别用于根据手机号和用户ID查找用户；AddNewLoginHistoryAsync方法用于记录一次登录操作；PublishEventAsync方法用于发布领域事件；SavePhoneCodeAsync方法用于保存短信验证码，而RetrievePhoneCodeAsync方法用于获取保存的短信验证码。</p><h2 id="ISmsCodeSender"><a href="#ISmsCodeSender" class="headerlink" title="ISmsCodeSender"></a>ISmsCodeSender</h2><p>ISmsCodeSender是用于发送短信验证码的防腐层接口。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 定义用于发送短信验证码的接口。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISmsCodeSender</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 异步发送短信验证码到指定手机号。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span>接收验证码的手机号。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;code&quot;&gt;</span>要发送的验证码内容。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>表示异步操作的任务。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function">Task <span class="title">SendCodeAsync</span>(<span class="params">PhoneNumber phoneNumber, <span class="built_in">string</span> code</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 表示校验验证码的结果。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> CheckCodeResult</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 校验成功。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    OK,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 未找到对应的手机号。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    PhoneNumberNotFound,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用户已被锁定。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Lockout,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 验证码错误。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    CodeError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UserDomainService"><a href="#UserDomainService" class="headerlink" title="UserDomainService"></a>UserDomainService</h2><p>实体类中定义的方法只是和特定实体类相关的业务逻辑代码，而跨实体类、跨聚合的代码需要定义在领域服务或者应用服务中。因此我们编写领域服务UserDomainService。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Users.Domain</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用户领域服务，封装用户相关的业务逻辑，如登录、验证码发送与校验、访问失败处理等。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserDomainService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用户仓储接口，用于数据持久化和查询</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IUserDomainRepository repository;</span><br><span class="line">        <span class="comment">// 短信验证码发送器接口</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ISmsCodeSender smsSender;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 构造函数，注入仓储和短信发送器</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserDomainService</span>(<span class="params">IUserDomainRepository repository, ISmsCodeSender smsSender</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.repository = repository;</span><br><span class="line">            <span class="keyword">this</span>.smsSender = smsSender;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 重置用户的访问失败次数和锁定状态</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResetAccessFail</span>(<span class="params">User user</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            user.AccessFail.Reset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 判断用户是否被锁定</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsLockOut</span>(<span class="params">User user</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> user.AccessFail.IsLockOut();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 记录一次用户访问失败（如登录失败），并根据失败次数自动锁定</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AccessFail</span>(<span class="params">User user</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            user.AccessFail.Fail();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 检查用户登录，返回登录结果（如成功、密码错误、被锁定等）</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNum&quot;&gt;</span>用户手机号<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;password&quot;&gt;</span>用户输入的密码<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>登录结果枚举<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;UserAccessResult&gt; <span class="title">CheckLoginAsync</span>(<span class="params">PhoneNumber phoneNum, <span class="built_in">string</span> password</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 根据手机号查找用户</span></span><br><span class="line">            User? user = <span class="keyword">await</span> repository.FindOneAsync(phoneNum);</span><br><span class="line">            UserAccessResult result;</span><br><span class="line">            <span class="keyword">if</span> (user == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 用户不存在</span></span><br><span class="line">                result = UserAccessResult.PhoneNumberNotFound;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (IsLockOut(user))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 用户被锁定</span></span><br><span class="line">                result = UserAccessResult.Lockout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (user.HasPassword() == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 用户未设置密码</span></span><br><span class="line">                result = UserAccessResult.NoPassword;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (user.CheckPassword(password))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 密码正确</span></span><br><span class="line">                result = UserAccessResult.OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 密码错误</span></span><br><span class="line">                result = UserAccessResult.PasswordError;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (user != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == UserAccessResult.OK)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 登录成功，重置失败次数</span></span><br><span class="line">                    ResetAccessFail(user);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 登录失败，记录失败</span></span><br><span class="line">                    AccessFail(user);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发布登录结果事件</span></span><br><span class="line">            UserAccessResultEvent eventItem = <span class="keyword">new</span>(phoneNum, result);</span><br><span class="line">            <span class="keyword">await</span> repository.PublishEventAsync(eventItem);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 发送短信验证码到指定手机号</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNum&quot;&gt;</span>用户手机号<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>发送结果<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;UserAccessResult&gt; <span class="title">SendCodeAsync</span>(<span class="params">PhoneNumber phoneNum</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> user = <span class="keyword">await</span> repository.FindOneAsync(phoneNum);</span><br><span class="line">            <span class="keyword">if</span> (user == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 用户不存在</span></span><br><span class="line">                <span class="keyword">return</span> UserAccessResult.PhoneNumberNotFound;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (IsLockOut(user))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 用户被锁定</span></span><br><span class="line">                <span class="keyword">return</span> UserAccessResult.Lockout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 生成4位随机验证码</span></span><br><span class="line">            <span class="built_in">string</span> code = Random.Shared.Next(<span class="number">1000</span>, <span class="number">9999</span>).ToString();</span><br><span class="line">            <span class="comment">// 保存验证码到仓储</span></span><br><span class="line">            <span class="keyword">await</span> repository.SavePhoneCodeAsync(phoneNum, code);</span><br><span class="line">            <span class="comment">// 发送验证码短信</span></span><br><span class="line">            <span class="keyword">await</span> smsSender.SendCodeAsync(phoneNum, code);</span><br><span class="line">            <span class="keyword">return</span> UserAccessResult.OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 校验用户输入的短信验证码是否正确</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNum&quot;&gt;</span>用户手机号<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;code&quot;&gt;</span>用户输入的验证码<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>校验结果<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;CheckCodeResult&gt; <span class="title">CheckCodeAsync</span>(<span class="params">PhoneNumber phoneNum, <span class="built_in">string</span> code</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> user = <span class="keyword">await</span> repository.FindOneAsync(phoneNum);</span><br><span class="line">            <span class="keyword">if</span> (user == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 用户不存在</span></span><br><span class="line">                <span class="keyword">return</span> CheckCodeResult.PhoneNumberNotFound;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (IsLockOut(user))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 用户被锁定</span></span><br><span class="line">                <span class="keyword">return</span> CheckCodeResult.Lockout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取服务器端保存的验证码</span></span><br><span class="line">            <span class="built_in">string</span>? codeInServer = <span class="keyword">await</span> repository.RetrievePhoneCodeAsync(phoneNum);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(codeInServer))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 没有验证码或已过期</span></span><br><span class="line">                <span class="keyword">return</span> CheckCodeResult.CodeError;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (code == codeInServer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 验证码正确</span></span><br><span class="line">                <span class="keyword">return</span> CheckCodeResult.OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 验证码错误，记录一次失败</span></span><br><span class="line">                AccessFail(user);</span><br><span class="line">                <span class="keyword">return</span> CheckCodeResult.CodeError;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在实现领域服务的时候，我们需要调用仓储服务和短信发送服务，所以我们通过构造方法注入IUserDomainRepository和ISmsCodeSender,我们再调用这两个服务的方法的时候，并不需要关心它们是由哪个类实现的，以及是如何实现的，这就是“依赖于接口，而非依赖于现实”的依赖反转带来给系统架构的好处。</p><p>由于User是聚合根，所以对UserAccessFail的操作都通过User进行，因此我们在UserDomainService中定义的AccessFail等方法都是通过User进行的。<br>User等实体类中都是和实体类相关的代码，而UserDomainService领域服务中都是跨实体类操作的代码。</p><h1 id="基础设施的实现"><a href="#基础设施的实现" class="headerlink" title="基础设施的实现"></a>基础设施的实现</h1><p>领域模型、领域服务中只定义了抽象的实体类、防腐层和仓储，我们需要在基础设施中对它们进行落地和实现。这些代码都位于Users.Infrastructure项目中。</p><h2 id="UserConfig-UserAccessFailConfig-UserLoginHistoryConfig"><a href="#UserConfig-UserAccessFailConfig-UserLoginHistoryConfig" class="headerlink" title="UserConfig\UserAccessFailConfig\UserLoginHistoryConfig"></a>UserConfig\UserAccessFailConfig\UserLoginHistoryConfig</h2><p>实体类、值对象的定义是和持久机制无关的，它们需要通过EF Core的配置、上下文等建立和数据库的关系，User的配置。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Users.Infrastructure.Configs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用户实体的EF Core配置类，定义表结构及相关映射规则</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">UserConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">User</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 配置User实体的数据库映射</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;builder&quot;&gt;</span>实体类型构建器<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;User&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 映射到表T_Users</span></span><br><span class="line">            builder.ToTable(<span class="string">&quot;T_Users&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配置PhoneNumber值对象的属性映射</span></span><br><span class="line">            builder.OwnsOne(x =&gt; x.PhoneNumber, nb =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 区号最大长度5，非Unicode</span></span><br><span class="line">                nb.Property(x =&gt; x.RegionCode).HasMaxLength(<span class="number">5</span>).IsUnicode(<span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 手机号最大长度20，非Unicode</span></span><br><span class="line">                nb.Property(x =&gt; x.Number).HasMaxLength(<span class="number">20</span>).IsUnicode(<span class="literal">false</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配置私有字段passwordHash的映射，最大长度100，非Unicode</span></span><br><span class="line">            builder.Property(<span class="string">&quot;passwordHash&quot;</span>).HasMaxLength(<span class="number">100</span>).IsUnicode(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配置一对一关系：User有一个AccessFail，UserAccessFail有一个User</span></span><br><span class="line">            builder.HasOne(x =&gt; x.AccessFail).WithOne(x =&gt; x.User)</span><br><span class="line">               <span class="comment">// 配置UserAccessFail的外键，指定UserId为外键字段</span></span><br><span class="line">               .HasForeignKey&lt;UserAccessFail&gt;(x =&gt; x.UserId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对值对象PhoneNumber进行了配置；由于passwordHash是一个私有成员变量，因此我们对他进行特殊的配置。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Users.Infrastructure.Configs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">UserAccessFailConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">UserAccessFail</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">Microsoft.EntityFrameworkCore.Metadata.Builders.EntityTypeBuilder&lt;UserAccessFail&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            builder.ToTable(<span class="string">&quot;T_UserAccessFails&quot;</span>);</span><br><span class="line">            builder.Property(<span class="string">&quot;lockOut&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Users.Infrastructure.Configs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">UserLoginHistoryConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">UserLoginHistory</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;UserLoginHistory&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            builder.ToTable(<span class="string">&quot;T_UserLoginHistories&quot;</span>);</span><br><span class="line">            builder.OwnsOne(x=&gt;x.PhoneNumber, nb =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 区号最大长度5，非Unicode</span></span><br><span class="line">                nb.Property(x =&gt; x.RegionCode).HasMaxLength(<span class="number">5</span>).IsUnicode(<span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 手机号最大长度20，非Unicode</span></span><br><span class="line">                nb.Property(x =&gt; x.Number).HasMaxLength(<span class="number">20</span>).IsUnicode(<span class="literal">false</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UserDbContext"><a href="#UserDbContext" class="headerlink" title="UserDbContext"></a>UserDbContext</h2><p>UserDbContext定义在Users.Infrastructure项目中，并且只为User、UserLoginHistory两个聚合根实体类声明DbSet属性，而不为User聚合中的UserAccessFail实体类定义DbSet属性，这样就约束开发人员尽量通过聚合根来操作聚合内的实体类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Users.Infrastructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// UserDbContext 是用户模块的数据库上下文，负责与数据库进行交互</span></span><br><span class="line">    <span class="comment">// 继承自 Entity Framework Core 的 DbContext</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">UserDbContext</span> : <span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Users 表示用户实体集合，对应数据库中的用户表</span></span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;User&gt; Users &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="comment">// LoginHistories 表示用户登录历史记录集合，对应数据库中的登录历史表</span></span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;UserLoginHistory&gt; LoginHistories &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数，接收数据库上下文配置参数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserDbContext</span>(<span class="params">DbContextOptions&lt;UserDbContext&gt; options</span>) : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置实体模型的映射关系</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 调用基类方法，保证基础配置被应用</span></span><br><span class="line">            <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">            <span class="comment">// 自动应用当前程序集中的所有实体配置（IEntityTypeConfiguration实现类）</span></span><br><span class="line">            modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">this</span>.GetType().Assembly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UserDomainRepository-ExpressionHelper"><a href="#UserDomainRepository-ExpressionHelper" class="headerlink" title="UserDomainRepository&#x2F;ExpressionHelper"></a>UserDomainRepository&#x2F;ExpressionHelper</h2><p>仓储接口IUserDomainRepository的实体类UserDomainRepository</p><p>我们把创建的UserLoginHistory对象添加到上下文中以后，并没有立即把数据保存到数据库中，因为到底什么时候保存工作单元中的修改是由应用服务层来决定的，仓储和领域层中都不能执行SaveChangesAsync操作。<br>文买把短信验证码保存在分布式缓存中，当然我们可以把短信验证码保存到数据库、Redis等地方。验证码保存到什么地方是由UserDomainRepository类来决定的，IUserDomainRepository服务的使用者并不需要知道这些细节。这就是整洁架构的内层定义和使用接口，以及外层实现接口所带来的好处。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Users.Infrastructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用户领域仓储实现类，负责用户相关的数据访问和操作。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserDomainRepository</span> : <span class="title">IUserDomainRepository</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用户数据库上下文，用于操作数据库</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> UserDbContext dbCtx;</span><br><span class="line">        <span class="comment">// 分布式缓存，用于存储验证码等临时数据</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IDistributedCache distCache;</span><br><span class="line">        <span class="comment">// MediatR中介者，用于发布领域事件</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IMediator mediator;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 构造函数，注入数据库上下文、分布式缓存和中介者。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserDomainRepository</span>(<span class="params">UserDbContext dbCtx, IDistributedCache distCache, IMediator mediator</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.dbCtx = dbCtx;</span><br><span class="line">            <span class="keyword">this</span>.distCache = distCache;</span><br><span class="line">            <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 新增一条用户登录历史记录。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span>用户手机号<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;msg&quot;&gt;</span>登录相关信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">AddNewLoginHistoryAsync</span>(<span class="params">PhoneNumber phoneNumber, <span class="built_in">string</span> msg</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 先查找用户</span></span><br><span class="line">            <span class="keyword">var</span> user = <span class="keyword">await</span> FindOneAsync(phoneNumber);</span><br><span class="line">            <span class="comment">// 创建登录历史记录（用户ID可能为null）</span></span><br><span class="line">            UserLoginHistory history = <span class="keyword">new</span> UserLoginHistory(user?.Id, phoneNumber, msg);</span><br><span class="line">            <span class="comment">// 添加到数据库上下文</span></span><br><span class="line">            dbCtx.LoginHistories.Add(history);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 根据手机号查找用户。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span>用户手机号<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>找到的用户对象，找不到返回null<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> Task&lt;User?&gt; FindOneAsync(PhoneNumber phoneNumber)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 包含访问失败信息，一起查出来</span></span><br><span class="line">            <span class="keyword">return</span> dbCtx.Users.Include(u =&gt; u.AccessFail).SingleOrDefaultAsync(MakeEqual((User u) =&gt; u.PhoneNumber, phoneNumber));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 根据用户ID查找用户。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;userId&quot;&gt;</span>用户唯一标识<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>找到的用户对象，找不到返回null<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> Task&lt;User?&gt; FindOneAsync(Guid userId)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 包含访问失败信息，一起查出来</span></span><br><span class="line">            <span class="keyword">return</span> dbCtx.Users.Include(u =&gt; u.AccessFail)</span><br><span class="line">                .SingleOrDefaultAsync(u =&gt; u.Id == userId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 发布用户访问结果领域事件（如登录成功、失败等）。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventData&quot;&gt;</span>事件数据<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task <span class="title">PublishEventAsync</span>(<span class="params">UserAccessResultEvent eventData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 通过MediatR发布事件</span></span><br><span class="line">            <span class="keyword">return</span> mediator.Publish(eventData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取指定手机号最近保存的验证码，并从缓存中移除。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span>用户手机号<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>验证码内容<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">RetrievePhoneCodeAsync</span>(<span class="params">PhoneNumber phoneNumber</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 拼接完整手机号作为缓存Key</span></span><br><span class="line">            <span class="built_in">string</span> fullNumber = phoneNumber.RegionCode + phoneNumber.Number;</span><br><span class="line">            <span class="built_in">string</span> cacheKey = <span class="string">$&quot;LoginByPhoneCode_Code_<span class="subst">&#123;fullNumber&#125;</span>&quot;</span>;</span><br><span class="line">            <span class="comment">// 从缓存获取验证码</span></span><br><span class="line">            <span class="built_in">string</span>? code = distCache.GetString(cacheKey);</span><br><span class="line">            <span class="comment">// 获取后立即移除，防止重复使用</span></span><br><span class="line">            distCache.Remove(cacheKey);</span><br><span class="line">            <span class="keyword">return</span> Task.FromResult(code);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 保存手机验证码到分布式缓存，有效期5分钟。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span>用户手机号<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;code&quot;&gt;</span>验证码内容<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task <span class="title">SavePhoneCodeAsync</span>(<span class="params">PhoneNumber phoneNumber, <span class="built_in">string</span> code</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 拼接完整手机号作为缓存Key</span></span><br><span class="line">            <span class="built_in">string</span> fullNumber = phoneNumber.RegionCode + phoneNumber.Number;</span><br><span class="line">            <span class="comment">// 创建分布式缓存项配置对象，用于设置缓存项的过期策略</span></span><br><span class="line">            <span class="keyword">var</span> options = <span class="keyword">new</span> DistributedCacheEntryOptions();</span><br><span class="line">            <span class="comment">// 设置5分钟过期</span></span><br><span class="line">            options.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(<span class="number">300</span>);</span><br><span class="line">            <span class="comment">// 保存到缓存</span></span><br><span class="line">            distCache.SetString(<span class="string">$&quot;LoginByPhoneCode_Code_<span class="subst">&#123;fullNumber&#125;</span>&quot;</span>, code, options);</span><br><span class="line">            <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装MakeEqual方法进行手机号的相等性比较。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Users.Infrastructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExpressionHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 构建一个用于比较对象属性是否相等的表达式。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 例如：可用于LINQ查询中，判断TItem类型对象的某个属性（TProp类型）是否与other对象的每个属性值都相等。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;TItem&quot;&gt;</span>要比较的对象类型<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;TProp&quot;&gt;</span>要比较的属性类型（必须是引用类型）<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;propAccessor&quot;&gt;</span>属性访问表达式，如 x =&gt; x.SomeProp<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;other&quot;&gt;</span>用于比较的属性对象<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>一个表达式，表示TItem对象的指定属性与other对象的所有属性值都相等<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Expression</span>&lt;<span class="title">Func</span>&lt;<span class="title">TItem</span>, <span class="title">bool</span>&gt;&gt; <span class="title">MakeEqual</span>&lt;<span class="title">TItem</span>, <span class="title">TProp</span>&gt;(<span class="params">Expression&lt;Func&lt;TItem, TProp&gt;&gt; propAccessor, TProp? other</span>)</span></span><br><span class="line"><span class="function">            <span class="keyword">where</span> TItem : <span class="keyword">class</span></span></span><br><span class="line"><span class="function">            <span class="keyword">where</span> TProp : <span class="keyword">class</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取表达式参数（如 x =&gt; ... 中的 x）</span></span><br><span class="line">            <span class="keyword">var</span> e1 = propAccessor.Parameters.Single();</span><br><span class="line">            BinaryExpression? conditionalExpr = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 遍历TProp类型的所有属性</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> prop <span class="keyword">in</span> <span class="title">typeof</span>(<span class="params">TProp</span>).<span class="title">GetProperties</span>())</span></span><br><span class="line">            &#123;</span><br><span class="line">                BinaryExpression equalExpr;</span><br><span class="line">                <span class="built_in">object</span>? otherValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 获取other对象对应属性的值</span></span><br><span class="line">                <span class="keyword">if</span> (other != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    otherValue = prop.GetValue(other);</span><br><span class="line">                &#125;</span><br><span class="line">                Type propType = prop.PropertyType;</span><br><span class="line">                <span class="comment">// 构建左侧表达式（如 x.SomeProp.属性）</span></span><br><span class="line">                <span class="keyword">var</span> leftExpr = MakeMemberAccess(</span><br><span class="line">                    propAccessor.Body,</span><br><span class="line">                    prop</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 构建右侧表达式（other对象的属性值）</span></span><br><span class="line">                Expression rightExpr = Convert(Constant(otherValue), propType);</span><br><span class="line">                <span class="comment">// 如果属性是值类型（如int、bool），用Equal比较</span></span><br><span class="line">                <span class="keyword">if</span> (propType.IsPrimitive)</span><br><span class="line">                &#123;</span><br><span class="line">                    equalExpr = Expression.Equal(leftExpr, rightExpr);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 否则尝试用op_Equality方法比较（如string等）</span></span><br><span class="line">                    equalExpr = MakeBinary(ExpressionType.Equal,</span><br><span class="line">                        leftExpr, rightExpr, <span class="literal">false</span>,</span><br><span class="line">                        prop.PropertyType.GetMethod(<span class="string">&quot;op_Equality&quot;</span>)</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 多个属性用AndAlso连接（全部相等才为true）</span></span><br><span class="line">                <span class="keyword">if</span> (conditionalExpr == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    conditionalExpr = equalExpr;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    conditionalExpr = Expression.AndAlso(conditionalExpr, equalExpr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有属性，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (conditionalExpr == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;propAccessor must have at least one property&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回最终的lambda表达式</span></span><br><span class="line">            <span class="keyword">return</span> Lambda&lt;Func&lt;TItem, <span class="built_in">bool</span>&gt;&gt;(</span><br><span class="line">                conditionalExpr, e1</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MockSmsCodeSender"><a href="#MockSmsCodeSender" class="headerlink" title="MockSmsCodeSender"></a>MockSmsCodeSender</h2><p>模拟短信验证码发送器</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Users.Infrastructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 模拟短信验证码发送器，实现 <span class="doctag">&lt;see cref=&quot;ISmsCodeSender&quot;/&gt;</span> 接口，仅用于测试或开发环境。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MockSmsCodeSender</span> : <span class="title">ISmsCodeSender</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;MockSmsCodeSender&gt; logger;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 构造函数，注入日志记录器。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;logger&quot;&gt;</span>日志记录器实例。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MockSmsCodeSender</span>(<span class="params">ILogger&lt;MockSmsCodeSender&gt; logger</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger = logger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 模拟异步发送短信验证码，将验证码信息写入日志。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span>接收验证码的手机号。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;code&quot;&gt;</span>要发送的验证码内容。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>表示异步操作的任务。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task <span class="title">SendCodeAsync</span>(<span class="params">PhoneNumber phoneNumber, <span class="built_in">string</span> code</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            logger.LogInformation(<span class="string">$&quot;向<span class="subst">&#123;phoneNumber&#125;</span>发送验证码：<span class="subst">&#123;code&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工作单元的实现"><a href="#工作单元的实现" class="headerlink" title="工作单元的实现"></a>工作单元的实现</h1><p>工作单元由应用服务层来确定，其他层不应该调用SaveChangesAsync方法保存对数据的修改。我们把Web API的控制器当成应用服务，而且对于大部分应用场景来讲，一次对控制器中方法的调用就对应一个工作单元，因此我们可以开发一个在控制器的方法调用结束后自动调用SaveChangesAsync的机制。这样就能大大简化应用服务层代码的编写，从而避免对SaveChangesAsync方法的重复调用。当然，对于特殊的应用服务层代码，我们可能仍然需要手动决定调用SaveChangesAsync方法的时机。</p><h2 id="UnitOfWorkAttribute"><a href="#UnitOfWorkAttribute" class="headerlink" title="UnitOfWorkAttribute"></a>UnitOfWorkAttribute</h2><p>我们定义一个Attribute,将其添加到需要重启自动提交工作单元的操作方法上。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Users.WebAPI</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// UnitOfWorkAttribute 是一个自定义特性（Attribute），用于标记需要启用工作单元（Unit of Work）模式的类或方法。</span></span><br><span class="line">    <span class="comment">// 该特性可以应用于类或方法上，且不允许重复应用，支持继承。</span></span><br><span class="line">    [<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = false, Inherited = true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitOfWorkAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// DbContextTypes 用于指定需要参与工作单元的 DbContext 类型数组。</span></span><br><span class="line">        <span class="keyword">public</span> Type[] DbContextTypes &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数，接收一个或多个 DbContext 类型作为参数。</span></span><br><span class="line">        <span class="comment">// 会检查传入的类型是否都继承自 DbContext，如果不是则抛出异常。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnitOfWorkAttribute</span>(<span class="params"><span class="keyword">params</span> Type[] dbContextTypes</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.DbContextTypes = dbContextTypes;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> type <span class="keyword">in</span> dbContextTypes)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 判断类型是否继承自 DbContext，如果不是则抛出异常。</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">typeof</span>(DbContext).IsAssignableFrom(type))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">$&quot;<span class="subst">&#123;type&#125;</span> 必须继承自 DbContext&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个控制器上标注了UnitOfWorkAttibute，那么这个控制器中所有的方法都会在执行结束后自动提交工作单元，我们也可以把UnitOfWorkAttribute添加到控制器的方法上。因为一个微服务中可能有多个上下文，所以我们通过DbContextTypes来指定工作单元结束后程序自动调用哪些上下文的SaveChangesAsync方法，DbContextTypes属性用来指定上下文的类型。</p><h2 id="UnitOfWorkFillter"><a href="#UnitOfWorkFillter" class="headerlink" title="UnitOfWorkFillter"></a>UnitOfWorkFillter</h2><p>我们实现一个全局的ActionFillter，来实现在控制器的操作方法执行结束后自动提交工作单元的功能。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Users.WebAPI</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 单元工作过滤器，用于自动处理数据库事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitOfWorkFilter</span> : <span class="title">IAsyncActionFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取控制器或方法上的 UnitOfWorkAttribute 特性</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> UnitOfWorkAttribute? GetUoWAttr(ActionDescriptor actionDesc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 尝试将 ActionDescriptor 转换为 ControllerActionDescriptor</span></span><br><span class="line">            <span class="keyword">var</span> caDesc = actionDesc <span class="keyword">as</span> ControllerActionDescriptor;</span><br><span class="line">            <span class="keyword">if</span> (caDesc == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果转换失败，返回 null</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 先从控制器类型上获取 UnitOfWorkAttribute 特性</span></span><br><span class="line">            <span class="keyword">var</span> uowAttr = caDesc.ControllerTypeInfo.GetCustomAttribute&lt;UnitOfWorkAttribute&gt;();</span><br><span class="line">            <span class="keyword">if</span> (uowAttr != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果控制器上有特性，直接返回</span></span><br><span class="line">                <span class="keyword">return</span> uowAttr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 否则从方法上获取 UnitOfWorkAttribute 特性</span></span><br><span class="line">                <span class="keyword">return</span> caDesc.MethodInfo.GetCustomAttribute&lt;UnitOfWorkAttribute&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拦截 Action 执行，处理数据库上下文的保存</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取当前 Action 上的 UnitOfWorkAttribute 特性</span></span><br><span class="line">            <span class="keyword">var</span> uowAttr = GetUoWAttr(context.ActionDescriptor);</span><br><span class="line">            <span class="keyword">if</span> (uowAttr == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果没有特性，直接执行下一个中间件</span></span><br><span class="line">                <span class="keyword">await</span> next();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用于存放所有需要处理的 DbContext 实例</span></span><br><span class="line">            List&lt;DbContext&gt; dbCtxs = <span class="keyword">new</span> List&lt;DbContext&gt;();</span><br><span class="line">            <span class="comment">// 遍历特性中声明的所有 DbContext 类型</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> dbCtxType <span class="keyword">in</span> uowAttr.DbContextTypes)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 通过依赖注入容器获取 DbContext 实例</span></span><br><span class="line">                <span class="keyword">var</span> sp = context.HttpContext.RequestServices;</span><br><span class="line">                DbContext dbCtx = (DbContext)sp.GetRequiredService(dbCtxType);</span><br><span class="line">                <span class="comment">// 添加到列表中</span></span><br><span class="line">                dbCtxs.Add(dbCtx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行 Action 方法</span></span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">await</span> next();</span><br><span class="line">            <span class="comment">// 如果没有异常发生</span></span><br><span class="line">            <span class="keyword">if</span> (result.Exception == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 遍历所有 DbContext，保存更改</span></span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> dbCtx <span class="keyword">in</span> dbCtxs)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> dbCtx.SaveChangesAsync();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后只要把UnitOfWorkFilter注册为ASP.NET Core的全局筛选器，所有添加了[UnitOfWork]的控制器或者操作方法就都能自动进行工作单元的提交了。</p><h1 id="应用服务层的实现"><a href="#应用服务层的实现" class="headerlink" title="应用服务层的实现"></a>应用服务层的实现</h1><p>ASP.NET Core Web API中的控制器就是应用服务层，因此我们在ASP.NET Core的项目Users.WebAPI中编写的代码就是应用服务层代码。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Logging&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;LogLevel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Microsoft.AspNetCore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Warning&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;AllowedHosts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ConnectionStrings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Server=localhost;Database=YOUXIANYU;Trusted_Connection=True;MultipleActiveResultSets=true;TrustServerCertificate=True;Encrypt=True;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在Users.WebAPI的Program.cs中，除了要进行上下文、UnitOfWorkFilter全局筛选器的注册、分布式缓存配置、MediatR配置等之外，我们还需要注册各层所需要的服务。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"><span class="keyword">using</span> Users.Domain;</span><br><span class="line"><span class="keyword">using</span> Users.Infrastructure;</span><br><span class="line"><span class="keyword">using</span> Users.WebAPI;</span><br><span class="line"><span class="keyword">using</span> MediatR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add services to the container.</span></span><br><span class="line"></span><br><span class="line">builder.Services.AddControllers();</span><br><span class="line"><span class="comment">// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle</span></span><br><span class="line">builder.Services.AddEndpointsApiExplorer();</span><br><span class="line">builder.Services.AddSwaggerGen();</span><br><span class="line"><span class="comment">// 配置数据库上下文，使用SQL Server数据库，连接字符串从配置文件读取</span></span><br><span class="line">builder.Services.AddDbContext&lt;UserDbContext&gt;(b =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> connStr = builder.Configuration.GetConnectionString(<span class="string">&quot;Default&quot;</span>);</span><br><span class="line">    b.UseSqlServer(connStr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 配置Redis缓存，设置Redis服务器地址和实例名称</span></span><br><span class="line">builder.Services.AddStackExchangeRedisCache(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Configuration = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    options.InstanceName = <span class="string">&quot;UsersCache&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 配置MVC选项，添加工作单元过滤器（UnitOfWorkFilter）用于自动管理事务</span></span><br><span class="line">builder.Services.Configure&lt;MvcOptions&gt;(opt =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    opt.Filters.Add&lt;UnitOfWorkFilter&gt;();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 注册领域服务UserDomainService为依赖注入服务</span></span><br><span class="line">builder.Services.AddScoped&lt;UserDomainService&gt;();</span><br><span class="line"><span class="comment">// 注册短信验证码发送服务接口和实现（MockSmsCodeSender为模拟实现）</span></span><br><span class="line">builder.Services.AddScoped&lt;ISmsCodeSender, MockSmsCodeSender&gt;();</span><br><span class="line"><span class="comment">// 注册用户领域仓储接口和实现</span></span><br><span class="line">builder.Services.AddScoped&lt;IUserDomainRepository, UserDomainRepository&gt;();</span><br><span class="line"><span class="comment">// 注册MediatR库，用于实现领域事件和命令的中介者模式</span></span><br><span class="line">builder.Services.AddMediatR(cfg =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    cfg.RegisterServicesFromAssembly(<span class="keyword">typeof</span>(Program).Assembly);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the HTTP request pipeline.</span></span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.UseSwagger();</span><br><span class="line">    app.UseSwaggerUI();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.UseHttpsRedirection();</span><br><span class="line"></span><br><span class="line">app.UseAuthorization();</span><br><span class="line"></span><br><span class="line">app.MapControllers();</span><br><span class="line"></span><br><span class="line">app.Run();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="UserAccessResultEventHandler"><a href="#UserAccessResultEventHandler" class="headerlink" title="UserAccessResultEventHandler"></a>UserAccessResultEventHandler</h2><p>我们编写代码来响应代码UserAccessResultEvent事件，然后向数据库中插入登录记录。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Users.WebAPI.Events</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用户访问结果事件处理器，实现INotificationHandler接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserAccessResultEventHandler</span> : <span class="title">INotificationHandler</span>&lt;<span class="title">UserAccessResultEvent</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用户领域仓储，用于数据访问</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IUserDomainRepository repository;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数，注入用户领域仓储</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserAccessResultEventHandler</span>(<span class="params">IUserDomainRepository repository</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.repository = repository; <span class="comment">// 保存仓储引用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理用户访问结果事件的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task <span class="title">Handle</span>(<span class="params">UserAccessResultEvent notification, CancellationToken cancellationToken</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = notification.Result; <span class="comment">// 获取访问结果枚举</span></span><br><span class="line">            <span class="keyword">var</span> phoneNum = notification.PhoneNumber; <span class="comment">// 获取用户手机号</span></span><br><span class="line">            <span class="built_in">string</span> msg; <span class="comment">// 定义登录历史信息字符串</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据访问结果类型生成不同的登录历史信息</span></span><br><span class="line">            <span class="keyword">switch</span> (result)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.OK:</span><br><span class="line">                    msg = <span class="string">$&quot;<span class="subst">&#123;phoneNum&#125;</span>登录成功&quot;</span>; <span class="comment">// 登录成功</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.PhoneNumberNotFound:</span><br><span class="line">                    msg = <span class="string">$&quot;<span class="subst">&#123;phoneNum&#125;</span>登陆失败，因为用户不存在&quot;</span>; <span class="comment">// 用户不存在</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.PasswordError:</span><br><span class="line">                    msg = <span class="string">$&quot;<span class="subst">&#123;phoneNum&#125;</span>登录失败，密码错误&quot;</span>; <span class="comment">// 密码错误</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.NoPassword:</span><br><span class="line">                    msg = <span class="string">$&quot;<span class="subst">&#123;phoneNum&#125;</span>登录失败，用户未设置密码&quot;</span>; <span class="comment">// 未设置密码</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.Lockout:</span><br><span class="line">                    msg = <span class="string">$&quot;<span class="subst">&#123;phoneNum&#125;</span>登录失败，用户被锁定&quot;</span>; <span class="comment">// 用户被锁定</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(); <span class="comment">// 未知结果抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用仓储方法，新增一条登录历史记录</span></span><br><span class="line">            <span class="keyword">return</span> repository.AddNewLoginHistoryAsync(phoneNum, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于领域事件的处理器是运行在工作单元中的，因此我们只要在代码中把对象加入repository即可，不需要手动调用SaveChangesAsync。</p><h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><p>实现登录的控制器，先在控制器上添加[UnitOfWork(typeof(UserDbContext))],这样控制器中的所有操作方法都会自动进行工作单元的提交，然后为控制器注入UserDomainSevice服务，在编写根据手机号和密码进行登录的操作方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ChangePasswordRequest 记录用于封装用户修改密码的请求数据。</span></span><br><span class="line">    <span class="comment">// 包含用户唯一标识 Id 以及新的密码 Password。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">ChangePasswordRequest</span>(<span class="params">Guid Id, <span class="built_in">string</span> Password</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 表示通过手机号和验证码进行登录的请求。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;PhoneNumber&quot;&gt;</span>用户的手机号。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;Code&quot;&gt;</span>验证码。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">CheckLoginByPhoneAndCodeRequest</span>(<span class="params">PhoneNumber PhoneNumber, <span class="built_in">string</span> Code</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 登录请求数据结构，包含手机号和密码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">LoginByPhoneAndPwdRequest</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        PhoneNumber PhoneNumber, // 用户手机号</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> Password          // 用户密码</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 该记录类型用于封装通过手机号和验证码发送登录请求的数据。</span></span><br><span class="line">    <span class="comment">// PhoneNumber 属性表示用户的手机号码。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">SendLoginByPhoneAndCodeRequest</span>(<span class="params">PhoneNumber PhoneNumber</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Users.WebAPI.Controllers</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 路由格式为 /Login/方法名，ApiController特性用于自动模型验证和路由推断</span></span><br><span class="line">    [<span class="meta">Route(<span class="string">&quot;[controller]/[action]&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    <span class="comment">// 使用UnitOfWork特性，指定该控制器操作的数据库上下文为UserDbContext</span></span><br><span class="line">    [<span class="meta">UnitOfWork(typeof(UserDbContext))</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoginController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用户领域服务，封装了登录、验证码等业务逻辑</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> UserDomainService domainService;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过依赖注入方式获取UserDomainService实例</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LoginController</span>(<span class="params">UserDomainService domainService</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.domainService = domainService;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 通过手机号和密码登录</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;req&quot;&gt;</span>包含手机号和密码的请求对象<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>登录结果，成功返回200，失败返回400<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        [<span class="meta">HttpPut</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">LoginByPhoneAndPwd</span>(<span class="params">LoginByPhoneAndPwdRequest req</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 密码长度校验，防止过短密码</span></span><br><span class="line">            <span class="keyword">if</span> (req.Password.Length &lt; <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> BadRequest(<span class="string">&quot;密码的长度不能小于3&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> phoneNum = req.PhoneNumber;</span><br><span class="line">            <span class="comment">// 调用领域服务进行登录校验</span></span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">await</span> domainService.CheckLoginAsync(phoneNum, req.Password);</span><br><span class="line">            <span class="comment">// 根据校验结果返回不同的响应</span></span><br><span class="line">            <span class="keyword">switch</span> (result)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.OK:</span><br><span class="line">                    <span class="keyword">return</span> Ok(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.PhoneNumberNotFound:</span><br><span class="line">                    <span class="keyword">return</span> BadRequest(<span class="string">&quot;手机号或者密码错误&quot;</span>);</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.Lockout:</span><br><span class="line">                    <span class="keyword">return</span> BadRequest(<span class="string">&quot;用户被锁定，请稍后再试&quot;</span>);</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.NoPassword:</span><br><span class="line">                    <span class="keyword">return</span> BadRequest(<span class="string">&quot;用户未设置密码，请先设置密码&quot;</span>);</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.PasswordError:</span><br><span class="line">                    <span class="keyword">return</span> BadRequest(<span class="string">&quot;手机号或者密码错误&quot;</span>);</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 发送短信验证码到指定手机号</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;req&quot;&gt;</span>包含手机号的请求对象<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>发送结果，成功返回200，失败返回400<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        [<span class="meta">HttpPost</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">SendCodeByPhone</span>(<span class="params">SendLoginByPhoneAndCodeRequest req</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 调用领域服务发送验证码</span></span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">await</span> domainService.SendCodeAsync(req.PhoneNumber);</span><br><span class="line">            <span class="comment">// 根据发送结果返回不同的响应</span></span><br><span class="line">            <span class="keyword">switch</span> (result)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.OK:</span><br><span class="line">                    <span class="keyword">return</span> Ok(<span class="string">&quot;验证码已发送，请注意查收&quot;</span>);</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.Lockout:</span><br><span class="line">                    <span class="keyword">return</span> BadRequest(<span class="string">&quot;用户被锁定，请稍后再试&quot;</span>);</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> BadRequest(<span class="string">&quot;请求错误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 校验用户输入的短信验证码</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;req&quot;&gt;</span>包含手机号和验证码的请求对象<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>校验结果，成功返回200，失败返回400<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        [<span class="meta">HttpPost</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">CheckCode</span>(<span class="params">CheckLoginByPhoneAndCodeRequest req</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 调用领域服务校验验证码</span></span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">await</span> domainService.CheckCodeAsync(req.PhoneNumber, req.Code);</span><br><span class="line">            <span class="comment">// 根据校验结果返回不同的响应</span></span><br><span class="line">            <span class="keyword">switch</span> (result)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> CheckCodeResult.OK:</span><br><span class="line">                    <span class="keyword">return</span> Ok(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                <span class="keyword">case</span> CheckCodeResult.PhoneNumberNotFound:</span><br><span class="line">                    <span class="keyword">return</span> BadRequest(<span class="string">&quot;请求错误&quot;</span>);</span><br><span class="line">                <span class="keyword">case</span> CheckCodeResult.Lockout:</span><br><span class="line">                    <span class="keyword">return</span> BadRequest(<span class="string">&quot;用户被锁定，请稍后再试&quot;</span>);</span><br><span class="line">                <span class="keyword">case</span> CheckCodeResult.CodeError:</span><br><span class="line">                    <span class="keyword">return</span> BadRequest(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Users.WebAPI.Controllers</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 路由格式为 [控制器名]/[方法名]，如 UsersMgr/AddNew</span></span><br><span class="line">    [<span class="meta">Route(<span class="string">&quot;[controller]/[action]&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    <span class="comment">// 使用工作单元过滤器，自动管理数据库事务，指定UserDbContext为上下文</span></span><br><span class="line">    [<span class="meta">UnitOfWork(typeof(UserDbContext))</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UsersMgrController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注入用户数据库上下文，用于操作数据库</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> UserDbContext dbCtx;</span><br><span class="line">        <span class="comment">// 注入用户领域服务，封装用户相关的业务逻辑</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> UserDomainService domainService;</span><br><span class="line">        <span class="comment">// 注入用户仓储接口，用于数据持久化和查询</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IUserDomainRepository repository;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数，依赖注入所需服务</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UsersMgrController</span>(<span class="params">UserDbContext dbCtx, UserDomainService domainService, IUserDomainRepository repository</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.dbCtx = dbCtx;</span><br><span class="line">            <span class="keyword">this</span>.domainService = domainService;</span><br><span class="line">            <span class="keyword">this</span>.repository = repository;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增用户接口，参数为手机号</span></span><br><span class="line">        [<span class="meta">HttpPost</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">AddNew</span>(<span class="params">PhoneNumber req</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 检查用户是否已存在</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">await</span> repository.FindOneAsync(req)) != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> BadRequest(<span class="string">&quot;用户已存在&quot;</span>); <span class="comment">// 已存在则返回错误</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建新用户对象</span></span><br><span class="line">            User user = <span class="keyword">new</span> User(req);</span><br><span class="line">            <span class="comment">// 添加到数据库上下文，等待事务提交时保存</span></span><br><span class="line">            dbCtx.Users.Add(user);</span><br><span class="line">            <span class="keyword">return</span> Ok(<span class="string">&quot;成功&quot;</span>); <span class="comment">// 返回成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改用户密码接口</span></span><br><span class="line">        [<span class="meta">HttpPut</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">ChangePassword</span>(<span class="params">ChangePasswordRequest req</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 根据用户ID查找用户</span></span><br><span class="line">            <span class="keyword">var</span> user = <span class="keyword">await</span> repository.FindOneAsync(req.Id);</span><br><span class="line">            <span class="keyword">if</span> (user == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> NotFound(<span class="string">&quot;用户不存在&quot;</span>); <span class="comment">// 未找到用户返回404</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重置用户访问失败状态（如登录失败次数等）</span></span><br><span class="line">            domainService.ResetAccessFail(user);</span><br><span class="line">            <span class="keyword">return</span> Ok(<span class="string">&quot;成功&quot;</span>); <span class="comment">// 返回成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有用户列表接口</span></span><br><span class="line">        [<span class="meta">HttpGet</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GetAll</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 查询所有用户</span></span><br><span class="line">            <span class="keyword">var</span> users = <span class="keyword">await</span> dbCtx.Users.ToListAsync();</span><br><span class="line">            <span class="keyword">return</span> Ok(users); <span class="comment">// 返回用户列表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用服务层主要进行的是数据的校验、请求数据的获取、领域服务返回值的显示等处理，并没有复杂的业务逻辑，因为主要的业务逻辑都被封装在领域层。<br>应用服务层是非常“薄”的一层，应用服务层要进行安全认证、权限校验、数据校验、事务控制、工作单元控制、领域服务层的调用等。</p>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
            <tag> DDD </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> MassTransit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是反射</title>
      <link href="/2025/06/29/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84/"/>
      <url>/2025/06/29/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>当然！你问的“什么是反射”，这里给你一个通俗易懂的中文解释：</p><hr><h2 id="反射（Reflection）是什么？"><a href="#反射（Reflection）是什么？" class="headerlink" title="反射（Reflection）是什么？"></a>反射（Reflection）是什么？</h2><p><strong>反射</strong> 是 .NET（以及很多语言和平台，比如 Java）提供的一种机制，它能让程序在运行时查看、检查、访问甚至修改<strong>自身的类型信息</strong>。</p><p>简单来说：</p><blockquote><p><strong>反射就是在运行时动态获取或操作对象、类型、方法、属性等元数据的能力。</strong></p></blockquote><p>常用的 System.Reflection 类型<br> Type<br>表示 .NET 中任何类型的运行时信息，是反射的核心入口。</p><p> PropertyInfo<br>表示属性的元数据，能用来读&#x2F;写属性值。</p><p> MethodInfo<br>表示方法的元数据，能用来调用方法。</p><p> FieldInfo<br>表示字段的元数据，能用来访问字段值。</p><p> ConstructorInfo<br>表示构造函数的元数据，可以用来创建对象。</p><p> Assembly<br>表示程序集（.dll 或 .exe），可以用它动态加载程序集并获取类型信息。</p><p> MemberInfo<br>表示成员（属性、方法、字段等）的基类，很多 API 返回它。</p><hr><h3 id="举个简单的例子"><a href="#举个简单的例子" class="headerlink" title="举个简单的例子"></a>举个简单的例子</h3><p>假设你有一个类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在平时的代码里，你可以直接用：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.Name = <span class="string">&quot;Alice&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>但如果你想在不知道类名字、属性名字的情况下，从字符串 <code>&quot;Person&quot;</code> 和 <code>&quot;Name&quot;</code> 来动态操作——就要用到 <strong>反射</strong>：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行时通过字符串获取类型</span></span><br><span class="line">Type type = Type.GetType(<span class="string">&quot;YourNamespace.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="built_in">object</span> obj = Activator.CreateInstance(type);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line"><span class="keyword">var</span> prop = type.GetProperty(<span class="string">&quot;Name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置属性值</span></span><br><span class="line">prop.SetValue(obj, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取属性值</span></span><br><span class="line"><span class="built_in">string</span> <span class="keyword">value</span> = (<span class="built_in">string</span>)prop.GetValue(obj);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>); <span class="comment">// 输出 Alice</span></span><br></pre></td></tr></table></figure><p>这就是反射：在程序运行时，通过类型的元信息（metadata）对类型、方法、属性等进行操作。</p><hr><h2 id="反射能做什么？"><a href="#反射能做什么？" class="headerlink" title="反射能做什么？"></a>反射能做什么？</h2><p> <strong>获取类型信息</strong><br>比如拿到类、接口、方法、属性、字段、构造函数的元数据。</p><p> <strong>动态创建对象</strong><br>比如你写一个插件系统，需要根据配置文件里写的类名创建实例。</p><p> <strong>调用方法</strong><br>你甚至可以在不知道方法名的情况下，通过字符串找到方法并调用。</p><p> <strong>访问和修改属性&#x2F;字段</strong><br>比如 ORM 框架会用反射把数据库结果自动映射到对象属性。</p><p> <strong>读取特性（Attribute）</strong><br>你可以在运行时读取类、属性、方法上的自定义特性（attribute），根据它们做不同的逻辑。</p><p> <strong>动态加载程序集</strong><br>比如插件系统，可以运行时加载 .dll 文件并使用里面的类型。</p><hr><h2 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h2><p> JSON&#x2F;XML&#x2F;数据库序列化&#x2F;反序列化（自动映射到对象）<br> IoC 容器（依赖注入）根据类型创建对象<br> ORM 框架（EF Core、Dapper）<br> 日志、审计系统<br> 插件架构：动态加载和调用插件<br> 写工具或框架：比如自动生成代码、做模型验证</p><hr><h2 id="为什么叫“反射”？"><a href="#为什么叫“反射”？" class="headerlink" title="为什么叫“反射”？"></a>为什么叫“反射”？</h2><p>因为它就像程序“照镜子”，能<strong>看见自己</strong>（类型结构、属性、方法）并且<strong>操作自己</strong>。</p><hr><h2 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h2><ul><li>性能比直接代码调用慢很多（虽然可以缓存反射结果减少开销）。</li><li>可维护性差：反射常用字符串（类型名、属性名），这些字符串如果拼错，编译器不会提示错误。</li><li>使用不当会破坏封装性（比如可以访问私有成员）。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 反射让你在运行时获取和操作类型信息，是很多框架的底层支撑<br> 用于动态行为、插件、自动化映射等<br> 功能强大，但要小心性能和可维护性</p><hr>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> charp编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core使用RabbitMQ和MassTransit</title>
      <link href="/2025/05/27/DDD/NET%20Core%208%E4%B8%AD%E4%BD%BF%E7%94%A8MassTransit/"/>
      <url>/2025/05/27/DDD/NET%20Core%208%E4%B8%AD%E4%BD%BF%E7%94%A8MassTransit/</url>
      
        <content type="html"><![CDATA[<h1 id="MassTransit"><a href="#MassTransit" class="headerlink" title="MassTransit"></a>MassTransit</h1><p>一、MassTransit</p><ol><li>基本概念<br>定位：基于 .NET 平台 的开源消息总线框架，用于构建分布式、异步通信的应用程序，支持多种消息传输协议（如 RabbitMQ、Azure Service Bus、Kafka 等）。<br>设计目标：简化分布式系统中消息传递的开发，提供高层次的抽象（如消费者、管道、 Saga 模式等），降低开发者对消息中间件底层细节的依赖。</li><li>核心特点<br>多传输协议支持：可无缝集成 RabbitMQ、Azure Service Bus、Kafka、ActiveMQ 等多种消息代理。<br>编程模型友好：<br>基于 C# 语言，支持依赖注入（DI）和 Lambda 表达式，代码简洁易读。<br>内置消费者管道（Consumer Pipeline），支持消息过滤、重试、日志记录等中间件。<br>分布式事务支持：通过 Saga 模式 实现长流程事务的异步协调（如订单状态更新、支付回调处理）。<br>高可用性与监控：<br>支持消费者集群和负载均衡。<br>集成 Prometheus、Grafana 等监控工具，提供运行时指标和健康检查。</li><li>应用场景<br>.NET 微服务架构：作为服务间通信的核心组件（尤其适合 C# 开发团队）。<br>复杂业务流程：需要 Saga 模式处理的长事务场景（如电商订单的支付、发货、退款流程）。<br>多消息代理混合架构：系统需要兼容多种消息中间件时（如迁移至云服务时过渡）。</li><li>优缺点<br>优点：<br>深度集成 .NET 生态，开发效率高，适合 C# 开发者。<br>高层次抽象隐藏了消息中间件的复杂性，聚焦业务逻辑。<br>缺点：<br>仅限 .NET 平台，跨语言支持有限。<br>对非 .NET 技术栈（如 Java、Python）不友好。</li></ol><p>MassTransit 是广泛使用的 .NET 服务总线，可简化基于消息的应用程序开发，而 MassTransit.RabbitMQ 则提供与 RabbitMQ 的必要集成。</p><h3 id="安装NuGet包"><a href="#安装NuGet包" class="headerlink" title="安装NuGet包"></a>安装NuGet包</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Install-Package MassTransit</span><br><span class="line">Install-Package MassTransit.RabbitMQ</span><br></pre></td></tr></table></figure><ol><li>TransferData 消息模型配置</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TransferData 记录类型，用于表示一次转账操作的数据</span></span><br><span class="line">    <span class="comment">// Type: 转账类型（如“存款”或“取款”）</span></span><br><span class="line">    <span class="comment">// Amount: 转账金额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">record</span> <span class="title">TransferData</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Type &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Amount &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Client 记录类型，表示一个客户的信息</span></span><br><span class="line">    <span class="comment">// Name: 客户姓名</span></span><br><span class="line">    <span class="comment">// Pin: 客户的PIN码（个人识别码）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Pin &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Account 记录类型，表示一个账户的信息</span></span><br><span class="line">    <span class="comment">// Name: 账户持有人姓名</span></span><br><span class="line">    <span class="comment">// Deposit: 账户余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Account</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Deposit &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CurrentBalance 类表示当前账户余额信息</span></span><br><span class="line">    <span class="comment">// Amount: 当前余额金额</span></span><br><span class="line">    <span class="comment">// Currency: 货币类型（如美元、欧元等）</span></span><br><span class="line">    <span class="comment">// Balance: 余额的整数表示形式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CurrentBalance</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Amount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Currency &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Balance &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在Program.cs中配置MassTransit。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 MassTransit 使用 RabbitMQ 作为消息总线</span></span><br><span class="line">builder.Services.AddMassTransit(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 RabbitMQ 进行传输</span></span><br><span class="line">    x.UsingRabbitMq((context, cfg) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 配置 RabbitMQ 主机地址和认证信息</span></span><br><span class="line">        cfg.Host(<span class="keyword">new</span> Uri(<span class="string">&quot;rabbitmq://localhost&quot;</span>), h =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            h.Username(<span class="string">&quot;root&quot;</span>); <span class="comment">// 用户名</span></span><br><span class="line">            h.Password(<span class="string">&quot;root&quot;</span>); <span class="comment">// 密码</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> QueueSenderController 控制器用于演示通过 MassTransit 向 RabbitMQ 发送命令、发布事件和请求响应。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Route(<span class="string">&quot;api/[controller]/[action]&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QueueSenderController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// MassTransit 的总线对象，用于发送和发布消息</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IBus bus;</span><br><span class="line">        <span class="comment">// 用于请求-响应模式的客户端</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IRequestClient&lt;TransferData&gt; requestClient;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 构造函数，注入总线和请求客户端</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;bus&quot;&gt;</span>MassTransit 总线<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;requestClient&quot;&gt;</span>请求-响应客户端<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">QueueSenderController</span>(<span class="params">IBus bus, IRequestClient&lt;TransferData&gt; requestClient</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.bus = bus;</span><br><span class="line">            <span class="keyword">this</span>.requestClient = requestClient;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 发送命令消息到指定的 RabbitMQ 队列</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>操作结果<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        [<span class="meta">HttpPost(<span class="string">&quot;send-command&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">SendCommand</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建一个账户对象，模拟要发送的数据</span></span><br><span class="line">            <span class="keyword">var</span> account = <span class="keyword">new</span> Account()</span><br><span class="line">            &#123;</span><br><span class="line">                Name = <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">                Deposit = <span class="number">500</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 指定 RabbitMQ 队列的地址</span></span><br><span class="line">            <span class="keyword">var</span> url = <span class="keyword">new</span> Uri(<span class="string">&quot;rabbitmq://localhost/send-command&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取发送端点并发送消息</span></span><br><span class="line">            <span class="keyword">var</span> endpoint = <span class="keyword">await</span> bus.GetSendEndpoint(url);</span><br><span class="line">            <span class="keyword">await</span> endpoint.Send(account);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Ok(<span class="string">&quot;命令已成功发送&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 发布事件消息，所有订阅者都能收到</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>操作结果<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        [<span class="meta">HttpPost(<span class="string">&quot;publish-event&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">PublishEvent</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 发布一个客户端事件，所有监听该事件的服务都能收到</span></span><br><span class="line">            <span class="keyword">await</span> bus.Publish(<span class="keyword">new</span> Client()</span><br><span class="line">            &#123;</span><br><span class="line">                Name = <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">                Pin = <span class="number">123456</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Ok(<span class="string">&quot;事件发布成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 发送请求并等待响应，演示请求-响应模式</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>响应内容<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        [<span class="meta">HttpPost(<span class="string">&quot;request-response&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">RequestResponse</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 构造转账数据</span></span><br><span class="line">            <span class="keyword">var</span> transferData = <span class="keyword">new</span> TransferData()</span><br><span class="line">            &#123;</span><br><span class="line">                Type = <span class="string">&quot;Withdrawal&quot;</span>,</span><br><span class="line">                Amount = <span class="number">25</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 发送请求并等待响应</span></span><br><span class="line">            <span class="keyword">var</span> request = requestClient.Create(transferData);</span><br><span class="line">            <span class="keyword">var</span> response = <span class="keyword">await</span> request.GetResponse&lt;CurrentBalance&gt;();</span><br><span class="line">            <span class="keyword">return</span> Ok(<span class="string">$&quot;响应数据: <span class="subst">&#123;response.Message.Currency&#125;</span>, 金额: <span class="subst">&#123;response.Message.Amount&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置消费者</p><p>创建接口，定义消费类型</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> IConsumer 接口定义了消费不同类型消息的方法。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 每个方法用于处理一种特定的数据类型。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IConsumer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 消费 Client 类型的消息。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;client&quot;&gt;</span>要处理的 Client 对象。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Consume</span>(<span class="params">Client client</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 消费 Account 类型的消息。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;account&quot;&gt;</span>要处理的 Account 对象。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Consume</span>(<span class="params">Account account</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 消费 TransferData 类型的消息。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;transferData&quot;&gt;</span>要处理的 TransferData 对象，包含转账类型和金额。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Consume</span>(<span class="params">TransferData transferData</span>)</span>;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 消费 CurrentBalance 类型的消息。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Consume</span>(<span class="params">CurrentBalance currentBalance</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// PublisherServicer 类实现了 MassTransit 的 IConsumer&lt;Client&gt; 接口，用于消费 Client 类型的消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PublisherServicer</span> : <span class="title">IConsumer</span>&lt;<span class="title">Client</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当有 Client 类型的消息到达时，Consume 方法会被自动调用</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Consume</span>(<span class="params">ConsumeContext&lt;Client&gt; context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从消息上下文中获取消息体（Client 对象）</span></span><br><span class="line">            <span class="keyword">var</span> info = context.Message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> RequestResponseServicer 类实现了 IConsumer 接口，用于处理 TransferData 类型的消息。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 当收到转账请求时，计算当前余额并响应给请求方。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RequestResponseServicer</span> : <span class="title">IConsumer</span>&lt;<span class="title">TransferData</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 消费并处理 TransferData 消息。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 先获取消息中的转账金额，然后用 1000 减去该金额，得到当前余额，最后将余额作为响应返回。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;context&quot;&gt;</span>包含消息内容和上下文信息的对象<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Consume</span>(<span class="params">ConsumeContext&lt;TransferData&gt; context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取消息内容</span></span><br><span class="line">            <span class="keyword">var</span> data = context.Message;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算当前余额：假设初始余额为 1000，减去转账金额</span></span><br><span class="line">            <span class="keyword">var</span> nowBalance = <span class="keyword">new</span> CurrentBalance()</span><br><span class="line">            &#123;</span><br><span class="line">                Balance = <span class="number">1000</span> - data.Amount</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前余额作为响应返回给请求方</span></span><br><span class="line">            <span class="keyword">await</span> context.RespondAsync(nowBalance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 消息消费者服务，实现了 IConsumer&amp;lt;Account&amp;gt; 接口，用于处理 Account 类型的消息。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SenderServicer</span> : <span class="title">IConsumer</span>&lt;<span class="title">Account</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 消费消息的方法，当接收到 Account 类型的消息时被调用。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;context&quot;&gt;</span>包含消息和上下文信息的 ConsumeContext 对象。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Consume</span>(<span class="params">ConsumeContext&lt;Account&gt; context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取消息体中的 Account 实例</span></span><br><span class="line">            <span class="keyword">var</span> account = context.Message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 MassTransit 服务</span></span><br><span class="line">builder.Services.AddMassTransit(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册消息消费者：PublisherServicer、SenderServicer、RequestResponseServicer</span></span><br><span class="line">    x.AddConsumer&lt;PublisherServicer&gt;();</span><br><span class="line">    x.AddConsumer&lt;SenderServicer&gt;();</span><br><span class="line">    x.AddConsumer&lt;RequestResponseServicer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 RabbitMQ 作为消息中间件</span></span><br><span class="line">    x.UsingRabbitMq((contxit, config) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 配置 RabbitMQ 主机地址和登录信息</span></span><br><span class="line">        config.Host(<span class="keyword">new</span> Uri(<span class="string">&quot;rabbitmq://localhost&quot;</span>), h =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            h.Username(<span class="string">&quot;root&quot;</span>); <span class="comment">// 用户名</span></span><br><span class="line">            h.Password(<span class="string">&quot;root&quot;</span>); <span class="comment">// 密码</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置 send-command 队列，绑定 SenderServicer 消费者</span></span><br><span class="line">        config.ReceiveEndpoint(<span class="string">&quot;send-command&quot;</span>, e =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            e.ConfigureConsumer&lt;SenderServicer&gt;(contxit);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置 publish-event 队列，绑定 PublisherServicer 消费者</span></span><br><span class="line">        config.ReceiveEndpoint(<span class="string">&quot;publish-event&quot;</span>, e =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            e.ConfigureConsumer&lt;PublisherServicer&gt;(contxit);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置 request-response 队列，绑定 RequestResponseServicer 消费者</span></span><br><span class="line">        config.ReceiveEndpoint(<span class="string">&quot;request-response&quot;</span>, e =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            e.ConfigureConsumer&lt;RequestResponseServicer&gt;(contxit);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
            <tag> DDD </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> MassTransit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET Core的聚合，RabbitMQ实现领域事件</title>
      <link href="/2025/05/24/DDD/EFCore%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%90%88%E9%80%82%E6%97%B6%E6%9C%BARabbitMQ%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/05/24/DDD/EFCore%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%90%88%E9%80%82%E6%97%B6%E6%9C%BARabbitMQ%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="EF-Core中发布领域事件的合适时机"><a href="#EF-Core中发布领域事件的合适时机" class="headerlink" title="EF Core中发布领域事件的合适时机"></a>EF Core中发布领域事件的合适时机</h1><p>领域事件大部分发生在领域模型的业务逻辑方法上或者领域服务上，我们可以在一个领域事件发生的时候立即调用IMediator的Publish方法来发布领域事件。我们一般在聚合根的实体类对象的ChangeName、构造方法等方法中发布领域事件，因为无论是应用服务还是领域服务，最终都要调用聚合根中的方法来操作聚合，我们这样做可以确保领域事件不会被漏掉。但是在实体类的业务方法中立即进行领域时间的发布可能会有以下问题。</p><ol><li><p>可能存在重复发送领域事件的情况。比如，在“修改用户信息”这个应用服务操作中我们分别调用实体类的ChangeName、ChangeAge、ChangeEmail方法修改用户的姓名、年龄和邮箱。因此每个Change???方法中都会发布“实体类被修改”的领域事件，所以领域事件的处理者就会被多次调用，这是没有必要的，其实只要发布一次“实体类被修改”的领域事件即可。</p></li><li><p>领域事件发布太早。为了确保新增加的实体类能够发布“新增实体类”的领域事件，我们需要在实体类的构造方法中发布领域事件，但是很有可能因为数据验证没有通过等原因，我们最终没有把这个新增的实体类保存到数据库中，这样在构造方法中过早地发布领域事件就可能导致“误报”的问题。</p></li></ol><p>参考eShopOnContainers项目中的做法，把领域事件的发布延迟到上下文保存修改时。也就是实体类中只注册要发布的领域事件，然后再上下文的SaveChanges方法被调用时，我们再发布领域事件。领域事件是由聚合根进行管理的，因此我们定义了供聚合根进行事件注册的接口IDomainEvents。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 定义领域事件集合的接口。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 该接口用于聚合根或实体对象中，管理与其相关的领域事件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 领域事件通常用于在领域模型内部发生重要业务行为时，</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 将这些行为以事件的形式发布给外部进行处理（如发送通知、集成等）。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 主要职责包括：</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 1. 获取当前已注册的所有领域事件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 2. 添加新的领域事件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 3. 如果不存在则添加新的领域事件（防止重复添加）。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 4. 清空所有已注册的领域事件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDomainEvents</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">IEnumerable&lt;INotification&gt; <span class="title">GetDomainEvents</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AddDomainEvent</span>(<span class="params">INotification eventItem</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AddDomainEventIfAbsent</span>(<span class="params">INotification eventItem</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ClearDomainEvents</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了简化实体类的代码编写，我们编写实现了IDomainEvents接口的抽象实体类BaseEntity。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 领域实体基类，支持领域事件的收集与管理。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 主要功能说明：</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 1. 通过 AddDomainEvent 方法添加领域事件（INotification 实例）。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 2. 通过 AddDomainEventIfAbsent 方法避免重复添加相同事件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 3. 通过 ClearDomainEvents 方法清空所有已收集的领域事件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 4. 通过 GetDomainEvents 方法获取当前收集的所有领域事件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 使用场景：</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> - 领域模型在业务操作中可调用 AddDomainEvent/AddDomainEventIfAbsent 添加事件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> - 应用层可在持久化操作后统一发布并清理领域事件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BaseEntity</span> : <span class="title">IDomainEvents</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;INotification&gt; DomainEvents = <span class="keyword">new</span>();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddDomainEvent</span>(<span class="params">INotification eventItem</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            DomainEvents.Add(eventItem);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddDomainEventIfAbsent</span>(<span class="params">INotification eventItem</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!DomainEvents.Contains(eventItem))</span><br><span class="line">            &#123;</span><br><span class="line">                DomainEvents.Add(eventItem);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClearDomainEvents</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            DomainEvents.Clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IEnumerable&lt;INotification&gt; <span class="title">GetDomainEvents</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> DomainEvents;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要在上下文中保存数据的时候发布注册的领域事件。在DDD中，每个聚合都对应一个上下文，因此项目中的上下文类非常多。为了简化上下文码的编写，我们编写BaseContext类，将在SaveChanges中发布领域事件的代码分装到这个类中。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 基础DbContext，集成领域事件发布机制。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 在调用SaveChangesAsync时，会自动收集实现IDomainEvents接口的实体上的领域事件，</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 并通过IMediator依次发布这些事件，最后再提交数据库变更。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 注意：禁止直接调用同步的SaveChanges方法。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseDbContext</span>:<span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IMediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDbContext</span>(<span class="params">DbContextOptions options,IMediator mediator</span>) : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">SaveChanges</span>(<span class="params"><span class="built_in">bool</span> acceptAllChangesOnSuccess</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(<span class="string">&quot;Dot&#x27;t call SaveCheanges&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">SaveChangesAsync</span>(<span class="params"><span class="built_in">bool</span> acceptAllChangesOnSuccess,CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> domainEntities = <span class="keyword">this</span>.ChangeTracker.Entries&lt;IDomainEvents&gt;()</span><br><span class="line">            .Where(x =&gt; x.Entity.GetDomainEvents().Any());</span><br><span class="line">        <span class="keyword">var</span> domainEvents = domainEntities.SelectMany(x =&gt; x.Entity.GetDomainEvents()).ToList();</span><br><span class="line">        domainEntities.ToList().ForEach(entity=&gt;entity.Entity.ClearDomainEvents());</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> domainEvent <span class="keyword">in</span> domainEvents)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> mediator.Publish(domainEvent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">base</span>.SaveChangesAsync(acceptAllChangesOnSuccess,cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为我们需要发布注册的领域事件，所以我们通过构造方法注入IMediator服务；我们重写父类的SaveChangesAsync方法，在调用父类的SaveChangesAsync方法保存修改之前，我们把所有实体类中注册的领域事件发布出去；第15行代码中获得ChangeTracker是上下文中用来对实体类的变化进行追踪的对象，Entries&lt;IDomainEvents&gt;获得的是所有实现了IDomainEvents接口的追踪实体类；我们在项目中强制要求不能使用同步的SaveChanges方法，因此第10行代码中对SaveChanges的调用抛出异常。</p><p>至此，我们完成了EFCore中简化领域事件发布的几个接口和抽象类的开发。接下来，我们编写用来测试的实体类和上下文，首先我们编写代表用户的实体类User</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 用户领域实体，包含用户的基本信息及领域事件的发布。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 主要功能说明：</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 1. 构造函数创建用户时发布 UserAddedEvent 领域事件。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 2. 修改昵称和年龄时，若未发布过 UserUpdatedEvent，则发布该事件。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 3. 软删除用户时发布 UserSoftDeletedEvent 领域事件。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 4. 继承自 BaseEntity，支持领域事件的收集与管理。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span>:<span class="title">BaseEntity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid Id &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> UserName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Email &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? Nickname &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>? Age &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsDeleted &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span>(<span class="params"><span class="built_in">string</span> userName,<span class="built_in">string</span> email</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Id = Guid.NewGuid();</span><br><span class="line">        <span class="keyword">this</span>.UserName = userName;</span><br><span class="line">        <span class="keyword">this</span>.Email = email;</span><br><span class="line">        <span class="keyword">this</span>.IsDeleted = <span class="literal">false</span>;</span><br><span class="line">        AddDomainEvent(<span class="keyword">new</span> UserAddedEvent(<span class="keyword">this</span>));        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangNickName</span>(<span class="params"><span class="built_in">string</span>? <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Nickname = <span class="keyword">value</span>;</span><br><span class="line">        AddDomainEventIfAbsent(<span class="keyword">new</span> UserUpdatedEvent(Id));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeAge</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Age=<span class="keyword">value</span>;</span><br><span class="line">        AddDomainEventIfAbsent(<span class="keyword">new</span> UserUpdatedEvent(Id));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SoftDelete</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.IsDeleted=<span class="literal">true</span>;</span><br><span class="line">        AddDomainEvent(<span class="keyword">new</span> UserSoftDeletedEvent(Id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在第16行代码的有参构造方法中，发布了UserAddedEvent领域事件，这样当我们创建新的实体类并且保存修改的时候，这个领域事件就会被发布。但是如果EF Core从数据库中加载已有数据的时候，也执行第16行代码的有参构造方法，就会导致在加载数据的时候也发步UserAddedEvent领域事件，这就发生逻辑错误了，因此我们在第9行代码中提供一个无参构造方法供EF Core从数据库中加载数据是使用。</p><p>因为我们可能连续调用ChangeNickName、ChangeAge等方法，所有我们在第21、26行代码中通过AddDomainEventlfAbsent注册领域事件，从而避免消息的重复发布。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">UserAddedEvent</span>(<span class="params">User Item</span>):INotification</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">UserUpdatedEvent</span>(<span class="params">Guid Id</span>):INotification</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">UserSoftDeletedEvent</span>(<span class="params">Guid Id</span>):INotification</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们编写事件处理类来对这些领域事件进行处理。首先我们编写响应UserAddedEvent领域事件，然后向用户发送注册邮件的NewUserSendEmailHandler类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewUserSendEmailHandler</span> : <span class="title">INotificationHandler</span>&lt;<span class="title">UserAddedEvent</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;NewUserSendEmailHandler&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewUserSendEmailHandler</span>(<span class="params">ILogger&lt;NewUserSendEmailHandler&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">Handle</span>(<span class="params">UserAddedEvent notification, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> user = notification.Item;</span><br><span class="line">        _logger.LogInformation(<span class="string">$&quot;向<span class="subst">&#123;user.Email&#125;</span>发送欢迎邮件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用日志输出代替真正的日志发送。在实际项目中，由于邮件发送比较耗时，建议把邮件发送的代码放到后台线程执行，而不是异步等待邮件发送的结果。</p><p>下面我们在实现一个“当用户的个人信息被修改后，发邮件通知用户的事件处理者”的功能。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ModifyUserLogHandler</span> : <span class="title">INotificationHandler</span>&lt;<span class="title">UserUpdatedEvent</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> UserDbContext _dbContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;ModifyUserLogHandler&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ModifyUserLogHandler</span>(<span class="params">BaseDbContext dbContext, ILogger&lt;ModifyUserLogHandler&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _dbContext = dbContext;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Handle</span>(<span class="params">UserUpdatedEvent notification, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> user=<span class="keyword">await</span> _dbContext.Users.FindAsync(notification.Id);</span><br><span class="line">        _logger.LogInformation(<span class="string">$&quot;通知用户<span class="subst">&#123;user.Email&#125;</span>的信息被修改&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为UserUpdatedEvent中只包含被修改用户的标识符，所以我们在第12行代码中通过FindAsync获取被修改用户的详细信息。因为FindAsync会首先从上下文的缓存中获取对象，而修改操作之前被修改的对象已经存在与缓存中了，所以用FindAsync不仅能够获取还没有提交到数据库的对象，而且由于FindAsync操作不会再到数据库中查询，因此程序的性能更高。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Route(<span class="string">&quot;api/[controller]/[action]&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UsersController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> UserDbContext context;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UsersController</span>(<span class="params">UserDbContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.context = context;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">HttpPost</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Add</span>(<span class="params">AddUserRequest req</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> user = <span class="keyword">new</span> User(req.UserName, req.Email);</span><br><span class="line">            context.Users.Add(user);</span><br><span class="line">            <span class="keyword">await</span> context.SaveChangesAsync();</span><br><span class="line">            <span class="keyword">return</span> Ok();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">HttpPut</span>]</span><br><span class="line">        [<span class="meta">Route(<span class="string">&quot;&#123;id&#125;&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Update</span>(<span class="params">Guid id,UpdateUserRequest req</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            User? user = context.Users.Find(id);</span><br><span class="line">            <span class="keyword">if</span> (user==<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> NotFound(<span class="string">$&quot;id=<span class="subst">&#123;id&#125;</span>的User不存在&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            user.ChangeAge(req.Age);</span><br><span class="line">            user.ChangeEmail(req.Email);</span><br><span class="line">            user.ChangeNickName(req.NickName);</span><br><span class="line">            <span class="keyword">await</span> context.SaveChangesAsync();</span><br><span class="line">            <span class="keyword">return</span> Ok();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">HttpDelete</span>]</span><br><span class="line">        [<span class="meta">Route(<span class="string">&quot;id&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Delete</span>(<span class="params">Guid id</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            User? user = context.Users.Find(id);</span><br><span class="line">            <span class="keyword">if</span> (user == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> NotFound(<span class="string">$&quot;id=<span class="subst">&#123;id&#125;</span>的User不存在&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            user.SoftDelete();</span><br><span class="line">            <span class="keyword">await</span> context.SaveChangesAsync();</span><br><span class="line">            <span class="keyword">return</span> Ok();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RabbitMQ的基本使用"><a href="#RabbitMQ的基本使用" class="headerlink" title="RabbitMQ的基本使用"></a>RabbitMQ的基本使用</h1><p>和领域事件不同，集成事件用于在微服务间进行事件的传递，因此这是服务器间的通信，所以必须借助于第三方服务器作为事件总线。我们一般使用消息中间件来作为事件总线。明前有Redis、RabbitMQ、Kafka、ActiveMQ等。</p><p>我们先了解RabbitMQ中的几个基本概念。</p><ol><li><p>信道（channel）：信道是消息的生产者、消息者和服务器之间进行通信的虚拟连接。<br>为什么叫“虚拟连接”呢？因此TCP连接的建立是非常消耗资源的，所以RabbitMQ在TCP链接的基础上构建了虚拟通信。我们尽量重复使用TCP连接，而通信是可以用完就关闭的。</p></li><li><p>队列（queue）：队列是用来进行消息收发的地方，生产者把消息放到队列中，消费者从队列中获取消息。</p></li><li><p>交换机（exchange）：交换机用于把消息路由到一个或者多个队列中。</p></li></ol><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>现在让我们生成两个项目，一个用于发布者，一个用于使用者</p><p><img src="/img%5CDDD%5C18.png"></p><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"><span class="keyword">using</span> System.Net.Quic;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接工厂对象，用于配置RabbitMQ连接参数</span></span><br><span class="line"><span class="keyword">var</span> factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.HostName = <span class="string">&quot;localhost&quot;</span>; <span class="comment">// RabbitMQ服务器地址</span></span><br><span class="line">factory.Port = <span class="number">5672</span>;            <span class="comment">// 端口号</span></span><br><span class="line">factory.UserName = <span class="string">&quot;root&quot;</span>;      <span class="comment">// 用户名</span></span><br><span class="line">factory.Password = <span class="string">&quot;root&quot;</span>;      <span class="comment">// 密码</span></span><br><span class="line">factory.VirtualHost = <span class="string">&quot;vhost&quot;</span>;  <span class="comment">// 虚拟主机</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建与RabbitMQ的连接（异步）</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> connection = <span class="keyword">await</span> factory.CreateConnectionAsync();</span><br><span class="line"><span class="comment">// 创建信道（异步），用于与RabbitMQ进行通信</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> channel = <span class="keyword">await</span> connection.CreateChannelAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个名为&quot;hello&quot;的队列，如果不存在则自动创建</span></span><br><span class="line"><span class="comment">// durable: 队列是否持久化，false表示不持久化</span></span><br><span class="line"><span class="comment">// exclusive: 是否排他，false表示允许多个连接访问</span></span><br><span class="line"><span class="comment">// autoDelete: 是否自动删除，false表示不自动删除</span></span><br><span class="line"><span class="comment">// arguments: 其他参数，这里为null</span></span><br><span class="line"><span class="keyword">await</span> channel.QueueDeclareAsync(queue: <span class="string">&quot;hello&quot;</span>, durable: <span class="literal">false</span>, exclusive: <span class="literal">false</span>, autoDelete: <span class="literal">false</span>, arguments: <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要发送的消息内容</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> message = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="comment">// 将消息内容编码为字节数组</span></span><br><span class="line"><span class="keyword">var</span> body = Encoding.UTF8.GetBytes(message);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息到指定队列（exchange为空字符串表示默认交换机）</span></span><br><span class="line"><span class="keyword">await</span> channel.BasicPublishAsync(exchange: <span class="built_in">string</span>.Empty, routingKey: <span class="string">&quot;hello&quot;</span>, body: body);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot; [x] Sent <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot; Press [enter] to exit&quot;</span>);</span><br><span class="line"><span class="comment">// 等待用户按下回车键后退出程序</span></span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure><h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"><span class="keyword">using</span> RabbitMQ.Client.Events;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接工厂对象，用于配置RabbitMQ连接参数</span></span><br><span class="line"><span class="keyword">var</span> factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.HostName = <span class="string">&quot;localhost&quot;</span>; <span class="comment">// RabbitMQ服务器地址</span></span><br><span class="line">factory.Port = <span class="number">5672</span>;            <span class="comment">// 端口号</span></span><br><span class="line">factory.UserName = <span class="string">&quot;root&quot;</span>;      <span class="comment">// 用户名</span></span><br><span class="line">factory.Password = <span class="string">&quot;root&quot;</span>;      <span class="comment">// 密码</span></span><br><span class="line">factory.VirtualHost = <span class="string">&quot;vhost&quot;</span>;  <span class="comment">// 虚拟主机</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建与RabbitMQ服务器的连接</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> connection = <span class="keyword">await</span> factory.CreateConnectionAsync();</span><br><span class="line"><span class="comment">// 在连接的基础上创建一个通道（channel），用于收发消息</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> channel = <span class="keyword">await</span> connection.CreateChannelAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个名为&quot;hello&quot;的队列，如果队列不存在则会自动创建</span></span><br><span class="line"><span class="comment">// durable: false 表示队列在RabbitMQ重启后不会保留</span></span><br><span class="line"><span class="comment">// exclusive: false 表示队列可以被多个连接共享</span></span><br><span class="line"><span class="comment">// autoDelete: false 表示队列在没有消费者时不会自动删除</span></span><br><span class="line"><span class="keyword">await</span> channel.QueueDeclareAsync(queue: <span class="string">&quot;hello&quot;</span>, durable: <span class="literal">false</span>, exclusive: <span class="literal">false</span>, autoDelete: <span class="literal">false</span>, arguments: <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;[*] Waiting for messages&quot;</span>); <span class="comment">// 提示正在等待消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个异步事件消费者，用于接收队列中的消息</span></span><br><span class="line"><span class="keyword">var</span> consumer = <span class="keyword">new</span> AsyncEventingBasicConsumer(channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当收到消息时触发的事件</span></span><br><span class="line">consumer.ReceivedAsync += (model, ea) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取消息的内容（字节数组）</span></span><br><span class="line">    <span class="keyword">var</span> body = ea.Body.ToArray();</span><br><span class="line">    <span class="comment">// 将字节数组转换为字符串</span></span><br><span class="line">    <span class="keyword">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class="line">    <span class="comment">// 打印收到的消息</span></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot; [x] Received <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始消费&quot;hello&quot;队列中的消息，autoAck: true 表示自动确认消息</span></span><br><span class="line"><span class="keyword">await</span> channel.BasicConsumeAsync(<span class="string">&quot;hello&quot;</span>, autoAck: <span class="literal">true</span>, consumer: consumer);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot; Press [enter] to exit.&quot;</span>); <span class="comment">// 提示用户按回车键退出</span></span><br><span class="line">Console.ReadLine(); <span class="comment">// 等待用户输入，防止程序退出</span></span><br></pre></td></tr></table></figure><h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p><img src="/img%5CDDD%5C19.png"></p><p>工作队列（又名：任务队列）背后的主要思想是避免 立即执行资源密集型任务，并且必须等待 它完成。相反，我们将任务安排在稍后完成。我们将任务封装为消息并将其发送到队列。正在运行的 worker 进程 将弹出任务并最终执行 工作。当您运行许多 worker 时，任务将在它们之间共享。</p><p>创建两个项目</p><p>在之前发送项目添加GetMessage方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"><span class="keyword">using</span> RabbitMQ.Client.Events;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接工厂，配置RabbitMQ服务器信息</span></span><br><span class="line"><span class="keyword">var</span> factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.HostName = <span class="string">&quot;localhost&quot;</span>; <span class="comment">// RabbitMQ服务器地址</span></span><br><span class="line">factory.Port = <span class="number">5672</span>;            <span class="comment">// 端口号</span></span><br><span class="line">factory.UserName = <span class="string">&quot;root&quot;</span>;      <span class="comment">// 用户名</span></span><br><span class="line">factory.Password = <span class="string">&quot;root&quot;</span>;      <span class="comment">// 密码</span></span><br><span class="line">factory.VirtualHost = <span class="string">&quot;vhosst&quot;</span>; <span class="comment">// 虚拟主机</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接和通道（Channel）</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> connection = <span class="keyword">await</span> factory.CreateConnectionAsync();</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> channel = <span class="keyword">await</span> connection.CreateChannelAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个持久化队列，名称为task_queue</span></span><br><span class="line"><span class="keyword">await</span> channel.QueueDeclareAsync(</span><br><span class="line">    queue: <span class="string">&quot;task_queue&quot;</span>,    <span class="comment">// 队列名称</span></span><br><span class="line">    durable: <span class="literal">true</span>,          <span class="comment">// 持久化</span></span><br><span class="line">    exclusive: <span class="literal">false</span>,       <span class="comment">// 非独占</span></span><br><span class="line">    autoDelete: <span class="literal">false</span>,      <span class="comment">// 不自动删除</span></span><br><span class="line">    arguments: <span class="literal">null</span>         <span class="comment">// 其他参数</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置每次只分发一个消息给消费者，保证公平分发</span></span><br><span class="line"><span class="keyword">await</span> channel.BasicQosAsync(</span><br><span class="line">    prefetchSize: <span class="number">0</span>,        <span class="comment">// 不限制消息大小</span></span><br><span class="line">    prefetchCount: <span class="number">1</span>,       <span class="comment">// 每次只分发一个消息</span></span><br><span class="line">    <span class="keyword">global</span>: <span class="literal">false</span>           <span class="comment">// 只对当前通道生效</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;[*] Waiting for message&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建异步消费者</span></span><br><span class="line"><span class="keyword">var</span> consumer = <span class="keyword">new</span> AsyncEventingBasicConsumer(channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册接收消息的事件处理方法</span></span><br><span class="line">consumer.ReceivedAsync += <span class="keyword">async</span> (model, ea) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取消息内容</span></span><br><span class="line">    <span class="built_in">byte</span>[] body = ea.Body.ToArray();</span><br><span class="line">    <span class="keyword">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;[x] 接收<span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟耗时操作，根据消息中.的数量决定等待时间</span></span><br><span class="line">    <span class="built_in">int</span> dots = message.Split(<span class="string">&#x27;.&#x27;</span>).Length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(dots * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;[x] Done&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动确认消息已处理</span></span><br><span class="line">    <span class="keyword">await</span> channel.BasicAckAsync(deliveryTag: ea.DeliveryTag, multiple: <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始消费队列中的消息，关闭自动确认</span></span><br><span class="line"><span class="keyword">await</span> channel.BasicConsumeAsync(</span><br><span class="line">    queue: <span class="string">&quot;task_queue&quot;</span>,    <span class="comment">// 队列名称</span></span><br><span class="line">    autoAck: <span class="literal">false</span>,         <span class="comment">// 关闭自动确认</span></span><br><span class="line">    consumer: consumer      <span class="comment">// 消费者对象</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot; Press [enter] to exit.&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure><h2 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布&#x2F;订阅"></a>发布&#x2F;订阅</h2><p><img src="/img%5CDDD%5C20.png"></p><p>在订阅模型中，多了一个Exchange角色，而且过程略有变化：<br>Exchange:交换机（X）。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。如何操作，取决于Exchange的类型。Exchange有常见的以下3种类型：<br>Fanout:广播，将消息交给所有绑定到交换机的队列<br>Direct:定向，把消息交给符合指定routingKey的队列<br>Topic:通配符，把消息交给符合routing pattern（路由模式）的队列</p><p>Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h3 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h3><p>您可能还记得，我们之前使用的队列具有 具体名称（remember 和 ？）。能够命名 队列对我们来说至关重要 —— 我们需要将 worker 指向 相同的队列。在以下情况下，为队列命名非常重要 希望在生成者和使用者之间共享队列。hellotask_queue</p><p>但对于我们的 Logger 来说，情况并非如此。我们想听听所有 日志消息，而不仅仅是其中的一个子集。我们是 也只对当前流淌的消息感兴趣，而不是在旧的消息中 的。要解决这个问题，我们需要两件事。</p><p>首先，每当我们连接到 Rabbit 时，我们都需要一个新的空队列。 为此，我们可以创建一个具有随机名称的队列，或者 更好的是 - 让服务器为我们选择一个随机队列名称。</p><p>其次，一旦我们断开了消费者的连接，队列应该是 自动删除。</p><p>在 .NET 客户端中，当我们不提供任何参数时，我们会创建一个具有生成名称的非持久、独占、自动删除队列：QueueDeclareAsync()</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QueueDeclareOk queueDeclareResult = <span class="keyword">await</span> channel.QueueDeclareAsync();</span><br><span class="line"><span class="built_in">string</span> queueName = queueDeclareResult.QueueName;</span><br></pre></td></tr></table></figure><p>现在我们需要 告诉 Exchange 将消息发送到我们的队列。这种关系 在 exchange 和 queue 之间称为 Binding。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> channel.QueueBindAsync(queue: queueName, exchange: <span class="string">&quot;logs&quot;</span>, routingKey: <span class="built_in">string</span>.Empty);</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接工厂并设置RabbitMQ服务器的相关参数</span></span><br><span class="line"><span class="keyword">var</span> factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.HostName = <span class="string">&quot;localhost&quot;</span>; <span class="comment">// RabbitMQ服务器地址</span></span><br><span class="line">factory.Port = <span class="number">5672</span>;            <span class="comment">// 端口号</span></span><br><span class="line">factory.UserName = <span class="string">&quot;root&quot;</span>;      <span class="comment">// 用户名</span></span><br><span class="line">factory.Password = <span class="string">&quot;root&quot;</span>;      <span class="comment">// 密码</span></span><br><span class="line">factory.VirtualHost = <span class="string">&quot;vhost&quot;</span>;  <span class="comment">// 虚拟主机</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步创建连接</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> connection = <span class="keyword">await</span> factory.CreateConnectionAsync();</span><br><span class="line"><span class="comment">// 异步创建信道（channel）</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> channel = <span class="keyword">await</span> connection.CreateChannelAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个名为&quot;logs&quot;的交换机，类型为Fanout（广播模式）</span></span><br><span class="line"><span class="keyword">await</span> channel.ExchangeDeclareAsync(exchange: <span class="string">&quot;logs&quot;</span>, type: ExchangeType.Fanout);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取要发送的消息内容</span></span><br><span class="line"><span class="keyword">var</span> message = GetMessage(args);</span><br><span class="line"><span class="comment">// 将消息内容编码为字节数组</span></span><br><span class="line"><span class="keyword">var</span> body = Encoding.UTF8.GetBytes(message);</span><br><span class="line"><span class="comment">// 通过交换机发布消息，routingKey为空表示广播</span></span><br><span class="line"><span class="keyword">await</span> channel.BasicPublishAsync(exchange: <span class="string">&quot;logs&quot;</span>, routingKey: <span class="built_in">string</span>.Empty, body: body);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;[x] 发送<span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot; Press [enter] to exit.&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取命令行参数作为消息内容，如果没有参数则发送默认消息</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetMessage</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((args.Length &gt; <span class="number">0</span>) ? <span class="built_in">string</span>.Join(<span class="string">&quot; &quot;</span>, args) : <span class="string">&quot;info:Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在建立连接后，我们声明了 交换。此步骤是必需的，因为发布到不存在的 禁止交换。</p><p>如果还没有队列绑定到 Exchange，则消息将丢失。 但这对我们来说没关系;如果还没有消费者在监听，我们可以安全地丢弃该消息。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"><span class="keyword">using</span> RabbitMQ.Client.Events;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接工厂，设置RabbitMQ服务器的相关参数</span></span><br><span class="line"><span class="keyword">var</span> factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.HostName = <span class="string">&quot;localhost&quot;</span>; <span class="comment">// RabbitMQ服务器地址</span></span><br><span class="line">factory.Port = <span class="number">5672</span>;            <span class="comment">// 端口号</span></span><br><span class="line">factory.UserName = <span class="string">&quot;root&quot;</span>;      <span class="comment">// 用户名</span></span><br><span class="line">factory.Password = <span class="string">&quot;root&quot;</span>;      <span class="comment">// 密码</span></span><br><span class="line">factory.VirtualHost = <span class="string">&quot;vhost&quot;</span>;  <span class="comment">// 虚拟主机</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建与RabbitMQ的连接</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> connection = <span class="keyword">await</span> factory.CreateConnectionAsync();</span><br><span class="line"><span class="comment">// 创建通道，用于与RabbitMQ进行通信</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> channel = <span class="keyword">await</span> connection.CreateChannelAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个名为&quot;logs&quot;的交换机，类型为fanout（广播模式）</span></span><br><span class="line"><span class="keyword">await</span> channel.ExchangeDeclareAsync(exchange: <span class="string">&quot;logs&quot;</span>, type: ExchangeType.Fanout);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个临时队列，队列名称由RabbitMQ自动生成</span></span><br><span class="line">QueueDeclareOk queueDeclareResult = <span class="keyword">await</span> channel.QueueDeclareAsync();</span><br><span class="line"><span class="built_in">string</span> queueName = queueDeclareResult.QueueName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将队列绑定到&quot;logs&quot;交换机，不指定路由键（fanout类型会忽略路由键）</span></span><br><span class="line"><span class="keyword">await</span> channel.QueueBindAsync(queue: queueName, exchange: <span class="string">&quot;logs&quot;</span>, routingKey: <span class="built_in">string</span>.Empty);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;[*] Waiting for logs.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个异步事件消费者，用于接收消息</span></span><br><span class="line"><span class="keyword">var</span> consumer = <span class="keyword">new</span> AsyncEventingBasicConsumer(channel);</span><br><span class="line"><span class="comment">// 注册接收消息的事件处理方法</span></span><br><span class="line">consumer.ReceivedAsync += (model, ea) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取消息体并转换为字符串</span></span><br><span class="line">    <span class="built_in">byte</span>[] body = ea.Body.ToArray();</span><br><span class="line">    <span class="keyword">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot; [X] <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始消费队列中的消息，autoAck=true表示自动确认消息</span></span><br><span class="line"><span class="keyword">await</span> channel.BasicConsumeAsync(queueName, autoAck: <span class="literal">true</span>, consumer: consumer);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot; Press [enter] to exit.&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p><img src="/img%5CDDD%5C21.png"></p><p>队列与交换机的绑定，不能是任意绑定，而是要指定一个RoutingKey<br>消息的发送方在向Exchange发送消息时，也必须指定消息的RoutingKey<br>Exchange不再把消息交给每一个绑定的队列，而是根据消息的RoutingKey进行判断，只有队列的RoutingKey与消息的RoutingKey完全一致，才会接收消息</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接工厂并设置RabbitMQ服务器的相关参数</span></span><br><span class="line"><span class="keyword">var</span> factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.HostName = <span class="string">&quot;localhost&quot;</span>; <span class="comment">// RabbitMQ服务器地址</span></span><br><span class="line">factory.Port = <span class="number">5672</span>;            <span class="comment">// 端口号</span></span><br><span class="line">factory.UserName = <span class="string">&quot;root&quot;</span>;      <span class="comment">// 用户名</span></span><br><span class="line">factory.Password = <span class="string">&quot;root&quot;</span>;      <span class="comment">// 密码</span></span><br><span class="line">factory.VirtualHost = <span class="string">&quot;vhost&quot;</span>;  <span class="comment">// 虚拟主机</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步创建连接</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> connection = <span class="keyword">await</span> factory.CreateConnectionAsync();</span><br><span class="line"><span class="comment">// 异步创建通道</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> channel = <span class="keyword">await</span> connection.CreateChannelAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个名为&quot;direct_logs&quot;的直连交换机</span></span><br><span class="line"><span class="keyword">await</span> channel.ExchangeDeclareAsync(exchange: <span class="string">&quot;direct_logs&quot;</span>, type: ExchangeType.Direct);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日志级别（如info、warning、error），默认为info</span></span><br><span class="line"><span class="keyword">var</span> severity = (args.Length &gt; <span class="number">0</span>) ? args[<span class="number">0</span>] : <span class="string">&quot;info&quot;</span>;</span><br><span class="line"><span class="comment">// 获取要发送的消息内容，默认为&quot;Hello World&quot;</span></span><br><span class="line"><span class="keyword">var</span> message = (args.Length &gt; <span class="number">1</span>) ? <span class="built_in">string</span>.Join(<span class="string">&quot; &quot;</span>, args.Skip(<span class="number">1</span>).ToArray()) : <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="comment">// 将消息内容编码为字节数组</span></span><br><span class="line"><span class="keyword">var</span> body = Encoding.UTF8.GetBytes(message);</span><br><span class="line"><span class="comment">// 发送消息到指定的交换机和路由键（即日志级别）</span></span><br><span class="line"><span class="keyword">await</span> channel.BasicPublishAsync(exchange: <span class="string">&quot;direct_logs&quot;</span>, routingKey: severity, body: body);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot; [x] 发送&#x27;<span class="subst">&#123;severity&#125;</span>:<span class="subst">&#123;message&#125;</span>&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot; Press [enter] to exit.&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"><span class="keyword">using</span> RabbitMQ.Client.Events;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查命令行参数，至少需要一个参数（info、warning 或 error）</span></span><br><span class="line"><span class="keyword">if</span> (args.Length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Error.WriteLine(<span class="string">&quot;Usage:&#123;0&#125; [info] [warning] [error]&quot;</span>,</span><br><span class="line">        Environment.GetCommandLineArgs()[<span class="number">0</span>]);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Press [enter] to exit.&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">    Environment.ExitCode = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接工厂，设置 RabbitMQ 服务器的连接信息</span></span><br><span class="line"><span class="keyword">var</span> factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.HostName = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">factory.Port = <span class="number">5672</span>;</span><br><span class="line">factory.UserName = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">factory.Password = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">factory.VirtualHost = <span class="string">&quot;vhost&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立与 RabbitMQ 的连接和通道（channel）</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> connection = <span class="keyword">await</span> factory.CreateConnectionAsync();</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> channel = <span class="keyword">await</span> connection.CreateChannelAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 direct 类型的交换机，名称为 direct_logs</span></span><br><span class="line"><span class="keyword">await</span> channel.ExchangeDeclareAsync(exchange: <span class="string">&quot;direct_logs&quot;</span>, type: ExchangeType.Direct);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个临时队列，队列名称由 RabbitMQ 自动生成</span></span><br><span class="line"><span class="keyword">var</span> queueDeclareResult = <span class="keyword">await</span> channel.QueueDeclareAsync();</span><br><span class="line"><span class="built_in">string</span> queueName = queueDeclareResult.QueueName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将队列绑定到交换机上，使用命令行参数作为路由键</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span>? severity <span class="keyword">in</span> args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> channel.QueueBindAsync(queue: queueName, exchange: <span class="string">&quot;direct_logs&quot;</span>, routingKey: severity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot; [*] Waitiy for messages.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建异步消费者，接收消息时触发事件</span></span><br><span class="line"><span class="keyword">var</span> consumer = <span class="keyword">new</span> AsyncEventingBasicConsumer(channel);</span><br><span class="line">consumer.ReceivedAsync += (model, ea) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取消息体并转换为字符串</span></span><br><span class="line">    <span class="keyword">var</span> body = ea.Body.ToArray();</span><br><span class="line">    <span class="keyword">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class="line">    <span class="keyword">var</span> routingKey = ea.RoutingKey;</span><br><span class="line">    <span class="comment">// 打印收到的消息和路由键</span></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot; [x] Received &#x27;<span class="subst">&#123;routingKey&#125;</span>:<span class="subst">&#123;message&#125;</span>&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始消费队列中的消息，自动确认消息</span></span><br><span class="line"><span class="keyword">await</span> channel.BasicConsumeAsync(queueName, autoAck: <span class="literal">true</span>, consumer: consumer);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot; Press [enter] to exit.&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure><p>如果您只想保存 ‘warning’ 和 ‘error’ （而不是 ‘info’） 日志 messages 添加到文件中，只需打开控制台并键入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet run info warning error</span><br></pre></td></tr></table></figure><h1 id="NET中简化DDD集成事件的框架"><a href="#NET中简化DDD集成事件的框架" class="headerlink" title=".NET中简化DDD集成事件的框架"></a>.NET中简化DDD集成事件的框架</h1><p>使用Zack.EventBus，并简化了以后迁移到其他MQ服务器的工作量。</p><ol><li><p>创建两个ASP.NET Core Web API项目，它们分别是发布集成事件的项目和消费集成事件的项目，然后我们为这两个项目都安装NuGe包：Zack.EventBus.</p></li><li><p>我们在配置系统下创建一个名字为EventBus的节点，节点下包含HostName、ExchangName两个属性，它们分别代表RabbitMQ服务器的地址和交换机的名字。</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Logging&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;LogLevel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Microsoft.AspNetCore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Warning&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;AllowedHosts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;EventBus&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;HostName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ExchangName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;EventBusDemo1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在两个项目中的Prgram.cs文件中的builder.Build()上面增加对IntegrationEventRabbitMQOptions进行配置的代码以及对AddEventBus的调用，然后还要在builder.Build()下面调用UseEventBus()。</li></ol><p>发送者</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从配置文件中获取名为&quot;EventBus&quot;的配置节</span></span><br><span class="line"><span class="keyword">var</span> eventBusSec = builder.Configuration.GetSection(<span class="string">&quot;EventBus&quot;</span>);</span><br><span class="line"><span class="comment">// 将&quot;EventBus&quot;配置节绑定到IntegrationEventRabbitMQOptions对象，用于后续依赖注入</span></span><br><span class="line">builder.Services.Configure&lt;IntegrationEventRabbitMQOptions&gt;(eventBusSec);</span><br><span class="line"><span class="comment">// 注册事件总线服务，指定队列名称为&quot;EventBusDemo1_Q1&quot;，并扫描当前程序集中的事件处理器</span></span><br><span class="line">builder.Services.AddEventBus(<span class="string">&quot;EventBusDemo1_Q1&quot;</span>, Assembly.GetExecutingAssembly());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"><span class="comment">// 启用事件总线中间件，自动订阅和处理集成事件</span></span><br><span class="line">app.UseEventBus();</span><br></pre></td></tr></table></figure><p>接收者</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eventBusSec = builder.Configuration.GetSection(<span class="string">&quot;EventBus&quot;</span>);</span><br><span class="line">builder.Services.Configure&lt;IntegrationEventRabbitMQOptions&gt;(eventBusSec);</span><br><span class="line">builder.Services.AddEventBus(<span class="string">&quot;EventBusDemo1_Q2&quot;</span>,Assembly.GetExecutingAssembly());</span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line">app.UseEventBus();</span><br></pre></td></tr></table></figure><p>这两个项目代码几乎一样，只有调用的AddEventBus方法的第一个参数queueName的值不一样，因为这个参数用来设定程序绑定的队列的名字，一般每个微服务项目的queueName参数值都不同，一边每个程序都能收到消息。对于同一个微服务的多个部署的集群实例，我们一般设置它们的queueName参数值相同，这样对于同一个消息，同一个微服务项目只有一个集群实例收到该消息，这符合大部分项目的需求。如果需要同一个微服务项目的每个集群实例都收到消息，则需要把每个集群实例的queueName参数值设置为不同的值，比如在原有的queueName后面再附加机器名、IP地址等集群内的唯一标识信息。</p><p>AddEventBus方法的第二个参数为含有监听集成事件的处理者代码的程序集。</p><ol start="4"><li>我们在需要发布领域事件的类中注入IEventBus服务，然后调用IEventBus的Publish方法发布消息。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 事件总线接口，用于发布和订阅事件</span></span><br><span class="line">    <span class="keyword">private</span> IEventBus eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过依赖注入获取事件总线实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoController</span>(<span class="params">IEventBus eventBus</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 HTTP POST 请求触发该方法，发布一个名为 &quot;UserAdded&quot; 的事件</span></span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Publish</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发布事件，事件名为 &quot;UserAdded&quot;，携带用户信息（用户名和年龄）</span></span><br><span class="line">        eventBus.Publish(<span class="string">&quot;UserAdded&quot;</span>, <span class="keyword">new</span> &#123; UserName = <span class="string">&quot;YOUXIANYU&quot;</span>, Age = <span class="number">19</span> &#125;);</span><br><span class="line">        <span class="comment">// 返回操作结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>我们创造一个实现了IIntegrationEventHandler接口的类，这个类用来处理收到的事件。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件名称为 &quot;UserAdded&quot;，用于标识该事件处理器处理的是用户新增事件</span></span><br><span class="line">[<span class="meta">EventName(<span class="string">&quot;UserAdded&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserAddesEventHandler</span> : <span class="title">IIntegrationEventHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 日志记录器，用于输出日志信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;UserAddesEventHandler&gt; logger;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，通过依赖注入获取日志记录器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserAddesEventHandler</span>(<span class="params">ILogger&lt;UserAddesEventHandler&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理事件的方法</span></span><br><span class="line">    <span class="comment">// eventName: 事件名称</span></span><br><span class="line">    <span class="comment">// eventData: 事件数据（这里一般是新用户的信息）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">Handle</span>(<span class="params"><span class="built_in">string</span> eventName, <span class="built_in">string</span> eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 记录一条日志，表示新建了一个用户，并输出用户相关数据</span></span><br><span class="line">        logger.LogInformation(<span class="string">&quot;新建了用户：&quot;</span> + eventData);</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
            <tag> DDD </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何安装RabbitMQ服务器</title>
      <link href="/2025/05/22/DDD/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85RabbitMQ/"/>
      <url>/2025/05/22/DDD/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="在Windows安装RabbitMQ"><a href="#在Windows安装RabbitMQ" class="headerlink" title="在Windows安装RabbitMQ"></a>在Windows安装RabbitMQ</h1><h3 id="安装RabbitMQ需要安装Erlang环境-网址：Downloads-Erlang-OTP"><a href="#安装RabbitMQ需要安装Erlang环境-网址：Downloads-Erlang-OTP" class="headerlink" title="安装RabbitMQ需要安装Erlang环境,网址：Downloads - Erlang&#x2F;OTP"></a>安装RabbitMQ需要安装Erlang环境,网址：Downloads - Erlang&#x2F;OTP</h3><p><img src="/img%5CDDD%5C5.png"></p><p>下载对应的版本<br>RabbitMQ Erlang Version Requirements — RabbitMQ<br><img src="/img%5CDDD%5C6.png"></p><h3 id="配置Erlang环境变量"><a href="#配置Erlang环境变量" class="headerlink" title="配置Erlang环境变量"></a>配置Erlang环境变量</h3><ol><li><p>在搜索框里输入编辑系统环境变量.</p></li><li><p>变量名一定要写成ERLANG_HOME，变量值就是你的Erlang的安装路径</p></li></ol><p><img src="/img%5CDDD%5C7.png"></p><ol start="3"><li><p>还需要在系统变量中选中Path进行编辑，新建一个%ERLANG_HOME%\bin<br><img src="/img%5CDDD%5C8.png"></p></li><li><p>打开命令窗口，输入erl或者erl -version()验证环境是否配置成功（出现以下版本号即成功，显示不是内部命令则环境变量配置失败）</p></li></ol><p><img src="/img%5CDDD%5C9.png"></p><h1 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h1><ol><li>RabbitMQ官网下载址：Installing on Windows — RabbitMQ</li></ol><p><img src="/img%5CDDD%5C10.png"></p><ol start="2"><li>配置RabbitMQ环境变量</li></ol><p><img src="E:\blog\themes\butterfly\source\img\DDD\11.png"></p><p><img src="/img%5CDDD%5C12.png"></p><ol start="3"><li>进入sbin文件下，打开命令窗口输入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure></li></ol><p><img src="/img%5CDDD%5C13.png"></p><ol start="4"><li>点击rabbit_server.bat,启动rabbitMQ</li></ol><p><img src="/img%5CDDD%5C14.png"></p><ol start="5"><li>最后输入<a href="http://localhost:15672/%EF%BC%88%E9%BB%98%E8%AE%A4%E8%B4%A6%E5%8F%B7%EF%BC%9Aguest%EF%BC%8C%E5%AF%86%E7%A0%81%EF%BC%9Aguest%EF%BC%89%E5%B0%B1%E8%83%BD%E8%BF%9B%E5%85%A5RabbitMQ%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2">http://localhost:15672/（默认账号：guest，密码：guest）就能进入RabbitMQ管理界面</a></li></ol><p><img src="/img%5CDDD%5C15.png"></p><ol start="6"><li>添加用户</li></ol><p><img src="/img%5CDDD%5C16.png"></p>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET Core的聚合，MediatR实现领域事件</title>
      <link href="/2025/05/20/DDD/%E8%81%9A%E5%90%88%E5%9C%A8NET%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/05/20/DDD/%E8%81%9A%E5%90%88%E5%9C%A8NET%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="聚合在-NET中的实现"><a href="#聚合在-NET中的实现" class="headerlink" title="聚合在.NET中的实现"></a>聚合在.NET中的实现</h1><p>上下文可以从数据库中查询出数据并且跟踪对象状态的改变，然后把对象状态的改变保存到数据库中，因此上下文就是一个天然的仓储的实现；上下文会跟踪多个对象状态的改变，让后在SaveChanges方法中把所有的改变一次性提交到数据库中，这是个“要么全部成功，要么全部失败”的操作，因此上下文也是一个天然的工作单元的实现。</p><p>有一些开发人员会再编写仓储和工作单元的接口以封装上下文的操作，这样可以把EF Core的操作封装起来，不仅可以让代码不依赖于EF Core，而且今后如果我们需要把EF Core替换为其他持久化机制，代码切换起来也会更容易。但是本书将直接用上下文作为仓储，而不是定义一个仓储的抽象层，微软也是这样建议的。因为EF Core是一个很好的仓储和工作单元的实现框架，很难找到另一款可以很好实现DDD的ORM框架，无论抽象层怎么定义，如果需要把EF Core替换为其他ORM框架，代码就不可能不做任何改变。我们直接用上下文做仓储，这样可以最大化地利用EF Core的特性，从而提供更高性能的仓储实现。</p><p>在EF Core中，我们可以不为每个实体类都声明对应的DbSet类型的属性，即使一个实体类没有声明对应的DbSet类型的属性，只要EF Core遇到实体类对象，EF Core仍然会像对待其他实体类对象一样对其进行处理。由于除了聚合根实体类之外，聚合中其他实体雷不应该被开发人员访问到，因此我们可以在上下文中只为聚合根实体类声明DbSet类型的属性。</p><ol><li>聚合关系的基本实现<br>聚合关系通过引用类型成员变量实现，子对象的生命周期不由父对象控制。例如：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子对象：可以独立存在</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">string</span> name</span>)</span> =&gt; Name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父对象：通过引用“聚合”子对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Department</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> DepartmentName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Employee _manager; <span class="comment">// 部门经理（聚合关系）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Department</span>(<span class="params"><span class="built_in">string</span> name, Employee manager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DepartmentName = name;</span><br><span class="line">        _manager = manager; <span class="comment">// 注入已存在的 Employee 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>集合聚合示例<br>父对象可以聚合多个子对象，例如一个团队包含多个成员：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Team</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TeamName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> List&lt;Employee&gt; _members = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Team</span>(<span class="params"><span class="built_in">string</span> name</span>)</span> =&gt; TeamName = name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加成员（子对象）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddMember</span>(<span class="params">Employee employee</span>)</span> =&gt; _members.Add(employee);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除成员（子对象不会被销毁）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveMember</span>(<span class="params">Employee employee</span>)</span> =&gt; _members.Remove(employee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>与组合关系的对比<br>组合（Composition）是更强的 “拥有” 关系，子对象的生命周期由父对象控制。例如：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Engine _engine; <span class="comment">// 组合关系</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _engine = <span class="keyword">new</span> Engine(); <span class="comment">// 父对象创建并管理子对象生命周期</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父对象销毁时，子对象也会被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Engine</span> &#123; &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>聚合的实际应用场景<br>依赖注入（DI）：通过构造函数注入依赖对象（聚合关系）。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IUserRepository _repository; <span class="comment">// 聚合关系</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span>(<span class="params">IUserRepository repository</span>) <span class="comment">// 注入已存在的仓储实例</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        _repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据模型聚合：例如订单聚合多个订单项。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> OrderId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;OrderItem&gt; Items &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span>(); <span class="comment">// 聚合多个订单项</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderItem</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>总结<br>聚合：通过引用关联对象，子对象可独立存在，生命周期不由父对象管理。<br>组合：子对象不可独立存在，父对象负责创建和销毁子对象。</p><p>还有一个问题需要讨论，如果一个微服务中有多个聚合根，那么我们是把每个聚合根实体类放到一个单独的上下文中，还是把所有实体类放到同一个上下文中？前者的优点是上下文的耦合度更低，聚合根之间的界限划分更清晰，缺点就是开发起来比较麻烦，而且实现跨聚合查询的时候也比较麻烦；后者的优点是开发难度低，跨聚合查询也简单，缺点就是聚合根在上下文里有一个定程度的耦合，我们无法很容易地看到聚合的划分。后者，也就是把同一个微服务中的所有实体类都放到同一个上下文中，因为虽然聚合之间的关系不紧密，但是它们毕竟属于同一个微服务，它们之间的关系仍然比它们和其他微服务之间的关系更紧密，而且我们还会在应用服务中进行跨聚合的组合操作，如果参与应用服务的组合操作的聚合都属于同一个上下文，我们再进行联合查询的时候可以获得更好的性能，再进行跨聚合的数据修改的保存的时候，也能更容易地实现强一致性的事务。当让，如果经过良好的微服务拆分设计之后，一个微服务中的部分聚合和其他聚合的关系仍然不紧密，我们也可以把它们放到不同的上下文中。</p><p>如果选择了把一个微服务中所有聚合中的实体类都放到同一个上下文中，为了区分聚合根实体类和其他实体类，我们可以定义一个不包含任何成员的标识接口，比如IAggregateRoot，然后要求所有的聚合根实体类都实现这个接口。</p><p>由于聚合之间是松耦合关系，它们只通过聚合根的Id进行关联，因此所有跨聚合的数据查询都应该是通过领域服务的协议来完成的，而不应该直接在数据库表之间进行jojn查询。当然，对于统计、汇总等报表类的应用，则不需要遵循聚合的规范，我们可以通过执行原生SQL语句进行跨表查询。</p><h2 id="实体类不要面向数据库建模"><a href="#实体类不要面向数据库建模" class="headerlink" title="实体类不要面向数据库建模"></a>实体类不要面向数据库建模</h2><ol><li><p>建模的时候不要先考虑实体在数据库中如何保存。比如实体类和数据表具有直接的对应关系，实体类中属性和数据表中的列几乎完成一致。这样设计出来的类称不上“实体类”，只能被成为数据对象（Data Object）。更不要用DB First（反向工程）。</p></li><li><p>因该不考虑数据库实现的情况下进行领域模型建模，然后再使用Fluent API等对实体类和数据库之间做适配。在实现的时候，可能需要对建模进行妥协性修改，但是这不应该在最开始被考虑。</p></li></ol><h1 id="用MediatR实现领域事件"><a href="#用MediatR实现领域事件" class="headerlink" title="用MediatR实现领域事件"></a>用MediatR实现领域事件</h1><p>第一步，创建一个ASP.NET Core项目，然后通过NuGet安装MediatR。<br>第二步，在项目的Program.cs中调用AddMediatR方法把与MediatR相关的服务注册到依赖注入容器中，AddMediatR方法的参数中一般指定事件处理者所在的若干个程序集。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddMediatR(cfg =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    cfg.RegisterServicesFromAssembly(<span class="keyword">typeof</span>(Program).Assembly);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第三步，定义一个在事件的发布者和处理者之间进行数据传递的类TestEvent，这个类需要实现INotification接口。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">TestEvent</span>(<span class="params"><span class="built_in">string</span> UserName</span>):INotification</span>;</span><br></pre></td></tr></table></figure><p>TestEvent中的UserName属性代表登录用户名。事件一般都是从发布者传递到处理者的，很少有在事件的处理者处直接反向通知事件发布者的需求，因此实现INotification的TestEvent类的属性一般都是不可变的，我们用record与发来声明这个类。</p><p>第四步，事件的处理者要实现NotificationHandler&lt;TNotification&gt;接口，其中的泛型参数TNotification代表此事件处理者要处理的消息类型。所有TNotification类型的事件都会被事件处理者处理。我们编写两个事件处理者，它们分别把收到的事件输出到控制台和写入文件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestEventHandler1</span> : <span class="title">INotificationHandler</span>&lt;<span class="title">TestEvent</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">Handle</span>(<span class="params">TestEvent notification, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;我收到了<span class="subst">&#123;notification.UserName&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestEventHandler2</span> : <span class="title">INotificationHandler</span>&lt;<span class="title">TestEvent</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Handle</span>(<span class="params">TestEvent notification, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> File.WriteAllTextAsync(<span class="string">&quot;D:/SqlServer.txt&quot;</span>, <span class="string">$&quot;来了<span class="subst">&#123;notification.UserName&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，在需要发布事件的类中注入IMediator类型的服务，然后我们调用Publish方法来发布。注意不要错误地调用Send方法来发布事件，因此Send方法是用来发布一对一事件的，而Publish方法是用来发布一对多事件的。我们需要在控制器的登陆方法中发布事件，这里我们省略实际的登陆代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestController</span>(<span class="params">IMediator mediator</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Login</span>(<span class="params">TestEvent req</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> mediator.Publish(<span class="keyword">new</span> TestEvent(req.UserName));</span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img%5CDDD%5C4.png"></p>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET Core的DDD实战-EF Core中实现值对象</title>
      <link href="/2025/05/19/DDD/EFCore%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%80%BC%E5%AF%B9%E8%B1%A1/"/>
      <url>/2025/05/19/DDD/EFCore%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%80%BC%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="EF-Core中实现值对象"><a href="#EF-Core中实现值对象" class="headerlink" title="EF Core中实现值对象"></a>EF Core中实现值对象</h1><p>在定义实体类的时候，实体类中的一些属性之间有着紧密的联系，比如我们要在表示城市的实体类City中定义表示地理位置的属性，因为地理位置包含“经度”（longitude）和“纬度”（latitude）两个值，所以我们可以为City类增加Longitude、Latitude两个属性。这也是大部分人的做法，这样做没什么太大的问题。不过，从逻辑上来讲，这样定义的经纬度和主键、名字等属性之间是平等的关系，体现不出来经度和纬度的紧密关系。如果我们能定义一个包含Longitude、Latitude两个属性的Geo类型，然后把City的“地理位置”属性定义为Geo类型，这样经度、纬度的关系就更紧密了。Geo类型的Longitude、Latitude两个属性通常不会被单独修改，因此Geo被定义成不可变类，也就是值对象。</p><p>在定义实体类的时候，实体类中有的属性为数值类型，比加“商品”实体类中的质量属性。我们如果把质量定义为double类型，<br>那么其实隐含了一个“质量单位”的领域知识，使用这个实体类的开发人员就需要知道这个领域知识,而且我们还要通过文档形式把这个领域知识记录下来，这又面临一个文档和代码修改同步的问题、在DDD中，我们要尽减少文档中不必要的领域知识。如果我们定义一个包含value(数值)、Unit(质量单位)的Weight类型,然后把“商品”的质量属性设置为weipht类型，这样的代码中天然包含了数值和质量单位信息。在定义实体类的时候，很多数值类型的属性其实都是隐含了单位的，比如金额隐含了币种信息。理想情况下，这些数值类型的属性都应该定义为包含了计量单位信息的类型。这些包数值和计量单位的类也一般被定义为不可变的值对象。</p><p>我们在编写实体类的时候，有一些属性的可选值范围是固定的，比如“员工”中用来定义职位级别的属性为int类型，可选范围为1~3，它们分别表示“初级”“中级”“高级”。我们用int类型表示级别，因此我们同样需要在文档中说明不同数值的含义。如果我们用C#中的枚举类型来表示这些固定可选值范围的属性，就可以让代码的可读性更强，也就更加符合DDD的思想。</p><p>EF Core 中提供了对于没有标识符的值对象进行映射的功能,那就是“从属实体类”(ownedentities)类型，我们只要在主实体类中声明从属实体类型的属性，然后使用FluentAP中的OwnsOne 等方法来配置。</p><p>在EFCore中，实体类的属性可以定义为枚举类型，枚举类型的属性在数据库中默认是以int类型来保存的。对于直接操作数据库的人员来讲，0、1、2这样的值没有“CNY”(人民币)、“USD”(美元)、“NZD”(新西兰元)等这样的 string 类型的值可读性强。EFCore 中可以在FluentAPI中用HasConversion<string>把枚举类型的值配置成字符串。</p><p>我们通过“地区”实体类Region来举例。一个省、一个市等都可以表示为一个地区，Region类含有Name(名字)、Area(面积)、Level(级别)、Population(总人口)、Location(地理行置)等属性:Name 中既包含中文名字，也包含英文名字，因此我们把它们定义到MultilingualSting 值对象中;Area 定义为包含Value(数值)、Unit(计量单位)两个属性的Area 类型:Location 定义为包含 Longitude(经度)、Latitude(纬度)两个属性的 Geo 类型.Level定义为包含 Province(省)、City(市)、County(县)、Town(镇)几个可选值的枚举类型RegionLevel。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 表示具有相关元数据（如名称、面积、人口和位置）的地理区域。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span>这个 <span class="doctag">&lt;see cref=&quot;Region&quot;/&gt;</span> 类提供了一种建模地理区域的方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>对其名称、定义区域、人口数据和特定位置的多语言支持。它还包括</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>分层级别对区域进行分类。此类的实例对于大多数属性都是不可变的，除了</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;see cref=&quot;Population&quot;/&gt;</span> 与 <span class="doctag">&lt;see cref=&quot;Level&quot;/&gt;</span>, 其可以使用所提供的方法进行更新。<span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Region</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> MultilingualString Name&#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> Area Area&#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> RegionLevel Level&#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span>? Population &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> Geo Location&#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Region</span>()</span> &#123; &#125;<span class="comment">//给EFCore从数据库中加载数据然后生成User对象返回用的</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Region</span>(<span class="params">MultilingualString name, Area area,Geo location,RegionLevel level</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Name= name;</span><br><span class="line">            <span class="keyword">this</span>.Area= area;</span><br><span class="line">            <span class="keyword">this</span>.Level= level;</span><br><span class="line">            <span class="keyword">this</span>.Location= location;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangePopulation</span>(<span class="params"><span class="built_in">long</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Population= <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeLevel</span>(<span class="params">RegionLevel <span class="keyword">value</span></span>)</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">this</span>.Level= <span class="keyword">value</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Region类Name、Area、Location都是不变的，因此我们把Id、Name、Area、Location属性设置为init;Level和Population是不变的，因此Level和Population属性设置为private set。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 实现多语言</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;Chinese&quot;&gt;</span>汉语<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;English&quot;&gt;</span>英语<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">record</span> <span class="title">MultilingualString</span>(<span class="params"><span class="built_in">string</span> Chinese, <span class="built_in">string</span>? English</span>)</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 表示具有指定值和单位的面积测量。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span>该记录封装了一个面积测量，包括其数值和单位测量。它是不变的，可以用来表示不同单位的面积，如平方米或平方英尺。<span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;Value&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;Unit&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="keyword">record</span> <span class="title">Area</span>(<span class="title">double</span> <span class="title">Value</span>, <span class="title">AreaType</span> <span class="title">Unit</span>);</span><br><span class="line">    <span class="built_in">enum</span> AreaType&#123;SquareKM, Hectare, CnMu&#125;; <span class="comment">//平方公里、公顷、市亩</span></span><br><span class="line">    <span class="built_in">enum</span> RegionLevel &#123; Province,City,County,Town&#125;;<span class="comment">//省、市、县、镇</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 代表具有指定纬度和经度的地理坐标。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span>这个 <span class="doctag">&lt;see cref=&quot;Geo&quot;/&gt;</span> 记录是不可变的，并确保纬度和经度值在有效范围内：</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;list type=&quot;bullet&quot;&gt;</span> <span class="doctag">&lt;item&gt;</span><span class="doctag">&lt;description&gt;</span>经度必须介于-180和180之间度。<span class="doctag">&lt;/description&gt;</span><span class="doctag">&lt;/item&gt;</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;item&gt;</span><span class="doctag">&lt;description&gt;</span>纬度必须介于-90和90之间度。<span class="doctag">&lt;/description&gt;</span><span class="doctag">&lt;/item&gt;</span> <span class="doctag">&lt;/list&gt;</span><span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">    <span class="keyword">record</span> <span class="title">Geo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> Longitude &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> Latitude &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Geo</span>(<span class="params"><span class="built_in">double</span> Longitude, <span class="built_in">double</span> Latitude</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Longitude &lt; <span class="number">-180</span> || Longitude &gt; <span class="number">180</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;longitude invalid&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Latitude &lt; <span class="number">-90</span>|| Latitude &gt; <span class="number">90</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;longitude invalid&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.Longitude = Longitude;</span><br><span class="line">            <span class="keyword">this</span>.Latitude = Latitude;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MultilingualString、AreaType都是以整体出现的，因此我们把它们通过record定义为不可变类型。从属实体类型并不要求必须为不可变类型，不过我们一般都把它们定义为不可变类型，这样能够提供更清晰的语义。</p><p>我们还需要通过Fluent API来对Region中的枚举类型以及从属实体类型进行配置。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 区域实体的EF Core配置类，配置了Area、Location、Level和Name等值对象属性的映射规则。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">RegionConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Region</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 为配置实体类型<span class="doctag">&lt;see cref=&quot;Region&quot;/&gt;</span> 类.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span>此方法定义了<span class="doctag">&lt;see cref=&quot;Region&quot;/&gt;</span> 实体，包括</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>拥有类型和属性约束。它指定了 <span class="doctag">&lt;c&gt;</span>Area<span class="doctag">&lt;/c&gt;</span>,</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;c&gt;</span>Location<span class="doctag">&lt;/c&gt;</span>, <span class="doctag">&lt;c&gt;</span>Level<span class="doctag">&lt;/c&gt;</span>, and <span class="doctag">&lt;c&gt;</span>Name<span class="doctag">&lt;/c&gt;</span> 属性 <span class="doctag">&lt;see cref=&quot;Region&quot;/&gt;</span> 实体.<span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;builder&quot;&gt;</span>这个 <span class="doctag">&lt;see cref=&quot;EntityTypeBuilder&#123;TEntity&#125;&quot;/&gt;</span> 用于配置 <span class="doctag">&lt;see cref=&quot;Region&quot;/&gt;</span> 实体.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Region&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            builder.OwnsOne(c =&gt; c.Area, nb =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                nb.Property(e =&gt; e.Unit).HasMaxLength(<span class="number">20</span>)</span><br><span class="line">                .IsRequired(<span class="literal">true</span>).HasConversion&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">            &#125;);</span><br><span class="line">            builder.OwnsOne(c =&gt; c.Location);</span><br><span class="line">            builder.Property(c=&gt;c.Level).HasMaxLength(<span class="number">20</span>)</span><br><span class="line">                .IsRequired(<span class="literal">true</span>).HasConversion&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">            builder.OwnsOne(c =&gt; c.Name, nb =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                nb.Property(e =&gt; e.English).HasMaxLength(<span class="number">20</span>).IsRequired(<span class="literal">true</span>);</span><br><span class="line">                nb.Property(e =&gt; e.Chinese).HasMaxLength(<span class="number">20</span>).IsRequired(<span class="literal">true</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用 wns0ne对从属实体类型属性进行配置。默认情况下，EFCore 将会按照约定对从属实体类型属性进行配置，如第9行代码所示;如果我们需要对从属实体类型属性进行自定义配置，可以像第5<del>8行代码以及第12</del>15 行代码那样在 OwnsOne 方法的第二个参数中进个配置。为了让枚举类型在数据库中映射为sting类型而不是默认的int类型，我们在第7行代码和第11行代码分别对于实体类Region以及从属实体类型Area中的枚举类型性HasConversion<string>方法进行配置。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyDbContext ctx = <span class="keyword">new</span> MyDbContext();</span><br><span class="line"></span><br><span class="line">MultilingualString name1 = <span class="keyword">new</span> MultilingualString(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;BeiJing&quot;</span>);</span><br><span class="line">Area areal = <span class="keyword">new</span> Area(<span class="number">16410</span>, AreaType.SquareKM);</span><br><span class="line">Geo loc = <span class="keyword">new</span> Geo(<span class="number">116.4074</span>, <span class="number">39.9042</span>);</span><br><span class="line">Region c1 = <span class="keyword">new</span> Region(name1, areal, loc, RegionLevel.Province);</span><br><span class="line">c1.ChangePopulation(<span class="number">21893100</span>);</span><br><span class="line">ctx.Regions.Add(c1);</span><br><span class="line">ctx.SaveChanges();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET Core的DDD的技术落实</title>
      <link href="/2025/05/17/DDD/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/05/17/DDD/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="贫血模型与充血模型"><a href="#贫血模型与充血模型" class="headerlink" title="贫血模型与充血模型"></a>贫血模型与充血模型</h1><p>在面向对象的设计中有贫血模型与充血模型两种风格。所谓的贫血模型指的是一个类中只有属性或者成员变量，没有方法，而充血模型指的是一个类中既有属性、成员变量，也有方法。</p><p>假设我们需要定义一个类，这个类中可以保存用户的用户名、密码就、积分；用户必须具有用户名；为了保证安全，密码采用密码的哈希值保存；用户的初始积分为10;每次登录成功奖励5个积分，每次登录失败扣3个积分（这样的需求肯定是不合理的）</p><h2 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a>贫血模型</h2><p>逻辑代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> UserName&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;<span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PasswordHash &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;<span class="comment">//密码的散列值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Credit &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;<span class="comment">//积分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个典型的只包含属性、不包含逻辑方法的类，这样的类通常被叫作POCO类，这就是典型的“贫血模型”。使用这样的类，我们编写代码来进行用户创建、登录、积分变动操作</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">User u1=<span class="keyword">new</span> User();</span><br><span class="line">u1.UserName=<span class="string">&quot;YOUXIANYU&quot;</span>;</span><br><span class="line">u1.Credit=<span class="number">10</span>;</span><br><span class="line">u1.PasswordHash=HashHelper.Hash(<span class="string">&quot;123456&quot;</span>);<span class="comment">//计算密码的散列值</span></span><br><span class="line"><span class="built_in">string</span> pwd = Console.RedLine();</span><br><span class="line"><span class="keyword">if</span>(HashHelper.Hash(pwd)==u1.PasswordHash)</span><br><span class="line">&#123;</span><br><span class="line">    u1.Credit+=<span class="number">5</span>;<span class="comment">//登录增加5积分</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;登陆成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(u1.Credit&lt;<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;积分不足，无法扣减&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        u1.Credit-=<span class="number">3</span>;<span class="comment">//登录失败，则扣除3积分</span></span><br><span class="line">        Console.WiteLine(<span class="string">&quot;登录失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四行代码中，调用HashHelper.Hash方法来计算字符串的哈希值；第五行代码中，等待用户输入一个密码，以便进行密码正确性的检查。上面的代码可以正常地实现需求，但又如下问题。</p><ol><li>一个User对象必须具有用户名，但是在第一行代码中创建的User类的对象的UserName属性为null。虽然我们很快在第二行代码中给UserName赋值了，但是如果User类使用不当，User类的对象有可能处于非法状态。</li><li>“用户的初始积分为10”这样的领域知识是由使用者在第三行代码中设定的，而不是由User类内化的行为。</li><li>“保存用户密码的哈希值”这样的User类内部的领域知识需要类的使用者了解，这样类的使用者才能在第四行代码和第6行代码完成设置密码及判断用户输入的密码是否正确。</li><li>用户的积分余额很显然不能为负值，因此我们在地13~21行代码中进行积分扣减的时候进行了判断，可是这样的行为应该封装到User类中，而不应该由User类的使用者进行判断。</li></ol><h2 id="充血模型"><a href="#充血模型" class="headerlink" title="充血模型"></a>充血模型</h2><p>面向对象的基本特征是：“封装性”：把类的内部实现细节封装起来，对外提供可供安全调用的方法，从而让类的使用无须关心类的内部实现。一个类中核心的元素是数据和行为，数据指的是类的属性或者成员变量，而行为指的是类的方法。而我们设计的User类只包含数据，不包含行为，我们用心设计的类只能利用面向对象编程的一部分能力。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? UserName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Credit &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? PasswordHash;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span>(<span class="params"><span class="built_in">string</span> userName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.UserName = userName;</span><br><span class="line">        <span class="keyword">this</span>.Credit = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangePassword</span>(<span class="params"><span class="built_in">string</span> newValue</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue.Length &gt; <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;密码太短&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.PasswordHash = newValue;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CheckPassword</span>(<span class="params"><span class="built_in">string</span> password</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> hash = password;</span><br><span class="line">        <span class="keyword">return</span> password == hash; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeductCredits</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Credit &lt;<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;额度不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;额度不能为负值&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.Credit-= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddCredits</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Credit += delta;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">User u1 = <span class="keyword">new</span> User(<span class="string">&quot;YOUXIANYU&quot;</span>);</span><br><span class="line">u1.ChangePassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="built_in">string</span>? pwd = Console.ReadLine();</span><br><span class="line"><span class="keyword">if</span> (u1.CheckPassword(pwd))</span><br><span class="line">&#123;</span><br><span class="line">    u1.AddCredits(<span class="number">5</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;登陆成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    u1.DeductCredits(<span class="number">3</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，User类的使用者的工作量少了很多，他们需要了解的领域知识也少了很多，</p><p>有的读者可能认为，无论是贫血模型还是充血模型，只不过是逻辑代码放置的位置不一样而已，本质上没有什么区别。这样的观点是错误的。首先，从代码的角度来讲，把本应该属于User类的行为封装到User类中，这是符合单一职责原则的，当系统中其他地方需要调用User类的时候就可以复用User类中的方法了，其次，贫血模型是站在开发人员角度思考问题的，而充血模型是站在业务角度思考问题的。领域专家不明白什么是 “把用户输入的密码进行哈希运算，然后把哈希值保存起来”，但是他们明白“修改密码，检查密码成功”等充血模型反应出来的概念，因此领域模型中的所有行为都应该有业务价值，而不应该只有反映数据属性。</p><p>尽管充血模型带来的好处是明显的，但是贫血模型依旧很流行，其根本原因在于早期的很多持久性框架（比如ORM等）要求实体类的所有属性必须是可读可写，而我们可以很简单的把数据库中的表按照字段逐个映射为一个贫血模型的POCO类，这样“数据库驱动”的思维方式更简单直接，因此我们就见到“到处都是贫血模型”的情况了。值得欣慰的是，目前大部分主流持久性框架都已经支持充血模型的写法了，比如EF Core对充血模型的支持就非常好，因此我们没有理由再继续写贫血模型了。采用充血模型编写代码，我们能更好的实现DDD和模型驱动编程了。</p><h1 id="EF-Core对实体类属性操作的密码"><a href="#EF-Core对实体类属性操作的密码" class="headerlink" title="EF Core对实体类属性操作的密码"></a>EF Core对实体类属性操作的密码</h1><p>EF Core对实体属性操作的秘密</p><p>1、Why？为EF Core实现充血模型做准备。</p><p>2、EF Core是通过实体对象的属性的get、set来进行属性的读写吗？</p><p>3、答案：基于性能和对特殊功能支持的考虑，EF Core在读写属性的时候，如果可能，它会直接跳过get、set，而直接操作真正存储属性值的成员变量。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Dog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;get被调用&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;set被调用&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.name = <span class="keyword">value</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Dog d1 = <span class="keyword">new</span> Dog &#123; Name= <span class="string">&quot;goofy&quot;</span> &#125;;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Dog初始化完毕&quot;</span>);</span><br><span class="line">ctx.Dogs.Add(d1);</span><br><span class="line">ctx.SaveChanges();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;SaveChanges完毕&quot;</span>);</span><br><span class="line"> ​</span><br><span class="line">Console.WriteLine(<span class="string">&quot;准备读取数据&quot;</span>);</span><br><span class="line">Dog d2 = ctx.Dogs.First(d=&gt;d.Name== <span class="string">&quot;goofy&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;读取数据完毕&quot;</span>);</span><br></pre></td></tr></table></figure><p>总结：</p><p>EF Core在读写实体对象的属性时，会查找属性对应的成员变量，如果能找到，EF Core会直接读写这个成员变量的值，而不是通过set和get代码块来读写。</p><p>修改Dog的成员变量名</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Dog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> xingming;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;get被调用&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> xingming;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;set被调用&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.xingming = <span class="keyword">value</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>1、EF Core会尝试按照命名规则去直接读写属性对应的成员变量，只有无法根据命名规则找到对应成员变量的时候，EF Core才会通过属性的get、set代码块来读写属性值。</p><p>2(*)、可以在FluentAPI中通过UsePropertyAccessMode()方法来修改默认的这个行为。</p><h1 id="EF-Core中充血模型的需求"><a href="#EF-Core中充血模型的需求" class="headerlink" title="EF Core中充血模型的需求"></a>EF Core中充血模型的需求</h1><p>充血模型实现的要求<br>一：属性是只读的或者是只能被类内部的代码修改。</p><p>二：定义有参数的构造方法。</p><p>三：有的成员变量没有对应属性，但是这些成员变量需要映射为数据表中的列，也就是我们需要把私有成员变量映射到数据表中的列。</p><p>四：有的属性是只读的，也就是它的值是从数据库中读取出来的，但是我们不能修改属性值。</p><p>五：有的属性不需要映射到数据列，仅在运行时被使用。</p><p>在EF Core中如何实现<br>实现“一”</p><p>属性是只读的或者是只能被类内部的代码修改。 实现：把属性的set定义为private或者init，然后通过构造方法为这些属性赋予初始值。</p><p>实现“二”</p><p>定义有参数的构造方法。 原理： EF Core中的实体类如果没有无参的构造方法，则有参的构造方法中的参数的名字必须和属性的名字一致。 实现方式1：无参构造方法定义为private。 实现方式2：实体类中不定义无参构造方法，只定义有意义的有参构造方法，但是要求构造方法中的参数的名字和属性的名字一致。</p><p>实现“三”</p><p>不属于属性的成员变量映射为数据列。 实现： builder.Property(“成员变量名”)</p><p>实现“四”</p><p>从数据列中读取值的只读属性。 EF Core中提供了“支持字段”（backing field）来支持这种写法：在配置实体类的代码中，使用HasField(“成员变量名”)来配置属性。</p><p>实现“五”</p><p>有的属性不需要映射到数据列，仅在运行时被使用。 实现：使用Ignore()来配置忽略这个属性。</p><h1 id="EF-Core中实现充血模型"><a href="#EF-Core中实现充血模型" class="headerlink" title="EF Core中实现充血模型"></a>EF Core中实现充血模型</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; <span class="comment">//特征一</span></span><br><span class="line">    <span class="keyword">public</span> DateTime CreatedDateTime &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; <span class="comment">//特征一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> UserName &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;<span class="comment">//特征一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Credit &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>? passwordHash;<span class="comment">//特征三</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>? remark;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? Remark<span class="comment">//特征四</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> remark; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? Tag &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//特征五</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span>()<span class="comment">//给EFCore从数据库中加载数据然后生成User对象返回用的</span></span></span><br><span class="line">    &#123;</span><br><span class="line">             <span class="comment">//特征二</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span>(<span class="params"><span class="built_in">string</span> yhm</span>)<span class="comment">//特征二</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.UserName = yhm;</span><br><span class="line">        <span class="keyword">this</span>.CreatedDateTime = DateTime.Now;</span><br><span class="line">        <span class="keyword">this</span>.Credit = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeUserName</span>(<span class="params"><span class="built_in">string</span> newValue</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.UserName = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangePasswordHash</span>(<span class="params"><span class="built_in">string</span> newValue</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue.Length &gt; <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;密码太短&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.passwordHash = HashHelper.ComputeMd5Hash(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置User实体类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">UserConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">User</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;User&gt; builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder.Property(<span class="string">&quot;passwordHash&quot;</span>);<span class="comment">//特征三</span></span><br><span class="line">        builder.Property(u =&gt; u.Remark).HasField(<span class="string">&quot;remark&quot;</span>);<span class="comment">//特征四</span></span><br><span class="line">        builder.Ignore(u=&gt;u.Tag);<span class="comment">//特征五</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置EF Core</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyDbContext</span>:<span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;User&gt; Users &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnConfiguring(optionsBuilder);</span><br><span class="line">        optionsBuilder.UseSqlServer(<span class="string">&quot;Server=localhost;Database=YourDatabaseName;Trusted_Connection=True;MultipleActiveResultSets=true;TrustServerCertificate=True;Encrypt=True;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">        <span class="keyword">new</span> UserConfig().Configure(modelBuilder.Entity&lt;User&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyDbContext ctx = <span class="keyword">new</span> MyDbContext();</span><br><span class="line">User u1 = <span class="keyword">new</span> User(<span class="string">&quot;YOUXIANYU&quot;</span>);</span><br><span class="line">u1.Tag = <span class="string">&quot;MyTag&quot;</span>;</span><br><span class="line">u1.ChangePasswordHash(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">ctx.Users.Add(u1);</span><br><span class="line">ctx.SaveChanges();</span><br></pre></td></tr></table></figure><p>因为User类的无参构造方法为私有的，所以我们只能调用设定初始用户名的构造方法，这样就保证了对象的合法性。上面的代码会在数据库中插入一条记录，我们修改数据库中Remark列的值为“you”,然后执行代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyDbContext ctx = <span class="keyword">new</span> MyDbContext();</span><br><span class="line">User u1 = ctx.Users.First(u =&gt; u.UserName == <span class="string">&quot;YOUXIANYU&quot;</span>);</span><br><span class="line">Console.WriteLine(u1.Remark);</span><br></pre></td></tr></table></figure><p><img src="/img%5CDDD%5C3.png"></p>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET Core的DDD架构</title>
      <link href="/2025/05/15/DDD/NET%20Core%E7%9A%84DDD/"/>
      <url>/2025/05/15/DDD/NET%20Core%E7%9A%84DDD/</url>
      
        <content type="html"><![CDATA[<h1 id="DDD的基本概念"><a href="#DDD的基本概念" class="headerlink" title="DDD的基本概念"></a>DDD的基本概念</h1><h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><h3 id="单体结构"><a href="#单体结构" class="headerlink" title="单体结构"></a>单体结构</h3><p>传统的软件项目大部分都是单体结构，也就是项目中的所有代码都放到同一个应用程序中，一般他们也都运行在同一个进程中。<br><img src="/img%5CDDD%5C1.png"></p><p>单体结构的项目有结构简单、部署简单等优点，但是有如下缺点：</p><ol><li>代码之间耦合严重，代码的可维护性低。</li><li>项目只能采用单一的语言和技术栈，甚至采用的开发包的版本都必须统一。</li><li>一个模块的崩溃就会导致整个项目的崩溃。</li><li>我们只能整体进行服务器扩容，无法对其中一个模块进行单独的服务器扩容。</li><li>当需要更新某一个功能时，我们需要把整个系统重新部署一遍，这会导致新功能的上线流程变长。</li></ol><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构把项目拆分为多个应用程序，每个程序单独构建和部署。<br><img src="/img%5CDDD%5C2.png"></p><p>微服务架构有如下的优点：</p><ol><li>每个微服务只负责一个特定的业务，业务逻辑清晰、代码简单，对于其他微服务的依赖非常低，因此易于开发和维护。</li><li>不同的微服务可以用不同的语言和技术栈开发。</li><li>一个微服务的运行不会影响其他微服务。</li><li>可以对一个特定的微服务进行单独维护可容。</li><li>当需要更新某个功能的时候，我们只需要重新部署这个功能所在的微服务即可，不需要重新部署整个系统。</li></ol><p>微服务架构缺点：</p><ol><li>在单体结构中，运维人员只需要保证一个应用的正常运行即可，而在微服务架构中，运维人员需要保证多应用的正常运行，这给运维人员带来更大的挑战。</li><li>在单体结构中，各模块之间是进程内调用，数据交互的效率高，而在微服务架构中，和微服务之间要通过网络进行通信，数据交互的效率低。</li><li>在单体结构中，各模块之间的调用都是在进程内进行的，实现容错、事务一致性等比较容易，而在微服务架构中，各微服务之间通过网络通信，实现容错、实物一致性等非常困难。</li></ol><h1 id="DDD之领域模型"><a href="#DDD之领域模型" class="headerlink" title="DDD之领域模型"></a>DDD之领域模型</h1><ol><li>领域（Domain）：一个组织做的事情。子领域。</li><li>领域的划分（以手机公司为例）：<br>核心域：解决项目的核心问题，和组织业务紧密相关。<br>支撑域：解决项目的非核心问题，则具有组织特性，但不具有通用性。<br>通用域：解决通用问题，没有组织特性。</li><li>领域的不同分类决定了公司的研发重点。</li></ol><p>领域模型（Domain Model）</p><ol><li>对于领域内的对象进行建模，从而抽象出来模型。</li><li>我们的项目应该开始于创建领域模型，而不是考虑如何设计数据库和编写代码。适用领域模型，我们可以一直用业务语言去描述和构建系统，而不是使用技术人员的语言。</li></ol><h1 id="实体类与值对象"><a href="#实体类与值对象" class="headerlink" title="实体类与值对象"></a>实体类与值对象</h1><p>实体类</p><ol><li>“标识符”用来唯一定位一个对象，在数据库中我们一般用表的主键来实现“标识符”。主键和标识符的思考角度不同。</li><li>“实体”拥有唯一的标识符，标识符的值不会改变，而对象的其他状态则会经历各种变化。标志符用来跟踪对象状态变化，一个实体的对象无论怎样变化，我们都能通过标识符定位这个对象。</li><li>是他一般的表现形式就是EF Core中的实体类。</li></ol><p>值对象</p><ol><li>值对象：没有标志符的对象，也有多个属性，依附于某个实体类对象而存在。比如“商家”的地理位置、衣服的RGB颜色。</li><li>定义为值对象和普通属性的区别：体现整体关系。</li></ol><h1 id="聚合和聚合根"><a href="#聚合和聚合根" class="headerlink" title="聚合和聚合根"></a>聚合和聚合根</h1><ol><li>聚合（Aggregate）</li></ol><p>定义：聚合是由多个关联对象组合而成的一个整体，这些对象在业务逻辑上相互依赖，形成一个边界清晰的单元。</p><p>核心特性：</p><p>一致性边界：在进行数据修改操作时，聚合要保证内部对象状态的一致性。<br>作为一个整体进行引用：外部对象只能引用聚合根，而不能直接引用聚合内部的其他成员。<br>生命周期管理：聚合内部对象的生命周期由聚合根统一管理。<br>应用场景：当处理具有复杂业务规则的实体关系时，比如订单与订单项、账户与交易记录等场景，就可以使用聚合。</p><ol start="2"><li>聚合根（Aggregate Root）</li></ol><p>定义：聚合根是聚合中的核心实体，它是外部访问聚合的唯一入口点。<br>核心职责：</p><p>封装内部逻辑：聚合根负责维护聚合内部对象之间的业务规则。<br>保证数据一致性：在聚合内部状态发生变化时，聚合根要确保这种变化符合业务规则。<br>管理生命周期：聚合根负责创建、删除聚合内部的对象。<br>应用场景：聚合根在领域服务中经常被用作事务边界，像订单管理、库存控制等场景都会用到。<br>3. 二者的关系</p><p>聚合根是聚合的 “代言人”，外部对象只能通过聚合根来与聚合进行交互，不能直接访问聚合内部的其他对象。<br>聚合根要确保聚合内部的数据在任何时候都满足业务规则，以此来维护数据的一致性。</p><ol start="4"><li>设计原则<br>最小引用原则：要尽量减少聚合之间的关联，避免出现复杂的引用网络。</li></ol><p>事务边界原则：一个聚合在一次事务中只能被一个聚合根修改。</p><p>不变性原则：聚合根要保证聚合内部的业务规则始终得到遵守。</p><h1 id="DDD领域服务和应用服务"><a href="#DDD领域服务和应用服务" class="headerlink" title="DDD领域服务和应用服务"></a>DDD领域服务和应用服务</h1><p>聚合根的实体类中没有业务逻辑代码，只有对象的创建、对象的初始化、状态管理等与个体相关的代码。对于聚合内的业务代码，我们编写领域服务（domain service），而对于跨聚合协作的逻辑，我们编写应用服务（application service）。应用服务协调多个领域服务来完成一个用例。</p><p>在DDD中，一个典型的用例的处理流程如下：</p><ol><li>准备业务操作所需要的数据，一般是从数据库或者其他外部数据源获取数据。</li><li>执行由一个或多个领域模型做出的业务操作，这些操作会修改实体类的状态，或者生成一些操作结果。</li><li>把对实体类的改变或者操作结果应用与外部系统，比如保存对实体类的修改到数据库或者把计算结果通过短信发送给用户。</li></ol><p>上面的步骤中，只有第一步和第三步涉及与外部系统的交互，第二步是对领域模型的业务逻辑操作。这三步组成一个典型的应用服务的逻辑，而若个领域服务被编排完成第二步的工作。领域模型与外部系统（数据库、缓存等）是隔离的，不会发生直接交互，也就是说领域服务不会涉及读写数据库的操纵。这样我们可以很好地实现责任的划分：业务逻辑放入领域服务，而与外部系统的交互由应用服务来负责。因为领域服务是用来协调领域对象完成业务逻辑操作的，所以领域服务是无状态的，状态由领域对象来管理。</p><p>需要注意的是，领域服务不是必需的，在一些简单的业务处理（比如增、删、改、查）中是没有领域知识（也就是业务逻辑）的，这种情况下应用服务可以完成所有操作，不需要引入领域服务，这样我们可以避免系统出现过度设计的问题。如果随着系统的进化，应用服务中出现了业务逻辑，我们就要把业务逻辑放入领域服务。</p><p>和聚合相关的两个概念是“仓储”（repository）和“工作单元”（unit of work）。聚合中的实体类不负责数据库读取和保存，这些工作是有仓库储负责的因此实体类负责业务逻辑的处理，仓储负责按照要求从数据库中读取数据已及把领域服务修改的数据保存回数据库，一个聚合对应一个用来实现数据持久化的仓储。聚合内数据操作的关系是非常紧密的，我们要保证事务的强一致性，而聚合间的协作是关系不紧密的，因此我们只要保证事务的最终一致性即可。聚合内的若干相关联的操作组成一个“工作单元”，这些工作单元要么全部成功，要么全部失败。<br>因为领域服务不依赖外部系统、不保存状态，所以领域服务比应用服务更容易进行单元测试，这对于提高系统的质量是非常有帮助的。</p>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core程序的发布</title>
      <link href="/2025/05/13/asp.net%20core/ASP.NET%20Core%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%91%E5%B8%83/"/>
      <url>/2025/05/13/asp.net%20core/ASP.NET%20Core%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<h1 id="网站发布"><a href="#网站发布" class="headerlink" title="网站发布"></a>网站发布</h1><ol><li>不能直接把bin&#x2F;Debug部署到生产环境的服务器上，性能低。应该创建网站的发布版，用【发布】功能。</li><li>两种部署模式：“框架依赖”和“独立”。两者的优缺点。</li><li>独立模式为什么要选目标操作系统和CUP类型。</li></ol><h3 id="如果你使用-Visual-Studio，可以通过以下步骤发布："><a href="#如果你使用-Visual-Studio，可以通过以下步骤发布：" class="headerlink" title="如果你使用 Visual Studio，可以通过以下步骤发布："></a>如果你使用 Visual Studio，可以通过以下步骤发布：</h3><ol><li><p>在解决方案资源管理器中右键点击项目</p></li><li><p>选择 “发布”<br><img src="/img%5CWEBAPI%5C33.png"></p></li><li><p>选择发布目标（文件夹、IIS、Azure 等）我们这里选择使用文件夹的方式发布。<br><img src="/img%5CWEBAPI%5C34.png"></p></li><li><p>配置发布设置（如目标框架、运行时、是否自包含等）<br><img src="/img%5CWEBAPI%5C35.png"><br><img src="/img%5CWEBAPI%5C36.png"></p></li></ol><p>点击 “发布” 按钮</p><h2 id="框架依赖部署（FDD）"><a href="#框架依赖部署（FDD）" class="headerlink" title="框架依赖部署（FDD）"></a>框架依赖部署（FDD）</h2><p>特点</p><p>依赖共享运行时：应用程序依赖目标环境中已安装的 .NET 运行时（如 .NET 6&#x2F;7&#x2F;8）。</p><p>体积小：发布包仅包含应用代码和第三方依赖（如 NuGet 包），不包含 .NET 运行时，因此包体积小。</p><p>跨平台兼容性：发布包不包含运行时，需确保目标环境的运行时版本与开发环境兼容。</p><p>更新便捷：.NET 运行时由操作系统或管理员统一更新，应用无需包含运行时更新。</p><p>适用场景</p><p>目标环境已预装 .NET 运行时（如服务器、开发机）。</p><p>需要频繁更新应用，希望减小发布包体积。<br>多应用共享同一运行时，节省系统资源。</p><h2 id="独立部署（SCD）"><a href="#独立部署（SCD）" class="headerlink" title="独立部署（SCD）"></a>独立部署（SCD）</h2><p>特点</p><p>包含完整运行时：应用程序包包含 .NET 运行时、框架库和应用代码，不依赖目标环境的运行时。</p><p>体积大：发布包包含完整的运行时，体积显著增大（通常几十到上百 MB）。</p><p>版本隔离：不同应用可使用不同版本的运行时，互不干扰。</p><p>无需预安装运行时：可直接在未安装 .NET 的环境中运行（如客户机、无管理员权限的服务器）。</p><p>适用场景</p><p>目标环境无法安装或管理 .NET 运行时（如客户机、共享主机）。</p><p>需要确保应用使用特定版本的运行时，避免版本冲突。</p><p>应用需要在不同版本的运行时环境中保持一致性。</p><h1 id="网站的运行"><a href="#网站的运行" class="headerlink" title="网站的运行"></a>网站的运行</h1><ol><li>在Windows（SandBox）和Linux（VMWare Player）里分别运行网站。</li><li>如何在生产服务器中部署.NET Core网站。尽管Kestrel已经强大到足以作为一个独立Web服务器被使用了，但是一般仍然不会让Kestrel直接面对终端用户的请求。配置域名证书、记录请求日志、Url重写等由反向代理服务器负责。</li><li>多种部署模式：K8S+容器（推荐，难度高）；Linux+Nginx；云平台；windows+IIS；</li></ol><h1 id="网站安全提醒"><a href="#网站安全提醒" class="headerlink" title="网站安全提醒"></a>网站安全提醒</h1><ol><li>启用https。</li><li>如果运维人员需要通过远程桌面或者SSH连接到服务器，那么一定要在服务器的防火墙设置只允许运维人员的IP段访问相关端口。</li><li>严格区分开发环境和生产环境。</li><li>不要相信客户端请求。</li></ol>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SignaLR案例：导入英汉词典</title>
      <link href="/2025/05/12/asp.net%20core/SignalR%E6%A1%88%E4%BE%8B/"/>
      <url>/2025/05/12/asp.net%20core/SignalR%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="SignaLR案例：导入英汉词典"><a href="#SignaLR案例：导入英汉词典" class="headerlink" title="SignaLR案例：导入英汉词典"></a>SignaLR案例：导入英汉词典</h1><p><b>需求</b></p><ol><li>英汉词典ECDICT中导入单词到数据库。</li><li>T_Worditems：Id（主键）、Word（单词）、Phonetic（音标）、Definition（英文解释）、Translation（中文翻译）</li></ol><p><img src="/img%5CWEBAPI%5C32.png"><br>下载地址：<a href="https://github.com/skywind3000/ECDICT">https://github.com/skywind3000/ECDICT</a></p><p>CSV（Comma-Separated Values）是一种常用的文本文件格式，用于存储和交换表格数据。以下是关于 CSV 格式的详细介绍：</p><p>特点</p><p>简单性：CSV 格式非常简单，它以纯文本形式存储数据，每行代表一条记录，字段之间用逗号分隔。这种简单的结构使得 CSV 文件易于阅读、编写和解析，几乎所有的文本编辑器和电子表格软件都能处理 CSV 文件。<br>通用性：CSV 是一种通用的格式，可被多种应用程序识别和导入，如电子表格软件（如 Microsoft Excel、Google Sheets）、数据库管理系统、数据分析工具等。这使得它成为不同系统之间数据交换的常用格式。</p><p>数据表示</p><p>记录：CSV 文件中的每一行都是一条记录，代表一个数据实体。例如，在一个学生信息表中，每一行可能代表一个学生的信息。<br>字段：每行中的字段用逗号分隔。例如，在学生信息表中，可能有姓名、年龄、性别、成绩等字段，它们之间用逗号隔开。如果字段值本身包含逗号或其他特殊字符，通常会用双引号将字段值括起来。</p><p>示例</p><p>以下是一个简单的 CSV 文件示例，包含了三个学生的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">姓名,年龄,性别,成绩</span><br><span class="line">张三,20,男,85</span><br><span class="line">李四,21,女,90</span><br><span class="line">王五,20,男,88</span><br></pre></td></tr></table></figure><p>应用场景</p><p>数据导出和导入：常用于从数据库中导出数据或将数据导入到数据库中。也可用于在不同的软件应用程序之间交换数据，例如将电子表格中的数据分享给其他用户或导入到数据分析工具中进行处理。<br>数据存储：对于一些简单的数据集，CSV 格式是一种方便的存储方式。它占用的空间相对较小，且易于管理和备份。</p><p>日志记录：一些应用程序会将日志信息以 CSV 格式保存，以便后续分析和处理。例如，网站服务器可能会将访问日志记录为 CSV 文件，包含访问时间、访问者 IP 地址、请求页面等信息。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><blockquote><ol><li>ImportExector中注入IHubContext&lt;ImportDictHub&gt;等服务。</li><li>暂时用字符串Split解析CSV，或者用更专业的库。</li><li>用SqlBulkCopy进行分批快速导入。</li></ol></blockquote><p><b>第一步，创建ASP.NET Core Web API。创建一个执行数据导入的类ImportExeccutor</b></p><blockquote><p>通过connectionId来通知前端传输的进度。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImportExecutor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//IHubContext&lt;ImportDictHub&gt;：用于与客户端实时通信，更新导入进度</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IHubContext&lt;ImportDictHub&gt; hubContext;</span><br><span class="line">        <span class="comment">//ILogger&lt;ImportExecutor&gt;：记录日志，便于调试和监控</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;ImportExecutor&gt; logger;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ImportExecutor</span>(<span class="params">IHubContext&lt;ImportDictHub&gt; hubContext, ILogger&lt;ImportExecutor&gt; logger</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.hubContext = hubContext;</span><br><span class="line">            <span class="keyword">this</span>.logger = logger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ExecuteAsync</span>(<span class="params"><span class="built_in">string</span> connectionId</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//异步读取 CSV 文件的所有行</span></span><br><span class="line">            <span class="built_in">string</span>[] lines = <span class="keyword">await</span> File.ReadAllLinesAsync(<span class="string">@&quot;E:\temp\stardict.csv&quot;</span>);</span><br><span class="line">            <span class="built_in">int</span> totalCount = lines.Length - <span class="number">1</span>;<span class="comment">//总行数：跳过表头</span></span><br><span class="line">            <span class="comment">//硬编码，连接数据库</span></span><br><span class="line">            <span class="built_in">string</span> connStr = <span class="string">&quot;Server=localhost;Database=T_youxianyu;Trusted_Connection=True;MultipleActiveResultSets=true;TrustServerCertificate=True;Encrypt=True;&quot;</span>;</span><br><span class="line">            <span class="comment">//SqlBulkCopy：高效地将大量数据批量插入 SQL Serve</span></span><br><span class="line">            <span class="keyword">using</span> SqlBulkCopy bulkCopy = <span class="keyword">new</span> SqlBulkCopy(connStr);</span><br><span class="line">            <span class="comment">//列映射：将 CSV 列映射到数据库表的列</span></span><br><span class="line">            bulkCopy.DestinationTableName = <span class="string">&quot;T_Worditems&quot;</span>;</span><br><span class="line">            bulkCopy.ColumnMappings.Add(<span class="string">&quot;Word&quot;</span>, <span class="string">&quot;Word&quot;</span>);</span><br><span class="line">            bulkCopy.ColumnMappings.Add(<span class="string">&quot;Phonetic&quot;</span>, <span class="string">&quot;Phonetic&quot;</span>);</span><br><span class="line">            bulkCopy.ColumnMappings.Add(<span class="string">&quot;Definition&quot;</span>, <span class="string">&quot;Definition&quot;</span>);</span><br><span class="line">            bulkCopy.ColumnMappings.Add(<span class="string">&quot;Translation&quot;</span>, <span class="string">&quot;Translation&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//DataTable：临时存储 CSV 数据，用于批量导入</span></span><br><span class="line">            <span class="keyword">using</span> DataTable dataTable = <span class="keyword">new</span> DataTable();</span><br><span class="line">            dataTable.Columns.Add(<span class="string">&quot;Word&quot;</span>);</span><br><span class="line">            dataTable.Columns.Add(<span class="string">&quot;Phonetic&quot;</span>);</span><br><span class="line">            dataTable.Columns.Add(<span class="string">&quot;Definition&quot;</span>);</span><br><span class="line">            dataTable.Columns.Add(<span class="string">&quot;Translation&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> line <span class="keyword">in</span> lines)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span>[] str = line.Split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="comment">//数据验证：检查每行是否包含足够的字段</span></span><br><span class="line">                <span class="built_in">string</span> word = str[<span class="number">0</span>];</span><br><span class="line">                <span class="built_in">string</span>? phonetic = str[<span class="number">1</span>];</span><br><span class="line">                <span class="built_in">string</span>? definition = str[<span class="number">2</span>];</span><br><span class="line">                <span class="built_in">string</span>? translation = str[<span class="number">3</span>];</span><br><span class="line">                <span class="comment">//创建 DataRow：将 CSV 数据转换为 DataTable 的行</span></span><br><span class="line">                DataRow row = dataTable.NewRow();</span><br><span class="line">                row[<span class="string">&quot;Word&quot;</span>] = word;</span><br><span class="line">                row[<span class="string">&quot;Phonetic&quot;</span>] = phonetic;</span><br><span class="line">                row[<span class="string">&quot;Definition&quot;</span>] = definition;</span><br><span class="line">                row[<span class="string">&quot;Translation&quot;</span>] = translation;</span><br><span class="line">                dataTable.Rows.Add(row);</span><br><span class="line">                counter++;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;已加载<span class="subst">&#123;counter&#125;</span>&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(dataTable.Rows.Count == <span class="number">100</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> bulkCopy.WriteToServerAsync(dataTable);</span><br><span class="line">                    <span class="comment">//批量写入：当 DataTable 积累到 100 行时，执行一次批量导入</span></span><br><span class="line">                    dataTable.Clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//进度通知：每处理 100 条记录或处理完所有记录时，通过 SignalR 通知客户端</span></span><br><span class="line">                <span class="keyword">await</span> hubContext.Clients.Client(connectionId).SendAsync(<span class="string">&quot;ImportProgress&quot;</span>,totalCount,counter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理剩余数据：确保最后一批不足 100 条的数据也被导入</span></span><br><span class="line">            <span class="keyword">await</span> bulkCopy.WriteToServerAsync(dataTable);</span><br><span class="line">            <span class="comment">//最终进度通知：确保客户端收到 100% 完成的通知</span></span><br><span class="line">            <span class="keyword">await</span> hubContext.Clients.Client(connectionId).SendAsync(<span class="string">&quot;ImportProgress&quot;</span>, totalCount, counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*public class ImportExecutor</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    private readonly IHubContext&lt;ImportDictHub&gt; hubContext;</span></span><br><span class="line"><span class="comment">    private readonly ILogger&lt;ImportExecutor&gt; logger;</span></span><br><span class="line"><span class="comment">    private readonly IConfiguration configuration;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public ImportExecutor(IHubContext&lt;ImportDictHub&gt; hubContext, ILogger&lt;ImportExecutor&gt; logger, IConfiguration configuration)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        this.hubContext = hubContext;</span></span><br><span class="line"><span class="comment">        this.logger = logger;</span></span><br><span class="line"><span class="comment">        this.configuration = configuration;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public async Task ExecuteAsync(string connectionId)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        try</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            string filePath = @&quot;E:\temp\stardict.csv&quot;;</span></span><br><span class="line"><span class="comment">            string[] lines = await File.ReadAllLinesAsync(filePath);</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            if (lines.Length &lt;= 1) // 检查是否有数据行</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                await hubContext.Clients.Client(connectionId).SendAsync(&quot;ImportProgress&quot;, 0, 0);</span></span><br><span class="line"><span class="comment">                return;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            int totalCount = lines.Length - 1; // 总行数：跳过表头</span></span><br><span class="line"><span class="comment">            string connStr = configuration.GetConnectionString(&quot;DefaultConnection&quot;);</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            using (var bulkCopy = new SqlBulkCopy(connStr))</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                bulkCopy.DestinationTableName = &quot;T_Worditems&quot;;</span></span><br><span class="line"><span class="comment">                bulkCopy.ColumnMappings.Add(&quot;Word&quot;, &quot;Word&quot;);</span></span><br><span class="line"><span class="comment">                bulkCopy.ColumnMappings.Add(&quot;Phonetic&quot;, &quot;Phonetic&quot;);</span></span><br><span class="line"><span class="comment">                bulkCopy.ColumnMappings.Add(&quot;Definition&quot;, &quot;Definition&quot;);</span></span><br><span class="line"><span class="comment">                bulkCopy.ColumnMappings.Add(&quot;Translation&quot;, &quot;Translation&quot;);</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                using (DataTable dataTable = new DataTable())</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    dataTable.Columns.Add(&quot;Word&quot;);</span></span><br><span class="line"><span class="comment">                    dataTable.Columns.Add(&quot;Phonetic&quot;);</span></span><br><span class="line"><span class="comment">                    dataTable.Columns.Add(&quot;Definition&quot;);</span></span><br><span class="line"><span class="comment">                    dataTable.Columns.Add(&quot;Translation&quot;);</span></span><br><span class="line"><span class="comment">                    </span></span><br><span class="line"><span class="comment">                    int counter = 0;</span></span><br><span class="line"><span class="comment">                    int progressCounter = 0;</span></span><br><span class="line"><span class="comment">                    const int BatchSize = 100;</span></span><br><span class="line"><span class="comment">                    const int ProgressUpdateInterval = 100; // 每处理100条记录更新一次进度</span></span><br><span class="line"><span class="comment">                    </span></span><br><span class="line"><span class="comment">                    // 跳过表头行</span></span><br><span class="line"><span class="comment">                    for (int i = 1; i &lt; lines.Length; i++)</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        string line = lines[i];</span></span><br><span class="line"><span class="comment">                        string[] str = line.Split(&#x27;,&#x27;);</span></span><br><span class="line"><span class="comment">                        </span></span><br><span class="line"><span class="comment">                        if (str.Length &lt; 4) // 确保数据行有足够的字段</span></span><br><span class="line"><span class="comment">                        &#123;</span></span><br><span class="line"><span class="comment">                            logger.LogWarning($&quot;第 &#123;i&#125; 行格式不正确: &#123;line&#125;&quot;);</span></span><br><span class="line"><span class="comment">                            continue;</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                        </span></span><br><span class="line"><span class="comment">                        string word = str[0];</span></span><br><span class="line"><span class="comment">                        string phonetic = str[1];</span></span><br><span class="line"><span class="comment">                        string definition = str[2];</span></span><br><span class="line"><span class="comment">                        string translation = str[3];</span></span><br><span class="line"><span class="comment">                        </span></span><br><span class="line"><span class="comment">                        DataRow row = dataTable.NewRow();</span></span><br><span class="line"><span class="comment">                        row[&quot;Word&quot;] = word;</span></span><br><span class="line"><span class="comment">                        row[&quot;Phonetic&quot;] = phonetic;</span></span><br><span class="line"><span class="comment">                        row[&quot;Definition&quot;] = definition;</span></span><br><span class="line"><span class="comment">                        row[&quot;Translation&quot;] = translation;</span></span><br><span class="line"><span class="comment">                        dataTable.Rows.Add(row);</span></span><br><span class="line"><span class="comment">                        counter++;</span></span><br><span class="line"><span class="comment">                        </span></span><br><span class="line"><span class="comment">                        if (dataTable.Rows.Count == BatchSize)</span></span><br><span class="line"><span class="comment">                        &#123;</span></span><br><span class="line"><span class="comment">                            await bulkCopy.WriteToServerAsync(dataTable);</span></span><br><span class="line"><span class="comment">                            dataTable.Clear();</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                        </span></span><br><span class="line"><span class="comment">                        // 每处理ProgressUpdateInterval条记录发送一次进度更新</span></span><br><span class="line"><span class="comment">                        if (counter % ProgressUpdateInterval == 0 || counter == totalCount)</span></span><br><span class="line"><span class="comment">                        &#123;</span></span><br><span class="line"><span class="comment">                            await hubContext.Clients.Client(connectionId).SendAsync(&quot;ImportProgress&quot;, totalCount, counter);</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    </span></span><br><span class="line"><span class="comment">                    // 写入剩余的数据</span></span><br><span class="line"><span class="comment">                    if (dataTable.Rows.Count &gt; 0)</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        await bulkCopy.WriteToServerAsync(dataTable);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    </span></span><br><span class="line"><span class="comment">                    // 确保发送最终进度</span></span><br><span class="line"><span class="comment">                    await hubContext.Clients.Client(connectionId).SendAsync(&quot;ImportProgress&quot;, totalCount, counter);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        catch (Exception ex)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            logger.LogError(ex, &quot;导入过程中发生错误&quot;);</span></span><br><span class="line"><span class="comment">            await hubContext.Clients.Client(connectionId).SendAsync(&quot;ImportError&quot;, ex.Message);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImportDictHub</span>:<span class="title">Hub</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//依赖注入：通过构造函数注入 ImportExecutor，该服务负责实际的 CSV 导入操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ImportExecutor importExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImportDictHub</span>(<span class="params">ImportExecutor importExecutor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.importExecutor = importExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">ImportEcdict</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//启动字典数据的导入过程</span></span><br><span class="line">        <span class="comment">/*this.Context.ConnectionId：获取当前客户端连接的唯一标识符</span></span><br><span class="line"><span class="comment">        importExecutor.ExecuteAsync(...)：调用导入执行器的异步方法开始导入</span></span><br><span class="line"><span class="comment">        _ = ...：使用弃元 (discard) 忽略返回的任务，表示不等待导入完成就返回</span></span><br><span class="line"><span class="comment">        return Task.CompletedTask：立即返回已完成的任务，让客户端知道请求已收到*/</span></span><br><span class="line">        _ = importExecutor.ExecuteAsync(<span class="keyword">this</span>.Context.ConnectionId);</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>异步非阻塞设计</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = importExecutor.ExecuteAsync(<span class="keyword">this</span>.Context.ConnectionId);</span><br></pre></td></tr></table></figure><p>为什么这样设计？<br>导入操作可能需要很长时间（几秒到几分钟不等）<br>如果等待导入完成再返回，会阻塞 SignalR 连接，影响其他客户端通信<br>采用 “触发并忘记”(fire-and-forget) 模式，让导入在后台执行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddSignalR();</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>[] urls = <span class="keyword">new</span>[] &#123; <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">builder.Services.AddCors(options =&gt;</span><br><span class="line">    options.AddDefaultPolicy(builder =&gt; builder</span><br><span class="line">    .WithOrigins(urls)</span><br><span class="line">    .AllowAnyMethod()</span><br><span class="line">    .AllowAnyHeader()</span><br><span class="line">    .AllowCredentials()));</span><br><span class="line"></span><br><span class="line">builder.Services.AddScoped&lt;ImportExecutor&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the HTTP request pipeline.</span></span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.UseSwagger();</span><br><span class="line">    app.UseSwaggerUI();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.UseHttpsRedirection();</span><br><span class="line"></span><br><span class="line">app.UseAuthorization();</span><br><span class="line">app.MapHub&lt;ImportDictHub&gt;(<span class="string">&quot;/ImportDictHub&quot;</span>);</span><br><span class="line">app.MapControllers();</span><br></pre></td></tr></table></figure><p>前端Vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;导入&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;importECDict&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">progress</span> <span class="attr">:value</span>=<span class="string">&quot;state.current&quot;</span> <span class="attr">:max</span>=<span class="string">&quot;state.total&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; reactive, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> * <span class="keyword">as</span> signalR <span class="keyword">from</span> <span class="string">&#x27;@microsoft/signalr&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> connection;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">current</span>: <span class="number">0</span>, <span class="attr">total</span>: <span class="number">0</span> &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> importECDict = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">await</span> connection.<span class="title function_">invoke</span>(<span class="string">&quot;ImportEcDict&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">alert</span>(<span class="string">&quot;启动导入&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">onMounted</span>(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">var</span> options = &#123; <span class="attr">skipNegotiation</span>: <span class="literal">true</span>, <span class="attr">transport</span>: signalR.<span class="property">HttpTransportType</span>.<span class="property">WebSockets</span> &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            connection = <span class="keyword">new</span> signalR.<span class="title class_">HubConnectionBuilder</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                .<span class="title function_">withUrl</span>(<span class="string">&#x27;https://localhost:7068/ImportDictHub&#x27;</span>, options)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                .<span class="title function_">withAutomaticReconnect</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                .<span class="title function_">build</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">await</span> connection.<span class="title function_">start</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            connection.<span class="title function_">on</span>(<span class="string">&#x27;ImportProgress&#x27;</span>, <span class="function">(<span class="params">total, current</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                state.<span class="property">total</span> = total;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                state.<span class="property">current</span> = current;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> &#123; state, importECDict &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
            <tag> SingnalR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core SignaLR服务器端消息推送</title>
      <link href="/2025/05/10/asp.net%20core/ASP.NET%20Core%E9%AB%98%E7%BA%A7%E7%BB%84%E4%BB%B6%E4%B8%89/"/>
      <url>/2025/05/10/asp.net%20core/ASP.NET%20Core%E9%AB%98%E7%BA%A7%E7%BB%84%E4%BB%B6%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是WebSocket和SignalR"><a href="#什么是WebSocket和SignalR" class="headerlink" title="什么是WebSocket和SignalR"></a>什么是WebSocket和SignalR</h1><ol><li>WebSocket基于TCP协议，支持二进制通信，双工通信。</li><li>性能和并发能力更强。</li><li>WebSocket服务器端部署到Web服务器上，因为可以借助HTTP协议完成初始的握手（可选），并且共享HTTP服务器的端口（主要）</li></ol><blockquote><p>虽然WebSocket是独立于HTTP的，但是我们一般仍然把WebSocket服务器端部署到Web服务器上，因为我们需要借助HTTP完成初始的握手，并且共享HTTP服务器的端口，这样就可以避免为WebSocket单独打开新的服务器端口。因此，SignalR的服务器端一般运行在ASP.NET Core项目中。</p></blockquote><p><b>SignIR</b></p><ol><li>ASP.NET Core SignalR（以下简称SignalR）,是.NET Core平台下对WebSocket的封装。</li><li>Hub（集线器），数据交换中心。</li></ol><p><img src="/img%5CWEBAPI%5C28.png"></p><h1 id="SignalR基本使用"><a href="#SignalR基本使用" class="headerlink" title="SignalR基本使用"></a>SignalR基本使用</h1><p>第一步，创建一个继承自Hub类的ChatRoomHub类,所有的客户端和服务器端都通过这个集线器进行通信.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChatRoomHub</span>:<span class="title">Hub</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//客户端可以通过 SignalR 连接调用此方法，并传递消息内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">SendPublicMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//表示当前客户端连接的上下文。</span></span><br><span class="line">        <span class="comment">//每个客户端连接的唯一标识符，由 SignalR 自动生成</span></span><br><span class="line">        <span class="built_in">string</span> connId = <span class="keyword">this</span>.Context.ConnectionId;</span><br><span class="line">        <span class="built_in">string</span> msg = <span class="string">$&quot;<span class="subst">&#123;connId&#125;</span><span class="subst">&#123;DateTime.Now&#125;</span>:<span class="subst">&#123;message&#125;</span>&quot;</span>;</span><br><span class="line">        <span class="comment">//Clients.All：表示所有连接到该 Hub 的客户端。</span></span><br><span class="line">        <span class="comment">/*SendAsync：异步调用客户端方法。</span></span><br><span class="line"><span class="comment">        第一个参数 &quot;ReceivePublicMessage&quot;：客户端需要实现的方法名。</span></span><br><span class="line"><span class="comment">        第二个参数 msg：传递给客户端的数据。*/</span></span><br><span class="line">        <span class="keyword">return</span> Clients.All.SendAsync(<span class="string">&quot;ReceivePulicMessage&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChatRoomHub类中定义的方法可以被客户端调用，也就是客户端可以向服务器端发送请求，方法的参数就是客户端向服务器端传送的消息，参数的个数原则上来讲不受限制，而且参数的类型支持string、bool、int等常用的数据类型。<br>在ChatRoomHub类中，我们定义了一个方法SendPublicMessage，方法的参数message为客户端传递过来的消息。在第5行代码中，我们获得了当前发送消息的客户端连接的唯一标识ConnectionId；在第6行代码中拼接出一个包含连接ID、当前时间、客户端消息的字符串；随后我们把msg字符串以名字为“ReceivePublicMessage”的消息发送到所有连接到集线器的客户端上。</p><p>第二步，编辑Program.cs，在builder.Build之前调用builder.Services.AddSignalR注册所有SignalR的服务，在app.MapControllers之前调用app.MapHub&lt;ChatRoomHub&gt;(“&#x2F;hubs&#x2F;ChatRoomHub”)启用SignalR中间件，并且设置当客户端通过SignalR请求“&#x2F;Hubs&#x2F;ChatRoomHub”这个路径的时候，由ChatRoomHub进行处理。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add services to the container.</span></span><br><span class="line"></span><br><span class="line">builder.Services.AddControllers();</span><br><span class="line"><span class="comment">// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle</span></span><br><span class="line">builder.Services.AddEndpointsApiExplorer();</span><br><span class="line">builder.Services.AddSwaggerGen();</span><br><span class="line"><span class="comment">//注入所有SignalR的服务</span></span><br><span class="line">builder.Services.AddSignalR(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.EnableDetailedErrors = <span class="literal">true</span>; <span class="comment">// 开发环境显示详细错误</span></span><br><span class="line">    options.ClientTimeoutInterval = TimeSpan.FromSeconds(<span class="number">30</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注入CORS服务</span></span><br><span class="line"><span class="built_in">string</span>[] urls = <span class="keyword">new</span>[] &#123; <span class="string">&quot;http://localhost:5173&quot;</span> &#125;;</span><br><span class="line">builder.Services.AddCors(options =&gt;</span><br><span class="line">    options.AddDefaultPolicy(builder =&gt;</span><br><span class="line">        builder.WithOrigins(urls).AllowAnyMethod()</span><br><span class="line">            .AllowAnyHeader().AllowCredentials())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the HTTP request pipeline.</span></span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.UseSwagger();</span><br><span class="line">    app.UseSwaggerUI();</span><br><span class="line">&#125;</span><br><span class="line">app.UseCors();</span><br><span class="line">app.UseHttpsRedirection();</span><br><span class="line">app.UseAuthentication();</span><br><span class="line">app.UseAuthorization();</span><br><span class="line">app.MapHub&lt;ChatRoomHub&gt;(<span class="string">&quot;/Hub/ChatRoomHub&quot;</span>);<span class="comment">//启用SignalR中间件</span></span><br><span class="line">app.MapControllers();</span><br><span class="line"></span><br><span class="line">app.Run();</span><br></pre></td></tr></table></figure><p>第三步，我们需要编写一共静态HTML页面提供交互界面。</p><p>执行如下命令安装SignalR的JavaScript客户端SDK：npm install @microsoft&#x2F;signalr</p><p>在SignalR的JavaScript客户端中，我们使用HubConnectionBuilder来创建从客户端到服务器端的连接；通过withUrl方法来设置服务器端集线器的地址，该地址必须是包含域名等的重连机制。虽然withAutomaticReconnect不是必须设置的，但是设置这个选项之后，如果连接被断开，客户端就会尝试重连，因此使用起来更方便。需要注意的是，客户端重连之后，由于这是个新的连接，因此在服务器端获得的ConnectionId是一个新的值。对HubConnectionBuilder设置完成后，我们调用build就可以构建完成一个客户端到集线器的连接。<br>通过build获得的到集线器的连接只能是逻辑上的连接，还需要调用start方法来实际启动连接。一旦连接建立完成，我们就可以通过连接对象的invoke函数来调用集线器中的方法，我们可以通过on函数来注册监听服务器适用SendAsync发送的消息的代码。</p><p><img src="/img%5CWEBAPI%5C29.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;state.userMessage&quot;</span> <span class="attr">v-on:keypress</span>=<span class="string">&quot;textMsgOnkeypress&quot;</span>/&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(msg,index) in state.messages&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; reactive, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> * <span class="keyword">as</span> signalR <span class="keyword">from</span> <span class="string">&quot;@microsoft/signalr&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> connection;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&quot;Login&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">userMessage</span>: <span class="string">&quot;&quot;</span>, <span class="attr">messages</span>: [] &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> textMsgOnkeypress = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (e.<span class="property">keyCode</span> != <span class="number">13</span>) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">await</span> connection.<span class="title function_">invoke</span>(<span class="string">&quot;SendPublicMessage&quot;</span>, state.<span class="property">userMessage</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      state.<span class="property">userMessage</span> = <span class="string">&quot;&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">onMounted</span>(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      connection = <span class="keyword">new</span> signalR.<span class="title class_">HubConnectionBuilder</span>()<span class="comment">//创建从客户端到服务器端的连接</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        .<span class="title function_">withUrl</span>(<span class="string">&quot;https://localhost:7122/Hub/ChatRoomHub&quot;</span>)<span class="comment">//设置服务器端集线器的地址</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        .<span class="title function_">withAutomaticReconnect</span>() <span class="comment">//设置自动重连机制</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        .<span class="title function_">build</span>();<span class="comment">//构建完成  </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">await</span> connection.<span class="title function_">start</span>();<span class="comment">//自动</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">//通过on函数来注册监听服务器端使用SendAsync发送的消息的代码</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      connection.<span class="title function_">on</span>(<span class="string">&quot;ReceivePulicMessage&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        state.<span class="property">messages</span>.<span class="title function_">push</span>(msg);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123; state, textMsgOnkeypress &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>功能实现<br>SignalR 连接初始化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connection = <span class="keyword">new</span> signalR.<span class="title class_">HubConnectionBuilder</span>()</span><br><span class="line">  .<span class="title function_">withUrl</span>(<span class="string">&quot;https://localhost:7122/Hub/ChatRoomHub&quot;</span>)</span><br><span class="line">  .<span class="title function_">withAutomaticReconnect</span>()</span><br><span class="line">  .<span class="title function_">build</span>();</span><br><span class="line"><span class="keyword">await</span> connection.<span class="title function_">start</span>();</span><br></pre></td></tr></table></figure><p>创建 SignalR 连接并配置自动重连<br>连接到服务器端的 ChatRoomHub 集线器<br>组件挂载完成后立即启动连接<br>消息接收处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.<span class="title function_">on</span>(<span class="string">&quot;ReceivePulicMessage&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  state.<span class="property">messages</span>.<span class="title function_">push</span>(msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注册事件监听器，监听服务器端发送的ReceivePulicMessage事件<br>接收到消息后将其添加到messages数组，触发视图更新<br>消息发送处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textMsgOnkeypress = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">keyCode</span> != <span class="number">13</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">await</span> connection.<span class="title function_">invoke</span>(<span class="string">&quot;SendPublicMessage&quot;</span>, state.<span class="property">userMessage</span>);</span><br><span class="line">  state.<span class="property">userMessage</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>监听输入框的按键事件，仅处理 Enter 键 (13)<br>通过connection.invoke调用服务器端的SendPublicMessage方法<br>发送成功后清空输入框</p><h1 id="协议协商"><a href="#协议协商" class="headerlink" title="协议协商"></a>协议协商</h1><p>SignalR其实并不只是对WebSocket的封装，它支持多种服务推送的实现方式，包括WebSocket、服务器发送事件（server-sent events）和长轮询。SiganlR的JavaScript客户端会先尝试用WebSocket连接服务器；如果失败了，他再用服务器发送事件方式连接服务器；如果又失败了，它再用长轮询方式连接服务器。因此SignalR会自适应复杂的客户端、网络、服务器环境来支持服务器端推送的实现。</p><p>协议协商的问题</p><ol><li>集群中协议协商的问题：“协商”请求被服务器A处理，而接下来的WebSocket请求却被服务器B处理。</li><li>解决方法：粘性会话和禁用协商。</li><li>粘性会话（Sticky Session）：把来自同一个客户端的请求都转发给同一台服务器上。缺点：因此共享公网IP等造成请求无法被平均的分配到服务器集群；扩容的自适应性不强。</li><li>禁用协商：直接向服务器发出WebSocket请求。WebSocket连接一旦建立后，在客户端和服务器端直接就建立了持续的网络连接通道，在这个WebSocket连接中的后续往返WebSocket通信都是有同一台服务器来处理。缺点：无法降级到“服务器发送事件”或“长轮询”，不过不是大问题。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  skipNegotiation: <span class="literal">true</span>,</span><br><span class="line">  transport: signalR.HttpTransportType.WebSockets,</span><br><span class="line">&#125;;</span><br><span class="line">connection = <span class="keyword">new</span> signalR.HubConnectionBuilder() <span class="comment">// 创建从客户端到服务器端的连接</span></span><br><span class="line">  .withUrl(<span class="string">&quot;https://localhost:7122/Hubs/ChatRoomHub&quot;</span>,options) <span class="comment">// 设置服务器端集线器的地址</span></span><br><span class="line">  .withAutomaticReconnect() <span class="comment">// 设置自动重连机制</span></span><br><span class="line">  .build(); <span class="comment">// 构建完成</span></span><br></pre></td></tr></table></figure><h1 id="SignalR分布式部署"><a href="#SignalR分布式部署" class="headerlink" title="SignalR分布式部署"></a>SignalR分布式部署</h1><p>在多台服务器组成的分布式环境中，我们可以采用粘性会话或者禁用协商的方式来保证来自同一个客户端的请求被同一台服务器处理，但是在分布式环境中，还有其他问题需要解决。</p><p><img src="/img%5CWEBAPI%5C30.png"></p><p>客户端1发消息3、4收不到，客户端3发消息1、2收不到。因为这两台服务器之间的ChatRoomHub没有通信。为了解决这个问题，我们可以让多台服务器上的集线器连接到一个消息队列中，通过这个消息队列完成跨服务器的消息投递。</p><p>微软官方提供了用Redis服务器来解决SignalR部署在分布式环境中数据同步的方案————Redis backplane。</p><ol><li><p>所有服务器连接到同一个消息中间件。必须使用粘性会话或者跳过协商。</p></li><li><p>安装NuGet:<br>Micrsosft.AspNetCore.SignalR.StackExchangeRedis</p></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddSignalR().AddStackExchangeRedis(<span class="string">&quot;127.0.0.1&quot;</span>,options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Configuration.ChannelPrefix = <span class="string">&quot;SignalRChat&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果有多个SignalR应用程序连接同一台Redis服务器，那么我们需要为每一个应用程序配置唯一的ChannelPrefix。</p><h1 id="SignalR身认证"><a href="#SignalR身认证" class="headerlink" title="SignalR身认证"></a>SignalR身认证</h1><p>配置JWT的代码</p><ol><li>在配置系统中配置一个名字为JWT的节点，并在节点下创建SigningKey、ExpireSeconds两个配置项，分别代表JWT的密钥和过期时间（单位为秒）。我们在创建一个对应JWT节点的配置类JWTOptions,类中包含SigningKey、ExpireSwconds这两个属性。</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;JWT&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;SigningKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jlkerujoigsnvjlkasjfwehiojkgnsgss&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ExpireSeconds&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3600&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ConnectionStrings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Server=localhost;Database=T_youxianyu;Trusted_Connection=True;MultipleActiveResultSets=true;TrustServerCertificate=True;Encrypt=True;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Logging&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;LogLevel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Microsoft.AspNetCore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Warning&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;AllowedHosts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JWTOptions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? SigningKey &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ExpirSeconds &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>安装：<br>Microsoft.AspNetCore.Authentication.JwtBearer</p></li><li><p>编写代码对JWT进行配置。</p></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add services to the container.</span></span><br><span class="line"></span><br><span class="line">builder.Services.AddControllers();</span><br><span class="line"><span class="comment">// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle</span></span><br><span class="line">builder.Services.AddEndpointsApiExplorer();</span><br><span class="line">builder.Services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> scheme = <span class="keyword">new</span> OpenApiSecurityScheme()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*Description：在 Swagger UI 中显示的描述信息，指导用户如何输入认证信息*/</span></span><br><span class="line">        Description = <span class="string">&quot;Authorization header.\r\nExample:&#x27;Bearer 12345abcdef&#x27;&quot;</span>,</span><br><span class="line">        <span class="comment">/*Reference：引用类型为安全方案，ID 为 &quot;Authorization&quot;*/</span></span><br><span class="line">        Reference = <span class="keyword">new</span> OpenApiReference</span><br><span class="line">        &#123;</span><br><span class="line">            Type = ReferenceType.SecurityScheme,</span><br><span class="line">            Id = <span class="string">&quot;Authorization&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">/*Scheme：指定为 &quot;oauth2&quot;，尽管我们使用的是 JWT，但 Swagger UI 使用此值来显示授权按钮*/</span></span><br><span class="line">        Scheme = <span class="string">&quot;oauth2&quot;</span>,</span><br><span class="line">        <span class="comment">/*Name：HTTP 请求头的名称，通常为 &quot;Authorization&quot;*/</span></span><br><span class="line">        Name = <span class="string">&quot;Authorization&quot;</span>,</span><br><span class="line">        <span class="comment">/*In：指定在请求头中传递认证信息*/</span></span><br><span class="line">        In = ParameterLocation.Header,</span><br><span class="line">        <span class="comment">/*Type：指定为 API 密钥类型*/</span></span><br><span class="line">        Type = SecuritySchemeType.ApiKey,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/*将上面定义的安全方案添加到 Swagger 生成器中，名称为 &quot;Authorization&quot;*/</span></span><br><span class="line">    c.AddSecurityDefinition(<span class="string">&quot;Authorization&quot;</span>, scheme);</span><br><span class="line">    <span class="comment">/*创建一个安全需求对象，要求所有 API 操作都需要上述定义的安全方案*/</span></span><br><span class="line">    <span class="keyword">var</span> requirement = <span class="keyword">new</span> OpenApiSecurityRequirement();</span><br><span class="line">    <span class="comment">/*空的字符串列表表示不需要任何特定的作用域（scopes），适用于 JWT 认证*/</span></span><br><span class="line">    requirement[scheme] = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    c.AddSecurityRequirement(requirement);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">IServiceCollection services = builder.Services;</span><br><span class="line"><span class="comment">//配置数据库</span></span><br><span class="line">services.AddDbContext&lt;IdDbContext&gt;(opt =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>? connStr = builder.Configuration.GetConnectionString(<span class="string">&quot;Default&quot;</span>);</span><br><span class="line">    opt.UseSqlServer(connStr);</span><br><span class="line">&#125;);</span><br><span class="line">services.AddDataProtection(); <span class="comment">//对数据进行保护</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用AddIdentityCore添加标识框架的一些重要的基础服务</span></span><br><span class="line">services.AddIdentityCore&lt;User&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对密码进行设置</span></span><br><span class="line">    options.Password.RequireDigit = <span class="literal">false</span>; <span class="comment">//必须是数字</span></span><br><span class="line">    options.Password.RequireLowercase = <span class="literal">false</span>; <span class="comment">//小写</span></span><br><span class="line">    options.Password.RequireNonAlphanumeric = <span class="literal">false</span>; <span class="comment">//非字母数字</span></span><br><span class="line">    options.Password.RequireUppercase = <span class="literal">false</span>; <span class="comment">//大写字母</span></span><br><span class="line">    options.Password.RequiredLength = <span class="number">6</span>;<span class="comment">//长度6</span></span><br><span class="line">    options.Tokens.PasswordResetTokenProvider = TokenOptions.DefaultEmailProvider;</span><br><span class="line">    options.Tokens.EmailConfirmationTokenProvider = TokenOptions.DefaultEmailProvider;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//在使用标识框架的时候也需要注入和初始化非常多的服务</span></span><br><span class="line"><span class="keyword">var</span> idBuilder = <span class="keyword">new</span> IdentityBuilder(<span class="keyword">typeof</span>(User), <span class="keyword">typeof</span>(Role), services);</span><br><span class="line">idBuilder.AddEntityFrameworkStores&lt;IdDbContext&gt;()</span><br><span class="line">    .AddDefaultTokenProviders()</span><br><span class="line">    .AddRoleManager&lt;RoleManager&lt;Role&gt;&gt;()</span><br><span class="line">    .AddUserManager&lt;UserManager&lt;User&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//从配置文件（如appsettings.json）的 &quot;JWT&quot; 部分读取配置，并注册为JWTOptions类型的选项服务</span></span><br><span class="line"><span class="comment">//后续可通过依赖注入使用这些配置</span></span><br><span class="line">services.Configure&lt;JWTOptions&gt;(builder.Configuration.GetSection(<span class="string">&quot;JWT&quot;</span>));</span><br><span class="line"><span class="comment">//设置应用的主要认证方案为 JWT Bearer</span></span><br><span class="line"><span class="comment">//添加 JWT 承载认证处理器</span></span><br><span class="line">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</span><br><span class="line">    .AddJwtBearer(x =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//再次读取 JWT 配置（存在重复读取问题）</span></span><br><span class="line">        <span class="comment">/*var jwtOptions = builder.Configuration.GetSection(&quot;JWT&quot;).Get&lt;JWTOptions&gt;();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 注册JWT选项到依赖注入容器</span></span><br><span class="line"><span class="comment">        services.Configure&lt;JWTOptions&gt;(builder.Configuration.GetSection(&quot;JWT&quot;));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 生成安全密钥</span></span><br><span class="line"><span class="comment">        var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtOptions.SigningKey));*/</span></span><br><span class="line">        <span class="comment">//从配置中获取签名密钥并转换为安全密钥对象</span></span><br><span class="line">        <span class="keyword">var</span> jwtOpt = builder.Configuration.GetSection(<span class="string">&quot;JWT&quot;</span>).Get&lt;JWTOptions&gt;();</span><br><span class="line">        <span class="built_in">byte</span>[] keyBytes = Encoding.UTF8.GetBytes(jwtOpt.SigningKey);</span><br><span class="line">        <span class="keyword">var</span> secKey = <span class="keyword">new</span> SymmetricSecurityKey(keyBytes);</span><br><span class="line">        x.TokenValidationParameters = <span class="keyword">new</span> TokenValidationParameters()</span><br><span class="line">        &#123;</span><br><span class="line">            ValidateIssuer = <span class="literal">false</span>,         <span class="comment">// 不验证令牌发行人</span></span><br><span class="line">            ValidateAudience = <span class="literal">false</span>,       <span class="comment">// 不验证令牌受众</span></span><br><span class="line">            ValidateLifetime = <span class="literal">false</span>,       <span class="comment">// 不验证令牌有效期</span></span><br><span class="line">            ValidateIssuerSigningKey = <span class="literal">true</span>, <span class="comment">// 验证签名密钥</span></span><br><span class="line">            IssuerSigningKey = secKey       <span class="comment">// 设置签名密钥</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*JwtBearerEvents：这是 JWT 身份验证中间件的事件处理类，允许在身份验证过程的不同阶段插入自定义逻辑。*/</span></span><br><span class="line">        x.Events = <span class="keyword">new</span> JwtBearerEvents</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*OnMessageReceived：当中间件从请求中接收令牌时触发的事件。这里重写了该事件处理方法。*/</span></span><br><span class="line">            OnMessageReceived = context =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//从 URL 查询参数中获取access_token值</span></span><br><span class="line">                <span class="keyword">var</span> accessToken = context.Request.Query[<span class="string">&quot;access_token&quot;</span>];</span><br><span class="line">                <span class="comment">//检查当前请求路径是否是 SignalR 集线器路径 / Hubs / ChatRoomHub</span></span><br><span class="line">                <span class="keyword">var</span> path = context.HttpContext.Request.Path;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(accessToken) &amp;&amp; (path.StartsWithSegments(<span class="string">&quot;/Hub/ChatRoomHub&quot;</span>)))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果两个条件都满足，则将查询参数中的令牌赋值给context.Token，供后续验证使用</span></span><br><span class="line">                    context.Token = accessToken;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">/*// 从配置中读取JWT选项</span></span><br><span class="line"><span class="comment">var jwtOptions = builder.Configuration.GetSection(&quot;JWT&quot;).Get&lt;JWTOptions&gt;();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 注册JWT选项到依赖注入容器</span></span><br><span class="line"><span class="comment">services.Configure&lt;JWTOptions&gt;(builder.Configuration.GetSection(&quot;JWT&quot;));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 生成安全密钥</span></span><br><span class="line"><span class="comment">var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtOptions.SigningKey));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 配置JWT认证</span></span><br><span class="line"><span class="comment">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</span></span><br><span class="line"><span class="comment">    .AddJwtBearer(options =&gt;</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        options.TokenValidationParameters = new TokenValidationParameters</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            ValidateIssuer = true,               // 验证发行人</span></span><br><span class="line"><span class="comment">            ValidateAudience = true,             // 验证受众</span></span><br><span class="line"><span class="comment">            ValidateLifetime = true,             // 验证过期时间</span></span><br><span class="line"><span class="comment">            ValidateIssuerSigningKey = true,     // 验证签名密钥</span></span><br><span class="line"><span class="comment">            ValidIssuer = jwtOptions.Issuer,     // 设置有效发行人</span></span><br><span class="line"><span class="comment">            ValidAudience = jwtOptions.Audience, // 设置有效受众</span></span><br><span class="line"><span class="comment">            IssuerSigningKey = securityKey,      // 设置签名密钥</span></span><br><span class="line"><span class="comment">            ClockSkew = TimeSpan.Zero            // 严格验证过期时间</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 可选：添加事件处理（如令牌验证失败时的自定义响应）</span></span><br><span class="line"><span class="comment">        options.Events = new JwtBearerEvents</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            OnAuthenticationFailed = context =&gt;</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                if (context.Exception is SecurityTokenExpiredException)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    context.Response.Headers.Add(&quot;Token-Expired&quot;, &quot;true&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                return Task.CompletedTask;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">    &#125;);*/</span></span><br><span class="line"><span class="comment">//注入所有SignalR的服务</span></span><br><span class="line">builder.Services.AddSignalR(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.EnableDetailedErrors = <span class="literal">true</span>; <span class="comment">// 开发环境显示详细错误</span></span><br><span class="line">    options.ClientTimeoutInterval = TimeSpan.FromSeconds(<span class="number">30</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注入CORS服务</span></span><br><span class="line"><span class="built_in">string</span>[] urls = <span class="keyword">new</span>[] &#123; <span class="string">&quot;http://localhost:5173&quot;</span> &#125;;</span><br><span class="line">builder.Services.AddCors(options =&gt;</span><br><span class="line">    options.AddDefaultPolicy(builder =&gt;</span><br><span class="line">        builder.WithOrigins(urls).AllowAnyMethod()</span><br><span class="line">            .AllowAnyHeader().AllowCredentials())</span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the HTTP request pipeline.</span></span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.UseSwagger();</span><br><span class="line">    app.UseSwaggerUI();</span><br><span class="line">&#125;</span><br><span class="line">app.UseCors();</span><br><span class="line">app.UseHttpsRedirection();</span><br><span class="line">app.UseAuthentication();</span><br><span class="line">app.UseAuthorization();</span><br><span class="line">app.MapHub&lt;ChatRoomHub&gt;(<span class="string">&quot;/Hub/ChatRoomHub&quot;</span>);<span class="comment">//启用SignalR中间件</span></span><br><span class="line">app.MapControllers();</span><br><span class="line"></span><br><span class="line">app.Run();</span><br></pre></td></tr></table></figure><ol start="4"><li><p>在app.UseAuthorization();之前添加app.UseAuthentication();</p></li><li><p>在控制器类Test1Controller中增加登录并且创建JWT的操作方法Login。</p></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">BuildToken</span>(<span class="params">IEnumerable&lt;Claim&gt; claims, JWTOptions options</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment"><span class="doctag">///</span>从配置中读取过期秒数，计算令牌过期时间</span></span><br><span class="line">     DateTime expires = DateTime.Now.AddSeconds(options.ExpirSeconds);</span><br><span class="line">     <span class="comment">//使用配置中的签名密钥创建安全密钥对象</span></span><br><span class="line">     <span class="built_in">byte</span>[] keyBytes = Encoding.UTF8.GetBytes(options.SigningKey);</span><br><span class="line">     <span class="comment">//指定 HMAC SHA-256 算法进行签名</span></span><br><span class="line">     <span class="keyword">var</span> secKey = <span class="keyword">new</span> SymmetricSecurityKey(keyBytes);</span><br><span class="line">     <span class="keyword">var</span> credentials = <span class="keyword">new</span> SigningCredentials(secKey, SecurityAlgorithms.HmacSha256Signature);</span><br><span class="line">     <span class="comment">//创建 JWT 令牌描述符，包含过期时间, 签名凭证, 用户声明</span></span><br><span class="line">     <span class="keyword">var</span> tokenDescriptor = <span class="keyword">new</span> JwtSecurityToken(expires: expires, signingCredentials: credentials, claims: claims);</span><br><span class="line">     <span class="comment">//使用JwtSecurityTokenHandler将令牌描述符转换为 JWT 字符串</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> JwtSecurityTokenHandler().WriteToken(tokenDescriptor);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Login</span>(<span class="params">LoginRequest loginRequest, [FromServices] IOptions&lt;JWTOptions&gt; jwtOptions</span>)</span></span><br><span class="line">&#123;  <span class="comment">//LoginRequest：包含用户名和密码的登录请求模型</span></span><br><span class="line">   <span class="comment">//IOptions&lt;JWTOptions&gt;：从依赖注入容器获取 JWT 配置选项</span></span><br><span class="line">    <span class="built_in">string</span> userName = loginRequest.UserName;</span><br><span class="line">    <span class="built_in">string</span> password = loginRequest.Password;</span><br><span class="line">    <span class="comment">//通过用户名查找用户</span></span><br><span class="line">    <span class="keyword">var</span> user = <span class="keyword">await</span> _userManager.FindByNameAsync(userName);</span><br><span class="line">    <span class="comment">//验证密码是否正确</span></span><br><span class="line">    <span class="keyword">var</span> success = <span class="keyword">await</span> _userManager.CheckPasswordAsync(user, password);</span><br><span class="line">    <span class="keyword">if</span> (!success&amp;&amp;user==<span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//验证失败返回 HTTP 400 错误</span></span><br><span class="line">        <span class="keyword">return</span> BadRequest(<span class="string">&quot;用户名或者密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> claims = <span class="keyword">new</span> List&lt;Claim&gt;();</span><br><span class="line">    <span class="comment">//NameIdentifier：用户唯一标识</span></span><br><span class="line">    claims.Add(<span class="keyword">new</span> Claim(ClaimTypes.NameIdentifier, user.Id.ToString()));</span><br><span class="line">    <span class="comment">//Name：用户名</span></span><br><span class="line">    claims.Add(<span class="keyword">new</span> Claim(ClaimTypes.Name, user.UserName));</span><br><span class="line">    <span class="keyword">var</span> roles = <span class="keyword">await</span> _userManager.GetRolesAsync(user);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> role <span class="keyword">in</span> roles)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Role：用户角色（可包含多个）</span></span><br><span class="line">        claims.Add(<span class="keyword">new</span> Claim(ClaimTypes.Role, role));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用辅助方法生成 JWT 字符串</span></span><br><span class="line">    <span class="comment">//返回 HTTP 200 响应，包含生成的令牌</span></span><br><span class="line">    <span class="built_in">string</span> jwtToken = BuildToken(claims, jwtOptions.Value);</span><br><span class="line">    <span class="keyword">return</span> Ok(jwtToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>在需要登录才能访问的集线器类上或者方法上添加[Authorize]。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChatHub</span> : <span class="title">Hub</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> UserManager&lt;User&gt; _userManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatHub</span>(<span class="params">UserManager&lt;User&gt; userManager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _userManager = userManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送公共消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">SendPublicMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> userName = Context.User.Identity.Name;</span><br><span class="line">        <span class="built_in">string</span> time = DateTime.Now.ToString(<span class="string">&quot;HH:mm&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> msg = <span class="string">$&quot;<span class="subst">&#123;userName&#125;</span>(<span class="subst">&#123;Context.ConnectionId&#125;</span>) <span class="subst">&#123;time&#125;</span>: <span class="subst">&#123;message&#125;</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Clients.All.SendAsync(<span class="string">&quot;ReceivePublicMessage&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>前端代码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">legend</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;state.loginData.userName&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;state.loginData.password&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;loginClick&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    公屏：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;state.userMessage&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">v-on:keypress</span>=<span class="string">&quot;txtMsgOnkeypress&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(msg,index) in state.messages&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">import</span> &#123; reactive, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">import</span> * <span class="keyword">as</span> signalR <span class="keyword">from</span> <span class="string">&#x27;@microsoft/signalr&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> connection;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;<span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// state中增加一个对用户名、密码进行绑定的属性，以及一个保存登录JWT的属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">accessToken</span>:<span class="string">&quot;&quot;</span>,<span class="attr">userMessage</span>: <span class="string">&quot;&quot;</span>, <span class="attr">messages</span>: [],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">loginData</span>: &#123; <span class="attr">userName</span>: <span class="string">&quot;&quot;</span>, <span class="attr">password</span>: <span class="string">&quot;&quot;</span> &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">privateMsg</span>: &#123; <span class="attr">destUserName</span>:<span class="string">&quot;&quot;</span>,<span class="attr">message</span>:<span class="string">&quot;&quot;</span>&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// 启动 SignalR 连接</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">const</span> startConn = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// 配置 SignalR 连接</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">const</span> transport = signalR.<span class="property">HttpTransportType</span>.<span class="property">WebSockets</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">const</span> options = &#123; <span class="attr">skipNegotiation</span>: <span class="literal">true</span>, <span class="attr">transport</span>: transport &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// 通过options的accessTokenFactory回调函数把JWT传递给服务器端</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// 创建并启动连接</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                options.<span class="property">accessTokenFactory</span> = <span class="function">() =&gt;</span> state.<span class="property">accessToken</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                connection = <span class="keyword">new</span> signalR.<span class="title class_">HubConnectionBuilder</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    .<span class="title function_">withUrl</span>(<span class="string">&#x27;https://localhost:7122/Hubs/ChatRoomHub&#x27;</span>, options)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    .<span class="title function_">withAutomaticReconnect</span>().<span class="title function_">build</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="keyword">await</span> connection.<span class="title function_">start</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                &#125; <span class="keyword">catch</span> (err) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="title function_">alert</span>(err);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// 注册消息接收处理函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                connection.<span class="title function_">on</span>(<span class="string">&#x27;ReceivePublicMessage&#x27;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    state.<span class="property">messages</span>.<span class="title function_">push</span>(msg);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="title function_">alert</span>(<span class="string">&quot;登陆成功可以聊天了&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// 登录按钮的响应函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">const</span> loginClick = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// 发送登录请求获取 JWT</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">const</span> resp = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;https://localhost:7122/Test/Login&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    state.<span class="property">loginData</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                state.<span class="property">accessToken</span> = resp.<span class="property">data</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">// 启动 SignalR 连接</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="title function_">startConn</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// 公屏消息输入框的按键处理</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">const</span> txtMsgOnkeypress = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">if</span> (e.<span class="property">keyCode</span> != <span class="number">13</span>) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="comment">// 调用服务器端方法发送消息</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="keyword">await</span> connection.<span class="title function_">invoke</span>(<span class="string">&quot;SendPublicMessage&quot;</span>, state.<span class="property">userMessage</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                &#125;<span class="keyword">catch</span> (err) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="title function_">alert</span>(err);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                state.<span class="property">userMessage</span> = <span class="string">&quot;&quot;</span>;<span class="comment">// 清空输入框</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// 私信输入框的按键处理</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">const</span> txtPrivateMsgOnkeypress = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">if</span> (e.<span class="property">keyCode</span> != <span class="number">13</span>) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">const</span> destUserName = state.<span class="property">privateMsg</span>.<span class="property">destUserName</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">const</span> msg = state.<span class="property">privateMsg</span>.<span class="property">message</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="keyword">const</span> ret = <span class="keyword">await</span> connection.<span class="title function_">invoke</span>(<span class="string">&quot;SendPublicMessage&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                        destUserName, msg);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="keyword">if</span> (ret != <span class="string">&quot;ok&quot;</span>) &#123; <span class="title function_">alert</span>(ret);&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                &#125; <span class="keyword">catch</span> (err) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="title function_">alert</span>(err);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                state.<span class="property">privateMsg</span>.<span class="property">message</span> = <span class="string">&quot;&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">return</span> &#123; state, loginClick, txtMsgOnkeypress, txtPrivateMsgOnkeypress&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="SignalR：针对部分客户端的消息推送"><a href="#SignalR：针对部分客户端的消息推送" class="headerlink" title="SignalR：针对部分客户端的消息推送"></a>SignalR：针对部分客户端的消息推送</h1><blockquote><p>在我们进行客户端筛选的时候，有3个筛选参数：ConnectionId、组合用户ID。ConnectionionId是SignalR为每个连接分配的唯一标识，我们可以通过集线器的Context属性中的ConnectionId属性获取当前连接的ConnectionId：每个组有唯一的名字，对于连接到同一个集线器中的客户端，我们可以把它们分组；用户ID是登录用户的ID，它对应的是类型为ClaimTypes.NameIdentifier的Claim的值，如果使用用户ID进行筛选，我们需要在客户端登录的时候设定类型为ClaimTypes.NameIdentifier的Claim。</p></blockquote><p><b>Hub类</b><br>Hub类的Groups属性为IGroupManager类型，它可以用来对组成员进行管理，IGroupManager类包含如下所示的方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行后，该客户端将被添加到指定名称的组中</span></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">this</span>.Groups.AddToGroupAsync(connId, message);</span><br><span class="line"><span class="comment">//执行后，该客户端将不再属于指定的组</span></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">this</span>.Groups.RemoveFromGroupAsync(connId, message);</span><br></pre></td></tr></table></figure><p>我们在把连接加入组中的时候，如果指定名字的组不存在，SignalR会自动创建组。因为连接和组的关系是通过ConnectionId建立的，所以客户端重连之后，我们就需要把连接重新加入组。</p><p>Hub类的Clients属性为IHubCallerClients类型，它可以用来对连接到当前集线器的客户端进行筛选。IHubCallerClients类包含如下所示的成员。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前连接的客户端</span></span><br><span class="line">T Caller &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"><span class="comment">//获取除了当前连接外的所有客户端</span></span><br><span class="line">T Others &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"><span class="comment">//获取名字为groupName组中除了当前连接外的其他客户端</span></span><br><span class="line"><span class="function">T <span class="title">OthersInGroup</span>(<span class="params"><span class="built_in">string</span> groupName</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取所有连接的客户端</span></span><br><span class="line">T All &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"><span class="comment">//获取除了excludedConnectionIds的客户端</span></span><br><span class="line"><span class="function">T <span class="title">AllExcept</span>(<span class="params">IReadOnlyList&lt;<span class="built_in">string</span>&gt; excludedConnectionIds</span>)</span>;</span><br><span class="line"><span class="comment">//获取connectionId客户端</span></span><br><span class="line"><span class="function">T <span class="title">Client</span>(<span class="params"><span class="built_in">string</span> connectionId</span>)</span>;</span><br><span class="line"><span class="comment">//获取包含在connectionIds中的客户端</span></span><br><span class="line"><span class="function">T <span class="title">Clients</span>(<span class="params">IReadOnlyList&lt;<span class="built_in">string</span>&gt; connectionIds</span>)</span>;</span><br><span class="line"><span class="comment">//获取组名groupName中的客户端</span></span><br><span class="line"><span class="function">T <span class="title">Group</span>(<span class="params"><span class="built_in">string</span> groupName</span>)</span>;</span><br><span class="line"><span class="comment">//获取组名groupName中的客户端，除了在excludedConnectionIds中</span></span><br><span class="line"><span class="function">T <span class="title">GroupExcept</span>(<span class="params"><span class="built_in">string</span> groupName, IReadOnlyList&lt;<span class="built_in">string</span>&gt; excludedConnectionIds</span>)</span>;</span><br><span class="line"><span class="comment">//获取组名包含在groupNames中的客户端</span></span><br><span class="line"><span class="function">T <span class="title">Groups</span>(<span class="params">IReadOnlyList&lt;<span class="built_in">string</span>&gt; groupNames</span>)</span>;</span><br><span class="line"><span class="comment">//获取用户id的客户端</span></span><br><span class="line"><span class="function">T <span class="title">User</span>(<span class="params"><span class="built_in">string</span> userId</span>)</span>;</span><br><span class="line"><span class="comment">//获取用户id包含在userIds中的客户端</span></span><br><span class="line"><span class="function">T <span class="title">Users</span>(<span class="params">IReadOnlyList&lt;<span class="built_in">string</span>&gt; userIds</span>)</span>;</span><br></pre></td></tr></table></figure><p><b>发送私聊消息</b></p><p>下面我们来为之前编写的Web聊天室增加“发送私聊消息”的功能。</p><ol><li>在ChatRoomHub中增加一个发送私聊消息的SendPrivateMessage方法。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChatHub</span> : <span class="title">Hub</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> UserManager&lt;User&gt; _userManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatHub</span>(<span class="params">UserManager&lt;User&gt; userManager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _userManager = userManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送公共消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">SendPublicMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> userName = Context.User.Identity.Name;</span><br><span class="line">        <span class="built_in">string</span> time = DateTime.Now.ToString(<span class="string">&quot;HH:mm&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> msg = <span class="string">$&quot;<span class="subst">&#123;userName&#125;</span>(<span class="subst">&#123;Context.ConnectionId&#125;</span>) <span class="subst">&#123;time&#125;</span>: <span class="subst">&#123;message&#125;</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Clients.All.SendAsync(<span class="string">&quot;ReceivePublicMessage&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送私人消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">SendPrivateMessage</span>(<span class="params"><span class="built_in">string</span> destUserName, <span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> destUser = <span class="keyword">await</span> _userManager.FindByNameAsync(destUserName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (destUser == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;目标用户不存在&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> srcUserName = Context.User.Identity.Name;</span><br><span class="line">        <span class="built_in">string</span> time = DateTime.Now.ToString(<span class="string">&quot;HH:mm&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> Clients.User(destUser.Id.ToString())</span><br><span class="line">            .SendAsync(<span class="string">&quot;ReceivePrivateMessage&quot;</span>, srcUserName, time, message);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，SignalR不会对消息进行持久化，因此即使目标用户当前不在线，SendAsync方法的调用也不会出错，而且用户上线后也不会收到离线期间的消息。同样的道理也适用于分组发送消息，用户在上线后才能加入一个分组，因此用户也无法收到离线期间该组内的消息。</p><p>如果我们的系统需要实现接收离线期间的消息的功能，就需要再自行额外开发消息的持久化功能，比如服务器端在向客户端发送消息的同时，也要把消息保存到数据库中；在用户上线时，程序要先到数据库中查询历史消息。</p><ol start="2"><li>在前端页面增加私聊功能的界面和代码。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div v-<span class="keyword">if</span>=<span class="string">&quot;!state.isConnected&quot;</span>&gt;</span><br><span class="line">            &lt;fieldset&gt;</span><br><span class="line">                &lt;legend&gt;登录&lt;/legend&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    用户名：&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;state.loginData.userName&quot;</span>/&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    密码：&lt;input type=<span class="string">&quot;password&quot;</span>  v-model=<span class="string">&quot;state.loginData.password&quot;</span>&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;input type=<span class="string">&quot;button&quot;</span> <span class="keyword">value</span>=<span class="string">&quot;登录&quot;</span> v-<span class="keyword">on</span>:click=<span class="string">&quot;loginClick&quot;</span>/&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/fieldset&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;div v-<span class="keyword">else</span>&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                公屏：&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;state.userMessage&quot;</span> </span><br><span class="line">                    v-<span class="keyword">on</span>:keypress=<span class="string">&quot;txtMsgOnkeypress&quot;</span> /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            </span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                私聊给：&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;state.privateMsg.destUserName&quot;</span>/&gt;</span><br><span class="line">                说：&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;state.privateMsg.message&quot;</span> </span><br><span class="line">                    v-<span class="keyword">on</span>:keypress=<span class="string">&quot;txtPrivateMsgOnkeypress&quot;</span>/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            </span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h3&gt;消息列表&lt;/h3&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;(msg, index) in state.messages&quot;</span> :key=<span class="string">&quot;index&quot;</span></span><br><span class="line">                        :<span class="keyword">class</span>=<span class="string">&quot;&#123; &#x27;private-message&#x27;: msg.isPrivate &#125;&quot;</span>&gt;</span><br><span class="line">                        &#123;&#123; msg.content &#125;&#125;</span><br><span class="line">                    &lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#123; reactive, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line">    import * <span class="keyword">as</span> signalR <span class="keyword">from</span> <span class="string">&#x27;@microsoft/signalr&#x27;</span>;</span><br><span class="line">    import axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    export <span class="literal">default</span> &#123;</span><br><span class="line">        name: <span class="string">&#x27;ChatComponent&#x27;</span>,</span><br><span class="line">        setup() &#123;</span><br><span class="line">            <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">                accessToken: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                userMessage: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                messages: [],</span><br><span class="line">                loginData: &#123; userName: <span class="string">&quot;&quot;</span>, password: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">                privateMsg: &#123; destUserName: <span class="string">&quot;&quot;</span>, message: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">                isConnected: <span class="literal">false</span></span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> connection = <span class="literal">null</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">const</span> startConn = <span class="function"><span class="keyword">async</span> <span class="title">function</span> ()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (connection) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">await</span> connection.stop();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                        console.error(<span class="string">&#x27;停止连接时出错:&#x27;</span>, err);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 连接到正确的 Hub（ChatHub）</span></span><br><span class="line">                <span class="keyword">const</span> options = &#123;</span><br><span class="line">                    skipNegotiation: <span class="literal">true</span>,</span><br><span class="line">                    transport: signalR.HttpTransportType.WebSockets,</span><br><span class="line">                    accessTokenFactory: () =&gt; state.accessToken</span><br><span class="line">                &#125;;</span><br><span class="line">                </span><br><span class="line">                connection = <span class="keyword">new</span> signalR.HubConnectionBuilder()</span><br><span class="line">                    .withUrl(<span class="string">&#x27;https://localhost:7122/Hubs/ChatHub&#x27;</span>, options)</span><br><span class="line">                    .withAutomaticReconnect().build();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 监听连接状态</span></span><br><span class="line">                connection.onclose(error =&gt; &#123;</span><br><span class="line">                    console.log(<span class="string">&#x27;连接已关闭:&#x27;</span>, error);</span><br><span class="line">                    state.isConnected = <span class="literal">false</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">                connection.onreconnected(connectionId =&gt; &#123;</span><br><span class="line">                    console.log(<span class="string">&#x27;已重新连接，ID:&#x27;</span>, connectionId);</span><br><span class="line">                    state.isConnected = <span class="literal">true</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">await</span> connection.start();</span><br><span class="line">                    state.isConnected = <span class="literal">true</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 注册消息处理函数</span></span><br><span class="line">                    connection.<span class="keyword">on</span>(<span class="string">&#x27;ReceivePublicMessage&#x27;</span>, (msg) =&gt; &#123;</span><br><span class="line">                        console.log(<span class="string">&#x27;收到公共消息:&#x27;</span>, msg);</span><br><span class="line">                        state.messages.push(&#123;</span><br><span class="line">                            content: msg,</span><br><span class="line">                            isPrivate: <span class="literal">false</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;);</span><br><span class="line">                    </span><br><span class="line">                    connection.<span class="keyword">on</span>(<span class="string">&#x27;ReceivePrivateMessage&#x27;</span>, (srcUser, time, msg) =&gt; &#123;</span><br><span class="line">                        console.log(<span class="string">&#x27;收到私信:&#x27;</span>, srcUser, time, msg);</span><br><span class="line">                        state.messages.push(&#123;</span><br><span class="line">                            content: `$&#123;srcUser&#125;在$&#123;time&#125;发来私信: $&#123;msg&#125;`,</span><br><span class="line">                            isPrivate: <span class="literal">true</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;);</span><br><span class="line">                    </span><br><span class="line">                    alert(<span class="string">&quot;登录成功，可以开始聊天了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    console.error(<span class="string">&#x27;连接失败:&#x27;</span>, err);</span><br><span class="line">                    alert(<span class="string">&#x27;连接服务器失败: &#x27;</span> + err.message);</span><br><span class="line">                    state.isConnected = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">const</span> loginClick = <span class="function"><span class="keyword">async</span> <span class="title">function</span> ()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> resp = <span class="keyword">await</span> axios.post(<span class="string">&#x27;https://localhost:7122/Test/Login&#x27;</span>,</span><br><span class="line">                        state.loginData);</span><br><span class="line">                    state.accessToken = resp.data;</span><br><span class="line">                    startConn();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    alert(<span class="string">&#x27;登录失败: &#x27;</span> + err.message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">const</span> ensureConnection = () =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (!connection || connection.state !== signalR.HubConnectionState.Connected) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&#x27;连接未建立或已断开，请先登录&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">const</span> txtMsgOnkeypress = <span class="function"><span class="keyword">async</span> <span class="title">function</span> (<span class="params">e</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.keyCode !== <span class="number">13</span>) <span class="keyword">return</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ensureConnection();</span><br><span class="line">                    <span class="keyword">await</span> connection.invoke(<span class="string">&quot;SendPublicMessage&quot;</span>, state.userMessage);</span><br><span class="line">                    state.userMessage = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    alert(err.message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">const</span> txtPrivateMsgOnkeypress = <span class="function"><span class="keyword">async</span> <span class="title">function</span> (<span class="params">e</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.keyCode !== <span class="number">13</span>) <span class="keyword">return</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">const</span> destUserName = state.privateMsg.destUserName;</span><br><span class="line">                <span class="keyword">const</span> msg = state.privateMsg.message;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!destUserName || !msg) &#123;</span><br><span class="line">                    alert(<span class="string">&#x27;请输入目标用户和消息内容&#x27;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ensureConnection();</span><br><span class="line">                    <span class="keyword">const</span> ret = <span class="keyword">await</span> connection.invoke(<span class="string">&quot;SendPrivateMessage&quot;</span>, destUserName, msg);</span><br><span class="line">                    <span class="keyword">if</span> (ret !== <span class="string">&quot;ok&quot;</span>) &#123;</span><br><span class="line">                        alert(ret);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 在自己的消息列表中显示已发送的私信</span></span><br><span class="line">                        <span class="keyword">const</span> time = <span class="keyword">new</span> Date().toLocaleTimeString();</span><br><span class="line">                        state.messages.push(&#123;</span><br><span class="line">                            content: `你在$&#123;time&#125;给$&#123;destUserName&#125;发送了私信: $&#123;msg&#125;`,</span><br><span class="line">                            isPrivate: <span class="literal">true</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    state.privateMsg.message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    alert(err.message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 组件卸载时关闭连接</span></span><br><span class="line">            onMounted(() =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> () =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (connection) &#123;</span><br><span class="line">                        connection.stop().<span class="keyword">catch</span>(err =&gt; &#123;</span><br><span class="line">                            console.error(<span class="string">&#x27;关闭连接时出错:&#x27;</span>, err);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> &#123; state, loginClick, txtMsgOnkeypress, txtPrivateMsgOnkeypress &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style <span class="keyword">scoped</span>&gt;</span><br><span class="line">.<span class="keyword">private</span>-message &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="在外部向集线器推送消息"><a href="#在外部向集线器推送消息" class="headerlink" title="在外部向集线器推送消息"></a>在外部向集线器推送消息</h1><p>不要再Hub做事务，违法单一原则。</p><blockquote><p>可以在MVC控制器、托管服务等外部向客户端推送消息。<br>可以通过注入IHubContext&lt;THub&gt;来获取对集线器进行操作的服务。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;TestController&gt; _logger;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> UserManager&lt;User&gt; _userManager;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> RoleManager&lt;Role&gt; _roleManager;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IHubContext&lt;ChatHub&gt; hubContext;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestController</span></span></span><br><span class="line"><span class="function">        (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            ILogger&lt;TestController&gt; logger,</span></span></span><br><span class="line"><span class="params"><span class="function">            UserManager&lt;User&gt; userManager,</span></span></span><br><span class="line"><span class="params"><span class="function">            RoleManager&lt;Role&gt; roleManager</span></span></span><br><span class="line"><span class="params"><span class="function">,</span></span></span><br><span class="line"><span class="params"><span class="function">            IHubContext&lt;ChatHub&gt; hubContext</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _logger = logger;</span><br><span class="line">            _userManager = userManager;</span><br><span class="line">            _roleManager = roleManager;</span><br><span class="line">            <span class="keyword">this</span>.hubContext = hubContext;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="meta">HttpPost</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&gt; <span class="title">AddUser</span>(<span class="params"><span class="built_in">string</span> userName,<span class="built_in">string</span> password</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User &#123; UserName = userName &#125;;</span><br><span class="line">            <span class="keyword">await</span> _userManager.CreateAsync(user,password);</span><br><span class="line">            hubContext.Clients.All.SendAsync(<span class="string">&quot;PublicMsgReceived&quot;</span>, <span class="string">&quot;欢迎&quot;</span> + userName + <span class="string">&quot;加入我们&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Ok(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
            <tag> JWT </tag>
            
            <tag> SignalR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core Session与JWT</title>
      <link href="/2025/05/09/asp.net%20core/ASP.NET%20Core%E9%AB%98%E7%BA%A7%E7%BB%84%E4%BB%B6/"/>
      <url>/2025/05/09/asp.net%20core/ASP.NET%20Core%E9%AB%98%E7%BA%A7%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Authentication与Authorization"><a href="#Authentication与Authorization" class="headerlink" title="Authentication与Authorization"></a>Authentication与Authorization</h1><p>1.Authentication对访问者的用户身份进行验证，“用户是否登陆成功”。<br>2.Authorization验证访问者用户身份是否又对资源访问的访问权限，“用户是否有权限访问这个地址”。</p><h1 id="标识（Identity）框架"><a href="#标识（Identity）框架" class="headerlink" title="标识（Identity）框架"></a>标识（Identity）框架</h1><p>1.标识（Identity）框架：采用基于角色的访问控制（Role-Based Access Control,简称RBAC）策略，内置了对用户、角色等表的管理以及相关的接口，支持外部登录、2FA等。<br>2.标识框架使用EF Core对数据进行操作，因此标识框架支持几乎所有数据库。</p><h2 id="Identity框架使用"><a href="#Identity框架使用" class="headerlink" title="Identity框架使用"></a>Identity框架使用</h2><p>1.IdentityUser&lt;TKey&gt;、IdentityRole&lt;TKey&gt;,TKey代表主键的类型。我们一般编写继承自IdentityUser&lt;TKey&gt;、IdentityRole&lt;TKey&gt;等的自定义类，可以增加自定义属性。<br>2.NuGet安装<br>Microsoft.AspNetCore.Identity.EntityFrameworkCore<br>3.创建继承自IdentityDbContext的类。<br>4.可以通过IdDbContext类来操作数据库，不过框架中提供了RoleManager、UserManager等类来简化对数据库的操作。<br>5.部分方法的返回值为Task&lt;IdentityResult&gt;类型，查看、讲解IdentityResult类型定义。</p><ol><li>创建用户实体类User和角色实体类Role. 分别继承自IdentityUser&lt;long&gt;、IdentityRole&lt;long&gt;的User类和Role类。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class User:IdentityUser&lt;long&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public DateTime CreationTime &#123; get; set; &#125;</span><br><span class="line">    public string? NickName &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Role</span>:<span class="title">IdentityRole</span>&lt;<span class="title">long</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IdnetityUser中定义类了很多属性。<br><img src="/img%5CWEBAPI%5C22.png"></p><p>除了IdentityUser和IdentityRole之外，表示框架中还有很多其他实体类。</p><ol start="2"><li>创建继承自IdentityDbContext的类，这是一个EF Core中的上下文类，我们可以通过这个类操作数据库。IdentityDbContext是一个泛型类，有3个泛型参数，分别代表用户类型、角色类型和主键类型。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IdDbContext</span>:<span class="title">IdentityDbContext</span>&lt;<span class="title">User</span>,<span class="title">Role</span>,<span class="title">long</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdDbContext</span>(<span class="params">DbContextOptions&lt;IdDbContext&gt; options</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnModelCreating(builder);</span><br><span class="line">        <span class="keyword">new</span> UserConfig().Configure(builder.Entity&lt;User&gt;());</span><br><span class="line">        <span class="keyword">new</span> RoleConfig().Configure(builder.Entity&lt;Role&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标识框架中的方法有执行失败的可能，比如重置密码可能由于密码太简单而失败，因此标识框架中部分方法的返回值为Task类型。IdentityResult类型中有bool类型的Succeeded属性表示操作是否成功；如果操作失败，我们可以从Errors属性中获取错误的详细信息，由于有可能有多条错误信息，因此Errors是一个IEnumerable类型的属性。IdentityError类包含Code（错误码）和Description（错误的详细信息）这两个属性。</p><ol start="3"><li>向依赖注入容器中注册与标识框架相关的服务。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add services to the container.</span></span><br><span class="line"></span><br><span class="line">builder.Services.AddControllers();</span><br><span class="line"><span class="comment">// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle</span></span><br><span class="line">builder.Services.AddEndpointsApiExplorer();</span><br><span class="line">builder.Services.AddSwaggerGen();</span><br><span class="line"></span><br><span class="line">IServiceCollection services = builder.Services;</span><br><span class="line"><span class="comment">//配置数据库</span></span><br><span class="line">services.AddDbContext&lt;IdDbContext&gt;(opt =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>? connStr = builder.Configuration.GetConnectionString(<span class="string">&quot;Default&quot;</span>);</span><br><span class="line">    opt.UseSqlServer(connStr);</span><br><span class="line">&#125;);</span><br><span class="line">services.AddDataProtection(); <span class="comment">//对数据进行保护</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用AddIdentityCore添加标识框架的一些重要的基础服务</span></span><br><span class="line">services.AddIdentityCore&lt;User&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对密码进行设置</span></span><br><span class="line">    options.Password.RequireDigit = <span class="literal">false</span>; <span class="comment">//必须是数字</span></span><br><span class="line">    options.Password.RequireLowercase = <span class="literal">false</span>; <span class="comment">//小写</span></span><br><span class="line">    options.Password.RequireNonAlphanumeric = <span class="literal">false</span>; <span class="comment">//非字母数字</span></span><br><span class="line">    options.Password.RequireUppercase = <span class="literal">false</span>; <span class="comment">//大写字母</span></span><br><span class="line">    options.Password.RequiredLength = <span class="number">6</span>;<span class="comment">//长度6</span></span><br><span class="line">    options.Tokens.PasswordResetTokenProvider = TokenOptions.DefaultEmailProvider;</span><br><span class="line">    options.Tokens.EmailConfirmationTokenProvider = TokenOptions.DefaultEmailProvider;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//在使用标识框架的时候也需要注入和初始化非常多的服务</span></span><br><span class="line"><span class="keyword">var</span> idBuilder = <span class="keyword">new</span> IdentityBuilder(<span class="keyword">typeof</span>(User), <span class="keyword">typeof</span>(Role), services);</span><br><span class="line">idBuilder.AddEntityFrameworkStores&lt;IdDbContext&gt;()</span><br><span class="line">    .AddDefaultTokenProviders()</span><br><span class="line">    .AddRoleManager&lt;RoleManager&lt;Role&gt;&gt;()</span><br><span class="line">    .AddUserManager&lt;UserManager&lt;User&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the HTTP request pipeline.</span></span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.UseSwagger();</span><br><span class="line">    app.UseSwaggerUI();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.UseHttpsRedirection();</span><br><span class="line"></span><br><span class="line">app.UseAuthorization();</span><br><span class="line"></span><br><span class="line">app.MapControllers();</span><br><span class="line"></span><br><span class="line">app.Run();</span><br></pre></td></tr></table></figure><p>然后执行数据库迁移Add-Migration createIdentity、Update-database等命令执行EF Core的数据库迁移，然后程序就会在数据库中生成多张数据库表。这些数据库表都由标识框架负责管理，开发人员一般不需要直接访问这些表。</p><ol start="5"><li>编写控制器的代码。我们在控制器中需要对角色、用户进行操作，也需要输出日志，因此通过控制器的构造方法注入相关的服务。编写创建角色和用户的方法CreateUserRole。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;TestController&gt; _logger;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> UserManager&lt;User&gt; _userManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> RoleManager&lt;Role&gt; _roleManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestController</span></span></span><br><span class="line"><span class="function">    (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        ILogger&lt;TestController&gt; logger, </span></span></span><br><span class="line"><span class="params"><span class="function">        UserManager&lt;User&gt; userManager, </span></span></span><br><span class="line"><span class="params"><span class="function">        RoleManager&lt;Role&gt; roleManager</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">        _userManager = userManager;</span><br><span class="line">        _roleManager = roleManager;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">CreateUserRole</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检查系统中是否已存在名为 &quot;admin&quot; 的角色</span></span><br><span class="line">        <span class="built_in">bool</span> roleExists = <span class="keyword">await</span> _roleManager.RoleExistsAsync(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//若不存在，则创建一个名为 &quot;Admin&quot; 的角色实例</span></span><br><span class="line">        <span class="comment">//（注意：角色名称为 &quot;Admin&quot;，与检查时的 &quot;admin&quot; 大小写不一致，可能导致后续问题）</span></span><br><span class="line">        <span class="keyword">if</span> (!roleExists)</span><br><span class="line">        &#123;</span><br><span class="line">            Role role = <span class="keyword">new</span> Role &#123; Name = <span class="string">&quot;Admin&quot;</span> &#125;;</span><br><span class="line">            <span class="keyword">var</span> r = <span class="keyword">await</span> _roleManager.CreateAsync(role);</span><br><span class="line">            <span class="keyword">if</span> (!r.Succeeded)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> BadRequest(r.Errors);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查名为 &quot;if&quot; 的用户是否存在</span></span><br><span class="line">        User user = <span class="keyword">await</span> _userManager.FindByNameAsync(<span class="string">&quot;if&quot;</span>);</span><br><span class="line">        <span class="comment">//若不存在，则创建新用户并设置用户名、邮箱，同时确认邮箱已验证</span></span><br><span class="line">        <span class="comment">//（EmailConfirmed = true）</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            user = <span class="keyword">new</span> User</span><br><span class="line">            &#123;</span><br><span class="line">                UserName = <span class="string">&quot;YOUXIANYU&quot;</span>,</span><br><span class="line">                Email = <span class="string">&quot;123456@QQ.COM&quot;</span>,</span><br><span class="line">                EmailConfirmed = <span class="literal">true</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//使用密码 &quot;123456&quot; 创建用户（注意：生产环境中应使用更安全的密码策略）</span></span><br><span class="line">            <span class="keyword">var</span> r = <span class="keyword">await</span> _userManager.CreateAsync(user, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!r.Succeeded)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> BadRequest(r.Errors);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将用户添加到 &quot;admin&quot; 角色</span></span><br><span class="line">            <span class="comment">//（注意：此处角色名称为 &quot;admin&quot;，与创建时的 &quot;Admin&quot; 大小写不一致，可能导致角色分配失败）</span></span><br><span class="line">            r = <span class="keyword">await</span> _userManager.AddToRoleAsync(user, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!r.Succeeded)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> BadRequest(r.Errors);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="string">&quot;注册成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.编写处理登录请求的操作方法Login。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Login</span>(<span class="params">LoginRequest loginRequest</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> userName = loginRequest.UserName;</span><br><span class="line">    <span class="built_in">string</span> password = loginRequest.Password;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过_userManager查找用户，若不存在则返回 HTTP 404。</span></span><br><span class="line">        <span class="keyword">var</span> user = <span class="keyword">await</span> _userManager.FindByNameAsync(userName);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> NotFound(<span class="string">$&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查用户是否因多次登录失败被锁定（基于ASP.NET Identity 的锁定机制）</span></span><br><span class="line">        <span class="keyword">var</span> islocked = <span class="keyword">await</span> _userManager.IsLockedOutAsync(user);</span><br><span class="line">        <span class="keyword">if</span> (islocked)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> lockoutEnd = <span class="keyword">await</span> _userManager.GetLockoutEndDateAsync(user);</span><br><span class="line">            <span class="keyword">return</span> BadRequest(<span class="string">$&quot;用户已锁定，解锁时间：<span class="subst">&#123;lockoutEnd.Value.LocalDateTime&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用CheckPasswordAsync验证密码，成功则返回 HTTP 200</span></span><br><span class="line">        <span class="keyword">var</span> success = <span class="keyword">await</span> _userManager.CheckPasswordAsync(user, password);</span><br><span class="line">        <span class="keyword">if</span> (success)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Ok(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用AccessFailedAsync记录登录失败次数，触发锁定逻辑（若达到失败次数阈值）</span></span><br><span class="line">        <span class="comment">//若记录失败则返回特定错误，否则返回通用失败信息</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> r = <span class="keyword">await</span> _userManager.AccessFailedAsync(user);</span><br><span class="line">            <span class="keyword">if</span> (!r.Succeeded)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> BadRequest(<span class="string">&quot;访问失败信息写入错误！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> BadRequest(<span class="string">&quot;失败！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        _logger.LogError(ex, <span class="string">&quot;登录过程发生异常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> StatusCode(<span class="number">500</span>, <span class="string">&quot;登录失败，请稍后重试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>检查登录用户信息</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&lt;<span class="built_in">string</span>&gt;&gt; CheckPwd(CheckPwdRequest req) <span class="comment">//检查密码</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> userName = req.userName; <span class="comment">//用户名</span></span><br><span class="line">    <span class="built_in">string</span> password = req.password; <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">var</span> user = <span class="keyword">await</span> userConfig.FindByNameAsync(userName); <span class="comment">//查找用户</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>) <span class="comment">// 用户不存在</span></span><br><span class="line">        <span class="keyword">return</span> NotFound(<span class="string">$&quot;用户<span class="subst">&#123;userName&#125;</span>不存在&quot;</span>); <span class="comment">// 返回404</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">await</span> userConfig.IsLockedOutAsync(user)) <span class="comment">//判断用户是否锁定</span></span><br><span class="line">        <span class="keyword">return</span> BadRequest(<span class="string">&quot;用户已锁定&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> success = <span class="keyword">await</span> userConfig.CheckPasswordAsync(user, password); <span class="comment">//检查密码</span></span><br><span class="line">    <span class="keyword">if</span> (success) <span class="comment">//密码正确</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> userConfig.ResetAccessFailedCountAsync(user); <span class="comment">//重置失败次数</span></span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="string">&quot;密码正确&quot;</span>); <span class="comment">//返回200</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> userConfig.AccessFailedAsync(user); <span class="comment">//增加失败次数</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="keyword">await</span> userConfig.GetAccessFailedCountAsync(user); <span class="comment">//获取失败次数</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= <span class="number">5</span>) <span class="comment">//失败次数超过5次</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> userConfig.SetLockoutEndDateAsync(user, DateTimeOffset.UtcNow.AddMinutes(<span class="number">5</span>)); <span class="comment">//锁定用户</span></span><br><span class="line">            <span class="keyword">return</span> BadRequest(<span class="string">&quot;用户已锁定&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BadRequest(<span class="string">$&quot;密码错误,还有<span class="subst">&#123;<span class="number">5</span> - count&#125;</span>次机会&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现密码的重置"><a href="#实现密码的重置" class="headerlink" title="实现密码的重置"></a>实现密码的重置</h2><p>1.生成重置Token<br>2.Token发给客户（邮件、短信等），形式：连接、验证码等。<br>3.根据Token完成密码的重置。</p><p>编写一个发送重置密码请求的操作方法SendResetPasswordToken.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&gt; <span class="title">SendResetPasswordToken</span>(<span class="params"><span class="built_in">string</span> userName</span>) <span class="comment">//发送重置密码的token</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> user = <span class="keyword">await</span> userConfig.FindByNameAsync(userName); <span class="comment">//查找用户</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>) <span class="comment">// 用户不存在</span></span><br><span class="line">        <span class="keyword">return</span> NotFound(<span class="string">$&quot;用户<span class="subst">&#123;userName&#125;</span>不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> token = <span class="keyword">await</span> userConfig.GeneratePasswordResetTokenAsync(user); <span class="comment">//生成重置密码的token</span></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;验证码是<span class="subst">&#123;token&#125;</span>&quot;</span>); <span class="comment">//输出验证码</span></span><br><span class="line">    <span class="keyword">return</span> Ok(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用GeneratePasswordResetTokenAsyncc方法来生成一个密码重置令牌，这个令牌会保存到数据库中，然后我们把这个令牌发送到用户邮箱。</p><p>编写重置密码的操作方法VerifyResetPasswordToken。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPut</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&gt; <span class="title">ResetPassword</span>(<span class="params"><span class="built_in">string</span> userName,<span class="built_in">string</span> token,<span class="built_in">string</span> newPassword</span>) <span class="comment">//重置密码</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> user = <span class="keyword">await</span> userConfig.FindByNameAsync(userName); <span class="comment">//查找用户</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) <span class="comment">// 用户不存在</span></span><br><span class="line">        <span class="keyword">return</span> NotFound(<span class="string">$&quot;用户<span class="subst">&#123;userName&#125;</span>不存在&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> r = <span class="keyword">await</span> userConfig.ResetPasswordAsync(user, token, newPassword); <span class="comment">//重置密码</span></span><br><span class="line">    <span class="keyword">if</span>(r.Succeeded) <span class="comment">// 重置密码成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> userConfig.ResetAccessFailedCountAsync(user); <span class="comment">// 重置失败次数</span></span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="string">&quot;重置密码成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> userConfig.AccessFailedAsync(user); <span class="comment">//增加失败次数</span></span><br><span class="line">        <span class="keyword">return</span> BadRequest(<span class="string">&quot;重置密码失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JWT（Json-Web-Token）"><a href="#JWT（Json-Web-Token）" class="headerlink" title="JWT（Json Web Token）"></a>JWT（Json Web Token）</h1><p>1.JWT把登录信息（也称作令牌）保存在客户端。<br>2.为了防止客户端的数据造假，保存在客户端的令牌经过了签名处理，而签名的密钥只有服务器端才知道，每次服务器段收到客户端提交过来的令牌的时候都要检查一下签名。<br>3.基于JWT如何实现“登录”。</p><p>JWT实现登陆的流程如下。</p><ol><li>客户端向服务端发送用户名、密码等请求登录。</li><li>服务器端校验用户名、密码，如果校验成功，则从数据库中取出这个用户的ID、角色等用户相关信息。</li><li>服务器段采用只有服务器端才知道的密钥来对用户信息的JSON字符串进行签名，形成签名数据。</li><li>服务器端把用户信息的JSON字符串和签名拼接到一起形成JWT，然后发送给客户端。</li><li>客户端保存服务器返回的JWT，并且在客户端每次向服务器端发送请求的时候都带上这个JWT。</li><li>每次服务器端收到浏览器请求中携带的JWT后，服务器端用密钥对JWT的签名进行校验，如果校验成功，服务器端则从JWT中的JSON字符串中读取出用户的信息。这样服务器端就知道这个请求对应的用户了，也就实现了登录的功能。</li></ol><h2 id="JWT的基本使用"><a href="#JWT的基本使用" class="headerlink" title="JWT的基本使用"></a>JWT的基本使用</h2><p>先创建一个控制台程序用来创建JWT，在创建一个程序读取JWT。<br>.NET中进行JWT读取的NuGet包是：System.IdentityModel.Tokens.Jwt</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NameIdentifier 和 Name：用于标识用户身份</span></span><br><span class="line"><span class="comment">//两个Role声明：表示用户同时拥有 &quot;User&quot; 和 &quot;Admin&quot; 角色</span></span><br><span class="line"><span class="comment">//自定义声明jz：可用于传递业务相关数据（如账户级别）</span></span><br><span class="line"><span class="keyword">var</span> claims = <span class="keyword">new</span> List&lt;Claim&gt;();</span><br><span class="line">claims.Add(<span class="keyword">new</span> Claim(ClaimTypes.NameIdentifier, <span class="string">&quot;6&quot;</span>)); <span class="comment">// 用户ID</span></span><br><span class="line">claims.Add(<span class="keyword">new</span> Claim(ClaimTypes.Name, <span class="string">&quot;路飞&quot;</span>)); <span class="comment">// 用户名</span></span><br><span class="line">claims.Add(<span class="keyword">new</span> Claim(ClaimTypes.Role, <span class="string">&quot;User&quot;</span>)); <span class="comment">// 角色1</span></span><br><span class="line">claims.Add(<span class="keyword">new</span> Claim(ClaimTypes.Role, <span class="string">&quot;Admin&quot;</span>)); <span class="comment">// 角色2</span></span><br><span class="line">claims.Add(<span class="keyword">new</span> Claim(<span class="string">&quot;jz&quot;</span>, <span class="string">&quot;112233&quot;</span>)); <span class="comment">// 自定义声明</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> key = <span class="string">&quot;hweorgnfhsoifhjafvbsfjawoighnbsdhfvklawhng&quot;</span>; <span class="comment">// 密钥</span></span><br><span class="line">DateTime expires = DateTime.Now.AddDays(<span class="number">1</span>); <span class="comment">//过期时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 HMAC-SHA256 算法对 JWT 进行签名</span></span><br><span class="line"><span class="comment">//密钥长度需足够（建议至少 128 位），且应安全存储（实际项目中不应硬编码）</span></span><br><span class="line"><span class="built_in">byte</span>[] secBytes = Encoding.UTF8.GetBytes(key);</span><br><span class="line"><span class="keyword">var</span> secKey = <span class="keyword">new</span> SymmetricSecurityKey(secBytes);</span><br><span class="line"><span class="keyword">var</span> credentials = <span class="keyword">new</span> SigningCredentials(secKey,SecurityAlgorithms.HmacSha256Signature);</span><br><span class="line"><span class="comment">//JWT 包含三部分：Header（头部）、Payload（负载）和 Signature（签名）</span></span><br><span class="line"><span class="comment">//生成的 JWT 可用于后续 API 请求的身份验证</span></span><br><span class="line"><span class="keyword">var</span> tokenDescriptor = <span class="keyword">new</span> JwtSecurityToken(claims:claims,expires:expires,signingCredentials:credentials);</span><br><span class="line"><span class="built_in">string</span> jwt = <span class="keyword">new</span> JwtSecurityTokenHandler().WriteToken(tokenDescriptor);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(jwt);</span><br></pre></td></tr></table></figure><p>运行程序</p><p><img src="/img%5CWEBAPI%5C23.png"></p><p>JWT被句点分隔成了3部分，分别是头部、负载和签名。JWT都是明文存储的，JWT中使用Base64URL算法对字符串进行编码，这个算法跟Base64算法基本相同，考虑到JWT可能会被放到URL中，而Base64有3个特殊字符+、&#x2F;和&#x3D;，它们在URL里面有特殊含义，因此我们需要从Base64中删除&#x3D;，并且把+替换成-、把&#x2F;替换成_。</p><p>把JWT字符串的头部和负载解码为可读的字符串。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> jwt = Console.ReadLine()!;</span><br><span class="line"><span class="built_in">string</span>[] segments = jwt.Split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="built_in">string</span> head = JwtDecode(segments[<span class="number">0</span>]); ;</span><br><span class="line"><span class="built_in">string</span> payload = JwtDecode(segments[<span class="number">1</span>]);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;--------head--------&quot;</span>);</span><br><span class="line">Console.WriteLine(head);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;--------payload--------&quot;</span>);</span><br><span class="line">Console.WriteLine(payload);</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">JwtDecode</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    s=s.Replace(<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;+&#x27;</span>).Replace(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (s.Length % <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            s += <span class="string">&quot;===&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            s += <span class="string">&quot;=&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> bytes = Convert.FromBase64String(s); </span><br><span class="line">    <span class="keyword">return</span> Encoding.UTF8.GetString(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img%5CWEBAPI%5C24.png"></p><p>JWT的编码和解码规则都是公开的，而且负部分的Claim信息也是明文的，因此恶意攻击者可以对负载部分中的用户ID等信息进行修改，从而冒充其他用户的身份来访问服务器上的资源。因此，服务器端需要对部分进行校验，从而检查JWT是否被篡改了。<br>我们可以调用JwtSecurityTokenHandler类对JWT进行解码，因为它会在对JWT解码前对签名进行校验。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> jwt =Console.ReadLine()!;<span class="comment">//从控制台读取用户输入的 JWT 字符串</span></span><br><span class="line"><span class="comment">//使用与生成 JWT 时相同的密钥</span></span><br><span class="line"><span class="built_in">string</span> secKey = <span class="string">&quot;hweorgnfhsoifhjafvbsfjawoighnbsdhfvklawhng&quot;</span>;</span><br><span class="line"><span class="comment">//创建 JWT 处理器和验证参数对象</span></span><br><span class="line"><span class="comment">//设置签名密钥为之前生成 JWT 时使用的密钥</span></span><br><span class="line"><span class="comment">//禁用发行人（Issuer）和受众（Audience）验证（实际项目中通常需要验证）</span></span><br><span class="line">JwtSecurityTokenHandler tokenHandler = <span class="keyword">new</span>();</span><br><span class="line">TokenValidationParameters valParam = <span class="keyword">new</span>();</span><br><span class="line"><span class="keyword">var</span> securityKey = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(secKey));</span><br><span class="line">valParam.IssuerSigningKey = securityKey;</span><br><span class="line">valParam.ValidateIssuer = <span class="literal">false</span>;</span><br><span class="line">valParam.ValidateAudience = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//ValidateToken 方法执行以下验证：</span></span><br><span class="line"><span class="comment">//签名是否有效（防止篡改）</span></span><br><span class="line"><span class="comment">//令牌是否过期（默认验证 exp 声明）</span></span><br><span class="line"><span class="comment">//其他自定义验证（根据 TokenValidationParameters 设置）</span></span><br><span class="line"><span class="comment">//验证通过后，从 ClaimsPrincipal 中提取所有声明并打印</span></span><br><span class="line">ClaimsPrincipal claimsPrincipl = tokenHandler.ValidateToken(jwt, valParam, <span class="keyword">out</span> SecurityToken sectToken);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> claim <span class="keyword">in</span> claimsPrincipl.Claims)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;claim.Type&#125;</span>=<span class="subst">&#123;claim.Value&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JWT机制让我们可以把用户的信息保存到客户端，每次客户端向服务器发送请求的时候，客户端只要把JWT发送到服务器端，服务器端就可以得知当前请求用户的信息，而通过签名的机制则可以避免JWT内存被篡改。</p><h1 id="ASP-NET-Core对于JWT的封装"><a href="#ASP-NET-Core对于JWT的封装" class="headerlink" title="ASP.NET Core对于JWT的封装"></a>ASP.NET Core对于JWT的封装</h1><ol><li>配置JWT节点，节点下创建SigningKey、ExpireSeconds两个配置项，分别代表JWT的密钥和过期时间（单位：秒）。在创建配置类JWTOptions，包含SigningKey、ExpireSeconds两个属性。</li><li>NuGet:Microsoft.AspNetCore.Authentication.JwtBearer</li></ol><p>第一步，在配置系统中配置一个名字为JWT的节点，并在节点下创建SigningKey、ExpireSeconds两个配置项，分别代表JWT的密钥和过期时间（单位为秒）。我们在创建一个对应JWT节点的配置类JWTOptions,类中包含SigningKey、ExpireSwconds这两个属性。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;JWT&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;SigningKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jlkerujoigsnvjlkasjfwehiojkgnsgss&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ExpireSeconds&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3600&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ConnectionStrings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;DefaultConnection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Server=localhost;Database=YourDatabaseName;Trusted_Connection=True;MultipleActiveResultSets=true;TrustServerCertificate=True;Encrypt=True;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Logging&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;LogLevel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Microsoft.AspNetCore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Warning&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;AllowedHosts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JWTOptions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> SigningKey &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ExpirSeconds &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，编写代码对JWT进行配置，内容添加到Program.cs的builder.Build之前。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从配置文件（如appsettings.json）的 &quot;JWT&quot; 部分读取配置，并注册为JWTOptions类型的选项服务</span></span><br><span class="line"><span class="comment">//后续可通过依赖注入使用这些配置</span></span><br><span class="line">services.Configure&lt;JWTOptions&gt;(builder.Configuration.GetSection(<span class="string">&quot;JWT&quot;</span>));</span><br><span class="line"><span class="comment">//设置应用的主要认证方案为 JWT Bearer</span></span><br><span class="line"><span class="comment">//添加 JWT 承载认证处理器</span></span><br><span class="line">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</span><br><span class="line">    .AddJwtBearer(x =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//再次读取 JWT 配置（存在重复读取问题）</span></span><br><span class="line">        <span class="comment">/*var jwtOptions = builder.Configuration.GetSection(&quot;JWT&quot;).Get&lt;JWTOptions&gt;();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 注册JWT选项到依赖注入容器</span></span><br><span class="line"><span class="comment">        services.Configure&lt;JWTOptions&gt;(builder.Configuration.GetSection(&quot;JWT&quot;));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 生成安全密钥</span></span><br><span class="line"><span class="comment">        var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtOptions.SigningKey));*/</span></span><br><span class="line">        <span class="comment">//从配置中获取签名密钥并转换为安全密钥对象</span></span><br><span class="line">        <span class="keyword">var</span> jwtOpt = builder.Configuration.GetSection(<span class="string">&quot;JWT&quot;</span>).Get&lt;JWTOptions&gt;();</span><br><span class="line">        <span class="built_in">byte</span>[] keyBytes = Encoding.UTF8.GetBytes(jwtOpt.SigningKey);</span><br><span class="line">        <span class="keyword">var</span> secKey = <span class="keyword">new</span> SymmetricSecurityKey(keyBytes);</span><br><span class="line">        x.TokenValidationParameters = <span class="keyword">new</span> TokenValidationParameters()</span><br><span class="line">        &#123;</span><br><span class="line">            ValidateIssuer = <span class="literal">false</span>,         <span class="comment">// 不验证令牌发行人</span></span><br><span class="line">            ValidateAudience = <span class="literal">false</span>,       <span class="comment">// 不验证令牌受众</span></span><br><span class="line">            ValidateLifetime = <span class="literal">false</span>,       <span class="comment">// 不验证令牌有效期</span></span><br><span class="line">            ValidateIssuerSigningKey = <span class="literal">true</span>, <span class="comment">// 验证签名密钥</span></span><br><span class="line">            IssuerSigningKey = secKey       <span class="comment">// 设置签名密钥</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">/*// 从配置中读取JWT选项</span></span><br><span class="line"><span class="comment">var jwtOptions = builder.Configuration.GetSection(&quot;JWT&quot;).Get&lt;JWTOptions&gt;();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 注册JWT选项到依赖注入容器</span></span><br><span class="line"><span class="comment">services.Configure&lt;JWTOptions&gt;(builder.Configuration.GetSection(&quot;JWT&quot;));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 生成安全密钥</span></span><br><span class="line"><span class="comment">var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtOptions.SigningKey));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 配置JWT认证</span></span><br><span class="line"><span class="comment">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</span></span><br><span class="line"><span class="comment">    .AddJwtBearer(options =&gt;</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        options.TokenValidationParameters = new TokenValidationParameters</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            ValidateIssuer = true,               // 验证发行人</span></span><br><span class="line"><span class="comment">            ValidateAudience = true,             // 验证受众</span></span><br><span class="line"><span class="comment">            ValidateLifetime = true,             // 验证过期时间</span></span><br><span class="line"><span class="comment">            ValidateIssuerSigningKey = true,     // 验证签名密钥</span></span><br><span class="line"><span class="comment">            ValidIssuer = jwtOptions.Issuer,     // 设置有效发行人</span></span><br><span class="line"><span class="comment">            ValidAudience = jwtOptions.Audience, // 设置有效受众</span></span><br><span class="line"><span class="comment">            IssuerSigningKey = securityKey,      // 设置签名密钥</span></span><br><span class="line"><span class="comment">            ClockSkew = TimeSpan.Zero            // 严格验证过期时间</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 可选：添加事件处理（如令牌验证失败时的自定义响应）</span></span><br><span class="line"><span class="comment">        options.Events = new JwtBearerEvents</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            OnAuthenticationFailed = context =&gt;</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                if (context.Exception is SecurityTokenExpiredException)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    context.Response.Headers.Add(&quot;Token-Expired&quot;, &quot;true&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                return Task.CompletedTask;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">    &#125;);*/</span></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the HTTP request pipeline.</span></span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.UseSwagger();</span><br><span class="line">    app.UseSwaggerUI();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.UseHttpsRedirection();</span><br><span class="line">app.UseAuthentication();</span><br><span class="line">app.UseAuthorization();</span><br><span class="line"></span><br><span class="line">app.MapControllers();</span><br><span class="line"></span><br><span class="line">app.Run();</span><br></pre></td></tr></table></figure><p>第4步，在Program.cs的app.UseAuthorization之前添加app.UseAuthentication。</p><p>第五步，在TestController类中增加登录并且创建JWT的操作方法Login。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="comment">//LoginRequest：包含用户名和密码的登录请求模型</span></span><br><span class="line"><span class="comment">//IOptions&lt;JWTOptions&gt;：从依赖注入容器获取 JWT 配置选项</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Login</span>(<span class="params">LoginRequest loginRequest, [FromServices] IOptions&lt;JWTOptions&gt; jwtOptions</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> userName = loginRequest.UserName;</span><br><span class="line">    <span class="built_in">string</span> password = loginRequest.Password;</span><br><span class="line">    <span class="comment">//通过用户名查找用户</span></span><br><span class="line">    <span class="keyword">var</span> user = <span class="keyword">await</span> _userManager.FindByNameAsync(userName);</span><br><span class="line">    <span class="comment">//验证密码是否正确</span></span><br><span class="line">    <span class="keyword">var</span> success = <span class="keyword">await</span> _userManager.CheckPasswordAsync(user,password);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//验证失败返回 HTTP 400 错误</span></span><br><span class="line">        <span class="keyword">return</span> BadRequest(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> claims = <span class="keyword">new</span> List&lt;Claim&gt;();</span><br><span class="line">                                   <span class="comment">//NameIdentifier：用户唯一标识</span></span><br><span class="line">    claims.Add(<span class="keyword">new</span> Claim(ClaimTypes.NameIdentifier,user.Id.ToString()));</span><br><span class="line">                                   <span class="comment">//Name：用户名</span></span><br><span class="line">    claims.Add(<span class="keyword">new</span> Claim(ClaimTypes.Name,user.UserName));</span><br><span class="line">    <span class="keyword">var</span> roles = <span class="keyword">await</span> _userManager.GetRolesAsync(user);</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> role <span class="keyword">in</span> roles)</span><br><span class="line">    &#123;</span><br><span class="line">                            <span class="comment">//Role：用户角色（可包含多个）</span></span><br><span class="line">        claims.Add(<span class="keyword">new</span> Claim(ClaimTypes.Role, role));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用辅助方法生成 JWT 字符串</span></span><br><span class="line">    <span class="comment">//返回 HTTP 200 响应，包含生成的令牌</span></span><br><span class="line">    <span class="built_in">string</span> jwtToken = BuildToken(claims, jwtOptions.Value);</span><br><span class="line">    <span class="keyword">return</span> Ok(jwtToken);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;claims&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;options&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这是一个静态方法，根据用户声明和配置生成 JWT</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">BuildToken</span>(<span class="params">IEnumerable&lt;Claim&gt; claims,JWTOptions options</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span>从配置中读取过期秒数，计算令牌过期时间</span></span><br><span class="line">    DateTime expires = DateTime.Now.AddSeconds(options.ExpirSeconds);</span><br><span class="line">    <span class="comment">//使用配置中的签名密钥创建安全密钥对象</span></span><br><span class="line">    <span class="built_in">byte</span>[] keyBytes = Encoding.UTF8.GetBytes(options.SigningKey);</span><br><span class="line">    <span class="comment">//指定 HMAC SHA-256 算法进行签名</span></span><br><span class="line">    <span class="keyword">var</span> secKey = <span class="keyword">new</span> SymmetricSecurityKey(keyBytes);</span><br><span class="line">    <span class="keyword">var</span> credentials = <span class="keyword">new</span> SigningCredentials(secKey, SecurityAlgorithms.HmacSha256Signature);</span><br><span class="line">    <span class="comment">//创建 JWT 令牌描述符，包含过期时间, 签名凭证, 用户声明</span></span><br><span class="line">    <span class="keyword">var</span> tokenDescriptor = <span class="keyword">new</span> JwtSecurityToken(expires:expires,signingCredentials:credentials,claims:claims);</span><br><span class="line">    <span class="comment">//使用JwtSecurityTokenHandler将令牌描述符转换为 JWT 字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JwtSecurityTokenHandler().WriteToken(tokenDescriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第六步，在需要登录才能访问的控制器类或者Action方法上添加[Authorize]</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Demo2Controller</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Hello</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> id= <span class="keyword">this</span>.User.FindFirst(ClaimTypes.NameIdentifier)!.Value; <span class="comment">//用户ID</span></span><br><span class="line">        <span class="built_in">string</span> userName = <span class="keyword">this</span>.User.FindFirst(ClaimTypes.Name)!.Value; <span class="comment">//用户名</span></span><br><span class="line">        IEnumerable&lt;Claim&gt; roleClaims = <span class="keyword">this</span>.User.FindAll(ClaimTypes.Role); <span class="comment">//角色</span></span><br><span class="line">        <span class="built_in">string</span> roleNames = <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, roleClaims.Select(c =&gt; c.Value)); <span class="comment">//角色</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="string">$&quot;Hello <span class="subst">&#123;userName&#125;</span>, your ID is <span class="subst">&#123;id&#125;</span>, and your roles are <span class="subst">&#123;roleNames&#125;</span>.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第七步，测试登录和访问。用PostMan自定义报文头：Authorization的值为“Bearer JWTToken”,Authorization的值中的“Bearer”和JWT令牌之间一定要通过空格分隔。前后不能多出来额外的空格、换行等。</p><p><img src="/img%5CWEBAPI%5C25.png"></p><p><img src="/img%5CWEBAPI%5C26.png"></p><p>[Authorize]的注意事项</p><ol><li>ASP.NET Core中身份验证和授权验证的功能由Authentication、Authorization中间件提供：app.UseAuthentication()、app.UseAuthorization()。</li><li>控制器类上标注[Authorize],则所有操作方法都会被进行身份验证和授权验证；对于标注了[Authorzie]的控制器中，如果其中某个操作方法不想被验证，可以在操作方法上添加[AllowAnonymous]。如果没有在控制器类上标注[Authorize],那么这个控制器中的所有操作方法都允许被自由地访问；对于没有标注[Authorzie]的控制器中，如果其中某个操作方法需要被验证，文买也可以在操作方法上添加[Authorize].</li><li>ASP.NET Core会按照HTTP协议的规范，从Authorization取出来令牌，并且进行校验、解析，然后把解析结果填充到User属性中，这一切都是ASP.NET Core完成的，不需要开发人员自己编写代码。但是一旦出现401，没有详细的报错信息，很难排查。</li></ol><h2 id="让Swagger中调试待验证的请求跟简单"><a href="#让Swagger中调试待验证的请求跟简单" class="headerlink" title="让Swagger中调试待验证的请求跟简单"></a>让Swagger中调试待验证的请求跟简单</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> scheme = <span class="keyword">new</span> OpenApiSecurityScheme()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*Description：在 Swagger UI 中显示的描述信息，指导用户如何输入认证信息*/</span></span><br><span class="line">        Description = <span class="string">&quot;Authorization header.\r\nExample:&#x27;Bearer 12345abcdef&#x27;&quot;</span>,</span><br><span class="line">        <span class="comment">/*Reference：引用类型为安全方案，ID 为 &quot;Authorization&quot;*/</span></span><br><span class="line">        Reference = <span class="keyword">new</span> OpenApiReference</span><br><span class="line">        &#123;</span><br><span class="line">            Type = ReferenceType.SecurityScheme,</span><br><span class="line">            Id = <span class="string">&quot;Authorization&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">/*Scheme：指定为 &quot;oauth2&quot;，尽管我们使用的是 JWT，但 Swagger UI 使用此值来显示授权按钮*/</span></span><br><span class="line">        Scheme = <span class="string">&quot;oauth2&quot;</span>,</span><br><span class="line">        <span class="comment">/*Name：HTTP 请求头的名称，通常为 &quot;Authorization&quot;*/</span></span><br><span class="line">        Name = <span class="string">&quot;Authorization&quot;</span>,</span><br><span class="line">        <span class="comment">/*In：指定在请求头中传递认证信息*/</span></span><br><span class="line">        In = ParameterLocation.Header,</span><br><span class="line">        <span class="comment">/*Type：指定为 API 密钥类型*/</span></span><br><span class="line">        Type = SecuritySchemeType.ApiKey,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/*将上面定义的安全方案添加到 Swagger 生成器中，名称为 &quot;Authorization&quot;*/</span></span><br><span class="line">    c.AddSecurityDefinition(<span class="string">&quot;Authorization&quot;</span>, scheme);</span><br><span class="line">    <span class="comment">/*创建一个安全需求对象，要求所有 API 操作都需要上述定义的安全方案*/</span></span><br><span class="line">    <span class="keyword">var</span> requirement = <span class="keyword">new</span> OpenApiSecurityRequirement();</span><br><span class="line">    <span class="comment">/*空的字符串列表表示不需要任何特定的作用域（scopes），适用于 JWT 认证*/</span></span><br><span class="line">    requirement[scheme] = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    c.AddSecurityRequirement(requirement);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/img%5CWEBAPI%5C31.png"></p><h1 id="解决JWT无法提前撤回的难题"><a href="#解决JWT无法提前撤回的难题" class="headerlink" title="解决JWT无法提前撤回的难题"></a>解决JWT无法提前撤回的难题</h1><p>JWT的缺点<br>1.到期前，令牌无法撤销</p><p>遇到这种情况用Session更好解决这个问题。</p><p>解决方法<br>在用户表中增加一个整数类型的列JWTVersion,代表最后一次发放出去的令牌的版本号;每次登录、发放令牌的时候，都让JWTVersion的值自增，同时将JWTVersion的值也放到JWT令牌的负载中；当执行禁用用户、撤回用户的令牌等操作的时候，把这个用户对应的JWTVersion列的值自增；当服务器段收到客户端提交的JWT令牌后，先把JWT令牌中的JWTVersion值和数据库中JWTVersion的值做一下比较，如果JWT令牌中JWTVersion的值小于数据库中JWTVsersion的值，就说明这个JWT令牌过期了。</p><p>先配置所需程序：</p><p>配置CheckAsync扩展方法：如果用户、密码正确则空，失败则自增</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">IdentityHelper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">CheckAsync</span>(<span class="params"><span class="keyword">this</span> Task&lt;IdentityResult&gt; task</span>) <span class="comment">//检查IdentityResult</span></span></span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">var</span> r = <span class="keyword">await</span> task; <span class="comment">//等待任务完成</span></span><br><span class="line">         <span class="keyword">if</span> (!r.Succeeded) <span class="comment">//如果操作失败</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> Exception(JsonSerializer.Serialize(r.Errors)); <span class="comment">//抛出异常并序列化错误信息</span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IOptionsSnapshot&lt;JWTSettings&gt; jwtSettings; <span class="comment">//密钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> UserManager&lt;MyUser&gt; userManager; <span class="comment">//用户管理器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoController</span>(<span class="params">IOptionsSnapshot&lt;JWTSettings&gt; jwtSettings, UserManager&lt;MyUser&gt; userManager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.jwtSettings = jwtSettings;</span><br><span class="line">        <span class="keyword">this</span>.userManager = userManager;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&lt;<span class="built_in">string</span>&gt;&gt; Login(<span class="built_in">string</span> userName,<span class="built_in">string</span> password) <span class="comment">//登录</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> user = <span class="keyword">await</span> userManager.FindByNameAsync(userName); <span class="comment">//根据用户名查找用户</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>) <span class="comment">//用户不存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> BadRequest(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">await</span> userManager.CheckPasswordAsync(user,password)) <span class="comment">//验证密码</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> userManager.AccessFailedAsync(user).CheckAsync(); <span class="comment">//重置登录失败次数</span></span><br><span class="line">            List&lt;Claim&gt; claims = <span class="keyword">new</span> List&lt;Claim&gt;();</span><br><span class="line">            claims.Add(<span class="keyword">new</span> Claim(ClaimTypes.NameIdentifier, user.Id.ToString())); <span class="comment">//用户ID</span></span><br><span class="line">            claims.Add(<span class="keyword">new</span> Claim(ClaimTypes.Name, user.UserName)); <span class="comment">//用户名</span></span><br><span class="line">            <span class="keyword">var</span> roles = <span class="keyword">await</span> userManager.GetRolesAsync(user); <span class="comment">//获取用户角色</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> role <span class="keyword">in</span> roles) <span class="comment">//遍历角色</span></span><br><span class="line">            &#123;</span><br><span class="line">                claims.Add(<span class="keyword">new</span> Claim(ClaimTypes.Role, role)); <span class="comment">//添加角色声明</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> key = jwtSettings.Value.SecKey; <span class="comment">//密钥</span></span><br><span class="line">            DateTime expires = DateTime.Now.AddSeconds(jwtSettings.Value.ExpirSeconds); <span class="comment">//过期时间</span></span><br><span class="line">            <span class="built_in">byte</span>[] secBytes = Encoding.UTF8.GetBytes(key); <span class="comment">//将密钥转换为字节数组</span></span><br><span class="line">            <span class="keyword">var</span> secKey = <span class="keyword">new</span> SymmetricSecurityKey(secBytes); <span class="comment">//创建对称密钥</span></span><br><span class="line">            <span class="keyword">var</span> credentials = <span class="keyword">new</span> SigningCredentials(secKey, SecurityAlgorithms.HmacSha256Signature); <span class="comment">//创建签名凭据</span></span><br><span class="line">            <span class="keyword">var</span> tokenDescriptor = <span class="keyword">new</span> JwtSecurityToken(claims: claims, <span class="comment">//声明</span></span><br><span class="line">                expires: expires, <span class="comment">//过期时间</span></span><br><span class="line">                signingCredentials: credentials); <span class="comment">//签名凭据</span></span><br><span class="line">            <span class="built_in">string</span> jwt = <span class="keyword">new</span> JwtSecurityTokenHandler().WriteToken(tokenDescriptor); <span class="comment">//生成JWT</span></span><br><span class="line">            <span class="keyword">return</span> jwt; <span class="comment">//输出JWT</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> userManager.AccessFailedAsync(user).CheckAsync(); <span class="comment">//增加登录失败次数</span></span><br><span class="line">            <span class="keyword">return</span> BadRequest(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为用户实体User类增加一个long类型的属性JWTVersion.</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyUser</span>:<span class="title">IdentityUser</span>&lt;<span class="title">long</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? WeiXinAccount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> JWTVersion &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;  <span class="comment">// JWT版本号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改登录并发放令牌的代码，把用户的JWTVersion属性的值自增，并且把JWTVersion的值写入JWT令牌。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> userManager.AccessFailedAsync(user).CheckAsync(); <span class="comment">//重置登录失败次数</span></span><br><span class="line">user.JWTVersion++; <span class="comment">//增加JWT版本号</span></span><br><span class="line"><span class="keyword">await</span> userManager.UpdateAsync(user); <span class="comment">//更新用户信息 </span></span><br><span class="line">List&lt;Claim&gt; claims = <span class="keyword">new</span> List&lt;Claim&gt;();</span><br><span class="line">claims.Add(<span class="keyword">new</span> Claim(ClaimTypes.NameIdentifier, user.Id.ToString())); <span class="comment">//用户ID</span></span><br><span class="line">claims.Add(<span class="keyword">new</span> Claim(ClaimTypes.Name, user.UserName)); <span class="comment">//用户名</span></span><br><span class="line">claims.Add(<span class="keyword">new</span> Claim(<span class="string">&quot;JWTVersion&quot;</span>, user.JWTVersion.ToString())); <span class="comment">//JWT版本号 </span></span><br></pre></td></tr></table></figure><ol start="3"><li>编写一个操作筛选器，统一实现对所有的控制器的操作方法中JWT令牌的检查操作。把JWTValidationFilter注册到Program.cs中MVC的全局筛选器中。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JWTValidationFilter</span> : <span class="title">IAsyncActionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IMemoryCache memCache; <span class="comment">//内存缓存</span></span><br><span class="line">    <span class="keyword">private</span> UserManager&lt;MyUser&gt; userManager; <span class="comment">//用户管理器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JWTValidationFilter</span>(<span class="params">IMemoryCache memCache, UserManager&lt;MyUser&gt; userManager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//构造函数</span></span><br><span class="line">        <span class="comment">//注入内存缓存和用户管理器            </span></span><br><span class="line">        <span class="keyword">this</span>.memCache = memCache;</span><br><span class="line">        <span class="keyword">this</span>.userManager = userManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> claimUserId = context.HttpContext.User.FindFirst(ClaimTypes.NameIdentifier); <span class="comment">//获取用户ID</span></span><br><span class="line">        <span class="keyword">if</span>(claimUserId == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> next(); <span class="comment">//如果没有用户ID，继续执行</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">long</span> userId = <span class="built_in">long</span>.Parse(claimUserId!.Value); <span class="comment">//解析用户ID</span></span><br><span class="line">        <span class="built_in">string</span> cacheKey = <span class="string">$&quot;JWTValidationFilter.UserInfo.<span class="subst">&#123;userId&#125;</span>&quot;</span>; <span class="comment">//缓存键</span></span><br><span class="line">        MyUser user = <span class="keyword">await</span> memCache.GetOrCreateAsync(cacheKey, <span class="keyword">async</span> e =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            e.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(<span class="number">5</span>); <span class="comment">//设置缓存过期时间</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> userManager.FindByIdAsync(userId.ToString()); <span class="comment">//根据用户ID查找用户</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">new</span> ObjectResult(<span class="string">$&quot;UserId(<span class="subst">&#123;userId&#125;</span>) not found&quot;</span>); <span class="comment">//用户不存在</span></span><br><span class="line">            result.StatusCode = (<span class="built_in">int</span>)HttpStatusCode.Unauthorized; <span class="comment">//未授权</span></span><br><span class="line">            context.Result = result; <span class="comment">//设置结果</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> claimJWTVersion = context.HttpContext.User.FindFirst(ClaimTypes.Version); <span class="comment">//获取JWT版本号</span></span><br><span class="line">        <span class="built_in">long</span> jwtVersion = <span class="built_in">long</span>.Parse(claimJWTVersion!.Value); <span class="comment">//解析JWT版本号</span></span><br><span class="line">        <span class="keyword">if</span>(jwtVersion != user.JWTVersion) <span class="comment">//如果JWT版本号不匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            next(); <span class="comment">//继续执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">new</span> ObjectResult(<span class="string">$&quot;UserId(<span class="subst">&#123;userId&#125;</span>) JWTVersion(<span class="subst">&#123;jwtVersion&#125;</span>) not match&quot;</span>); <span class="comment">//JWT版本号不匹配</span></span><br><span class="line">            result.StatusCode = (<span class="built_in">int</span>)HttpStatusCode.Unauthorized; <span class="comment">//未授权</span></span><br><span class="line">            context.Result = result; <span class="comment">//设置结果</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>把JWTValidationFilter注册到Program.cs中MVC的全局筛选器中。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.Configure&lt;MvcOptions&gt;(opt =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    opt.Filters.Add&lt;JWTValidationFilter&gt;(); <span class="comment">// 添加JWT验证过滤器</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
            <tag> JWT </tag>
            
            <tag> SignalR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core 托管，数据的校验</title>
      <link href="/2025/05/09/asp.net%20core/ASP.NET%20Core%E9%AB%98%E7%BA%A7%E7%BB%84%E4%BB%B6%E4%BA%8C/"/>
      <url>/2025/05/09/asp.net%20core/ASP.NET%20Core%E9%AB%98%E7%BA%A7%E7%BB%84%E4%BB%B6%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="托管-轮询-服务"><a href="#托管-轮询-服务" class="headerlink" title="托管(轮询)服务"></a>托管(轮询)服务</h1><ol><li>场景，代码运行在后台。比如服务器启动的时候在后台预先加载数据在缓存，每天凌晨3点把数据导出到备份数据库，每隔5秒钟在两张表之间同步一次数据。</li><li>托管服务实现IHostdService接口，一般编写从BackgroundService继承的类。<br>测试：延迟若干秒再读取文件，再延迟，再输出。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoBgService</span>:<span class="title">BackgroundService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;DemoBgService&gt; _logger; <span class="comment">//注入日志服务</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoBgService</span>(<span class="params">ILogger&lt;DemoBgService&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">ExecuteAsync</span>(<span class="params">CancellationToken stoppingToken</span>)</span>   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">3000</span>); <span class="comment">//等待3秒</span></span><br><span class="line">        <span class="built_in">string</span> s = <span class="keyword">await</span> File.ReadAllTextAsync(<span class="string">&quot;D:/SqlServer.txt&quot;</span>); <span class="comment">//读取文件</span></span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">3000</span>); <span class="comment">//等待3秒</span></span><br><span class="line">        _logger.LogInformation(s); <span class="comment">// 输出日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用AddHostedService到依赖注入容器中</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddHostedService&lt;DemoBgService&gt;(); <span class="comment">//注册后台服务</span></span><br></pre></td></tr></table></figure><h2 id="托管服务的异常问题"><a href="#托管服务的异常问题" class="headerlink" title="托管服务的异常问题"></a>托管服务的异常问题</h2><ol><li>从.NET 6开始，当托管服务发生未处理异常的时候，程序就会自动停止并退出。可以把HostOptions.BackgroundServiceExceptionBehavior设置为lgnore,程序会忽略异常，而不是停止程序。不过推荐采用默认的设置，因为“异常应该被妥善的处理，而不是被忽略”。</li><li>要在ExecuteAsync方法中把代码用try…catch包裹起来，当发生异常的时候，记录日志中或发生报警等。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">3000</span>); <span class="comment">//等待3秒</span></span><br><span class="line">    <span class="built_in">string</span> s = <span class="keyword">await</span> File.ReadAllTextAsync(<span class="string">&quot;D:/SqlServer.txt&quot;</span>); <span class="comment">//读取文件</span></span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">3000</span>); <span class="comment">//等待3秒</span></span><br><span class="line">    _logger.LogInformation(s); <span class="comment">// 输出日志</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;程序中出现异常&quot;</span>+ex); <span class="comment">//输出异常信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="托管服务中使用依赖注入的陷阱"><a href="#托管服务中使用依赖注入的陷阱" class="headerlink" title="托管服务中使用依赖注入的陷阱"></a>托管服务中使用依赖注入的陷阱</h2><ol><li><p>托管服务是以单例的生命周期注册到依赖注入容器中的。因此不能注入生命周期为范围或者瞬太的服务。比如注入EF Core的上下文的话，程序就会抛出异常。</p></li><li><p>可以通过构造方法注入一个IServiceScopeFactory服务，它可以用来创建一个IServiceScope对象，这样我们就可以通过IServiceScope来创建短生命周全的服务了。记得再Dispose中释放IServiceScope。</p></li><li><p>下面实现一个常驻后台的托管服务，它实现的功能是每隔5s对数据库中的数据进行汇总，然后把汇总结果写入一个文本文件中。</p></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExplortStatisticBgService</span> : <span class="title">BackgroundService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> MyDbContext ctx; <span class="comment">//注入数据库上下文</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;ExplortStatisticBgService&gt; _logger; <span class="comment">//注入日志服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IServiceScope serviceScope; <span class="comment">//注入服务范围</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExplortStatisticBgService</span>(<span class="params">IServiceScopeFactory scopeFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceScope = scopeFactory.CreateScope(); <span class="comment">//创建服务范围</span></span><br><span class="line">        <span class="keyword">var</span> sp = serviceScope.ServiceProvider; <span class="comment">//获取服务提供者</span></span><br><span class="line">        <span class="keyword">this</span>.ctx = sp.GetRequiredService&lt;MyDbContext&gt;(); <span class="comment">//获取数据库上下文</span></span><br><span class="line">        <span class="keyword">this</span>._logger = sp.GetRequiredService&lt;ILogger&lt;ExplortStatisticBgService&gt;&gt;(); <span class="comment">//获取日志服务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">ExecuteAsync</span>(<span class="params">CancellationToken stoppingToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!stoppingToken.IsCancellationRequested) <span class="comment">// 判断是否取消请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> DoExecuteAsync(); <span class="comment">//执行具体操作</span></span><br><span class="line">                <span class="keyword">await</span> Task.Delay(<span class="number">3000</span>); <span class="comment">//等待3秒</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                _logger.LogError(ex, <span class="string">&quot;程序中出现异常&quot;</span>); <span class="comment">//输出异常信息</span></span><br><span class="line">                <span class="keyword">await</span> Task.Delay(<span class="number">3000</span>); <span class="comment">//等待3秒</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">DoExecuteAsync</span>() <span class="comment">//执行具体操作</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里可以添加你需要执行的具体操作</span></span><br><span class="line">        <span class="comment">// 例如：导出统计数据到文件等</span></span><br><span class="line">        <span class="comment">//await Task.Delay(1000); //模拟异步操作</span></span><br><span class="line">        <span class="keyword">var</span> items = ctx.Users.GroupBy(u =&gt; u.UserName).Select(g =&gt; <span class="keyword">new</span></span><br><span class="line">        &#123;</span><br><span class="line">            UserName = g.Key, <span class="comment">//分组的键</span></span><br><span class="line">            Count = g.Count() <span class="comment">//统计每个用户的数量</span></span><br><span class="line">        &#125;); <span class="comment">// 分组统计</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(); <span class="comment">//创建StringBuilder对象</span></span><br><span class="line">        sb.AppendLine(<span class="string">$&quot;Date:<span class="subst">&#123;DateTime.Now&#125;</span>&quot;</span>); <span class="comment">//添加当前日期</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> items) <span class="comment">// 遍历统计结果</span></span><br><span class="line">        &#123;</span><br><span class="line">            sb.Append(item.UserName).AppendLine(<span class="string">$&quot;:<span class="subst">&#123;item.Count&#125;</span>&quot;</span>); <span class="comment">//添加用户名和数量</span></span><br><span class="line">            sb.AppendLine(); <span class="comment">//添加空行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">await</span> File.WriteAllTextAsync(<span class="string">&quot;D:/SqlServer.txt&quot;</span>, sb.ToString()); <span class="comment">//写入文件</span></span><br><span class="line">        _logger.LogInformation(<span class="string">&quot;导出统计数据成功&quot;</span>); <span class="comment">//输出日志</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Dispose(); <span class="comment">//释放资源</span></span><br><span class="line">        serviceScope.Dispose(); <span class="comment">//释放服务范围</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="请求数据的校验"><a href="#请求数据的校验" class="headerlink" title="请求数据的校验"></a>请求数据的校验</h2><p>.NET Core中内置了对数据校验的支持，在System.ComponentModel.DataAnnotations命名空间下定义了非常多的校验规则Attribute,比如[Required]用来设置值必须是非空的、[EmailAddress]用来设置值必须是Email格式的、[RegularExpression]用来根据给定的正则表达式对数据进行校验。我们也可以使用CustomValidationAttribute或者模型类实现IValidatableObject接口来编写自定义的校验规则。</p><p>.NET Core内置的校验机制有以下几个问题</p><ol><li>无论是通过在属性上标注校验规则Attribute的方法，还是实现IValidatableObject接口的方式，我们的校验规则都是和模型类耦合在一起的，这违反了面向对象的“单一职责原则”。</li><li>.NET Core中内置的校验规则不够多，很多常用的校验需求都需要我们编写自定义校验规则。</li></ol><h2 id="FluentValidation的基本使用"><a href="#FluentValidation的基本使用" class="headerlink" title="FluentValidation的基本使用"></a>FluentValidation的基本使用</h2><ol><li>FluentValidation：用类似于EF Core中Fluent API的方式进行校验规则的配置，也就是我们可以把对模型类的校验放到单独的校验类中。</li><li>在项目中安装NuGet包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FluentValidation.AspNetCore</span><br></pre></td></tr></table></figure></li></ol><p>第一步，在Program.cs中添加注册相关服务的代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddFluentValidationAutoValidation(); <span class="comment">//注册FluentValidation自动验证</span></span><br><span class="line">builder.Services.AddFluentValidationClientsideAdapters(); <span class="comment">//注册FluentValidation客户端验证</span></span><br><span class="line">builder.Services.AddValidatorsFromAssemblies(AppDomain.CurrentDomain.GetAssemblies()); <span class="comment">//注册所有程序集中的验证器</span></span><br></pre></td></tr></table></figure><p>AddValidatorsFromAssemblies方法用于把指定程序集中所有实现了IValidator接口的数据校验类注册到依赖注入容器中。</p><p>第二步，编写一个模型类Login2Request。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">Login2Request</span>(<span class="params"><span class="built_in">string</span> Email,<span class="built_in">string</span> Password,<span class="built_in">string</span> Password2</span>)</span>; <span class="comment">//定义登录请求记录</span></span><br></pre></td></tr></table></figure><p>第三步，编写一个继承自AbstractValidator的数据校验类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Login2RequestValidator</span> : <span class="title">AbstractValidator</span>&lt;<span class="title">Login2Request</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Login2RequestValidator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        RuleFor(x =&gt; x.Email)</span><br><span class="line">            .NotEmpty().WithMessage(<span class="string">&quot;邮箱不能为空&quot;</span>)</span><br><span class="line">            .EmailAddress().WithMessage(<span class="string">&quot;邮箱格式不正确&quot;</span>);</span><br><span class="line">        RuleFor(x =&gt; x.Password)</span><br><span class="line">            .NotEmpty().WithMessage(<span class="string">&quot;密码不能为空&quot;</span>)</span><br><span class="line">            .MinimumLength(<span class="number">6</span>).WithMessage(<span class="string">&quot;密码长度不能小于6位&quot;</span>);</span><br><span class="line">        RuleFor(x =&gt; x.Password2)</span><br><span class="line">            .NotEmpty().WithMessage(<span class="string">&quot;确认密码不能为空&quot;</span>)</span><br><span class="line">            .Equal(x =&gt; x.Password).WithMessage(<span class="string">&quot;两次输入的密码不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValuesController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult <span class="title">Login</span>(<span class="params">Login2Request request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Ok(request); <span class="comment">//返回请求对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img%5CWEBAPI%5C27.png"></p><h2 id="FluentValidation中的注入服务"><a href="#FluentValidation中的注入服务" class="headerlink" title="FluentValidation中的注入服务"></a>FluentValidation中的注入服务</h2><p>在编写数据校验代码的时候，有时候我们需要调用依赖注入容器中的服务，FluentValidation中的数据校验类是通过依赖注入容器实例化的，因此我们同样可以通过构造方法来数据校验中注入服务。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Login3RequestValidator</span> : <span class="title">AbstractValidator</span>&lt;<span class="title">Login3Request</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Login3RequestValidator</span>(<span class="params">MyDbContext dbCtx</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RuleFor(x =&gt; x.UserName).NotNull()</span><br><span class="line">            .MustAsync((name,_) =&gt;dbCtx.Users.AnyAsync(u =&gt; u.UserName == name))</span><br><span class="line">            .WithMessage(c =&gt; <span class="string">$&quot;用户名<span class="subst">&#123;c.UserName&#125;</span>不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
            <tag> JWT </tag>
            
            <tag> SignalR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core筛选器，中间件</title>
      <link href="/2025/04/24/asp.net%20core/ASP.NET%20Core%E7%AD%9B%E9%80%89%E5%99%A8%EF%BC%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2025/04/24/asp.net%20core/ASP.NET%20Core%E7%AD%9B%E9%80%89%E5%99%A8%EF%BC%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="筛选器"><a href="#筛选器" class="headerlink" title="筛选器"></a>筛选器</h1><p>1.筛选器（filter,也可以翻译为“过滤器”）是ASP.NET Core中提供的一种切面编程机制，它允许开发人员创建自定义筛选器来处理横切关注点，也就是在ASP.NET Core特定的位置执行我们自定义的代码，比如在控制器的操作方法之前执行数据检查的代码，或者在ActionResult执行的时候向响应报文头中写入自定义数据等。<br>2.ASP.NET Core中的筛选器有以下5种类型：授权筛选器（Authorization filter）、资源筛选器（Resource filter）、操作筛选器（Action filter）、异常筛选器（Exception filter）、结果筛选器（Result filter）。<br>3.所有筛选器一般有同步和异步两个版本，在大部分场景下，异步筛选器的性能更好，而且可以支持在实现类中编写异步调用的代码。</p><h2 id="异常筛选器"><a href="#异常筛选器" class="headerlink" title="异常筛选器"></a>异常筛选器</h2><p>当系统中出现未经处理的异常的时候，异常筛选器就会执行，我们可以在异常筛选器中对异常进行处理。<br>这样的异常信息只有客户端才知道，网站的运维人员不知道这个异常的存在，我们需要在程序中把未处理异常记录到日志中。</p><p>1.当系统中出现未处理异常的时候，我们需要统一给客户端返回如下格式的响应报文：{“code”:”500”,”message”:”异常信息”}。对于开发环境中message是异常堆栈，对于其他环境message用一个general的报错信息。<br>2.实现IAsyncExceptionFiler接口。注入IHostEnvironment得知运行环境。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyExceptionFilter</span> : <span class="title">IAsyncExceptionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;MyExceptionFilter&gt; logger;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IHostEnvironment env;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyExceptionFilter</span>(<span class="params">ILogger&lt;MyExceptionFilter&gt; logger, IHostEnvironment env</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger = logger;</span><br><span class="line">        <span class="keyword">this</span>.env = env;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">OnExceptionAsync</span>(<span class="params">ExceptionContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Exception exception = context.Exception;</span><br><span class="line">        logger.LogError(exception,<span class="string">&quot;UnhandledException occured&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> message;</span><br><span class="line">        <span class="keyword">if</span>(env.IsDevelopment())</span><br><span class="line">        &#123;</span><br><span class="line">            message = exception.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">           message= <span class="string">&quot;程序中出现未处理异常&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ObjectResult result = <span class="keyword">new</span> ObjectResult(<span class="keyword">new</span> &#123; code = <span class="number">500</span>, message = message &#125;);</span><br><span class="line">        result.StatusCode = <span class="number">500</span>;</span><br><span class="line">        context.Result = result;</span><br><span class="line">        context.ExceptionHandled = <span class="literal">true</span>; <span class="comment">// 标记异常已处理</span></span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置context.ExceptionHandled &#x3D; true;通过这样的方式来告知ASP.NET Core不再执行默认的异常响应逻辑。</p><p>我们在Program.cs的builder.Build之前添加全局的筛选器。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.Configure&lt;MvcOptions&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Filters.Add&lt;MyExceptionFilter&gt;();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>MvcOptions是ASP.NET Core项目的主要配置对象，我们在第3行代码中向Filters注册全局的筛选器，这样，项目中所有的ASP.NET Core中的未处理异常都会被MyExxceptionFilter处理。用这种方式注入的筛选器是由依赖注入机制进行管理的，因此我们可以通过构造方法为筛选器注入其他的服务。</p><h2 id="操作筛选器基础"><a href="#操作筛选器基础" class="headerlink" title="操作筛选器基础"></a>操作筛选器基础</h2><p>每次ASP.NET Core中控制器的操作器的操作方法执行的时候，操作筛选器都会被执行，我们可以在操作方法执行之前和执行之后执行一些代码，完成特定的功能。<br>操作筛选器一般实现IAsyncActionFilter接口，这个接口定义OnActionExecutionAsync方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task OnActionExecutionAsync (ActionExecutingContext context, ActionExecutionDelegate next)</span><br></pre></td></tr></table></figure><p>其中，context参数代表Action执行的上下文对象，从context中我们可以获取请求的路径、参数值等信息；next参数代表下一个要执行的操作筛选器。一个项目中可以注册多个操作筛选器，这些操作筛选器组成一个链，上一个筛选器执行完了再执行下一个。next就是一个用来指向下一个筛选器的话，next就会执行要执行的操作方法。</p><p><img src="/img%5CWEBAPI%5C16.png"></p><p>1.编写一个实现了IAsyncActionFilter接口的类MyActionFilter1.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyActionFilter1</span> : <span class="title">IAsyncActionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyActionFilter1：开始执行&quot;</span>);</span><br><span class="line">        ActionExecutedContext r = <span class="keyword">await</span> next();</span><br><span class="line">        <span class="keyword">if</span>(r.Exception != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;MyActionFilter1：发生异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;MyActionFilter1：执行结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>next的返回值是操作方法的执行结果，返回值是ActionExecutedContext类型的。如果操作方法执行的时候出现了未处理异常，那么ActionExecutedContext的Exception属性就是异常对象，ActionExecutedContext的Result属性就是操作方法的执行结果。</p><p>2.编写一个和MyActionFilter1类似的类MyActionFilter2.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyActionFilter2</span> : <span class="title">IAsyncActionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyActionFilter2：开始执行&quot;</span>);</span><br><span class="line">        ActionExecutedContext r = <span class="keyword">await</span> next();</span><br><span class="line">        <span class="keyword">if</span>(r.Exception != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;MyActionFilter2：发生异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;MyActionFilter2：执行结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在Program.cs中注册这两个操作筛选器。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.Configure&lt;MvcOptions&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 添加全局筛选器</span></span><br><span class="line">    options.Filters.Add(<span class="keyword">new</span> MyActionFilter1());</span><br><span class="line">    options.Filters.Add(<span class="keyword">new</span> MyActionFilter2());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4.在控制其中增加一个要测试的操作方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;TextController：Get方法被调用&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><p><img src="/img%5CWEBAPI%5C17.png"></p><h1 id="案例：自动启动事务的操作筛选器"><a href="#案例：自动启动事务的操作筛选器" class="headerlink" title="案例：自动启动事务的操作筛选器"></a>案例：自动启动事务的操作筛选器</h1><p>1.数据库事务：要么全部成功、要么全部失败。<br>2.自动化：启动、提交以及回滚事务。<br>3.当一段使用EF Core进行数据库操作的代码放到TransactionScope声明的范围中的时候，这段代码就会自动被标记为“支持事务”。<br>4.TransactionScope实现了IDisposale接口，如果一个TransactionScope的对象没有调用Conmplete()就执行了Dispose()方法，则事务会被回滚，否则事务就会被提交。<br>5.TransactionScope还支持嵌套式事务。<br>6..NET Core中的TransactionScope不像.NET FX一样有MSDTC分布式事务提升的问题。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> MyDbContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoController</span>(<span class="params">MyDbContext ctx</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">Test1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (TransactionScope tx=<span class="keyword">new</span> TransactionScope(<span class="comment">/*TransactionScopeAsyncFlowOption.Enabled*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            ctx.Books.Add(<span class="keyword">new</span> Book &#123; Name = <span class="string">&quot;.Net1&quot;</span>, Price = <span class="number">1</span> &#125;);</span><br><span class="line">            <span class="keyword">await</span> ctx.SaveChangesAsync(); <span class="comment">// 这里会自动启用事务</span></span><br><span class="line">            ctx.Personcs.Add(<span class="keyword">new</span> Personcs &#123; Name = <span class="string">&quot;YOUXIANYU&quot;</span>, Age = <span class="number">19</span> &#125;);</span><br><span class="line">            <span class="keyword">await</span> ctx.SaveChangesAsync(); <span class="comment">// 这里会自动启用事务</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们编写的操作方法中，可能不希望有的方法自动启用事务控制，可以给这些操作方法添加一个自定义的NotTransactionlAttribute。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Method)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NotTransactionalAttribute</span>:<span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，开发筛选器TransactionScopeFilter,其OnActionExecutionAsync方法的实现。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TransactionScopeFilt</span> : <span class="title">IAsyncActionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> hasNotTransactionalAttribute = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (context.ActionDescriptor <span class="keyword">is</span> ControllerActionDescriptor)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> actionDesc = (ControllerActionDescriptor)context.ActionDescriptor;</span><br><span class="line">            hasNotTransactionalAttribute = actionDesc.MethodInfo.IsDefined(<span class="keyword">typeof</span>(NotTransactionalAttribute), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasNotTransactionalAttribute)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> next();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> txScope = <span class="keyword">new</span> TransactionScope(TransactionScopeAsyncFlowOption.Enabled);</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">await</span> next();</span><br><span class="line">        <span class="keyword">if</span> (result.Exception == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            txScope.Complete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置Program.cs程序集</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.Configure&lt;MvcOptions&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Filters.Add(<span class="keyword">typeof</span>(TransactionScopeFilt));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="案例：开发请求限流器"><a href="#案例：开发请求限流器" class="headerlink" title="案例：开发请求限流器"></a>案例：开发请求限流器</h1><p>1.Action Filter可以在满足条件的时候终止操作方法的执行。<br>2.在Action Filter中，如果我们不调用await next(),就可以终止Action方法的执行了。<br>3.为了避免而已客户端频繁发送大量请求消耗服务器资源，我们要实现“一秒钟内只允许最多有一个来自同一个IP地址的请求”。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RateLimitFilter</span> : <span class="title">IAsyncActionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMemoryCache memCache; <span class="comment">//注入内存缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RateLimitFilter</span>(<span class="params">IMemoryCache memCache</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.memCache = memCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> removeIP = context.HttpContext.Connection.RemoteIpAddress.ToString(); <span class="comment">//获取请求IP</span></span><br><span class="line">        <span class="built_in">string</span> cacheKey = <span class="string">$&quot;LastVisitTick_<span class="subst">&#123;removeIP&#125;</span>&quot;</span>; <span class="comment">//缓存键</span></span><br><span class="line">        <span class="built_in">long</span>? lastTick = memCache.Get&lt;<span class="built_in">long</span>?&gt;(cacheKey);  <span class="comment">//获取上次请求时间</span></span><br><span class="line">        <span class="keyword">if</span> (lastTick == <span class="literal">null</span> || Environment.TickCount64 - lastTick &gt; <span class="number">1000</span>)  <span class="comment">//请求间隔大于1秒</span></span><br><span class="line">        &#123;</span><br><span class="line">            memCache.Set(cacheKey, Environment.TickCount64, TimeSpan.FromSeconds(<span class="number">10</span>));  <span class="comment">//设置缓存时间为10秒</span></span><br><span class="line">            <span class="keyword">return</span> next();  <span class="comment">//继续执行请求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            context.Result = <span class="keyword">new</span> ContentResult &#123; StatusCode = <span class="number">429</span>, Content = <span class="string">&quot;请求过快，请稍后再试&quot;</span> &#125;;  <span class="comment">//返回429状态码</span></span><br><span class="line">            <span class="keyword">return</span> Task.CompletedTask; <span class="comment">//结束请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启用内存缓存</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.Configure&lt;MvcOptions&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Filters.Add(<span class="keyword">typeof</span>(RateLimitFilter));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>中间件是ASP.NET Core的核心组件，MVC框架、相应缓存、身份验证、CORS、Swagger等都是内置中间件。</p><p><img src="/img%5CWEBAPI%5C18.png"></p><h2 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h2><p>1.广义上来讲：Tomcat、WebLogic、Redis、ISS；狭义上来讲，ASP.NET Core中的中间件指ASP.ENT Core中的一个组件。<br>2.中间件由前逻辑、next、后逻辑3部分组成，前逻辑为第一段要执行的逻辑代码、next为指向下一个中间件的调用、后逻辑为从下一个中间件执行返回所执行的逻辑代码。每个HTTP请求都要经历一个系列中间件的处理，每个中间件对于请求进行特定的处理后，再转到下一个中间件，最终的业务逻辑代码执行完成后，相应的内容也会按照处理的相反顺序进行处理，然后形成HTTP响应报文返回给客户端。<br>3.中间件组成一个管道，整个ASP.ENT Core的执行过程就是HTTP请求和相应按照中间件组装的顺序在中间件之间流转的过程。开发人员可以对组成管道的中间件按照需要进行自由组合。</p><h3 id="中间件的三个概念"><a href="#中间件的三个概念" class="headerlink" title="中间件的三个概念"></a>中间件的三个概念</h3><p>Map、Use和Run。Map用来定义一个管道可以处理那些请求，Use和Run用来定义管道，一个管道由若干个Use和一个Run组成，每个Use引入一个中间件，而Run是用来执行最终的核心应用逻辑。</p><p><img src="/img%5CWEBAPI%5C19.png"></p><h2 id="基本中间件使用"><a href="#基本中间件使用" class="headerlink" title="基本中间件使用"></a>基本中间件使用</h2><p>创建一个ASP.NET Core空项目。</p><p>简单的自定义中间件<br>为了能够更清晰地了解中间件，我们创建一个空的ASP.NET Core项目，然后手动添加中间件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">app.Map(<span class="string">&quot;/test&quot;</span>, <span class="keyword">async</span> (pipeBuilder) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    pipeBuilder.Use(<span class="keyword">async</span> (context, next) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        context.Response.ContentType = <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;1 start&lt;br/&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">await</span> next.Invoke();</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;1 end&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pipeBuilder.Use(<span class="keyword">async</span> (context, next) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;2 start&lt;br/&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">await</span> next.Invoke();</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;2 end&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pipeBuilder.Run(<span class="keyword">async</span> context =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;Run&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要注意的是，按照微软的建议，如果我们在一个中间件中使用ctx.Response.WriteAsync等方式向客户端发送响应，我们就不能再执行next.Invoke把请求转到其他中间件了。因为其他中间件有可能对Response进行了更改，比如修改响应状态码、修改报文头或者向响应报文中写入其他数据，这样就会造成响应报文体被损坏的问题。因此，在代码中的中间件中，我们在向报文体中写入内容后，又执行next.Invoke是不推荐的行为。</p><h3 id="中间件类"><a href="#中间件类" class="headerlink" title="中间件类"></a>中间件类</h3><p>1.如果定义中间件的代码比较复杂，或者需要重复使用一个中间件的话，最好把中间的代码放到一个单独的类中，这样的类我们称之为“中间件类”。<br>2.中间件类是一个普通的.NET类，它不需要继承任何父类或者实现任何接口，但是这个类需要有一个构造方法，构造方法至少有一个RequertDelegate类型的参数，这个参数用来指向下一个中间件。这个类还需要定义一个名字为Invoke或InvokeAsync的方法，方法至少有一个HttpContext类型的参数，方法的返回值必须是Task类型。中间件类的构造方法和Invoke（或InvokeAsync）方法还可以定义其他参数，其他参数的值会通过依赖注入自动赋值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestIMddleware</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> RequestDelegate next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestIMddleware</span>(<span class="params">RequestDelegate next</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">InvokeAsync</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;TestIMddleware start&lt;br/&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">await</span> next.Invoke(context);</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;TestIMddleware end&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发一个简单的中间件类，这个中间件类会检查请求中是否有password为123的查询字符串，而且会把请求报文体按照JSON格式尝试解析为dynamic类型的对象，并且把pynamic对象放入context.Items中供后续的中间件或者Run使用。</p><p>JsonSerializer.Deserialize&lt;dynamic&gt;<br>把json反序列化为dynamic类型</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CheckMiddleware</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> RequestDelegate next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheckMiddleware</span>(<span class="params">RequestDelegate next</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">InvokeAsync</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> pwd = context.Request.Query[<span class="string">&quot;passwork&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (pwd == <span class="string">&quot;123&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (context.Request.HasJsonContentType())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> reqStream = context.Request.BodyReader.AsStream();</span><br><span class="line">                <span class="keyword">var</span> obj = JsonSerializer.Deserialize&lt;<span class="built_in">dynamic</span>&gt;(reqStream);</span><br><span class="line">                context.Items[<span class="string">&quot;BodyJson&quot;</span>] = obj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">await</span> next(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            context.Response.StatusCode = <span class="number">401</span>;</span><br><span class="line">            <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;没有权限访问&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用中间件类CheckAndParsingMiddleware,修改后的Program.cs</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">app.Map(<span class="string">&quot;/test&quot;</span>, <span class="keyword">async</span> (pipeBuilder) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    pipeBuilder.Use(<span class="keyword">async</span> (context, next) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        context.Response.ContentType = <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;1 start&lt;br/&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">await</span> next.Invoke();</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;1 end&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pipeBuilder.Use(<span class="keyword">async</span> (context, next) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;2 start&lt;br/&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">await</span> next.Invoke();</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;2 end&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pipeBuilder.UseMiddleware&lt;TestIMddleware&gt;();</span><br><span class="line">    pipeBuilder.Run(<span class="keyword">async</span> context =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;Run&lt;br/&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">dynamic</span> obj = context.Items[<span class="string">&quot;BodyJson&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">$&quot;BodyJson: <span class="subst">&#123;obj&#125;</span>&lt;br/&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    pipeBuilder.Run(<span class="keyword">async</span> context =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;Run&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/img%5CWEBAPI%5C20.png"></p><h1 id="Filter（筛选器）和Middileware（中间件）的区别"><a href="#Filter（筛选器）和Middileware（中间件）的区别" class="headerlink" title="Filter（筛选器）和Middileware（中间件）的区别"></a>Filter（筛选器）和Middileware（中间件）的区别</h1><p>中间件是ASP.NET Core这个基础提供的功能，而Filter是ASP.NET Core WVC中提供的功能。ASP.NET Core MVC是由MVC中间件提供的框架，而Filter属于MVC中间件提供的功能。</p><p><img src="/img%5CWEBAPI%5C21.png"></p><p>区别</p><ol><li>中间件可以处理所有的请求，而Filter只能处理对控制器的请求；中间件运行在一个更底层、更抽象的级别，因此在中间件中无法处理MVC中间件特有的概念。</li><li>中间件和Filter可以完成很多相似的功能。“未处理异常中间件”和“未处理异常Filter”;“请求限流中间件”和“请求限流Filter”的区别。</li><li>优先选择使用中间件；但是如果这个组件只针对MVC或者需要调用一些MVC相关的类的时候，我们就只能选择Filter。</li></ol>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置系统与ASP.NET Core</title>
      <link href="/2025/04/21/asp.net%20core/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F%E4%B8%8EASP.NET%20Core%E7%9A%84%E9%9B%86%E7%BE%A4/"/>
      <url>/2025/04/21/asp.net%20core/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F%E4%B8%8EASP.NET%20Core%E7%9A%84%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="配置系统与ASP-NET-Core"><a href="#配置系统与ASP-NET-Core" class="headerlink" title="配置系统与ASP.NET Core"></a>配置系统与ASP.NET Core</h1><h3 id="默认添加的配置提供者"><a href="#默认添加的配置提供者" class="headerlink" title="默认添加的配置提供者"></a>默认添加的配置提供者</h3><p>1.加载现有的IConfiguration。<br>2.加载项目根目录下的appsettings.json。<br>3.加载项目根目录下的appsettings.{Environment}.json。<br>4.当程序运行在开发环境下，程序会加载“用户机密”配置。<br>5.加载环境变量中的配置。<br>6.加载命令行中的配置。</p><h3 id="配置的环境问题"><a href="#配置的环境问题" class="headerlink" title="配置的环境问题"></a>配置的环境问题</h3><p>1.开发环境、测试环境、生产环境需要进行不同配置。<br>2.运行环境：ASP.NET Core会从环境变量中读取名字为ASPNETCORE_ENVIRONMENT的值。推荐值：Development（开发环境）、Stagin（测试环境）、Production（开发环境）。<br>3.读取方法：app.Environment.EnvironmentName、app.Environment.IsDvelopment()…<br>4.在Windows和VS（推荐开发时用）中设置环境变量的方法。</p><p>在Program.cs中设置</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(app.Environment.EnvironmentName);</span><br><span class="line">Console.WriteLine(app.Environment.IsDevelopment());</span><br><span class="line">Console.WriteLine(app.Environment.IsProduction());</span><br></pre></td></tr></table></figure><p>在Controllers中设置</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IWebHostEnvironment webhost;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestController</span>(<span class="params">IWebHostEnvironment webhost</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.webhost = webhost;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Get</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> webhost.EnvironmentName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NET-Core防止机密配置外泄"><a href="#NET-Core防止机密配置外泄" class="headerlink" title=".NET Core防止机密配置外泄"></a>.NET Core防止机密配置外泄</h1><h2 id="用“用户机密”来避免机密信息的泄露"><a href="#用“用户机密”来避免机密信息的泄露" class="headerlink" title="用“用户机密”来避免机密信息的泄露"></a>用“用户机密”来避免机密信息的泄露</h2><p>1.把不方便放到appsettings.json中的机密信息放到一个不在项目中的json文件中。<br>2.在ASP.NET Core项目上单击鼠标右键，选择【管理用户机密】。<br>3.secrets.json文件到底保存在哪里？如何和项目建立关系？csproj文件中的&lt;UserSecretsld&gt;</p><p>这个节点的值就是一个用来定位用户机密配置的标识。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;PropertyGroup&gt;</span><br><span class="line">  &lt;TargetFramework&gt;net8<span class="number">.0</span>&lt;/TargetFramework&gt;</span><br><span class="line">  &lt;Nullable&gt;enable&lt;/Nullable&gt;</span><br><span class="line">  &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;</span><br><span class="line">  &lt;UserSecretsId&gt;e049b89f<span class="number">-2772</span><span class="number">-408</span>a<span class="number">-9073</span><span class="number">-938f</span>00afc514&lt;/UserSecretsId&gt;</span><br><span class="line">&lt;/PropertyGroup&gt;</span><br></pre></td></tr></table></figure><p>读取配置</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name= app.Configuration.GetSection(<span class="string">&quot;name&quot;</span>).Value;</span><br><span class="line">Console.WriteLine(name);</span><br></pre></td></tr></table></figure><h3 id="在使用用户机密的时候有如下几点需要注意"><a href="#在使用用户机密的时候有如下几点需要注意" class="headerlink" title="在使用用户机密的时候有如下几点需要注意"></a>在使用用户机密的时候有如下几点需要注意</h3><p>1.用户机密机制是供开发人员使用的，因此不适合在生成环境中使用。<br>2.secrets.json中的配置任然是明文存储的，并没有加密。如果想避免连接字符串等机密配置被别人看到，可以采用Azure Key Vault等配置服务器。但是无论什么配置服务器，只要程序能读取这些配置，采用任何配置服务器的“连接字符串加密”只能增加机密信息被发现的难度，不能彻底杜绝机密信息被发现。<br>3.如果因为重装、就需要重新配置，麻烦。如果影响大的话，还是用集中式配置服务器。</p><h1 id="配置系统综合"><a href="#配置系统综合" class="headerlink" title="配置系统综合"></a>配置系统综合</h1><h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><p>1.系统的主要配置（Redis、Smtp）放到配置专用的数据库中。<br>2.连接配置数据库的连接字符串配置在“用户机密”中。<br>3.把Smtp的配置显示到界面上。<br>4.程序启动的时候就连接Redis,并且把Redis连接对象注册到依赖注入系统中。</p><p>第一步：在SQL Server数据库中创建一张保存配置信息的数据库表T_Configs,表包含Id、Name、Value这3列，Id列定义为整数类型的标识列，Name列和Value列都定义为字符串类型，Name列为配置项的名字，Value列为配置项的值。</p><p>第二步：在T_Configs表中增加两行数据。<br><img src="/img%5CWEBAPI%5C12.png"></p><p>第三步：在项目中创建一个SmtpOptions类用来绑定Smtp的配置值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SmtpOptions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Host &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> UserName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Password &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="built_in">string</span>.Empty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步：通过NuGet安装从数据库中读取配置的Zack.AnyDBConfigProvider,以及连接Redis的Stack Exchange.Redis。</p><p>第五步：在项目上右击，选择【管理用户机密】。配置secrets.json。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ConnectionStrings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configServer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Data Source=.;Initial Catalog=demo1;Integrated Security=SSPI;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>第六步：编写代码进行配置系统的初始化。在Program.cs文件的WebApplication.CreateBuilder(args)的下面添加。</p><p>安装NuGet包StackExchange.Redis</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">builder.Host.ConfigureAppConfiguration((_, configBuilder) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> connStr=builder.Configuration.GetConnectionString(<span class="string">&quot;ConnectionStrings&quot;</span>);</span><br><span class="line">    configBuilder.AddDbConfiguration(() =&gt; <span class="keyword">new</span> SqlConnection(connStr),reloadOnChange:<span class="literal">true</span>,reloadInterval:TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">&#125;);</span><br><span class="line">builder.Services.Configure&lt;SmtpOptions&gt;(builder.Configuration.GetSection(<span class="string">&quot;Smtp&quot;</span>));</span><br><span class="line">builder.Services.AddSingleton&lt;IConnectionMultiplexer&gt;(sp =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> connStr = builder.Configuration.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Redis:ConnStr&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ConnectionMultiplexer.Connect(connStr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第七步：在控制器中通过构造方法注入获取SmtpOptions和Redis连接对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">builder.Host.ConfigureAppConfiguration((_, configBuilder) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> connStr = builder.Configuration.GetConnectionString(<span class="string">&quot;configServer&quot;</span>);</span><br><span class="line">    configBuilder.AddDbConfiguration(() =&gt; <span class="keyword">new</span> SqlConnection(connStr), reloadOnChange: <span class="literal">true</span>, reloadInterval: TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">&#125;);</span><br><span class="line">builder.Services.AddSingleton&lt;IConnectionMultiplexer&gt;(sp =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> connStr = builder.Configuration.GetSection(<span class="string">&quot;Redis&quot;</span>).Value;</span><br><span class="line">    <span class="keyword">return</span> ConnectionMultiplexer.Connect(connStr);</span><br><span class="line">&#125;);</span><br><span class="line">builder.Services.Configure&lt;SmtpOptions&gt;(builder.Configuration.GetSection(<span class="string">&quot;Smtp&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/img%5CWEBAPI%5C13.png"></p><h1 id="EF-Core与ASP-NET-Core的集成"><a href="#EF-Core与ASP-NET-Core的集成" class="headerlink" title="EF Core与ASP.NET Core的集成"></a>EF Core与ASP.NET Core的集成</h1><p>EF Core可以用于所有.NET Core平台下的程序，ASP.NET Core也不例外。在ASP.NET Core中使用EF Core的时候还有一些需要额外注意的问题。</p><h3 id="分层项目中EF-Core的用法"><a href="#分层项目中EF-Core的用法" class="headerlink" title="分层项目中EF Core的用法"></a>分层项目中EF Core的用法</h3><p>在编写简单的演示案例的时候，我们通常会把项目的所有代码放在同一个文件夹中，而对于现实中比较复杂的项目，我们通常是要  其进行分层的，也就是不同的类放到不同的文件夹中。这样的分层项目中使用EF Core的时候有一些问题需要考虑。</p><p>1.创建一个.NET类库项目，项目名字为BooksEFCore。<br>NuGet：Microsoft.EntityFrameworkCore.Relational<br>并且在项目中增加代表图书的实体类Book和它的实体类的配置类BookConfig.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Book</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> AuthorName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime PuDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">BookConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Book</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Book&gt; builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(<span class="string">&quot;T_Book&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，这里把Book类声明为一个记录类，而不是普通的类，主要是为了让编译器自动生成ToString方法，帮我们简化对象的输出。</p><p>2.在BookEFCore项目中增加上下文类。</p><p>数据库的配置1</p><p>1.上下文类MyDbContext：为什么正式项目中最好别不要在MyDbContext写数据库配置（连接不同的DB甚至不同类型的DB）。尽量数据库配置的代码写到ASP.NET Core项目中。不重复OnConfiguring方法，而是为MyDbContext类的构造方法增加DbContextOptions&lt;MyDbContext&gt;参数。在ASP.NET Core项目对DbContextOptions的配置。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyDbContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Book</span>&gt; Books</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDbContext</span>(<span class="params">DbContextOptions&lt;MyDbContext&gt; options</span>) : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">        <span class="keyword">new</span> BookConfig().Configure(modelBuilder.Entity&lt;Book&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建ASP.NET Core项目，添加对“BooksEFCore”项目的引用。NuGet安装<br>Microsoft.EntityFrameworkCore.SqlServer<br>在ASP.NET Core项目的appsettings.json中增加对数据库连接字符串的配置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;ConnectionStrings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Server=localhost;Database=T_dome;Trusted_Connection=True;MultipleActiveResultSets=true;Encrypt=false;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>3.配置文件、配置代码等放到ASP.NET Core项目中。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddDbContext&lt;MyDbContext&gt;(opt =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> Default = builder.Configuration.GetConnectionString(<span class="string">&quot;Default&quot;</span>);</span><br><span class="line">    opt.UseSqlServer(Default);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用AddDbContext方法来通过依赖注入的方式让MyDbContext采用我们指定的连接字符串连接数据库。由于AddDbContext方法是泛型的，因此我们可以为同一个项目中的多个不同的上下文设定连接不同的数据库。</p><p>4.在ASP.NET Core想买中增加使用MyDbContext进行数据库读写的测试代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TextController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> MyDbContext dbCtx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextController</span>(<span class="params">MyDbContext dbCtx</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.dbCtx = dbCtx;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Index</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        dbCtx.Add(<span class="keyword">new</span> Book &#123; Id=Guid.NewGuid(),AuthorName= <span class="string">&quot;AuthorName&quot;</span>, Price = <span class="number">100</span>, PuDate = DateTime.Now, Title = <span class="string">&quot;Title&quot;</span> &#125;);</span><br><span class="line">        <span class="keyword">await</span> dbCtx.SaveChangesAsync(); </span><br><span class="line">        <span class="keyword">var</span> book=dbCtx.Books.First();</span><br><span class="line">        <span class="keyword">return</span> Content(book.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.生成实体类的迁移脚本。安装Microsoft.EntityFrameworkCore.Tools。然后把EFCoreBook设置为启动项目，并且在【程序包管理器控制台】中也选中EFCoreBook项目后，执行Add-Migration和Update-Database</p><p>6.再执行Add-Migration的时候，迁移工具就会提示：Unable to create a ‘DbContext’ of type ‘RuntimeType’.<br>数据库迁移的时候出现这种错误，采用IDesignTimeDbContextFactory接口来解决这个问题。<br>当项目中存在一个IDesignTimeDbContextFactory接口的实现类的时候，数据库迁移工具就会调用这个实现类的CreateDbContext方法来获取上下文对象，然后迁移工具会使用这个上下文对象来连接数据库。因此，我们需要在BooksEFCore项目创建一个IDesignTimeDbContextFactory接口的实现类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyDesignTimeDbContextFactroy</span> : <span class="title">IDesignTimeDbContextFactory</span>&lt;<span class="title">MyDbContext</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyDbContext <span class="title">CreateDbContext</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DbContextOptionsBuilder&lt;MyDbContext&gt; builder = <span class="keyword">new</span> DbContextOptionsBuilder&lt;MyDbContext&gt;();</span><br><span class="line">        <span class="built_in">string</span> ConnStr=<span class="string">&quot;Server=localhost;Database=T_dome3;Trusted_Connection=True;MultipleActiveResultSets=true;Encrypt=false;&quot;</span>;</span><br><span class="line">        builder.UseSqlServer(ConnStr);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyDbContext(builder.Options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但有数据泄露的风险</p><p><img src="/img%5CWEBAPI%5C15.png"></p>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core Web API基础组件</title>
      <link href="/2025/04/19/asp.net%20core/ASP.NET%20Core%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/"/>
      <url>/2025/04/19/asp.net%20core/ASP.NET%20Core%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="ASP-NET-Core中服务注入的地方"><a href="#ASP-NET-Core中服务注入的地方" class="headerlink" title="ASP.NET Core中服务注入的地方"></a>ASP.NET Core中服务注入的地方</h1><p>1.在ASP.NET Core项目中一般不需要自己创建ServiceCollection、IServiceProvider。在Program.cs的builder.Build()之前向builder.Services中注入。<br>2.在Controller中可以通过构造方法注入服务。</p><p>定义一个MyService类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyService</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="built_in">string</span>&gt; <span class="title">GetName</span>()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">string</span>[] &#123;<span class="string">&quot;you&quot;</span>,<span class="string">&quot;xian&quot;</span>,<span class="string">&quot;yu&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ASP.NET Core项目的Program.cs文件中的var app&#x3D;builder.Build()代码之前通过AddScoped方法来注册MyService服务。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddScoped&lt;MyService&gt;();</span><br></pre></td></tr></table></figure><p>在控制器中，我们通过构造方法来注入服务。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestController</span>:<span class="title">ControllerBase</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> MyService myService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestController</span>(<span class="params">MyService myService</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myService=myService;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Test</span>()</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> names=myService.GetNames();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>,names);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="低使用频率服务的另类注入方式"><a href="#低使用频率服务的另类注入方式" class="headerlink" title="低使用频率服务的另类注入方式"></a>低使用频率服务的另类注入方式</h3><p>1.把Action用到的服务通过Action的参数注入，在这个参数上标注[FromServices]。和Action的其他参数不冲突。<br>2.一般不需要，只有调用频率不高并且资源的创建比较消耗资源的服务才[FromServices]。<br>3.只有Action方法才能用[FromServices],普通的类默认不支持。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Test</span>(<span class="params">[FromServices]MyService myService,<span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> names=myService.GetName();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>,names)+<span class="string">&quot;,Hello:&quot;</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开发模块化的服务注册框架"><a href="#开发模块化的服务注册框架" class="headerlink" title="开发模块化的服务注册框架"></a>开发模块化的服务注册框架</h3><p>一个软件通常有多个项目组成，这些项目都会直接或者间接被主ASP.NET Core项目引用。这些项目中通常都会用到若干个被注入的服务，因此我们需要在主ASP.NET Core项目的Program.cs中注册这些服。这样不仅增加了Program.cs管理的复杂度，而且增加了项目的耦合度。</p><p>Scrutor是 Kristian Hellang 大神写的一个基于Microsoft.Extensions.DependencyInjection的一个扩展库，主要是为了简化我们对DI的操作。</p><p>Scrutor提供Scan这个方法。</p><p>1.选择程序集：指定从哪个程序集中扫描类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.Scan(scan =&gt; scan.FromAssemblyOf&lt;Class1&gt;());</span><br></pre></td></tr></table></figure><p>2.添加类：过滤需要注册的类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.Scan(scan =&gt; scan.FromAssemblyOf&lt;Class1&gt;()</span><br><span class="line">.AddClasses(cl =&gt; cl.Where(t =&gt; t.Name.EndsWith(<span class="string">&quot;Service&quot;</span>)))<span class="comment">//只注册以Service结尾的类</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>3.指定注册方式：指定应该注册为哪些接口。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.Scan(scan =&gt; scan.FromAssemblyOf&lt;Class1&gt;()</span><br><span class="line">.AddClasses(cl =&gt; cl.Where(t =&gt; t.Name.EndsWith(<span class="string">&quot;Service&quot;</span>)))</span><br><span class="line">.AsImplementedInterfaces() <span class="comment">//注册为实现的所有接口</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>4.设置生命周期：为注册的服务设置生命周期</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.Scan(scan =&gt; scan.FromAssemblyOf&lt;Class1&gt;()</span><br><span class="line">.AddClasses(cl =&gt; cl.Where(t =&gt; t.Name.EndsWith(<span class="string">&quot;Service&quot;</span>)))</span><br><span class="line">.AsImplementedInterfaces()</span><br><span class="line">.WithScopedLifetime() <span class="comment">//设置为Scoped生命周期</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="性能优化“万金油”：缓存"><a href="#性能优化“万金油”：缓存" class="headerlink" title="性能优化“万金油”：缓存"></a>性能优化“万金油”：缓存</h2><p>缓存（caching）是系统优化中简单又有效的工具，只要简单几行代码或几个简单的配置，我们就可利用缓存的性能得到极大的提升。</p><p>1.什么是缓存</p><p>缓存是一个用来保存数据的区域，从缓存区域中读取数据的速度比从数据源读取数据的速度快很多。在从数据源（如数据库）获取数据之后，我们可以把数据保存到缓存中。</p><p><img src="/img%5CWEBAPI%5C%E7%BC%93%E5%AD%98.png"></p><h3 id="客户端响应缓存"><a href="#客户端响应缓存" class="headerlink" title="客户端响应缓存"></a>客户端响应缓存</h3><p>1.RFC7324是HTTP协议中对缓存进行控制的规范，其中重要的是cache-control这个响应报文头。服务器如果返回cache-control:max-age&#x3D;60,则表示服务器指示浏览器端“可以缓存这个响应内容60秒”。<br>2.我们只要给需要进行缓存控制的控制器的操作方法添加ResponseCacheAttribute这个Attribute，ASP.NET Core会自动添加cache-control报文头。<br>3.验证：编写一个返回当前时间的Action方法。分别加和不加ResponseCacheAttribute看区别。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">ResponseCache(Duration =20)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DateTime <span class="title">Now</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> DateTime.Now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次访问，服务器返回当前时间<br><img src="/img%5CWEBAPI%5C6.png"></p><p>第二次访问，响应是直接从浏览器缓存中获取的。<br><img src="/img%5CWEBAPI%5C7.png"></p><p>第三次访问<br><img src="/img%5CWEBAPI%5C8.png"></p><h3 id="服务器端响应缓存"><a href="#服务器端响应缓存" class="headerlink" title="服务器端响应缓存"></a>服务器端响应缓存</h3><p>1.如果ASP.NET Core中安装了“相应缓存中间件”，那么ASP.NET Core不仅会继续根据[ResponseCache]设置来生成cache-control响应报文头来设置客户端缓存，而且服务器也会按照[ResponseCache]的设置来对应响应服务器端缓存。和客户端缓存的区别？来子多个不同客户端的相同请求。<br>2.“响应缓存中间件”的好处：对于来自不同客户端的相同请求或者不支持客户端缓存的客户端，能降低服务器端的压力。<br>3.用法：在程序集Program.cs中app.MapControllers()之前加上app.UseResponseCaching()。请确保app.UseCors()写到app.UseResponseCaching()之前。  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.UseResponseCaching();<span class="comment">//启动服务器端响应缓存</span></span><br><span class="line">app.MapControllers();</span><br></pre></td></tr></table></figure><p>服务器端响应缓存很鸡肋<br>1.无法解决恶意请求给服务器带来的压力。<br>2.服务器端响应缓存还有很多限制，包括但不限于：响应状态码为200的GET或者HEAD响应才可能被缓存；报文头中不能含有Authorization、Set-Cookie等。<br>3.建议采用ASP.NET Core提供的内存缓存、分布式缓存机制来编写程序，以更灵活地进行自定义缓存处理。</p><h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><p>1.把缓存数据放在应用程序的内存。内存缓存中保存的是一个系列的键值对，就像Dictionary类型一样。<br>2.内存缓存的数据保存在当前运行的网站程序的内存中，是和进程相关的。因为在Web服务器中，多个不同网站重启后，内存缓存中的所有数据也就都被清空了。</p><p><b>内存缓存用法</b><br>1.启用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddMemoryCache();<span class="comment">//添加内存缓存服务</span></span><br></pre></td></tr></table></figure><p>2.注入IMemoryCache接口，查看接口的方法：TryGetValue、Remove、Set、GetOrCreate、GetOrCreateAsync</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IMemoryCache memoryCache;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;TestController&gt; logger;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestController</span>(<span class="params">IMemoryCache memoryCache, ILogger&lt;TestController&gt; logger</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.memoryCache = memoryCache;</span><br><span class="line">    <span class="keyword">this</span>.logger = logger;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&lt;Book?&gt;&gt; GetBookById(<span class="built_in">long</span> id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//GetOrCreateAsync二合一：1。获取缓存 2.如果没有缓存，则执行GetBookByIdAsync方法，并将结果缓存</span></span><br><span class="line">    logger.LogInformation(<span class="string">$&quot;GetBookById id=<span class="subst">&#123;id&#125;</span>&quot;</span>); <span class="comment">// 记录日志</span></span><br><span class="line">    Book? b= <span class="keyword">await</span> memoryCache.GetOrCreateAsync(<span class="string">&quot;Book&quot;</span> + id, <span class="keyword">async</span> (e) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        logger.LogInformation(<span class="string">$&quot;GetBookById id=<span class="subst">&#123;id&#125;</span> 进入缓存&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> MyDbContext.GetBookByIdAsync(id);</span><br><span class="line">    &#125;);</span><br><span class="line">    logger.LogInformation(<span class="string">$&quot;GetBookById id=<span class="subst">&#123;id&#125;</span> 结束缓存&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NotFound(<span class="string">$&quot;找不到id=<span class="subst">&#123;id&#125;</span>的书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存的过期时间策略"><a href="#缓存的过期时间策略" class="headerlink" title="缓存的过期时间策略"></a>缓存的过期时间策略</h3><p>1.上面的例子中的缓存不会过期，除非重启服务器。<br>2.解决方法：在数据改变的时候调用Remove或者Set来删除或者修改缓存（优点：及时）；过期时间（只要过期时间比较短，缓存数据不一致的情况也不会持续很长时间。）<br>3.两种过期时间策略：绝对过期时间、滑过过期时间。</p><p>缓存的绝对过期时间</p><p>1.GetOrCreateAsync()方法的回调方法中有一个ICacheEntry类型的参数，通过ICacheEntry对当前的缓存项做设置。<br>2.AbsoluteExpirationRelativeToNow用来设定缓存项的绝对过期时间。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">logger.LogInformation(<span class="string">$&quot;GetBookById id=<span class="subst">&#123;id&#125;</span>&quot;</span>); <span class="comment">// 记录日志</span></span><br><span class="line">Book? b= <span class="keyword">await</span> memoryCache.GetOrCreateAsync(<span class="string">&quot;Book&quot;</span> + id, <span class="keyword">async</span> (e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    e.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(<span class="number">10</span>); <span class="comment">// 设置缓存过期时间</span></span><br><span class="line">    logger.LogInformation(<span class="string">$&quot;GetBookById id=<span class="subst">&#123;id&#125;</span> 进入缓存&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> MyDbContext.GetBookByIdAsync(id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>缓存的滑动过期时间</p><p>1.ICacheEntry的SlidingExpiration属性用来设定缓存项的滑动过期时间。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">logger.LogInformation(<span class="string">$&quot;GetBookById id=<span class="subst">&#123;id&#125;</span>&quot;</span>); <span class="comment">// 记录日志</span></span><br><span class="line">Book? b= <span class="keyword">await</span> memoryCache.GetOrCreateAsync(<span class="string">&quot;Book&quot;</span> + id, <span class="keyword">async</span> (e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*e.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(10); // 设置缓存过期时间*/</span></span><br><span class="line">    e.SlidingExpiration = TimeSpan.FromSeconds(<span class="number">10</span>); <span class="comment">// 设置滑动过期时间</span></span><br><span class="line">    logger.LogInformation(<span class="string">$&quot;GetBookById id=<span class="subst">&#123;id&#125;</span> 进入缓存&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> MyDbContext.GetBookByIdAsync(id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>两种过期时间混用</p><p>使用滑动过期时间策略，如果一个缓存项一直被频繁访问，那么这个缓存项就会一直被续期而不过期。可以对一个缓存项同时设定滑动过期时间和绝对过期时间长，这样缓存想的内容会在绝对过期时间内随着访问被滑动续期，但是一旦超过了绝对过期时间，缓存像就会被删除。</p><h3 id="缓存穿透问题的规避"><a href="#缓存穿透问题的规避" class="headerlink" title="缓存穿透问题的规避"></a>缓存穿透问题的规避</h3><p>在使用内存缓存的时候，如果处理不当，我们容易遇到“缓存穿透”的问题。我们注意到，IMemoryCache接口中有一个Get(object key)方法，它用来根据缓存键key查找缓存值，如果找不到缓存项，则方法会返回null等默认值。</p><p>缓存穿透的解决方案</p><p>1.解决方法：把“查不到”也当成一个数据放入缓存。<br>2.我们用GetOrCreateAsync方法即可，因为它会把null值也当成合法的缓存值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">logger.LogInformation(<span class="string">$&quot;GetBookById id=<span class="subst">&#123;id&#125;</span>&quot;</span>); <span class="comment">// 记录日志</span></span><br><span class="line">Book? b= <span class="keyword">await</span> memoryCache.GetOrCreateAsync(<span class="string">&quot;Book&quot;</span> + id, <span class="keyword">async</span> (e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*e.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(10); // 设置缓存过期时间*/</span></span><br><span class="line">    <span class="comment">/*e.SlidingExpiration = TimeSpan.FromSeconds(10); // 设置滑动过期时间*/</span></span><br><span class="line">    Book? d= <span class="keyword">await</span> MyDbContext.GetBookByIdAsync(id);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;GetBookById id=<span class="subst">&#123;id&#125;</span> 进入缓存&quot;</span>); <span class="comment">// 记录日志</span></span><br><span class="line">    logger.LogInformation(<span class="string">$&quot;GetBookById id=<span class="subst">&#123;id&#125;</span> 进入缓存&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> MyDbContext.GetBookByIdAsync(id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>1.缓存项集中过期引起缓存雪崩。<br>2.解决方法：在基础过期时间之上，再加一个随机的过期时间。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logger.LogInformation(<span class="string">$&quot;GetBookById id=<span class="subst">&#123;id&#125;</span>&quot;</span>); <span class="comment">// 记录日志</span></span><br><span class="line">Book? b= <span class="keyword">await</span> memoryCache.GetOrCreateAsync(<span class="string">&quot;Book&quot;</span> + id, <span class="keyword">async</span> (e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*e.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(10); // 设置缓存过期时间*/</span></span><br><span class="line">    <span class="comment">/*e.SlidingExpiration = TimeSpan.FromSeconds(10); // 设置滑动过期时间*/</span></span><br><span class="line">    e.AbsoluteExpirationRelativeToNow=TimeSpan.FromSeconds(Random.Shared.Next(<span class="number">5</span>, <span class="number">10</span>)); <span class="comment">// 设置缓存过期时间</span></span><br><span class="line">    Book? d= <span class="keyword">await</span> MyDbContext.GetBookByIdAsync(id);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;GetBookById id=<span class="subst">&#123;id&#125;</span> 进入缓存&quot;</span>); <span class="comment">// 记录日志</span></span><br><span class="line">    logger.LogInformation(<span class="string">$&quot;GetBookById id=<span class="subst">&#123;id&#125;</span> 进入缓存&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> MyDbContext.GetBookByIdAsync(id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="封装内存缓存操作的帮助类"><a href="#封装内存缓存操作的帮助类" class="headerlink" title="封装内存缓存操作的帮助类"></a>封装内存缓存操作的帮助类</h3><p>1.IQueryable、IEnumerable等类型可能存在着延迟加载的问题，如果把这两种类型的变量指向的对象保存到缓存中，在我们把它们取出来再去执行的时候，如果它们延迟加载时候需要的对象已经被释放的话，就会执行失败。因此缓存禁止这两种类型。<br>2.实现随机缓存过期时间。</p><p>使用NuGet包：Zack.ASPNETCore</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddScoped&lt;IMemoryCacheHelper, MemoryCacheHelper&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&lt;Book?&gt;&gt; Test3(<span class="built_in">long</span> id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> book = <span class="keyword">await</span> memoryCache.GetOrCreateAsync(<span class="string">&quot;Book&quot;</span> + id, <span class="keyword">async</span> (e) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        e.SlidingExpiration = TimeSpan.FromSeconds(<span class="number">5</span>); <span class="comment">// 设置滑动过期时间</span></span><br><span class="line">        <span class="keyword">var</span> book = <span class="keyword">await</span> MyDbContext.GetBookByIdAsync(id);</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (book == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NotFound(<span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>分布式系统中的内存缓存<br><img src="/img%5CWEBAPI%5C%E5%88%86%E5%B8%83%E5%BC%8F.png"><br>如果集群节点的数量非常多的话，这样的重复查询也同样可能会把数据库压垮。</p><p>1.常用的分布式缓存服务器有Redis、Memcached等。<br>2..NET Core中提供了统一的分布式缓存服务器的操作接口IDistributedCache，用法和内存缓存类似。<br>3.分布式缓存和内存缓存的区别：缓存值的类型为byte[]，需要我们进行类型转换，也提供了一些按照string类型存取缓存值的扩展方法。</p><p><img src="/img%5CWEBAPI%5C9.png"></p><p>用什么做缓存服务器</p><p>1.Memcached是缓存专用，性能非常高，但是集群、高可用等方面比较弱，而且有“缓存键的最大长度为250字节”等限制。可以安装EnyimMemcachedCore这个第三NuGet包。<br>2.Redis不局限于缓存，Redis做缓存服务器比Memcached性能稍差，但是Redis的高可用、集群等方面非常强大，适合在数据量大、高可用性等场合使用。</p><p>使用Redis</p><p>1.NuGet安装</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.Extensions.Caching.StackExchangeRedis</span><br></pre></td></tr></table></figure><p>配置redis</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddStackExchangeRedisCache(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Configuration= <span class="string">&quot;127.0.0.1:6379&quot;</span>;</span><br><span class="line">    options.InstanceName = <span class="string">&quot;XIAN_&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IMemoryCache memoryCache;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;TestController&gt; logger;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IMemoryCacheHelper memoryCacheHelper;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IDistributedCache distCache;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestController</span>(<span class="params">IMemoryCache memoryCache, ILogger&lt;TestController&gt; logger, IMemoryCacheHelper memoryCacheHelper, IDistributedCache distCache</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.memoryCache = memoryCache;</span><br><span class="line">    <span class="keyword">this</span>.logger = logger;</span><br><span class="line">    <span class="keyword">this</span>.memoryCacheHelper = memoryCacheHelper;</span><br><span class="line">    <span class="keyword">this</span>.distCache = distCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">HttpGet </span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&lt;Book?&gt;&gt; Test2(<span class="built_in">long</span> id)</span><br><span class="line">&#123;</span><br><span class="line">    Book? book;</span><br><span class="line">    <span class="built_in">string</span>? s= <span class="keyword">await</span> distCache.GetStringAsync(<span class="string">&quot;Book&quot;</span> + id);</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        book = <span class="keyword">await</span> MyDbContext.GetBookByIdAsync(id);</span><br><span class="line">       <span class="keyword">await</span> distCache.SetStringAsync(<span class="string">&quot;Book&quot;</span> + id,JsonSerializer.Serialize(book));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        book = JsonSerializer.Deserialize&lt;Book?&gt;(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (book == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NotFound(<span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<br><img src="/img%5CWEBAPI%5C11.png"></p><p>使用Redisdesktop查看,转换json格式<br><img src="/img%5CWEBAPI%5C10.png"></p><h3 id="封装分布式缓存操作的帮助类"><a href="#封装分布式缓存操作的帮助类" class="headerlink" title="封装分布式缓存操作的帮助类"></a>封装分布式缓存操作的帮助类</h3><p>解决雪崩缓存问题</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddScoped&lt;IDistributedCacheHelper, DistributedCacheHelper&gt;();</span><br></pre></td></tr></table></figure><p>注入服务</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IMemoryCache memoryCache;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;TestController&gt; logger;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IMemoryCacheHelper memoryCacheHelper;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IDistributedCache distCache;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IDistributedCacheHelper distributedCacheHelper;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestController</span>(<span class="params">IMemoryCache memoryCache, ILogger&lt;TestController&gt; logger, IMemoryCacheHelper memoryCacheHelper, IDistributedCache distCache, IDistributedCacheHelper distributedCacheHelper</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.memoryCache = memoryCache;</span><br><span class="line">    <span class="keyword">this</span>.logger = logger;</span><br><span class="line">    <span class="keyword">this</span>.memoryCacheHelper = memoryCacheHelper;</span><br><span class="line">    <span class="keyword">this</span>.distCache = distCache;</span><br><span class="line">    <span class="keyword">this</span>.distributedCacheHelper = distributedCacheHelper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&lt;Book?&gt;&gt; Test3(<span class="built_in">long</span> id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> book = <span class="keyword">await</span> distributedCacheHelper.GetOrCreateAsync(<span class="string">&quot;Book&quot;</span> + id, <span class="keyword">async</span> (e) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        e.SlidingExpiration = TimeSpan.FromSeconds(<span class="number">5</span>); <span class="comment">// 设置滑动过期时间</span></span><br><span class="line">        <span class="keyword">var</span> book = <span class="keyword">await</span> MyDbContext.GetBookByIdAsync(id);</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (book == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NotFound(<span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue快速上手二</title>
      <link href="/2025/04/11/vue/Vue3-2/"/>
      <url>/2025/04/11/vue/Vue3-2/</url>
      
        <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">        &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;button @click=&quot;add&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">defineOptions(&#123; name: &#x27;person5&#x27; &#125;)</span><br><span class="line">import &#123; ref ,onBeforeMount,onMounted,onBeforeUpdate, onUpdated,onBeforeUnmount,onUnmounted&#125; from &#x27;vue&#x27;</span><br><span class="line">//数据</span><br><span class="line">let sum = ref(0)</span><br><span class="line"></span><br><span class="line">//方法</span><br><span class="line">function add() &#123;</span><br><span class="line">    sum.value+=1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建</span><br><span class="line">console.log(&#x27;创建&#x27;)</span><br><span class="line"></span><br><span class="line">//挂载前</span><br><span class="line">onBeforeMount(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;挂载前&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">//挂载完毕</span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;挂载完毕&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">//更新前</span><br><span class="line">onBeforeUpdate(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;更新前&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">//更新完毕</span><br><span class="line">onUpdated(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;更新完毕&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">//卸载前</span><br><span class="line">onBeforeUnmount(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;卸载前&#x27;)</span><br><span class="line"> &#125;)</span><br><span class="line">//卸载完毕</span><br><span class="line">onUnmounted(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;卸载完毕&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.person&#123;</span><br><span class="line">    background-color: aqua;</span><br><span class="line">    box-shadow: 0 0 10px;</span><br><span class="line">    border-radius: 10px;</span><br><span class="line">    padding:20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;Preson5 v-if=&quot;isShow&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">defineOptions(&#123; name:&#x27;you&#x27;&#125;)</span><br><span class="line">import Preson5 from &#x27;./components/Preson5.vue&#x27;;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">let isShow=ref(true)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i axios</span><br><span class="line">npm i vue-router</span><br></pre></td></tr></table></figure><p>1.app.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h2&gt;Vue路由测试&lt;/h2&gt;</span><br><span class="line">    &lt;div class=&quot;navigate&quot;&gt;</span><br><span class="line">        &lt;RouterLink to=&quot;/home&quot;active-class=&quot;you&quot;&gt;首页&lt;/RouterLink&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;main-content&quot;&gt;</span><br><span class="line">        &lt;RouterView&gt;&lt;/RouterView&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; RouterView,RouterLink &#125; from &#x27;vue-router&#x27;;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.navigate a.you&#123;</span><br><span class="line">    background-color: aqua;</span><br><span class="line">    box-shadow: 0 0 10px;</span><br><span class="line">    border-radius: 10px;</span><br><span class="line">    padding:20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>2.index.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个路由器，并暴露出去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步：引入createRouter</span></span><br><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Home.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步L：创建路由器</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>:<span class="title function_">createWebHistory</span>(),</span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">       &#125; </span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//暴露出去router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>3.Home.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;home&quot;&gt;hksjflasfjlsa&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>4.main.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入createApp用于创建应用</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="comment">//引入App根组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="comment">//引入路由器</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个应用</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"><span class="comment">//使用路由器</span></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line"><span class="comment">//挂在整个应用到app容器中</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue快速上手一</title>
      <link href="/2025/04/10/vue/Vue3/"/>
      <url>/2025/04/10/vue/Vue3/</url>
      
        <content type="html"><![CDATA[<h1 id="创建Vue3工程"><a href="#创建Vue3工程" class="headerlink" title="创建Vue3工程"></a>创建Vue3工程</h1><p>创建一个Vue应用，确保安装了Node.js</p><p>1.在命令行中运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vue@latest</span><br></pre></td></tr></table></figure><p><img src="/img%5Cjs%5Cvue.png"></p><p><img src="/img%5Cjs%5Cvue2.png"></p><blockquote><p>在终端：npm i 会把所有要用的包都下载好</p></blockquote><p>通过package.json文件，在终端命令行中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>启动项目</p><p><img src="/img%5Cjs%5Cvue3.png"></p><h2 id="编写APP组件"><a href="#编写APP组件" class="headerlink" title="编写APP组件"></a>编写APP组件</h2><p>删除原来的src文件夹，新建一个src文件夹,实现一个小效果。<br>1.在文件夹中创建<code>main.ts</code>和<code>App.vue</code>。<br>2.在<code>main.ts</code>引入createApp,App根组件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入createApp用于创建应用</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="comment">//引入App根组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>3.编写</p><blockquote><p>.vue里面要写三种标签：&lt;template&gt;–html–&lt;&#x2F;templategt&gt;&lt;script&gt;–js–&lt;&#x2F;script&gt;lt;style&gt;&lt;&#x2F;style&gt;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;cn&quot;&gt;YOUXIANYU&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;App&#x27; //组件名</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.cn&#123;</span><br><span class="line">   background-color: blueviolet;</span><br><span class="line">   box-shadow:0 0 10px;</span><br><span class="line">   border-radius: 10px;</span><br><span class="line">   padding: 20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt; </span><br></pre></td></tr></table></figure><p><img src="/img%5Cjs%5Cvue4.png"></p><h1 id="Vue3核心语法"><a href="#Vue3核心语法" class="headerlink" title="Vue3核心语法"></a>Vue3核心语法</h1><h2 id="CompositionAPI"><a href="#CompositionAPI" class="headerlink" title="CompositionAPI"></a>CompositionAPI</h2><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>setup是Vue3中一个新的配置项，值是一个函数，它是Composition API“表演的舞台”，组件中所用到的：数据、方法、计算属性、监视···等等，军配置在setup中。</p><p>特点：<br>setup函数返回的对象中的内容，可直接在模板中使用。<br>setup中访问this是undefined。<br>setup函数会在beforeCreate之前调用，它是“领先”所有钩子执行的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;person&quot;&gt;</span><br><span class="line">&lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;button @click=&quot;changName&quot;class=&quot;cn&quot;&gt;更改姓名&lt;/button&gt;</span><br><span class="line">&lt;button @click=&quot;changage&quot;class=&quot;cn&quot;&gt;更改年龄&lt;/button&gt;</span><br><span class="line">&lt;button @click=&quot;showTel&quot;class=&quot;cn&quot;&gt;获取联系方式&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;Person&#x27;,</span><br><span class="line">    //生命周期</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">        console.log(&#x27;deforeCreate&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        //数据</span><br><span class="line">        let name = &#x27;YOUXIANYU&#x27; //注意此时的name不是响应式的</span><br><span class="line">        let age = 19 //注意此时的age不是响应式的</span><br><span class="line">        let tel = &#x27;14292369230&#x27; //注意此时的tel不是响应式的</span><br><span class="line"></span><br><span class="line">        //方法</span><br><span class="line">        function changName() &#123;</span><br><span class="line">            name=&#x27;youxianyu&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        function changage() &#123;</span><br><span class="line">            age+=1</span><br><span class="line">        &#125;</span><br><span class="line">        function showTel() &#123;</span><br><span class="line">            alert(tel)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &#123;name,age,changName,changage,showTel&#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.person&#123;</span><br><span class="line">    background-color: burlywood;</span><br><span class="line">    box-shadow: 0 0 10px;</span><br><span class="line">    border-radius: 10px;</span><br><span class="line">    padding:20px;</span><br><span class="line">&#125;</span><br><span class="line">.cn&#123;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>setup返回值也可以是一个渲染函数</p><p>setup语法糖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">defineOptions(&#123; name: &#x27;Person&#x27; &#125;)</span><br><span class="line">        //数据</span><br><span class="line">        let name = &#x27;YOUXIANYU&#x27; //注意此时的name不是响应式的</span><br><span class="line">        let age = 19 //注意此时的age不是响应式的</span><br><span class="line">        let tel = &#x27;14292369230&#x27; //注意此时的tel不是响应式的</span><br><span class="line"></span><br><span class="line">        //方法</span><br><span class="line">        function changName() &#123;</span><br><span class="line">            name=&#x27;youxianyu&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        function changage() &#123;</span><br><span class="line">            age+=1</span><br><span class="line">        &#125;</span><br><span class="line">        function showTel() &#123;</span><br><span class="line">            alert(tel)</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="ref：基本类型的响应式数据"><a href="#ref：基本类型的响应式数据" class="headerlink" title="ref：基本类型的响应式数据"></a>ref：基本类型的响应式数据</h3><p>作用：定义响应式变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">defineOptions(&#123; name: &#x27;Person&#x27; &#125;)</span><br><span class="line">import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class="line">        //数据</span><br><span class="line">        let name = ref(&#x27;YOUXIANYU&#x27;) //注意此时的name不是响应式的</span><br><span class="line">        let age = ref(19)//注意此时的age不是响应式的</span><br><span class="line">        let tel = &#x27;14292369230&#x27; //注意此时的tel不是响应式的</span><br><span class="line"></span><br><span class="line">        //方法</span><br><span class="line">        function changName() &#123;</span><br><span class="line">            name.value=&#x27;youxianyu&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        function changage() &#123;</span><br><span class="line">            age.value+=1</span><br><span class="line">        &#125;</span><br><span class="line">        function showTel() &#123;</span><br><span class="line">            alert(tel)</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="对象类型的响应式数据"><a href="#对象类型的响应式数据" class="headerlink" title="对象类型的响应式数据"></a>对象类型的响应式数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;preson&quot;&gt;</span><br><span class="line">        &lt;h1&gt;一人&#123;&#123;car.brand&#125;&#125;,价值&#123;&#123;car.price&#125;&#125;元&lt;/h1&gt;</span><br><span class="line">        &lt;button @click=&quot;changePrice&quot; class=&quot;on&quot;&gt;修改人物价格&lt;/button&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=&quot;g in games&quot;:key=&quot;g.id&quot;&gt;&#123;&#123;g.name&#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一个游戏名字&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">defineOptions(&#123; name: &#x27;preson&#x27; &#125;)</span><br><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;</span><br><span class="line">//数据</span><br><span class="line">let car = reactive(&#123; brand: &#x27;almango&#x27;, price: 10 &#125;)</span><br><span class="line">let games = reactive([&#123; id: &#x27;hsadfdskjfds&#x27;, name: &#x27;解释就是掩饰&#x27; &#125;,</span><br><span class="line">&#123;id:&#x27;hsadfdskjfds&#x27;,name:&#x27;掩饰就是&#x27;&#125;,&#123;id:&#x27;hsadfdskjfds&#x27;,name:&#x27;事实&#x27;&#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">//方法</span><br><span class="line">function changePrice() &#123;</span><br><span class="line">    car.price+=10</span><br><span class="line">&#125;</span><br><span class="line">function changeFirstGame() &#123;</span><br><span class="line">    games[0].name=&#x27;就是个jb&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>ref对比reactive</p><p>宏观角度：<br>1.ref用来定义：基本类型数据、对象类型数据；<br>2.reactive用来定义：对象类型数据。</p><p>区别：<br>1.ref创建的变量必须使用.value<br>2.reactive重新分配一个新对象，会失去响应式</p><p>使用规则：<br>1.若需要一个基本类型的响应数据，必须使用ref。<br>2.若需要一个响应式对象，层级不深，ref、reactive都可以。<br>3.若需要一个响应式对象，且层级较深，推荐使用reactive。</p><h3 id="roReft与toRef"><a href="#roReft与toRef" class="headerlink" title="roReft与toRef"></a>roReft与toRef</h3><p>作用：将一个响应式对象的每一个属性，转换为ref对象。<br>toRefs与toRef功能一致，但toRefs可以批量转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">defineOptions(&#123; name: &#x27;preson2&#x27; &#125;)</span><br><span class="line">import &#123; reactive, toRefs &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">//数据</span><br><span class="line">let preson = reactive(&#123;</span><br><span class="line">    name: &#x27;youxianyu&#x27;,</span><br><span class="line">    age:19</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let &#123;name,age&#125;=toRefs(preson)</span><br><span class="line"></span><br><span class="line">function changeName() &#123;</span><br><span class="line">    name.value+=&#x27;~&#x27;</span><br><span class="line">&#125;</span><br><span class="line">function changeage() &#123;</span><br><span class="line">    age.value+=1</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;preson3&quot;&gt;</span><br><span class="line">        姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br&gt;</span><br><span class="line">        名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br&gt;\&lt;button @click=&quot;changeFullName&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">        全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">defineOptions(&#123; name: &#x27;preson3&#x27; &#125;)</span><br><span class="line">import &#123;ref,computed&#125; from &#x27;vue&#x27;;</span><br><span class="line">let firstName = ref(&#x27;YOU&#x27;)</span><br><span class="line">let lastName = ref(&#x27;XIANYU&#x27;)</span><br><span class="line">//这么定义的fullName是一个计算属性，且是只读的</span><br><span class="line">let fullName = computed( &#123;</span><br><span class="line">    get()&#123;</span><br><span class="line">        return firstName.value.slice(0,1).toUpperCase()+firstName.value.slice(1)+lastName.value</span><br><span class="line">    &#125;,</span><br><span class="line">    set(val) &#123;</span><br><span class="line">        const [str1, str2] = val</span><br><span class="line">        firstName.value = str1</span><br><span class="line">        lastName.value=str2</span><br><span class="line">    console.log(&#x27;set&#x27;,val )</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">function changeFullName() &#123;</span><br><span class="line">    fullName.value =&#x27;li-ls&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="watch监视"><a href="#watch监视" class="headerlink" title="watch监视"></a>watch监视</h1><p>作用：监视数据的变化（和Vue2中的watch作用一致）<br>特点：Vue3中的watch只能监视以下四种数据：<br>1.ref定义的数据。<br>2.reactive定义的数据。<br>3.函数返回一个值。<br>4.一个包含上述内容的数组。</p><br><p>1.监视ref定义的【基本类型】数据：直接写数据名即可，监视的是其value值的变化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;Person&quot;&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;sum&#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;button @click=&quot;changeSum&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">import &#123; ref, watch &#125; from &#x27;vue&#x27;;</span><br><span class="line">let sum = ref(0)</span><br><span class="line"></span><br><span class="line">function changeSum() &#123;</span><br><span class="line">    sum.value+=1</span><br><span class="line">&#125;</span><br><span class="line">//监视</span><br><span class="line">watch(sum, (newValue,oldValue) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;sum变化了&#x27;,newValue,oldValue)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br><p>2.监视ref定义的【对象类型】数据：直接写数据名，监视的是对象的【地址值】，若想监视对象内部的数据，要手动开启深度监视。</p><blockquote><p>若修改的是ref定义的对象中的属性，newValue和oldValue都是新值，因为它们是同一个对象。<br>若修改整个ref定义的对象，newValue是新值，oldValue是旧值，因为不是同一个对象了。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(preson,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(newValue,oldValue)</span><br><span class="line">&#125;,&#123;deep:true&#125;)</span><br></pre></td></tr></table></figure><br><p>3.监视reactive定义的【对象类型】数据，且默认开启了深度监视。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(person,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(newValue,oldValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>4.监视ref或reactive定义的【对象类型】数据中的某个属性。<blockquote><p>若该属性值不是【对象类型】，需要写成函数形式。<br>若该属性值依然是【对象类型】，可直接编，也可写成函数，不过建议写成函数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">        &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;h2&gt;汽车：&#123;&#123;person.car.c1&#125;&#125;\&#123;&#123;person.car.c2&#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">        &lt;button @click=&quot;changeage&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class="line">        &lt;button @click=&quot;changec1&quot;&gt;修改第一辆车&lt;/button&gt;</span><br><span class="line">        &lt;button @click=&quot;changec2&quot;&gt;修改第二辆车&lt;/button&gt;</span><br><span class="line">        &lt;button @click=&quot;changeCar&quot;&gt;修改整辆车&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">defineOptions(&#123; name: &#x27;person5&#x27; &#125;)</span><br><span class="line">import &#123; reactive,watch &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">//数据</span><br><span class="line">let person = reactive(&#123;</span><br><span class="line">    name: &#x27;youxianyu&#x27;,</span><br><span class="line">    age: 19,</span><br><span class="line">    car: &#123;</span><br><span class="line">        c1:&#x27;奔驰&#x27;,</span><br><span class="line">        c2:&#x27;宝马&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//方法</span><br><span class="line">function changeName() &#123;</span><br><span class="line">    person.name+=&#x27;~&#x27;</span><br><span class="line">&#125;</span><br><span class="line">function changeage() &#123;</span><br><span class="line">    person.age+=1</span><br><span class="line">&#125;</span><br><span class="line">function changec1() &#123;</span><br><span class="line">    person.car.c1=&#x27;奥迪&#x27;</span><br><span class="line">&#125;</span><br><span class="line">function changec2() &#123;</span><br><span class="line">    person.car.c2=&#x27;大众&#x27;</span><br><span class="line">&#125;</span><br><span class="line">function changeCar() &#123;</span><br><span class="line">    person.car=&#123;</span><br><span class="line">        c1:&#x27;雅迪&#x27;,c2:&#x27;爱玛&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">watch(() =&gt; person.name, (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    console.log(newValue, oldValue)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>总结：监视的要是对象里的属性，那么最好写函数式，注意点：若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。</p><br><p>5.监视上述的多个数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([()=&gt;person.name,()=&gt;person.car.c1],(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(newValue,oldValue)</span><br><span class="line">&#125;,&#123;deep:ture&#125;)</span><br></pre></td></tr></table></figure><h3 id="watchRffect"><a href="#watchRffect" class="headerlink" title="watchRffect"></a>watchRffect</h3><p>立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。</p><p>watch对比watchEffect<br>1.都能监听响应式数据的变化，不同的是监听数据变化的方式不同<br>2.watch：要明确指出监视的数据<br>3.watchEffect：不同明确指出监视的数据（函数中用到哪写属性，那就监视哪些属性）</p><p>需求：当水温到达60°，或水位到达80cm时，该服务器发请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(()=&gt;&#123;</span><br><span class="line">    if(temp.value&gt;=60||height.value&gt;=80)&#123;</span><br><span class="line">        console.log(&#x27;给服务器发请求&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="标签的ref属性"><a href="#标签的ref属性" class="headerlink" title="标签的ref属性"></a>标签的ref属性</h3><p>作用：用于注册模板引用<br>用在普通DOM标签上，获取的是DOM节点。<br>用在组件标签上，获取的是组件实例对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 ref=&quot;title&quot;&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h3 id="props的使用"><a href="#props的使用" class="headerlink" title="props的使用"></a>props的使用</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">PersonInter</span>&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个自定义类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> person=<span class="title class_">Array</span>&lt;<span class="title class_">PersonInter</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    &lt;Preson5 a=&quot;aha&quot; :list=&quot;personList&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    import &#123; reactive &#125; from &#x27;vue&#x27;;</span><br><span class="line">    import &#123; type person &#125; from &#x27;./types&#x27;;</span><br><span class="line"></span><br><span class="line">    let personList = reactive&lt;person&gt;([</span><br><span class="line">    &#123; id: &#x27;shgslfs&#x27;, name: &#x27;shkg&#x27;, age: 12 &#125;,</span><br><span class="line">    &#123; id: &#x27;shgslfs&#x27;, name: &#x27;shkg&#x27;, age: 12 &#125;,</span><br><span class="line">    &#123; id: &#x27;shgslfs&#x27;, name: &#x27;shkg&#x27;, age: 12 &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;li v-for=&quot;p in list&quot; :key=&quot;p.id&quot;&gt;&#123;&#123;p.name&#125;&#125;&#123;&#123;p.age&#125;&#125;&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import &#123;defineProps,withDeraults&#125; from &#x27;vue&#x27;</span><br><span class="line">import &#123;type Persons&#125; from &#x27;@/types&#x27;</span><br><span class="line"></span><br><span class="line">//接收</span><br><span class="line">definProps([&#x27;a&#x27;,&#x27;list&#x27;])</span><br><span class="line"></span><br><span class="line">//接收list+限制类型</span><br><span class="line">defineProps&lt;list:Persons&gt;()</span><br><span class="line"></span><br><span class="line">//接收list+限制类型+限制必要性+指定默认值</span><br><span class="line">withDeraults(defineProps&lt;&#123;list?:Persons&#125;&gt;()),&#123;</span><br><span class="line">    list:()=&gt;[&#123;id:&#x27;hgskfs&#x27;,name:&#x27;you&#x27;,age:19&#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript快速上手</title>
      <link href="/2025/04/10/JavaScript/TypeScript/"/>
      <url>/2025/04/10/JavaScript/TypeScript/</url>
      
        <content type="html"><![CDATA[<h1 id="tsc、TypeScript编译器"><a href="#tsc、TypeScript编译器" class="headerlink" title="tsc、TypeScript编译器"></a>tsc、TypeScript编译器</h1><p>在终端安装typescript:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br></pre></td></tr></table></figure><p>安装完成后可以使用<code>tsc</code>命令来执行typescript的相关代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc -v  //查看版本号</span><br></pre></td></tr></table></figure><p>在vscode新建一个index.ts,输入一下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: string</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: number</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: boolean</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">b = <span class="number">99</span></span><br><span class="line">c = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params">x: number, y: number</span>): number &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">count</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">srt1</span>: string </span><br><span class="line"></span><br><span class="line">srt1 = <span class="string">&#x27;youxianyu&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> srt1)</span><br></pre></td></tr></table></figure><p>直接使用浏览器是不认识的，需要用<code>tsc</code>命令转换为javascript代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsc --watch <span class="comment">//全局转换</span></span><br><span class="line">tsc --watch index.ts <span class="comment">//转换指定.ts</span></span><br></pre></td></tr></table></figure><p><img src="/img%5Cjs%5Cts.png"></p><p>转换后index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">let</span> b;</span><br><span class="line"><span class="keyword">let</span> c;</span><br><span class="line">a = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">b = <span class="number">99</span>;</span><br><span class="line">c = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">count</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"><span class="keyword">let</span> srt1;</span><br><span class="line">srt1 = <span class="string">&#x27;youxianyu&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> srt1);</span><br></pre></td></tr></table></figure><p>使用index.js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>成功<br><img src="/img%5Cjs%5Czk.png"></p><h1 id="常用类型"><a href="#常用类型" class="headerlink" title="常用类型"></a>常用类型</h1><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>any的含义量：任意类型，一旦将变量类型限制为any,那就意味着放弃了对该变量的类型检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">an</span>: <span class="built_in">any</span> <span class="comment">//显示</span></span><br><span class="line"></span><br><span class="line">an = <span class="number">91</span></span><br><span class="line">an = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">an = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">as</span>: <span class="built_in">any</span> <span class="comment">//隐式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">as</span> = <span class="number">92</span></span><br><span class="line"><span class="keyword">as</span> = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="keyword">as</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>注意：any类型的变量，可以赋值给任意类型的变量</p><h3 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h3><p>unknown的含义是：未知类型。</p><p>1.unknown可以理解为一个类型安全any,适用于：不确定数据的具体类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">un</span>: <span class="built_in">unknown</span></span><br><span class="line"></span><br><span class="line">un = <span class="number">99</span></span><br><span class="line">un = <span class="literal">false</span></span><br><span class="line">un = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">string</span></span><br><span class="line">x = un  <span class="comment">//不能将类型“unknown”分配给类型“string”</span></span><br><span class="line"><span class="comment">//但可以进行类型检查</span></span><br></pre></td></tr></table></figure><p>2.unknown会强制开发者在使用之前进行类型检查，从而提供更强的类型安全性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">un</span>: <span class="built_in">unknown</span></span><br><span class="line"></span><br><span class="line">un = <span class="number">99</span></span><br><span class="line">un = <span class="literal">false</span></span><br><span class="line">un = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> un === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    x=un</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x = un <span class="keyword">as</span> <span class="built_in">string</span></span><br><span class="line">x=&lt;<span class="built_in">string</span>&gt;un</span><br></pre></td></tr></table></figure><p>3.读取any类型数据的任何属性都不会报错，而unknown正好与之相反。</p><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>never的含义是：任何值都不是，简而言之就是不能有值（什么都不行）<br>1.几乎不用never去直接限制变量，因为没有意义。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">never</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下对a的所有赋值都会有警告</span></span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">a=<span class="literal">true</span></span><br><span class="line">a=<span class="literal">undefined</span></span><br><span class="line">a=unll</span><br></pre></td></tr></table></figure><p>2.never一般是typescript主动推断出来的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">string</span></span><br><span class="line">a=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> a ==== <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toUpperCase</span>())</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.never也可用于限制函数的返回值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throwError</span>(<span class="params">str: <span class="built_in">string</span></span>): <span class="built_in">never</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;程序异常退出&#x27;</span>+str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>void通常用于函数返回值声明，含义【函数不返回任何值，调用者也不应该依赖其返回值进行任何操作】</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logMessage</span>(<span class="params">msg: <span class="built_in">string</span></span>): <span class="built_in">void</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">logMessage</span>(<span class="string">&#x27;youxianyu&#x27;</span>)</span><br></pre></td></tr></table></figure><p>注意：logMessage函数是没有显示返回值的，但会有一个隐式返回值，就是undefined；记：undefined是viod可以接受的一种“空”。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logMessage</span>(<span class="params">msg: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logMessage1</span>(<span class="params">msg: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logMessage2</span>(<span class="params">msg: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：若函数返回值类型为void,那么：<br>1.从语法上讲：函数是可以返回undefined的，至于显示返回，还是隐式返回，这都无所谓！<br>2.从语义上讲：函数调用者不应关心函数返回的值，也不应依赖返回值进行任何操作及时返回了undefined值。</p><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">o</span>: <span class="built_in">object</span> <span class="comment">//a能存储的类型是【非原始类型】</span></span><br><span class="line"></span><br><span class="line">o = &#123;&#125;</span><br><span class="line">o = &#123; <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span> &#125;</span><br><span class="line">o = [<span class="number">1</span>, <span class="number">35</span>, <span class="number">453</span>, <span class="number">23</span>, <span class="number">3</span>]</span><br><span class="line">o = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line">o = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; &#125;</span><br><span class="line">o = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下代码，是将【原始类型】赋给a,有警告</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">a = ture</span><br><span class="line">a = <span class="string">&#x27;you&#x27;</span></span><br><span class="line">a = <span class="literal">null</span></span><br><span class="line">a=<span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>Object除了undefined和null的任何值。</p><h3 id="声明对象类型"><a href="#声明对象类型" class="headerlink" title="声明对象类型"></a>声明对象类型</h3><p>1.实际开发中，限制一般对象，通常使用以下形式。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person1: &#123; name: <span class="built_in">string</span>, age?: number &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person3: &#123; name: <span class="built_in">string</span>; age?: number &#125;</span><br><span class="line"><span class="keyword">let</span> person2: &#123;</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    age?: number</span><br><span class="line">&#125;</span><br><span class="line">person1=&#123;name:<span class="string">&#x27;tom&#x27;</span>,age:<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure><p>2.索引签名：允许定义对象可以具有任意数量的属性，这些属性的键和类型是可变的，常用于：描述类型不确定的属性。（具有动态属性的对象）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person:&#123;</span><br><span class="line">    name:<span class="built_in">string</span></span><br><span class="line">    age?:number</span><br><span class="line">    [<span class="meta">key:string</span>]: any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person=&#123;</span><br><span class="line">    name:<span class="string">&#x27;youxianyu&#x27;</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    gender:<span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明函数类型"><a href="#声明函数类型" class="headerlink" title="声明函数类型"></a>声明函数类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">count</span>:<span class="function">(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>)=&gt;</span> <span class="built_in">number</span></span><br><span class="line">count = <span class="keyword">function</span>(<span class="params">x,y</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript中的&#x3D;&gt;在函数类型声明表示函数类型，描述其参数类型和返回值类型。<br>JavaScript中的&#x3D;&gt;是一种定义函数的语法，是具体的函数实现。<br>函数类型声明还可以使用L:接口，自定义类型等方式。</p><h3 id="声明数组类型"><a href="#声明数组类型" class="headerlink" title="声明数组类型"></a>声明数组类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>:<span class="built_in">string</span>[]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>:<span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; <span class="comment">//泛型</span></span><br><span class="line"></span><br><span class="line">arr1=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">arr2=[<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元组（tuble）是一种特殊的数组类型，可以存储固定数量的元素，并且每个元素类型是已知的且可以不同，元组用于精确描述一组值的类型，？表示可选元素。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个元素必须是string类型，第二关元素是number类型。</span></span><br><span class="line"><span class="keyword">let</span> arr1=[<span class="built_in">string</span>,<span class="built_in">number</span>]</span><br><span class="line"><span class="comment">//第一个元素必须是number类型，第二个元素是可选的，如果存在，必须是boolean类型。</span></span><br><span class="line"><span class="keyword">let</span> arr2=[<span class="built_in">number</span>,<span class="built_in">boolean</span>?]</span><br><span class="line"><span class="comment">//第一个元素必须是number类型，后面的元素可以是任意数量的string类型。</span></span><br><span class="line"><span class="keyword">let</span> arr3=[<span class="built_in">number</span>,...<span class="built_in">string</span>[]]</span><br><span class="line"></span><br><span class="line">arr1=[<span class="string">&#x27;hello&#x27;</span>,<span class="number">123</span>]</span><br><span class="line">arr2=[<span class="number">100</span>,flase]</span><br><span class="line">arr2=[<span class="number">200</span>]</span><br><span class="line">arr3=[<span class="number">100</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>]</span><br><span class="line">arr3=[<span class="number">100</span>]</span><br><span class="line"></span><br><span class="line">arr1=[<span class="string">&#x27;hello&#x27;</span>,<span class="number">123</span>,<span class="literal">false</span>]</span><br></pre></td></tr></table></figure><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>枚举（enum）可以定义一组命名常量，他能增强代码的可读性，也让代码更好维护。</p><p>如下代码的功能是：根据调用walk时传入的不同参数，执行不同的逻辑，存在的问题是调用walk时传参时没有任何提示，编码者很容易写错字符串内容；并且用于判断逻辑的up、down、left、right是连续且相关的一组值，那此时就特别适合使用枚举（enum）。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">walk</span>(<span class="params">str: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&#x27;up&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str === <span class="string">&#x27;down&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sk&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str === <span class="string">&#x27;left&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;kn&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str === <span class="string">&#x27;right&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;kn&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">walk</span>(<span class="string">&#x27;up&#x27;</span>)</span><br><span class="line"><span class="title function_">walk</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line"><span class="title function_">walk</span>(<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"><span class="title function_">walk</span>(<span class="string">&#x27;right&#x27;</span>)</span><br></pre></td></tr></table></figure><p>1.数字枚举<br>数字枚举一种最常用的枚举类型，其成员的值会自动递增，且数字枚举还具备反向映射的特点，在下面代码的打印中，可以通过只来获取对应的枚举成员名称。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span>&#123;</span><br><span class="line">    up,</span><br><span class="line">    down,</span><br><span class="line">    left,</span><br><span class="line">    right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">walk</span>(<span class="params">str: Direction</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="title class_">Direction</span>.<span class="property">up</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str===<span class="title class_">Direction</span>.<span class="property">down</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sk&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> () &#123;str===<span class="title class_">Direction</span>.<span class="property">left</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;kn&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str === <span class="title class_">Direction</span>.<span class="property">right</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;kn&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">walk</span>(<span class="title class_">Direction</span>.<span class="property">down</span>)</span><br></pre></td></tr></table></figure><p>2.字符串枚举</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> pirection&#123;</span><br><span class="line">    up=<span class="string">&#x27;up&#x27;</span>,</span><br><span class="line">    down=<span class="string">&#x27;down&#x27;</span>,</span><br><span class="line">    left=<span class="string">&#x27;left&#x27;</span>,</span><br><span class="line">    right=<span class="string">&#x27;right&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">dir</span>:<span class="title class_">Direction</span>=<span class="title class_">Direction</span>.<span class="property">up</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dir)</span><br></pre></td></tr></table></figure><p>3.常量枚举</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Directions</span>&#123;</span><br><span class="line">    up,</span><br><span class="line">    down,</span><br><span class="line">    left,</span><br><span class="line">    right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x=<span class="title class_">Directions</span>.<span class="property">up</span>; </span><br></pre></td></tr></table></figure><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type可以为任意类型创建别名，让代码更简洁、可读性更强，同时能更方便地进行类型复用和扩展。<br>1.基本用法<br>类型别名使用type关键字，type后跟类型名称</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> num=<span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">price</span>:num</span><br><span class="line">price=<span class="number">100</span></span><br></pre></td></tr></table></figure><p>2.联合类型<br>联合类型是一种高级类型，他表示一个值可以是几种不同类型之一</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Status</span> = <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Gender</span> = <span class="string">&#x27;男&#x27;</span> | <span class="string">&#x27;女&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printstatus</span>(<span class="params"><span class="built_in">string</span> Status</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logGender</span>(<span class="params">str:Gender</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printstatus</span>(<span class="number">404</span>)</span><br><span class="line"><span class="title function_">printstatus</span>(<span class="string">&#x27;200&#x27;</span>)</span><br><span class="line"><span class="title function_">printstatus</span>(<span class="string">&#x27;501&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">logGender</span>(<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="title function_">logGender</span>(<span class="string">&#x27;女&#x27;</span>)</span><br></pre></td></tr></table></figure><p>3.交叉类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Area</span> = &#123;</span><br><span class="line">    <span class="attr">height</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">width</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Address</span> = &#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">cell</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">room</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">House</span> = <span class="title class_">Area</span> &amp; <span class="title class_">Address</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">house</span>: <span class="title class_">House</span> = &#123;</span><br><span class="line">    <span class="attr">height</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="number">120</span>,</span><br><span class="line">    <span class="attr">num</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">cell</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">room</span>: <span class="string">&#x27;702&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复习类相关知识"><a href="#复习类相关知识" class="headerlink" title="复习类相关知识"></a>复习类相关知识</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span> </span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫：<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,今年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;YOUXIANYU&#x27;</span>, <span class="number">19</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1)</span><br><span class="line">p1.<span class="title function_">speak</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>&#123;</span><br><span class="line">    <span class="attr">grade</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, grade: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name, age)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">grade</span>=grade</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">study</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我是学生：<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,今年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁<span class="subst">$&#123;<span class="variable language_">this</span>.grade&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;youxianyu&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;大一&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1)</span><br><span class="line">s1.<span class="title function_">study</span>()</span><br><span class="line">s1.<span class="title function_">study</span>()</span><br></pre></td></tr></table></figure><p>简写</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name:<span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一种无法被实例化的类，专门用来定义类的结构和行为，类中可以写抽象方法，也可以写具体实现。抽象类主要用来为其派生类提供一个基础结构，要求其派生类必须实现其中的抽象方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Package</span>&#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> weight: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">calculate</span>(): <span class="built_in">number</span></span><br><span class="line">    <span class="comment">//具体方法</span></span><br><span class="line">    <span class="title function_">printPackage</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.weight&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.calculate()&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StandardPackage</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Package</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">weight: <span class="built_in">number</span>, <span class="keyword">public</span> unitPrice: <span class="built_in">number</span></span>) &#123; <span class="variable language_">super</span>(weight) &#125;</span><br><span class="line">    <span class="title function_">calculate</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">weight</span>*<span class="variable language_">this</span>.<span class="property">unitPrice</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpressPackage</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Package</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">weight: <span class="built_in">number</span>, <span class="keyword">public</span> unitPrice: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">        <span class="keyword">public</span> additional: <span class="built_in">number</span></span></span><br><span class="line"><span class="params">    </span>) &#123; <span class="variable language_">super</span>(weight) &#125;</span><br><span class="line">    <span class="title function_">calculate</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">weight</span> &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>*<span class="variable language_">this</span>.<span class="property">unitPrice</span>+(<span class="variable language_">this</span>.<span class="property">weight</span>-<span class="number">10</span>)*<span class="variable language_">this</span>.<span class="property">additional</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">weight</span>*<span class="variable language_">this</span>.<span class="property">unitPrice</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">StandardPackage</span>(<span class="number">10</span>, <span class="number">50</span>)</span><br><span class="line">s2.<span class="title function_">printPackage</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s3 = <span class="keyword">new</span> <span class="title class_">ExpressPackage</span>(<span class="number">10</span>, <span class="number">30</span>, <span class="number">7</span>)</span><br><span class="line">s3.<span class="title function_">printPackage</span>()</span><br></pre></td></tr></table></figure><p>总结：何时使用抽象类<br>1.定义通用接口：为一组相关的类定义通用的行为（方法或属性）时。<br>2.提供基础实现：在抽象类中提供某些方法或为其提供基础实现，这样派生类就可以继承这些实现。<br>3.确保关键实现：强制派生实现一些关键行为。<br>4.共享代码和逻辑：当多个类需要共享部分代码时，抽象类可以避免代码重复。</p><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p>定义类结构</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonInterface</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="title function_">speak</span>(<span class="attr">n</span>:<span class="built_in">number</span>):<span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span> <span class="keyword">implements</span> <span class="title class_">PersonInterface</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">    <span class="title function_">speak</span>(<span class="attr">n</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>`</span>) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Person1</span>(<span class="string">&#x27;youxianyu&#x27;</span>, <span class="number">19</span>)</span><br><span class="line">p2.<span class="title function_">speak</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>定义对象结构</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserInterface</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">gender</span>: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">run</span>: <span class="function">(<span class="params">n: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">user</span>: <span class="title class_">UserInterface</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;you&#x27;</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">    <span class="title function_">run</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;n&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义函数接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CountInterface</span>&#123;</span><br><span class="line">    (<span class="attr">a</span>: <span class="built_in">number</span>,<span class="attr">b</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">count</span>: <span class="title class_">CountInterface</span>=<span class="function">(<span class="params">x,y</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> logData&lt;T&gt;(<span class="attr">data</span>: T) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logData&lt;<span class="built_in">number</span>&gt;(<span class="number">100</span>)</span><br><span class="line">logData&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;you&#x27;</span>)</span><br></pre></td></tr></table></figure><p>多个泛型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> logData&lt;T,U&gt;(<span class="attr">data1</span>: T,<span class="attr">data2</span>:U): T | U&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data1,data2)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Data</span>.<span class="title function_">now</span>() % <span class="number">2</span> ? <span class="attr">data1</span>:data2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logData&lt;<span class="built_in">number</span>,<span class="built_in">boolean</span>&gt;(<span class="number">100</span>,<span class="literal">true</span>)</span><br><span class="line">logData&lt;<span class="built_in">string</span>,<span class="built_in">number</span>&gt;(<span class="string">&#x27;you&#x27;</span>,<span class="number">666</span>)</span><br></pre></td></tr></table></figure><p>泛型接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonInterface</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">extraInfo</span>:T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">JobInfo</span> = &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">company</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">PersonInterface</span>&lt;<span class="title class_">JobInfo</span>&gt;=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;you&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">    <span class="attr">extraInfo</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;程序员&#x27;</span>,</span><br><span class="line">        <span class="attr">company</span>:<span class="string">&#x27;加油&#x27;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">        <span class="keyword">public</span> name: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">        <span class="keyword">public</span> age: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">        <span class="keyword">public</span> extraInfo: T</span></span><br><span class="line"><span class="params">    </span>) &#123; &#125;</span><br><span class="line">    <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span><span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">extraInfo</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">JobInfo</span> = &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">company</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>&lt;<span class="title class_">JobInfo</span>&gt;(<span class="string">&#x27;you&#x27;</span>, <span class="number">19</span>, &#123;<span class="attr">title</span>:<span class="string">&#x27;xian&#x27;</span>,<span class="attr">company</span>:<span class="string">&#x27;okoko&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Demo</span>(<span class="params">target: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(target)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Demo</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span>=age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用实例</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CustomString</span>(<span class="params">target: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    target.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CustomString</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span>=age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;you&#x27;</span>, <span class="number">19</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="title function_">toString</span>())</span><br></pre></td></tr></table></figure><h3 id="关于构造类型"><a href="#关于构造类型" class="headerlink" title="关于构造类型"></a>关于构造类型</h3><p>声明构造类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Constructor</span> = <span class="keyword">new</span> (...<span class="attr">args</span>:<span class="built_in">any</span>[])=&gt;&#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">fn:Constructor</span>)&#123;&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="title class_">Person</span>)</span><br></pre></td></tr></table></figure><p>声明构造类型+指定静态属性</p>]]></content>
      
      
      <categories>
          
          <category> TS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core开发Web API</title>
      <link href="/2025/04/08/asp.net%20core/ASP.NET%20Core%20Web%20API/"/>
      <url>/2025/04/08/asp.net%20core/ASP.NET%20Core%20Web%20API/</url>
      
        <content type="html"><![CDATA[<h1 id="Web-API项目的创建"><a href="#Web-API项目的创建" class="headerlink" title="Web API项目的创建"></a>Web API项目的创建</h1><p>在项目模板中选择【ASP.NET Core Web API】创建项目。</p><p><img src="/img%5CWEBAPI%5C1.png"></p><p>可以看到，ASP.NET Core Web API项目的结构和ASP.NET Core MVC项目的结构非常类似，不同的是ASP.NET Core Web API项目没有Views文件夹，因为Web API直接返回的是结构化的数据，不需要提供展示数据的视图。项目中生成的样板代码WeatherForecastController是一个控制器类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;[controller]&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherForecastController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span>[] Summaries = <span class="keyword">new</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Freezing&quot;</span>, <span class="string">&quot;Bracing&quot;</span>, <span class="string">&quot;Chilly&quot;</span>, <span class="string">&quot;Cool&quot;</span>, <span class="string">&quot;Mild&quot;</span>, <span class="string">&quot;Warm&quot;</span>, <span class="string">&quot;Balmy&quot;</span>, <span class="string">&quot;Hot&quot;</span>, <span class="string">&quot;Sweltering&quot;</span>, <span class="string">&quot;Scorching&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;WeatherForecastController&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherForecastController</span>(<span class="params">ILogger&lt;WeatherForecastController&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(Name = <span class="string">&quot;GetWeatherForecast&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;WeatherForecast&gt; <span class="title">Get</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>).Select(index =&gt; <span class="keyword">new</span> WeatherForecast</span><br><span class="line">        &#123;</span><br><span class="line">            Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),</span><br><span class="line">            TemperatureC = Random.Shared.Next(<span class="number">-20</span>, <span class="number">55</span>),</span><br><span class="line">            Summary = Summaries[Random.Shared.Next(Summaries.Length)]</span><br><span class="line">        &#125;)</span><br><span class="line">        .ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器类WeatherForecastController继承自ControllerBase类。我们注意到，ASP.NET Core MVC项目中控制器类继承自Controller类，Controller类是ControllerBase类的子类。Controller类中包含View等和MVC中的视图等相关的代码，因此我们在编写Web API的时候，控制器类一般不需要继承自Controller类。</p><p>Web API项目中的控制器类一般需要添加[ApiController]这个Attribute。[Route(“[controller]”)]这个Attribute是用来设置路由的对&#x2F;WeatherForecast路径的请求由WeatherForecast Controller来处理。</p><p>控制器的操作方法Get上添加[HttpGet]这个Attribute表示，当向&#x2F;WeatherForecast路径发送GET请求的时候，由Get方法进行处理。 由于操作方法是根据[HttpGet]这个Attribute与请求的谓词（也就是GET、POST、PUT等）进行匹配的，因此其操作方法的名字并不影响执行结果。总之，控制器类上添加的[Route(“[controller]”)]及Get方法上添加的[HttpGet]决定了客户端向&#x2F;WeatherForecast这个路径发送GET请求的时候，由Get方法进行处理。Get方法返回的对象会被自动进行JOSN序列化返回客户端。</p><p><img src="/img%5CWEBAPI%5C2.png"></p><h2 id="Post、Put等操作方法"><a href="#Post、Put等操作方法" class="headerlink" title="Post、Put等操作方法"></a>Post、Put等操作方法</h2><p>Web API会根据HTTP请求的谓词来匹配操作方法，因此我们可以为控制器类增加一个标注了[HttpPost]的操作方法，这个方法就可以处理Post请求了，这同样适用于[HttpPut]等。<br>比如我们为WeatherForecastController增加一个SaveNote方法，这个方法把用户提交的内容保存到文本文件中，方法的返回值为保持的文件名。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">saveNote</span>(<span class="params">SaveNoteRequest request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> filename = <span class="string">$&quot;<span class="subst">&#123;request.Title&#125;</span>.txt&quot;</span>;</span><br><span class="line">        System.IO.File.WriteAllTextAsync(filename, request.Content);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;Title: <span class="subst">&#123;request.Title&#125;</span>, Content: <span class="subst">&#123;request.Content&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>SaveNote方法有一个SaveNoteRequest类的参数，SaveNoteReauest类是一个包含Title（标题）、Content（内容）两个属性的类。<br>运行项目，可以看到浏览器中展示的Swagger页面中已经增加了可以处理POST请求的选项。</p><p><img src="/img%5CWEBAPI%5C3.png"></p><p>我们修改默认生产的请求报文体的内容，把title和content属性值修改为有实际意义的值。</p><h1 id="Restful-reptesentational-state-transfer-表现层状态转移"><a href="#Restful-reptesentational-state-transfer-表现层状态转移" class="headerlink" title="Restful(reptesentational state transfer,表现层状态转移)"></a>Restful(reptesentational state transfer,表现层状态转移)</h1><h2 id="什么是Restful"><a href="#什么是Restful" class="headerlink" title="什么是Restful"></a>什么是Restful</h2><p>Web API开发有两种风格：面向过程（简称RPC）、面向REST的（简称REST）。<br>在RPC风格的Web API中，我们通过“控制器&#x2F;操作方法”的形式来调用服务器端的方法，把服务器端的代码当成方法去调用。这种风格的接口可能会用POST请求处理所有的操作方法，无论是获取、新增、更新还是删除数据，这样的接口中，我们通过QueryString（查询字符串）或这请求报文体来为服务器传递数据。只要服务器端能够正常完成客户端请求的处理，服务器就会统一返回200的HTTP状态码。对于逻辑上的错误，返回的HTTP状态码也是200，只不过在响应报文体中通过不同的错误码来表示，比如“获取的用户不存在”的错误码为1，“没有权限获取这个用户”的错误码为2。</p><p>在RPC风格的接口中，当需要加载所有用户的时候，我们就向&#x2F;Persons&#x2F;GetAll这个路径发送GET请求；<br>加载id&#x3D;8,&#x2F;Persons&#x2F;GetById?id&#x3D;8<br>更新id&#x3D;8,&#x2F;Persons&#x2F;Update<br>新增用户，&#x2F;Persons&#x2F;AddNew<br>删除id&#x3D;8,&#x2F;Persons&#x2F;DeleteById&#x2F;8<br>并且把新用户信息以JSON格式放到请求报文体中；<br>由此可见，在RPC风格的系统中，URL中包含以名词形式描述的资源（比如Persons）和以动词形式描述的动作（比如AddNew）。</p><p>与之对应，在REST风格的Web API中，接口把服务器当成资源来处理。REST风格的接口按照HTTP设计之初的语义来使用HTTP，把系统中的所用内容都抽象为资源，所有对资源的操作都是无状态的且可以通过标准的HTTP谓词来进行。</p><p>在一个Restful风格的Web API系统中，每一个控制器都是对一类资源的操作的集合，每个操作方法都被不同的HTTP谓词触发。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PesonsController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;Person&gt; <span class="title">GetPersons</span>()</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;&#123;id&#125;&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">GetPerson</span>(<span class="params"><span class="built_in">long</span> id</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpPut(<span class="string">&quot;&#123;id&#125;&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdatePerson</span>(<span class="params"><span class="built_in">long</span> id,Person person</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SavePerson</span>(<span class="params">Person person</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpDelete(<span class="string">&quot;&#123;id&#125;&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeletePerson</span>(<span class="params"><span class="built_in">long</span> id</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Restful的优缺点"><a href="#Restful的优缺点" class="headerlink" title="Restful的优缺点"></a>Restful的优缺点</h2><p>REST的优点</p><p>1.通过URL对资源定位，语义更清晰；<br>2.通过HTTP谓语表示不同的操作，接口自描述；<br>3.可以对GET、PUT、DELETE请求进行重试；<br>4.可以用GET请求做缓存；<br>5.通过HTTP状态码反映服务器端的处理结果，同样错误处理机制。<br>6.网管等可以分析请求处理结果。</p><p>REST的缺点</p><p>1.真是系统中的资源非常复杂，很难清晰进行资源的划分，对技术人员的业务和技术水平要求高。<br>2.不是所有的操作多能简单地对应到确定的HTTP谓词中。<br>3.系统的进化可能会改变幂等性。<br>4.通过URL进行资源定位不符合中文用户的习惯。<br>5.HTTP状体码个数有限。<br>6.有些环节会篡改非200响应码的响应报文。<br>7.有的客户端不支持PUT、DELETE请求。</p><h2 id="Resuful中如何传递参数"><a href="#Resuful中如何传递参数" class="headerlink" title="Resuful中如何传递参数"></a>Resuful中如何传递参数</h2><p>HTTP传递参数的三种方式</p><p>URL：适合定位；长度限制。&#x2F;<br>QueryString：灵活；长度限制。<br>请求报文体：灵活；长度不限制；不支持GET、Delete。</p><p>不同语义<br>URL：资源定位。<br>QueryString：URL之外的额外数据。<br>请求报文体：供PUT、POST提供数据。</p>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core Web API各种技术及选择</title>
      <link href="/2025/04/08/asp.net%20core/ASP.NET%20Core%20Web%20API%E5%90%84%E7%A7%8D%E6%8A%80%E6%9C%AF%E9%80%89%E6%8B%A9/"/>
      <url>/2025/04/08/asp.net%20core/ASP.NET%20Core%20Web%20API%E5%90%84%E7%A7%8D%E6%8A%80%E6%9C%AF%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="控制器父类用哪个"><a href="#控制器父类用哪个" class="headerlink" title="控制器父类用哪个"></a>控制器父类用哪个</h1><p>控制器类都是继承自ControllerBase,而ASP.NET Core MVC项目中的控制器类默认继承自Controller。Controller类继承自ControllerBase,Controller类在ControllerBase的基础上增加了和视图相关的方法，而Web API的接口不涉及视图，因此除非读者需要在同一个控制器中同时提供Web API和MVC的功能，否则Web API的控制器类继承自ControllerBase即可。</p><h1 id="操作方法的异步、返回值、状态码"><a href="#操作方法的异步、返回值、状态码" class="headerlink" title="操作方法的异步、返回值、状态码"></a>操作方法的异步、返回值、状态码</h1><h3 id="ACTION方法的异步"><a href="#ACTION方法的异步" class="headerlink" title="ACTION方法的异步"></a>ACTION方法的异步</h3><p>1.Action方法既可以同步也可以异步。<br>2.异步Action方法的名字一般不需要以Async结尾。<br>3.Web API中Action方法的返回值如果是普通数据类型，那么返回值就会默认被序列化为Json格式。<br>4.Web API中的Action方法的返回值同样支持IActionResult类型，不包含类型信息，因此Swagger等无法推断出类型，所以推荐用ActionResult&lt;T&gt;,它支持类型转换，从而用起来更简单。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult&lt;<span class="built_in">string</span>&gt; <span class="title">GetXIAN</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;You are a good person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;You are a bad person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NotFound(<span class="string">&quot;Person not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Action方法参数"><a href="#Action方法参数" class="headerlink" title="Action方法参数"></a>Action方法参数</h3><p>我们再给服务器端传递参数的时候，有URL、QueryString、请求报文体3种方式。</p><p>1.在[HttpGet]、[HttpPost]等中使用占位符，比如{schoolName},捕捉路径中的内容，从而供Action方法的参数使用。加入请求的路径为&#x2F;Students&#x2F;GetAll&#x2F;school&#x2F;MIT&#x2F;class&#x2F;A001[HttpGet(“school&#x2F;{schoolName}&#x2F;class&#x2F;{classNo}”)]<br>2.捕捉的值会自动赋值给Action中同名的参数；如果名字不一致，可以用[FormRoute(Name&#x3D;”名字”)]</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="string">&quot;students/school/&#123;schoolName&#125;/class/&#123;classNo&#125;&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">GetStudent</span>(<span class="params"><span class="built_in">string</span> schoolName, [FromRoute(Name =<span class="string">&quot;classNo&quot;</span></span>)]<span class="built_in">int</span> classNum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person &#123; Id = classNum + <span class="number">6</span>, Name = schoolName + <span class="string">&quot;的扛把子&quot;</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="捕捉QUERYSTRING的值"><a href="#捕捉QUERYSTRING的值" class="headerlink" title="捕捉QUERYSTRING的值"></a>捕捉QUERYSTRING的值</h3><p>1.使用[FromQuery]来获取QueryString中的值。如果名字一致，只要为参数添加[FromQuery]即可；而如果名字不一致，[FromQuery(Name&#x3D;名字)]。<br>2.QueryString和Route可以混用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ActionResult&lt;Person[]&gt; GetAll([FromQuery] <span class="built_in">string</span> paueNum, [FromQuery(Name = <span class="string">&quot;pSize&quot;</span>)] <span class="built_in">int</span> pageSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person[] &#123; pageSize == <span class="number">0</span> ? <span class="keyword">new</span> Person &#123; Id = <span class="number">1</span>, Name = <span class="string">&quot;YOUXIANYU&quot;</span>, ChildenName = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span> &#125; &#125; : <span class="keyword">new</span> Person &#123; Id = <span class="number">2</span>, Name = <span class="string">&quot;YOUXIANYU&quot;</span>, ChildenName = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span> &#125; &#125; &#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="JSON报文体"><a href="#JSON报文体" class="headerlink" title="JSON报文体"></a>JSON报文体</h3><p>1.Web API的开发模式下，Json格式的请求提是主流。<br>2.只要声明一个模型类和Json请求的格式一致即可。<br>3.也是可以把从URL获取参数、从请求报文体获取数据等这些混合使用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost(<span class="string">&quot;classId/&#123;classId&#125;&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult&lt;<span class="built_in">long</span>&gt; <span class="title">AddNew</span>(<span class="params"><span class="built_in">long</span> classId,StudentModel s</span>)</span></span><br></pre></td></tr></table></figure><p>4.一定要设定请求头中的Content-Type为application&#x2F;json,而且数据必须是合法的json格式。</p><p>表单请求：从Content-Type为multipart&#x2F;form-data的请求中获取数据的[FromForm]</p><p>从请求报文头中获取值的[FromHeader]。</p><h2 id="ASP-NET-Core-Web-API前后端分离开发"><a href="#ASP-NET-Core-Web-API前后端分离开发" class="headerlink" title="ASP.NET Core Web API前后端分离开发"></a>ASP.NET Core Web API前后端分离开发</h2><h3 id="开发Web-API-后端接口"><a href="#开发Web-API-后端接口" class="headerlink" title="开发Web API 后端接口"></a>开发Web API 后端接口</h3><p>首先，我们新建一个ASP.NET Core Web 然后在项目中创建一个控制器类LoginController。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Route(<span class="string">&quot;api/[controller]/[action]&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoginValuesController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">HttpPost</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ActionResult&lt;LoginResponse&gt; <span class="title">Login</span>(<span class="params">LoginRequest req</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="function">req <span class="title">is</span> (<span class="params"><span class="string">&quot;YOUXIANYU&quot;</span>, <span class="string">&quot;123456&quot;</span></span>))</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> items = Process.GetProcesses()</span><br><span class="line">                    .Select(p =&gt; <span class="keyword">new</span> ProcessInfo(p.Id, p.ProcessName, p.WorkingSet64));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> LoginResponse(<span class="literal">true</span>, items.ToArray());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> LoginResponse(<span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Login方法用来判断请求的用户名、密码是否正确，如果正确的话，服务器端会把当前计算机上运行的所有进程信息返回给客户端，返回的信息包括进程ID、进程名（ProcessName）和内存占用（WorkingSet64）。</p><p>其中LoginResult、LoginRequest、ProcessInfo类的定义。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">LoginRequest</span>(<span class="params"><span class="built_in">string</span> UserName,<span class="built_in">string</span> Password</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">ProcessInfo</span>(<span class="params"><span class="built_in">long</span> Id,<span class="built_in">string</span> Name,<span class="built_in">long</span> WorkingSet</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">LoginResponse</span>(<span class="params"><span class="built_in">bool</span> OK,ProcessInfo[]? ProcessInfos</span>)</span>;</span><br></pre></td></tr></table></figure><p>LoginResult类的IsOK属性表示请求的用户名和密码是否正确，如果正确，服务器端的进程信息会被设置到Processes属性上：LoginRequest类代表请求的参数信息，其中的UserName代表用户名，Password代表密码：ProcessInfo类代表进程信息，其中的Id代表进程ID，ProccessName代表进程名，WorkingSet64代表为进程分配的物理内存量。<br>在Swagger页面上测试一下Login方法。如果我们通过请求报文体设置的用户名、密码错误的话，服务器端的响应如图。</p><p><img src="/img%5CWEBAPI%5C4.png"></p><p><img src="/img%5CWEBAPI%5C5.png"></p><h3 id="搭建前端"><a href="#搭建前端" class="headerlink" title="搭建前端"></a>搭建前端</h3><p>1.在src文件夹下创建views文件夹。<br>2.安装axios. npm i axios<br>3.在views文件夹下创建Login.vue文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; v-model=&quot;state.loginData.userName&quot;/&gt;</span><br><span class="line">    密码：&lt;input type=&quot;password&quot; v-model=&quot;state.loginData.password&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;登录&quot; @click=&quot;loginSubmit&quot;/&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li v-for=&quot;p in state.processes&quot; :key=&quot;p.id&quot;&gt;&#123;&#123;p.id&#125;&#125;&#123;&#123; p.processName&#125;&#125;&#123;&#123;p.workingSet64&#125;&#125;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line">import &#123; reactive, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;Login&#x27;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const state = reactive(&#123; loginData: &#123;&#125;, processes: [] &#125;);</span><br><span class="line">        const loginSubmit = async() =&gt; &#123;</span><br><span class="line">            const payload = state.loginData;</span><br><span class="line">            const resp = await axios.post(&#x27;https://localhost:7105/api/Login/Login&#x27;, payload);</span><br><span class="line">            const data = resp.data;</span><br><span class="line">            if (!data.isOK) &#123;</span><br><span class="line">                alert(&quot;登录失败&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            state.processes = data.processes;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;state,loginSubmit&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">    alert(state);</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>4.使用vue-router来做前端的页面路由。在前端的项目根目录执行：<br>npm run-router<br>5.在src下创建route文件夹，并且在route文件夹下创建index.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&quot;@/view/Login.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">redirect</span>: <span class="string">&quot;/Login&quot;</span></span><br><span class="line">&#125;, &#123; <span class="attr">path</span>: <span class="string">&quot;/Login&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;Login&quot;</span>, <span class="attr">coponent</span>: <span class="title class_">Login</span> &#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123; <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(), <span class="attr">routes</span>: routes &#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><p>6.编辑src&#x2F;main.js,增加import router from ‘.&#x2F;route’ 以及use(router),修改main.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./assets/main.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">use</span>(router).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>7.src&#x2F;App.vue中增加指定Login视图的链接以及显示路由视图的&lt;router-view&#x2F;&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">// import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;</span><br><span class="line">// import TheWelcome from &#x27;./components/TheWelcome.vue&#x27;</span><br><span class="line">import Login from &#x27;./view/Login.vue&#x27;;</span><br><span class="line">import &#123; RouterView,RouterLink&#125; from &#x27;vue-router&#x27;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;router-link to=&quot;/Login&quot;&gt;Login&lt;/router-link&gt;&lt;router-view/&gt;</span><br><span class="line">      &lt;login/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>1.跨域通讯的问题。解决方案：JSONP、前端代理后端请求、CORS等。<br>2.CORS原理：在服务器的响应报文头中通过access-control-allow-orign告诉浏览器允许跨域访问的域名。<br>3.在Program.cs的“var app&#x3D;builder.Build()”这句代码之前注册<br>4.在Program.cs的app.UserHttpsRedirection()这句代码之前增加一行app.UseCors()</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add services to the container.</span></span><br><span class="line"></span><br><span class="line">builder.Services.AddControllers();</span><br><span class="line"><span class="comment">// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle</span></span><br><span class="line">builder.Services.AddEndpointsApiExplorer();</span><br><span class="line">builder.Services.AddSwaggerGen();</span><br><span class="line">builder.Services.AddCors(opt =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    opt.AddDefaultPolicy(b =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        b.WithOrigins(<span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;http://localhost:5173&quot;</span> &#125;)</span><br><span class="line">            .AllowAnyMethod()</span><br><span class="line">            .AllowAnyHeader()</span><br><span class="line">            .AllowCredentials();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the HTTP request pipeline.</span></span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.UseSwagger();</span><br><span class="line">    app.UseSwaggerUI();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.UseCors();</span><br><span class="line">app.UseHttpsRedirection();</span><br><span class="line"></span><br><span class="line">app.UseAuthorization();</span><br><span class="line"></span><br><span class="line">app.MapControllers();</span><br><span class="line"></span><br><span class="line">app.Run();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core MVC入门</title>
      <link href="/2025/04/07/asp.net%20core/ASP.NET%20Core%20MVC%E5%85%A5%E9%97%A8/"/>
      <url>/2025/04/07/asp.net%20core/ASP.NET%20Core%20MVC%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ASP-NET-Core-MVC介绍"><a href="#ASP-NET-Core-MVC介绍" class="headerlink" title="ASP.NET Core MVC介绍"></a>ASP.NET Core MVC介绍</h1><p>Wbe应用是.NET Core开发中常见的项目类型，无论是网站还是HTTP服务接口，都有提供对外Web访问的能力，而.NET Core中进行Web应用开发的核心底层技术是ASP.NET Core。<br>在ASP.NET Core这个底层基础上，微软开发了ASP.NET Core和ASP.NET Core API这两个框架。随着软件项目复杂度的增加及软件项目分工的细化，前后端分离已经成为主流开发模式，后端开发人员使用ASP.NET Core Web API开发服务接口，界面交互等有前端开发人员使用Vue等前端框架来完成。在ASP.NET Core MVC这种开发模式下，后端开发人员也仍然要编写一部分前端的代码，而在前后端分离的开发模式下，后端开发人员不在需要处理任何界面逻辑，而只是需要编写ASP.NET Core Web API。</p><h2 id="编写第一个MVC程序"><a href="#编写第一个MVC程序" class="headerlink" title="编写第一个MVC程序"></a>编写第一个MVC程序</h2><p>ASP.NET Core MVC采用MVC模式，也就是把页面交互的代码分为模型（model）、视图（view）和控制器（controller）3个部分。视图负责内容的展现，也就用来显示HTML网页；控制器负责处理用户的请求及为视图准备数据；模型负责在视图和控制器之间传递数据。</p><p><img src="/img%5CHello%5CMVC.png"></p><p>在MVC模式中，试听和控制器不直接交换、不互相依赖，彼此之间通过模型进行数据传输。使用MVC模式的优点是视图和控制器降低了耦合，系统的结构更清晰。</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>1.控制器由Controller类实现，试图一般是扩展名为cshtml的文件，而模型则是只有属性的普通C#类。</p><p>2.控制器类的名字一般以Controller结尾，并且被放在Controller文件夹下。控制器的名字微控制器的类名去掉Controller。</p><p>3.视图一般被放到Views文件夹下的控制器名字的文件夹下。</p><p>4.视图-&gt;浏览器全提交的请求-&gt;模型-&gt;控制器-&gt;处理-&gt;模型-&gt;视图。渲染：Render。</p><p>下面演示一个在控制器中查询数据，然后把数据传递给视图进行渲染的案例。</p><p>第一步，在Models文件夹下创建一个Preson类，这个类包含代表姓名的Name属性，代表是否为VIP的IsVIP属性，以及代表创建日期的CreatedTime属性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> Name,<span class="built_in">bool</span> IsVIP,DateTime CreatedDateTime</span>)</span>;</span><br></pre></td></tr></table></figure><p>第二步，在Controllers文件夹下创建一个继承自Controller类的TestController类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Demo1</span>() <span class="comment">//Action 方法：操作方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//return View();</span></span><br><span class="line">        Person p1=<span class="keyword">new</span> Person(<span class="string">&quot;YOUXIANYU&quot;</span>, <span class="literal">true</span>, DateTime.Now);</span><br><span class="line">        <span class="keyword">return</span> View(p1);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器中方法的返回值一般是IActionResult类型的，控制器类中被外界直接访问的方法叫作“操作方法”。</p><p>Demo1方法中，我们创建了Person类的对象，并且为了对象的属性赋予了初始值，最后通过return View（mode1）方法告诉框架“请把mode1这个对象传递给与操作方法同名的视图”，因此狂就会把mode1对象传递给名为Demo1.cshtml的视图文件。</p><p>第三步，在Views文件下创建和TestController名称对应的Test文件夹，然后在Test文件夹上右击，选择添加Razor视图-空这个项目模板，文件名填写Demo1.cshtml文件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@model WebApplication1.Models.Person</span><br><span class="line">&lt;div&gt;姓名：@Model.Name&lt;/div&gt;</span><br><span class="line">&lt;div&gt;是否VIP:@Model.IsVIP&lt;/div&gt;</span><br><span class="line">&lt;div&gt;@Model.CreatedDateTime&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="/img%5CHello%5Clj.png"></p><h3 id="热重载"><a href="#热重载" class="headerlink" title="热重载"></a>热重载</h3><p>在以调试模式运行ASP.NET Core项目的时候，如果我们修改了服务器端的代码，必须终止并重新运行程序，修改后的代码才能生效。再比较复杂的项目中，这样的开发流程非常麻烦，因为我们需要重新打开浏览器、重新执行要测试请求。</p><p>可以用【启动（不调试）】方法运行项目，然后再修改代码后，重新生成解决方案，这样代码就生效了，不需要重启浏览器。不过在这种方式下运行程序，我们无法进行设置断点、查看变量的值等调试操作。</p><p>而.NET6开始，.NET中增加了热重载功能，它允许我们在以调试方式运行程序的时候，也无须重启程序而让修改的代码生效。它的用法很简单，只要在修改完代码以后单击Visual Studio工具栏中的热重载。</p><p>我们也可以单击热重载的下拉列表，勾选【文件保存时热重载】，这样当我们修改完代码并保存文件后，Visual Studio会自动执行热重载，开发就更方便。</p>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EF Core表达式树</title>
      <link href="/2025/04/05/asp.net%20core/EFCore%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/"/>
      <url>/2025/04/05/asp.net%20core/EFCore%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a>表达式树</h1><h2 id="什么是表达式树"><a href="#什么是表达式树" class="headerlink" title="什么是表达式树"></a>什么是表达式树</h2><p>表达式树（expression tree）是用树形数据结构来表示代码逻辑运算的技术，他让我们可以在运行时访问逻辑运算的结构。表达式树在.NET中对应Expression&lt;TDelegate&gt;类型。我们既可以让C#编译器帮我们从Lambda表达式生成表达式树，也可以在运行时通过API动态创建表达式树。</p><p>Lambda表达式生成表达式树。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expression&lt;Func&lt;House, <span class="built_in">bool</span>&gt;&gt; expression = h =&gt; h.Price &gt; <span class="number">5</span>;</span><br><span class="line">Expression&lt;Func&lt;House, House,<span class="built_in">double</span>&gt;&gt;h2 = h2=(b1,b2)=&gt;b1.Price + b2.Price;</span><br></pre></td></tr></table></figure><p>编译器会把&#x3D;&gt;b.Price&gt;5这个表达式构建成Expression对象（表达式树对象），然后我们就可以使用这个表达式树对象进行数据查询了。</p><h2 id="Expression和委托的关系"><a href="#Expression和委托的关系" class="headerlink" title="Expression和委托的关系"></a>Expression和委托的关系</h2><p>把Expression&lt;Func&lt;House,bool&gt;&gt;换成Func&lt;House,bool&gt;,写成下面的版本：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;House,<span class="built_in">bool</span>&gt; func = h =&gt; h.Price &gt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">db.Houses.Where(func).ToList();</span><br></pre></td></tr></table></figure><p>查看SQL语句</p><p>Expression<br><img src="/img%5CHello%5Cai.png"></p><p>Func<br><img src="/img%5CHello%5Cai.png"></p><p>我们发现查询Func生成的SQL语句没有b.Price&gt;5这个逻辑的，说明这个版本是通过客户端评估完成的。因此，为了能够正常地使用EF Core,我们一定要使用Expression&lt;TDelegate&gt;类型。</p><p>Expression对象存储了运算逻辑，他把运算逻辑保存成抽象语法树（AST），可以在运行时动态获取运算逻辑。而普通委托没有。</p><p>太难了，以后再学</p>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EF Core并发控制</title>
      <link href="/2025/04/04/asp.net%20core/EF%20Core%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%88%A9%E5%99%A8/"/>
      <url>/2025/04/04/asp.net%20core/EF%20Core%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%88%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="EF-Core优化之AsNoTracking"><a href="#EF-Core优化之AsNoTracking" class="headerlink" title="EF Core优化之AsNoTracking"></a>EF Core优化之AsNoTracking</h1><p>EF Core默认会对通过上下文查询出来的所有实体类进行跟踪，以便于在执行SaveChanges的时候把实体类的改变同步到数据库中。上下文不仅会跟踪对象的状态改变，还会通过快照的方式记录实体类的原始值，这是比较消耗资源的。<br>因此，如果开发人员能够确认通过上下文查询出来的对象只是用来展示，不会发生状态改变，那么可以使用AsNoTracking方法告诉IQueryable在查询的时候“禁用跟踪”。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Blog[] blogs = ctx.Blogs.AsNoTracking().Take(<span class="number">3</span>).ToArray();</span><br><span class="line">Blog b1 = blogs[<span class="number">0</span>];</span><br><span class="line">b1.Id = <span class="number">100</span>;</span><br><span class="line">EntityEntry entry1=ctx.Entry(b1);</span><br><span class="line">Console.WriteLine(entry1.State);</span><br></pre></td></tr></table></figure><p>上面代码的执行结果是“Detached”,也就说使用AsNoTracking查询出来的实体类是不被上下文跟踪的。<br>因此，在项目开发中，如果我们查询出来的对象不会被修改、删除等，那么在查询的时候，可以启用AsNoTracking，这样就能降低EF Core的资源占用。</p><h1 id="EF-Core中批量删除和更新数据"><a href="#EF-Core中批量删除和更新数据" class="headerlink" title="EF Core中批量删除和更新数据"></a>EF Core中批量删除和更新数据</h1><p>删除 Age 大于 10 的数据</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">using</span> <span class="keyword">var</span> db = <span class="keyword">new</span> MyDbContext();</span><br><span class="line"><span class="keyword">await</span> db.MyEntities.Where(<span class="keyword">static</span> x =&gt; x.Age &gt; <span class="number">10</span>).ExecuteDeleteAsync();</span><br></pre></td></tr></table></figure><p>所有员工的工资增加 1000</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> context.Employees.ExecuteUpdateAsync</span><br><span class="line">(s =&gt; s.SetProperty(e =&gt; e.Salary, e =&gt; e.Salary + <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><h1 id="全局查询筛选器"><a href="#全局查询筛选器" class="headerlink" title="全局查询筛选器"></a>全局查询筛选器</h1><p>EF Core支持在配置实体类的时候，为实体类设置全局查询筛选器，EF Core会自动将全局查询筛选器应用于涉及这个实体类型的所有LINQ查询。这个功能常见的应用场景有“软删除”和“多租户”。</p><p>我们可以给对应实体类设置一个全局筛选器，这样所有的查询都会自动增加全局查询筛器，被软删除的数据就会自动从查询结果中过滤掉。</p><p>首先，我们给实体类增加一个bool类型的属性IsDeleted,如果对应的数据被标记为已删除，那么IsDeleted的值就会true，否则就是false。<br>在实体类的Fluent API中增加一句代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;().ToTable(<span class="string">&quot;Blog&quot;</span>)</span><br><span class="line">        .HasQueryFilter(b =&gt; b.IsDeleted == <span class="literal">false</span>)<span class="comment">//全局筛选器</span></span><br><span class="line">        .HasMany(b =&gt; b.Posts)</span><br><span class="line">        .WithOne(p =&gt; p.Blog)</span><br><span class="line">        .HasForeignKey(p =&gt; p.BlogId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="悲观并发控制"><a href="#悲观并发控制" class="headerlink" title="悲观并发控制"></a>悲观并发控制</h1><p>EF Core没有封装悲观并发控制的使用，需要开发人员编写原生SQL语句来使用悲观并发控制。不同数据库的语法不一样。<br>MySQL</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;请输入您的姓名&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> name = Console.ReadLine();</span><br><span class="line"><span class="keyword">using</span> MyDbContext ctx = <span class="keyword">new</span> MyDbContext();</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> tx = <span class="keyword">await</span> ctx.Database.BeginTransactionAsync();<span class="comment">//事务</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;准备Select &quot;</span> + DateTime.Now.TimeOfDay);</span><br><span class="line"><span class="keyword">var</span> h1 = <span class="keyword">await</span> ctx.Houses.FromSqlInterpolated(<span class="string">$&quot;select * from T_Houses where Id=1 for update&quot;</span>)</span><br><span class="line">.SingleAsync();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;完成Select &quot;</span> + DateTime.Now.TimeOfDay);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(h1.Owner))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">5000</span>);</span><br><span class="line">h1.Owner = name;</span><br><span class="line"><span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;抢到手了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (h1.Owner == name)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;这个房子已经是你的了，不用抢&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;这个房子已经被<span class="subst">&#123;h1.Owner&#125;</span>抢走了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">await</span> tx.CommitAsync();</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure><h1 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h1><p>两种方案：并发令牌、RowVersion<br>如果有一个确定的字段要被进行并发控制，那么使用IsConcurrencyToken()把这个字段设置为并发令牌即可；<br>如果无法确定一个唯一的并发令牌列，那么就可以引入一个额外的属性设置为并发令牌，并且在每次更新数据的时候，手动更新这一列的值。如果用的是SQLServer数据库，那么也可以采用RowVersion列，这样就不用开发者手动来在每次更新数据的时候，手动更新并发令牌的值了。</p><p>乐观并发控制的原理</p><blockquote><p>Update T_Houses set Owner&#x3D;新值<br>where Id&#x3D;i and Owner&#x3D;旧值</p></blockquote><p>举例子：当Update的时候，如果数据库中的Owner值已经被其他操作者更新为其他值了，那么where语句的值就会为false,因此这个Update语句影响的行数就是0，EF Core就知道“发生并发冲突”了，因此SaveChanges()方法就会抛出DbUpateConcurrencyException异常。</p><p>1.把被并发修改的属性使用IsConcurrencyToken()设置为并发令牌。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;().ToTable(<span class="string">&quot;Blog&quot;</span>)</span><br><span class="line">    .Property(e =&gt; e.Owner).IsConcurrencyToken();</span><br></pre></td></tr></table></figure><p>MySQL</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;请输入您的姓名&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> name = Console.ReadLine();</span><br><span class="line"><span class="keyword">using</span> MyDbConfigText ctx = <span class="keyword">new</span> MyDbConfigText() ;</span><br><span class="line"><span class="keyword">var</span> h1 = <span class="keyword">await</span> ctx.Blogs.SingleAsync(h =&gt; h.Id == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(h1.Owner))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">5000</span>);</span><br><span class="line">    h1.Owner = name;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;抢到手了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (DbUpdateConcurrencyException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> entry = ex.Entries.First();</span><br><span class="line">        <span class="keyword">var</span> dbValues = <span class="keyword">await</span> entry.GetDatabaseValuesAsync();</span><br><span class="line">        <span class="built_in">string</span> newOwner = dbValues.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="keyword">nameof</span>(Blog.Owner));</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;并发冲突，被<span class="subst">&#123;newOwner&#125;</span>提前抢走了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (h1.Owner == name)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;这个房子已经是你的了，不用抢&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;这个房子已经被<span class="subst">&#123;h1.Owner&#125;</span>抢走了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure><h3 id="SQLServer的ROWVERSION"><a href="#SQLServer的ROWVERSION" class="headerlink" title="SQLServer的ROWVERSION"></a>SQLServer的ROWVERSION</h3><p>SQLServer数据库可以用一个byte[]类型的属性做并发令牌属性，然后使用IsRowVersion()把这个属性设置为RowVersion类型，这样这个属性对应的数据库列就会被设置为ROWVERSION类型。对于ROWVERSION类型的列，在每次插入或更新行时，数据库会自动为这一行的ROWVERSION类型的列其生成新值。<br>在SQLServer中，timestamp和rowversion是同一种类型的不同别名而已。</p><p>我们先定义一个byte[]类型属性的House类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">House</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Owner &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] RowVer &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对House实体类进行配置，对RowVer属性设置IsRowVersion。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;House&gt; builder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    builder.ToTable(<span class="string">&quot;T_Houses&quot;</span>);</span><br><span class="line">    builder.Property(h =&gt; h.Name).IsRequired();</span><br><span class="line">    <span class="comment">//builder.Property(h=&gt;h.Owner).IsConcurrencyToken();</span></span><br><span class="line">    builder.Property(h =&gt; h.RowVer).IsRowVersion();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EF Core原理揭秘</title>
      <link href="/2025/04/03/asp.net%20core/EF%20Core%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
      <url>/2025/04/03/asp.net%20core/EF%20Core%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="EF-Core原理揭秘"><a href="#EF-Core原理揭秘" class="headerlink" title="EF Core原理揭秘"></a>EF Core原理揭秘</h1><h2 id="既生IEnumerable-何生IQueryable"><a href="#既生IEnumerable-何生IQueryable" class="headerlink" title="既生IEnumerable,何生IQueryable"></a>既生IEnumerable,何生IQueryable</h2><p>可以使用LINQ中的Where等方法对普通集合进行处理。比如下面的C#代码可以把int数组中大于10的数据取出来。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums=&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">933</span>,<span class="number">2</span>,<span class="number">69</span>,<span class="number">69</span>,<span class="number">11</span>&#125;;</span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; items=nums.Where(n=&gt;n&gt;<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>Where方法中，转到定义下，可以看到，这里调用的Where方法是Enumerable类中的扩展方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">IEnumerable</span>&lt;<span class="title">TSource</span>&gt; <span class="title">Where</span>&lt;<span class="title">TSource</span>&gt;(<span class="params"><span class="keyword">this</span> IEnumerable&lt;TSource&gt; source,Func&lt;TSoure,<span class="built_in">bool</span>&gt; predicate</span>)</span>;</span><br></pre></td></tr></table></figure><p>也可以在EF Core的DbSet类型上调用Where之类的方法进行数据的筛选。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IQueryable&lt;Book&gt; books=ctx.Books.Where(b=&gt;b.Price&gt;<span class="number">1.1</span>);</span><br></pre></td></tr></table></figure><p>查看这里调用的Where方法的声明，我们会发现它是定义在Queryble类中的扩展方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">IQueryable</span>&lt;<span class="title">TSource</span>&gt; <span class="title">Where</span>&lt;<span class="title">TSource</span>&gt;(<span class="params"><span class="keyword">this</span> IQueryable&lt;TSource&gt; source,EXpression&lt;Func&lt;TSource,<span class="built_in">bool</span>&gt;&gt; predicate</span>)</span>;</span><br></pre></td></tr></table></figure><p>这个Where方法是一个IQueryable&lt;TSource&gt;类型的扩展方法，返回值是IQueryable<TSource>类型。IQueryable其实就是一个继承了IEnumerable接口的接口。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IQuryable</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;:<span class="title">IEnumerable</span>&lt;<span class="title">T</span>&gt;,<span class="title">IEnumerable</span>,<span class="title">IQueryable</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>IQuryable接口就是继承自IEnumerable接口的；IQueryable类中的Where方法除了参数和返回值的类型是IQueryable,其他用法和I&#x2F;Enumerable类型的Where方法没有什么不同。<br>Where方法会在内存中对每条数据进行过滤，而EF Core如果也把全部数据都在内存中进行过滤，如果数据量非常大，就会有性能问题。因此EF Core中的Where实现必须有一套“把Where条件转换为SQL语句”的机制，让数据的筛选在数据库服务器上执行。<br>Enumerable类中定义的供普通集合用的Where等方法都是“客户端评估”，因此微软创造了IQueryable类型，并且在Queryable等类中定义了和Enumerable类中类似的Where等方法。Queryable中定义的Where方法支持把LINQ查询转化为SQL语句。我们尽量调用IQueryable版本的方法。</p><h2 id="IQueryable的延迟执行"><a href="#IQueryable的延迟执行" class="headerlink" title="IQueryable的延迟执行"></a>IQueryable的延迟执行</h2><p> IQueryable不仅可以带来“服务器段评估”这个功能，而且提供了延迟执行的功能。</p><p> 没有遍历的查询<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IQueryable&lt;Article&gt; articles = ctx.Articles.Include(a =&gt; a.Comments);</span><br><span class="line">Console.WriteLine(articles);</span><br></pre></td></tr></table></figure><br>从日志结果输出可以看出，上面的代码竟然没有执行SQL语句，而我们明明执行了Where方法进行数据的过滤查询。</p><p>遍历查询</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;1.Where之前&quot;</span>);</span><br><span class="line">IQueryable&lt;Article&gt; articles1 = ctx.Articles.Where(b =&gt; b.Id &gt; <span class="number">2</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;2.遍历Where之前&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> articles1)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(b.Title+<span class="string">&quot;:&quot;</span>+b.Id);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;3.遍历Where之后&quot;</span>);</span><br></pre></td></tr></table></figure><p>仔细观察上面的程序的日志输出结果的SQL语句、“2.遍历Where之前”和“3.遍历Where之后”的输出顺序。按照C#中的代码，Where调用的代码在“2.遍历Where之前”的前面执行，但是在执行结果中，SQL语句反而在“2.遍历Where之前”的后面执行，这是为什么？<br>IQueryable只是代表“可以放到数据库服务器中执行的查询”，他没有立即执行，只是“可以被执行”而已。其实可以从IQueryable类型的英文含义看出来，“IQueryable”的意思是“可查询的”，可以查询，但是没有执行查询，查询的执行被延迟了。</p><p>那么IQueryable什么时候才会执行查询呢？一个原则就是：对于IQueryable接口，调用“非立即执行”方法的时候不会执行查询，而调用“立即查询”方法的时候则会立即执行查询。判断一个方法是否是立即执行方法的简单方式是：一个方法的返回值类型如果是IQueryable类型，这个方法一般就是非立即执行查询方法，否则这个方法就是立即执行方法。</p><h3 id="分布构建IQueryable"><a href="#分布构建IQueryable" class="headerlink" title="分布构建IQueryable"></a>分布构建IQueryable</h3><p>EF Core为什么要实现“IQueryable延迟执行”这样复杂的机制呢？因为我们可以先使用IQueryable拼接出复杂的查询条件，再去执行查询。<br>比如：定义一个方法根据给定的关键字srarchWords查询匹配的书；如果searchAll参数是true，则书名或者作者名中含有给定的searchWords都匹配，否则只匹配书名；如果orderByPrice参数为true，则按照价格排序，否者就自然排序；upperPrice参数代表价格上限。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueryBooks</span>(<span class="params"><span class="built_in">string</span> searchWords,<span class="built_in">bool</span> searchAll,<span class="built_in">bool</span> orderByPirce,<span class="built_in">double</span> upperPrice</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">QueryBooks(<span class="string">&quot;爱&quot;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueryBooks</span>(<span class="params"><span class="built_in">string</span> searchWords,<span class="built_in">bool</span> searchAll,<span class="built_in">bool</span> orderByPrice,<span class="built_in">double</span> upperPrice</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> TestDbContext ctx=<span class="keyword">new</span> TestDbContext();</span><br><span class="line">    IQueryable&lt;Book&gt; books=ctx.Books.Where(b=&gt;b.Price&lt;=upperPrice);</span><br><span class="line">    <span class="keyword">if</span>(searchAll)</span><br><span class="line">    &#123;</span><br><span class="line">        books=books.Where(b=&gt;b.Title.Contains(searchWords)||b.AuthorName.Contains(searchWords));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        books=books.Where(b=&gt;b.Title.Contains(searchWhords));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(orderByPice)</span><br><span class="line">    &#123;</span><br><span class="line">        books=books.OrderBy(b=&gt;b.Price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span>(Book b <span class="keyword">in</span> books)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;b.Id&#125;</span>,<span class="subst">&#123;b.Title&#125;</span>,<span class="subst">&#123;b.Price&#125;</span>,<span class="subst">&#123;b.AuthorName&#125;</span>&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EF-Core分页查询"><a href="#EF-Core分页查询" class="headerlink" title="EF Core分页查询"></a>EF Core分页查询</h2><p>如果数据库表中国的数据比较多，再把查询结果展现到前端的时候，我们通常要对数据进行分页展示。</p><p>在学习LINQ的时候，我们知道可以使用Skip(n)方法实现“跳过n条数据”，可以使用Take(n)方法实现“取最多n条数据”，这两个方法配合起来就可以分页获取数据，比如Skip(3).Take(8)就是“获取从第3条开始的最多8条数据”。在EF Core中也同样支持这两个方法。<br>在实现分页的时候，为了显示页码条，我们需要直到满足条件的数据的总条数是多少。可以使用IQueryable的复用，分别实现数据的分页查询和获取满足条件数据总条数这两个查询操作。</p><p>封装一个方法，用来输出标题不包含“张三”的第n页（页码从1开始）的内容，并且输出总页数，每页最多显示5条数据。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OutputPage(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputPage</span>(<span class="params"><span class="built_in">int</span> pageIndex,<span class="built_in">int</span> pageSize</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> TestDbContext ctx = <span class="keyword">new</span> TestDbContext();</span><br><span class="line">    IQueryable&lt;Book&gt; books =ctx.Books.Where(b =&gt; !b.Title.Contains(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    <span class="built_in">long</span> count = books.LongCount();</span><br><span class="line">    <span class="built_in">long</span> pageCount = (<span class="built_in">long</span>)Math.Ceiling(count*<span class="number">1.0</span>/pageSize);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;页数：&quot;</span>+pageCount);</span><br><span class="line">    <span class="keyword">var</span> pagedBooks = books.Skip((pageIndex<span class="number">-1</span>)*pageSize).Take(pageSize);</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> b <span class="keyword">in</span> pagedBooks)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WiteLine(b.Id+<span class="string">&quot;,&quot;</span>b.Title);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我知道，ADO.NET中有DataReader和DataTable两种读取数据库查询结果的方式。如果查询结果有很多条数据，DataReader则会分批从数据库服务器读取数据。DataReader的优点是客户端内存占用小，缺点是如果遍历读取数据并进行处理的过程缓慢的话，会导致程序占用数据库连接的时间较长，从而降低数据库服务器的并发连接能力；DataTable的优点是数据库被快速地加载到了客户端内存中，因此不会较长时间地占用数据库连接，缺点是如果数据量大的话，客户端的内存占用会比较大。</p><p>IQueryable遍历读取数据的时候，用的是类似DataReader的方式还是类似DataTable的方式呢？</p><p>在遍历执行的过程中，如果我们关闭SQL Server服务器或者断开服务器的网络，程序就会出错，这说明IQueryable的方式读取查询结果的。其实IQueryable内部的遍历就是在调用DataReader进行数据读取。因此，在遍历IQueryable的过程中，它需要占用一个数据库连接。<br>如果需要一次性把所有数据都读取到客户端内存中，可以用IQueryable的ToArray、ToArrayAsync、ToList、ToListAsync等方法。</p><p>在遍历数据的过程中，如果我们关闭SQL Server服务器或断开服务器的网络，程序是可以正常运行的，这说明ToListAsync方法把查询结果加载到客户端内存中了。</p><h3 id="何时需要一次性加载"><a href="#何时需要一次性加载" class="headerlink" title="何时需要一次性加载"></a>何时需要一次性加载</h3><p>1.遍历IQueryable并且进行数据处理的过程很耗时。</p><p>2.如果方法需要返回查询结果，并且在方法里销毁DbContext的话，是不能返回IQueryable的。必须一次性加载返回。</p><p>3.多个IQueryable的遍历嵌套。很多数据库的ADO.NET Core Provider是不支持多个DataReader同时执行的。把连接字符串中的MultipleActiveResultSets&#x3D;true删掉，其他数据库不支持这个。</p><h2 id="EF-Core中的异步方法"><a href="#EF-Core中的异步方法" class="headerlink" title="EF Core中的异步方法"></a>EF Core中的异步方法</h2><p>异步编程通常能狗提升系统的吞吐量，因此如果实现某个功能的方法即有同步方法又有异步方法，我们一般应该优先使用异步方法。</p><blockquote><p>IQueryable的异步方法有AllAsync、AnyAsync、AverageAsync、ContainsAsync、CountAsync、FirstAsync、FirstOrDefaultAsync、ForEachAsync、LongCountAsync、MaxAsync、MinAsync、SingleAsync、SingleOrDefaultAsync、SumAsync等。</p></blockquote><p>IQueryable的这些异步方法的扩展方法都是立即执行方法，而GroupBy、OrderBy、Join、Where等非立即执行方法则没有对应的异步方法。因为这些非立即执行方法并没有实际执行SQL语句，并不是消耗I&#x2F;O的操作，因此不需要定义这些方法的异步版本。</p><h2 id="如何执行原生SQL语句"><a href="#如何执行原生SQL语句" class="headerlink" title="如何执行原生SQL语句"></a>如何执行原生SQL语句</h2><p>尽管EF Core已经非常强大，但是仍然存在无法被写成标准EF Core调用方法的SQL语句，因此在少数场景下，我们依然需要在EF Core中执行原生SQL语句。</p><h3 id="执行SQL非查询语句"><a href="#执行SQL非查询语句" class="headerlink" title="执行SQL非查询语句"></a>执行SQL非查询语句</h3><p>我们可以通过dbCtx.Database.ExecuteSqlInterpolated或者异步的dbCtx.Database.ExecuteSqlInterpolatedAsync方法执行原生的SQL非查询语句。<br>insert into…select于法是一种“先查询出数据，再把查询结果插入数据库表”的语法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    <span class="built_in">double</span> price = <span class="built_in">double</span>.Parse(Console.ReadLine());</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;请输入姓名&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> aName = Console.ReadLine();</span><br><span class="line">    <span class="built_in">int</span> rows = <span class="keyword">await</span> ctx.Database.ExecuteSqlInterpolatedAsync(<span class="string">$@&quot;insert into T_Books (Title,PubTime,Price,AuthorName)</span></span><br><span class="line"><span class="string">select Title,PubTime,Price,<span class="subst">&#123;aName&#125;</span> from T_Books where Price&gt;<span class="subst">&#123;price&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样的字符串不会有SQL注入攻击漏洞。</p><h3 id="执行实体类SQL查询语句"><a href="#执行实体类SQL查询语句" class="headerlink" title="执行实体类SQL查询语句"></a>执行实体类SQL查询语句</h3><p>如果我们要执行的SQL语句是一个查询语句，并且查询的结果也能对应一个实体类，就可以调用对应实体类的DbSet的FromSqlInterpolated方法执行一个SQL查询语句，方法的参数是FormattbleString类型，因此同样可以使用字符串内插入传递参数。<br>编写一个程序要求用户输入一个年份，然后使用SQL预计获取出版年份大于指定年份的书，并且使用order by newid()这个SQL Server的特有用法进行随机排序。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;请输入年份&quot;</span>);</span><br><span class="line"><span class="built_in">int</span> year = <span class="built_in">int</span>.Parse(Console.ReadLine());</span><br><span class="line">IQueryable&lt;Blog&gt; books=ctx.Blogs.FromSqlInterpolated(<span class="string">$@&quot;select * from T_Books where DatePart(year,PubTime)&gt;<span class="subst">&#123;year&#125;</span> order by newid()&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> book <span class="keyword">in</span> books)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(book.Id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FromSqlInterpolated方法的返回值是IQueryable类型的，因此我们可以在实际执行IQueryable之前，对IQueryable进行进一步的处理。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;请输入年份&quot;</span>);</span><br><span class="line"><span class="built_in">int</span> year = <span class="built_in">int</span>.Parse(Console.ReadLine());</span><br><span class="line">IQueryable&lt;Blog&gt; books=ctx.Blogs.FromSqlInterpolated(<span class="string">$@&quot;select * from T_Books where DatePart(year,PubTime)&gt;<span class="subst">&#123;year&#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> book <span class="keyword">in</span> books<span class="comment">/*.OrderBy(a=&gt;price)*/</span>.Skip(<span class="number">3</span>).Take(<span class="number">6</span>))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(book.Id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>FromSqlInterpolated的使用局限性<br>1.SQL查询必须返回实体类型对应数据库表的所有列。<br>2.查询结果集中的列名必须与属性映射到的列名匹配。<br>3.SQL语句只能进行单表查询，不能使用Join语句进行关联查询，但是可以在查询后面使用Include方法进行关联数据的获取。</p></blockquote><h3 id="执行任意SQL查询语句"><a href="#执行任意SQL查询语句" class="headerlink" title="执行任意SQL查询语句"></a>执行任意SQL查询语句</h3><p>通过ctx.Databse.GetDbConnection获得一个数据库连接，然后就可以直接调用ADO.NET的相关方法执行任意的SQL语句了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items=ctx.Databse.GetDbConnection().Query&lt;GroupArticleByPrice&gt;(<span class="string">&quot;select Price,Count(*) PCount from T_Articles group by Price&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> items)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item.Price+<span class="string">&quot;:&quot;</span>+item.PCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EF Core关系配置</title>
      <link href="/2025/03/30/asp.net%20core/%E5%85%B3%E7%B3%BB%E9%85%8D%E7%BD%AE/"/>
      <url>/2025/03/30/asp.net%20core/%E5%85%B3%E7%B3%BB%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="关系配置"><a href="#关系配置" class="headerlink" title="关系配置"></a>关系配置</h1><p>推荐IDE:JetBrains Rider </p><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><p>一对多是最常见的实体类的关系。比如文章和评论的关系就是一对多的关系，也就是一篇文章对应多条评论。</p><p>文章</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Article</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//主键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//标题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Massage &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//内容</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Comment&gt; Comments &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;= <span class="keyword">new</span> List&lt;Comment&gt;(); <span class="comment">//此评论的多条评论</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>评论</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Comment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//主键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Massage &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//评论属于哪篇文章</span></span><br><span class="line">    <span class="keyword">public</span> Article TheArticle &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//评论内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EF Core中实体类之间关系的配置采用如下的模式：HasXXX(…).WithYYY(…);<br>Has在英语中是“有”的意思，With在英语中是“带有”的意思，因此HasXXX(…).WithYYY(…)就代表“A实体类对象有XXX个B实体类对象，B实体类对象带有YYY个A实体类对象”。其中HasXXX(…)用来设置当前这个实体类和关联的另一个实体类的关系，WithYYY(…)用来反向配置实体类的关系。XXX、YYY有One和Many这两个可选值。</p><p>我们在A实体类中配置builder.HasOne&lt;B&gt;(…).WithMany(…)就表示A和B是“一对多”的关系，也就是一个A实体类的对象对应一个B实体类的对象，而一个B实体类的对象有多个A实体类的对象与之对应；如果在A实体类中配置builder.HasOne&lt;B&gt;(…).WithOne(…)就表示A和B是“一对一”的关系，也就是一个A实体类的对象对应一个B实体类对象，而一个B实体类的对象也有一个A实体类的对象与之对应；如果A实体类中配置builder.HasMany&lt;B&gt;(…).WithMany(…)就表示A和B是“多对多”的关系，也就是一个A实体类的对象对应多个B实体类的对象，而一个B实体类的对象也有多个A实体类的对象与之对应。</p><p>使用Fluent API就行关系的配置。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ArticleConfig</span>:<span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Article</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Article&gt; builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(<span class="string">&quot;T_Article&quot;</span>);</span><br><span class="line">        builder.Property(a=&gt;a.Title).HasMaxLength(<span class="number">100</span>).IsUnicode().IsRequired();</span><br><span class="line">        builder.Property(a =&gt; a.Massage).IsUnicode().IsRequired();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CommentConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Comment</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Comment&gt; builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(<span class="string">&quot;T_Comment&quot;</span>);</span><br><span class="line">        builder.Property(a=&gt;a.Massage).IsUnicode().IsRequired();</span><br><span class="line">        builder.HasOne&lt;Article&gt;(c =&gt; c.TheArticle).WithMany(a=&gt;a.Comments).IsRequired();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyDbContext</span>: <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Article&gt; Articles &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Comment&gt; Comments &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnConfiguring(optionsBuilder);</span><br><span class="line">        <span class="built_in">string</span> connstr=<span class="string">&quot;Server=localhost;Database=T_dome;Trusted_Connection=True;MultipleActiveResultSets=true;Encrypt=false;&quot;</span>;</span><br><span class="line">        optionsBuilder.UseSqlServer(connstr);</span><br><span class="line">        optionsBuilder.LogTo(Console.WriteLine);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">        modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">this</span>.GetType().Assembly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.HasOne&lt;Article&gt;(c =&gt; c.TheArticle).WithMany(a=&gt;a.Comments).IsRequired();</span><br></pre></td></tr></table></figure><p>这行代码的意思就是“一条评论对应一篇文章，一篇文章有多条评论”。</p><p>HasOne&lt;Article&gt;(c&#x3D;&gt;c.Article)中的Lambda表达式c&#x3D;&gt;c.Article表示Comment类的Article属性是指向Article实体类型。</p><p>WithMany(a&#x3D;&gt;a.Comments)表示一个Article对应多个Comment,并且在Article中可以通过Comments属性访问到相关的Comment对象。</p><p>IsRequired表示Comment中的Article属性是不可为空的。</p><p><img src="/img%5CHello%5CSHU.png"></p><p>其中T_Comment表的Articleid列是一个指向T_Articles表Id列的外键。</p><p>插入数据</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (MyDbContext ctx=<span class="keyword">new</span> MyDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    Article article = <span class="keyword">new</span> Article();</span><br><span class="line">    article.Title = <span class="string">&quot;EF Core&quot;</span>;</span><br><span class="line">    article.Massage = <span class="string">&quot;EF Core is good&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Comment comment1 = <span class="keyword">new</span> Comment &#123; Massage=<span class="string">&quot;太好了&quot;</span>&#125;;</span><br><span class="line">    Comment comment2 = <span class="keyword">new</span> Comment &#123; Massage = <span class="string">&quot;太棒了&quot;</span> &#125;;</span><br><span class="line">    article.Comments.Add(comment1);</span><br><span class="line">    article.Comments.Add(comment2);</span><br><span class="line">    </span><br><span class="line">    ctx.Articles.Add(article);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联数据的获取"><a href="#关联数据的获取" class="headerlink" title="关联数据的获取"></a>关联数据的获取</h2><p>EF Core的关系配置不仅能帮我们简化数据的插入，也可以简化数据的获取。把Id&#x3D;&#x3D;1的文章及评论输出。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Article a=ctx.Articles.Include(a=&gt;a.Comments).Single(a =&gt; a.Id == <span class="number">1</span>);</span><br><span class="line">Console.WriteLine(a.Title);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> a.Comments)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item.Id+<span class="string">&quot;;&quot;</span>+item.Massage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![](img\Hello\屏幕截图 2025-03-31 094530.png)<br><img src="/img%5CHello%5CSQLGUAN.png"></p><h2 id="单项导航属性"><a href="#单项导航属性" class="headerlink" title="单项导航属性"></a>单项导航属性</h2><p>上面的关系配置的例子中，在Article类中声明了Comment属性指向Comment类，这样我们不仅可以通过Comment类的Article属性获取评论对应的文章信息，还可以通过Article类的Comments属性获取文章的所有评论信息。这样的关系叫作“双向导航”。</p><p>双向导航让我们可以通过任意一方的对象获取对方的信息，但是有时候我们不方便声明双向导航。<br>比如基础的“用户”实体类会被非常多的其他实体类引用，比如“请假单”中会有“申请者”“批准者”等“用户”实体类型的属性。因此系统中会有几十个甚至上百个实体类都有“用户”实体类的属性，但是“用户”实体类不需要为每个实体类都声明一个导航属性。这种情况下，我们就需要一种只在“多端”声明导航属性，而不需要在“一端”声明导航属性的单项导航机制。</p><p>这种单项导航属性的配置只要在WithMany()方法中不指定属性即可。</p><p>创建实体类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//主键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//用户名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Leave</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//主键</span></span><br><span class="line">    <span class="keyword">public</span> User Requester &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//请假人</span></span><br><span class="line">    <span class="keyword">public</span> User? Approver &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//审批人</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Remark &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//请假事由</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明实体类的属性</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyDbContext</span>:<span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;User&gt; Users &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Leave&gt; Leaves  &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> connStr =</span><br><span class="line">            <span class="string">&quot;Server=localhost;Database=T_dome;Trusted_Connection=True;MultipleActiveResultSets=true;Encrypt=false;&quot;</span>;</span><br><span class="line">        optionsBuilder.UseSqlServer(connStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">        modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">this</span>.GetType().Assembly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写Leave类的配置</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LeaveConfig</span>: <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Leave</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Leave&gt; builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder.HasOne&lt;User&gt;(l =&gt; l.Requester).WithMany().IsRequired();</span><br><span class="line">        builder.HasOne&lt;User&gt;(l =&gt; l.Approver).WithMany();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入数据到数据库</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (MyDbContext db = <span class="keyword">new</span> MyDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User&#123;Name= <span class="string">&quot;John&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Leave u1=<span class="keyword">new</span> Leave&#123;Remark = <span class="string">&quot;Holiday&quot;</span>,Requester = user&#125;;</span><br><span class="line">    db.Leaves.Add(u1);</span><br><span class="line">    db.SaveChangesAsync();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>假设实现一个电商网站，那么“订单”和“快递信息”可以定义两个实体类，这两个实体类之间就是一对一的关系：一个订单对应一个快递信息，一个快递信息对应一个订单。</p><p>订单实体类Order</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//订单编号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//订单名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Address &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//订单地址</span></span><br><span class="line">    <span class="keyword">public</span> Delivery? Delivery &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//订单的配送信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快递信息实体类Delivery</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Delivery</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//配送编号</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CompanName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//配送公司名称/*895632./85、        public string Number &#123; get; set; &#125;//配送单号</span></span><br><span class="line">    <span class="keyword">public</span> Order? Order &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//配送的订单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> OrderId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//配送的订单编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一对一关系，由于双方是“平等”的关系，外键列可以建在任意一方，因此我们必须显式地在其中一个实体类中声明一个外键属性。就像上面的实体类定义中，Delivery类中声明了一个外键属性OrderId,当然我们也可以改成在Order类中声明一个外键属性DeliveryId,效果一样的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title">OrderConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Order</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Order&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            builder.ToTable(<span class="string">&quot;T_Order&quot;</span>);</span><br><span class="line">            builder.Property(o=&gt;o.Address).IsRequired();</span><br><span class="line">            builder.Property(o =&gt; o.Name).IsRequired();</span><br><span class="line">            builder.HasOne&lt;Delivery&gt;(o=&gt;o.Delivery).WithOne(d=&gt;d.Order).HasForeignKey&lt;Delivery&gt;(d =&gt; d.OrderId);</span><br><span class="line">*<span class="number">-9</span>+<span class="number">6</span></span><br><span class="line"><span class="number">3</span>        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">OrderConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Order</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Order&gt; builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(<span class="string">&quot;T_Order&quot;</span>);</span><br><span class="line">        builder.Property(o=&gt;o.Address).IsRequired();</span><br><span class="line">        builder.Property(o =&gt; o.Name).IsRequired();</span><br><span class="line">        builder.HasOne&lt;Delivery&gt;(o=&gt;o.Delivery).WithOne(d=&gt;d.Order).HasForeignKey&lt;Delivery&gt;(d =&gt; d.OrderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和一对多关系类似，在一对一关系中，把关系放到哪一方的实体类的配置中都可以。</p><p>插入数据及查询</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (MyDbContext db = <span class="keyword">new</span> MyDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    db.Database.EnsureDeleted();</span><br><span class="line">    db.Database.EnsureCreated();</span><br><span class="line">    Order order = <span class="keyword">new</span> Order</span><br><span class="line">    &#123;</span><br><span class="line">        Name = <span class="string">&quot;订单1&quot;</span>,</span><br><span class="line">        Address = <span class="string">&quot;地址1&quot;</span>,</span><br><span class="line">        Delivery = <span class="keyword">new</span> Delivery</span><br><span class="line">        &#123;</span><br><span class="line">            CompanName = <span class="string">&quot;公司1&quot;</span>,</span><br><span class="line">            Number = <span class="string">&quot;123456&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    db.Add(order);</span><br><span class="line">    db.SaveChanges();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">    Order order1 = db.Set&lt;Order&gt;().Include(o =&gt; o.Delivery).FirstOrDefault();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;订单名称:<span class="subst">&#123;order1.Name&#125;</span>,订单地址:<span class="subst">&#123;order1.Address&#125;</span>,配送公司:<span class="subst">&#123;order1.Delivery?.CompanName&#125;</span>,配送单号:<span class="subst">&#123;order1.Delivery?.Number&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>多对多指的是A实体类的一个对象可以被多个B实体类的对象引用，B实体类的一个对象也可以被多个A实体类的对象引用。<br>一个老师对应多个学生，一个学生对应多个老师，因此老师和学生之间的关系就是多对多。</p><p>声明学生类Student和老师类Teacher两个实体类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Teacher&gt; Teachers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; Students &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，学生类Student中有一个List类型的Teachers代表这个学生的所有老师，同样的 ，老师类Teacher中也有一个List类型的Student代表这个老师的所有学生。</p><p>实体类配置</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TeacherConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Teacher</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Teacher&gt; builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(<span class="string">&quot;Teacher&quot;</span>);</span><br><span class="line">        builder.Property(s=&gt;s.Name).IsUnicode().HasMaxLength(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SudentConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Student</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Student&gt; builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(<span class="string">&quot;T_Student&quot;</span>);</span><br><span class="line">        builder.Property(s=&gt;s.Name).IsUnicode().HasMaxLength(<span class="number">50</span>);</span><br><span class="line">        builder.HasMany&lt;Teacher&gt;(s =&gt; s.Teachers).WithMany(t =&gt; t.Students).UsingEntity(j=&gt;j.ToTable(<span class="string">&quot;T_StudentTeacher&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多对多关系中，我们必须引入一张额外的数据库表存两张表之间的对应关系。在EFCore中，使用UsingEntity(j&#x3D;&gt;j.ToTable(“T_StudentTeacher”))的方式配置中间表。</p><p>插入，查询数据</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestDbConText db = <span class="keyword">new</span> TestDbConText())</span><br><span class="line">&#123;</span><br><span class="line">    db.Database.EnsureDeleted();</span><br><span class="line">    db.Database.EnsureCreated();</span><br><span class="line">    Student student = <span class="keyword">new</span> Student</span><br><span class="line">    &#123;</span><br><span class="line">        Name = <span class="string">&quot;学生1&quot;</span>,</span><br><span class="line">        Teachers = <span class="keyword">new</span> List&lt;Teacher&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Teacher&#123;Name=<span class="string">&quot;老师1&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> Teacher&#123;Name=<span class="string">&quot;老师2&quot;</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    db.Add(student);</span><br><span class="line">    db.SaveChanges();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">    Student student1 = db.Set&lt;Student&gt;().Include(s =&gt; s.Teachers).FirstOrDefault();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;学生名称:<span class="subst">&#123;student1.Name&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> student1.Teachers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;老师名称:<span class="subst">&#123;item.Name&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EF Core实体类配置</title>
      <link href="/2025/03/28/asp.net%20core/EF%20Core%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB%E9%85%8D%E7%BD%AE/"/>
      <url>/2025/03/28/asp.net%20core/EF%20Core%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="EF-Core实体类配置"><a href="#EF-Core实体类配置" class="headerlink" title="EF Core实体类配置"></a>EF Core实体类配置</h1><h2 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h2><p>主要的约定规则<br>规则1：数据库表名采用上下文类中对应的DbSet的属性名。<br>规则2：数据库表列的名字采用实体类属性的名字，列的数据库类型采用和实体类属性类型兼容的类型。比如在SQL Server中，string类型对应nvarchar,long类型对应bigint.<br>规则3：数据库表列尔可空性取决于对应实体类熟悉的可空性。<br>规则4：名字为Id的属性为主键，如果主键为short、int或者long类型，则主键默认采用自动增长类型的列。</p><h2 id="Data-Annotation（数据注解）"><a href="#Data-Annotation（数据注解）" class="headerlink" title="Data Annotation（数据注解）"></a>Data Annotation（数据注解）</h2><p>Data Annotation指的是可以使用.NET提供的Attribute对实体类、属性等进行标注的方式来实现实体类配置。比如通过[Table(“T_Books”)]，我们可以把实体类对应的表名配置为T_Books;</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定表名</span></span><br><span class="line">[<span class="meta">Table(<span class="string">&quot;T_Cats&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//主键</span></span><br><span class="line">    [<span class="meta">Required</span>]<span class="comment">//非空</span></span><br><span class="line">    [<span class="meta">MaxLength(20)</span>]<span class="comment">//最大长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//姓名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：简单 | 缺点：耦合</p><h2 id="Fluent-API"><a href="#Fluent-API" class="headerlink" title="Fluent API"></a>Fluent API</h2><p>Fluent API属于官方的推荐用法</p><p>Fluent API能够更好地进行职责分离。实体类只能负责进行抽象地描述，不涉及与数据库相关的细节，所有和数据库相关的细节被放到配置类中，这样我们能更方便地进行大型项目的管理。</p><p>2.Fluent API的功能更强大。Fluent API几乎能实现Data Annotation的所有功能，而Data Annotation则不支持Fluent API的一些功能。</p><h2 id="Fluent-API-基本配置"><a href="#Fluent-API-基本配置" class="headerlink" title="Fluent API 基本配置"></a>Fluent API 基本配置</h2><h3 id="视图与实体类映射"><a href="#视图与实体类映射" class="headerlink" title="视图与实体类映射"></a>视图与实体类映射</h3><p>可以用下面的代码把blogsView这个数据库中的视图和Blog实体类进行映射：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;().ToView(<span class="string">&quot;blogView&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="排除属性映射"><a href="#排除属性映射" class="headerlink" title="排除属性映射"></a>排除属性映射</h3><p>一个实体类的所有属性都会映射到数据库表中，如果想让EF Core忽略一个属性，就可以用lgnore配置。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;().Ignore(b=&gt;b.Name2);</span><br></pre></td></tr></table></figure><h3 id="数据库表列名"><a href="#数据库表列名" class="headerlink" title="数据库表列名"></a>数据库表列名</h3><p>数据库表中的列名默认和属性名一样，我们可以使用HasColumnName方法配置一个不同的列名。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;().Property(b=&gt;b.BlogId).HasColumnName(<span class="string">&quot;blog_id&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="列数据类型"><a href="#列数据类型" class="headerlink" title="列数据类型"></a>列数据类型</h3><p>EF Core默认会根据实体类的属性类型、最大长度等确定字段的数据类型，我们可以使用HasColumnType为列指定数据类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.Property(e=&gt;e.Tilte).HasColumnType(<span class="string">&quot;nvarchar(200)&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>EF Core默认把名字为Id或者“实体类型+id”的属性作为主键，我们可以用HasKey配置其他属性作为主键。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Student&gt;().HasKey(c=&gt;c.Number);</span><br></pre></td></tr></table></figure><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>EF Core中可用HasIdex方法配置索引。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;().HasIndex(b=&gt;b.Url);</span><br></pre></td></tr></table></figure><p>EF Core也支持多个属性组成的复合索引，只要给HasIndex方法传递由一个或多个属性的名字组成的匿名类对象即可。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Person&gt;().HasIndex(p=&gt;<span class="keyword">new</span>&#123;p.FirstName,p.LastName&#125;);</span><br></pre></td></tr></table></figure><p>EF Core中定义的索引不是唯一索引，我们可以用IsUnique方法把索引配置为唯一索引。我们还可以用IsClustered方法把索引设置为聚集索引。</p><h2 id="主键类型选择并不简单"><a href="#主键类型选择并不简单" class="headerlink" title="主键类型选择并不简单"></a>主键类型选择并不简单</h2><p>在数据库设计中，对于主键类型来讲，有自动自增（简称自增）的long类型和Guid类型两种常用的方案。</p><h3 id="普通自增"><a href="#普通自增" class="headerlink" title="普通自增"></a>普通自增</h3><p>自增long类型的使用非常简单，所有主流数据库系统都内置了对自增列的支持，新插入的数据库会由数据库自动赋予一个新增的、不重复的主键值。自增long类型占用磁盘空间小，可读性强，但是自增long类型的主键在数据库迁移以及分布式系统（分布表、数据库集群）中使用起来比较麻烦，而且在高并发插入的时候性能比较差。<br>由于自增列的值一般都是由数据库生成的，因此无法提前获得新增数据行的主键值，我们需要把数据保存到数据库之后才能获得主键的值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dog dog=<span class="keyword">new</span> Dog();</span><br><span class="line">       dog.Name = <span class="string">&quot;Trump&quot;</span>;</span><br><span class="line">       Console.WriteLine(dog.Id);</span><br><span class="line">       ctx.Dogs.Add(dog);</span><br><span class="line">       <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">       Console.WriteLine(dog.Id);</span><br></pre></td></tr></table></figure><h3 id="Guid算法"><a href="#Guid算法" class="headerlink" title="Guid算法"></a>Guid算法</h3><p>Guid算法使用网卡的MAC地址，时间戳等信息生成一个全球唯一的ID。由于Guid的全球唯一性，它适用于分布式系统，在进行多数据库数据合并的时候很方便，因此我们也可以用Guid类型作为主键。<br>值得注意的是，由于Guid算法生成的值是不连续的，（即使是SQLServer中NewSequentialId函数生成的Guid也不能根本解决这个问题），因此我们在使用Guid类型作为主键的时候，他将会导致新插入的每条数据都要经历查找何时插入位置的过程，在数据量大的时候将会导致非常糟糕的数据插入性能。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Rebbit r = <span class="keyword">new</span> Rebbit();</span><br><span class="line">r.Id = Guid.NewGuid();</span><br><span class="line">r.Name = <span class="string">&quot;YOUXIANYU&quot;</span>;</span><br><span class="line">Console.WriteLine(r.Id);</span><br><span class="line">ctx.Rebbits.Add(r);</span><br><span class="line">Console.WriteLine(r.Id);</span><br><span class="line"><span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">Console.WriteLine(r.Id);</span><br></pre></td></tr></table></figure><h2 id="其他数据库迁移命令"><a href="#其他数据库迁移命令" class="headerlink" title="其他数据库迁移命令"></a>其他数据库迁移命令</h2><h3 id="Update-database-其他参数"><a href="#Update-database-其他参数" class="headerlink" title="Update-database 其他参数"></a>Update-database 其他参数</h3><p>可以用Update-database XXX 把数据库回滚到XXX迁移脚本之后的状态。注意，这个命令只能把当前连接的数据库进行回滚，因此迁移脚本仍然存在。</p><h3 id="删除迁移脚本"><a href="#删除迁移脚本" class="headerlink" title="删除迁移脚本"></a>删除迁移脚本</h3><p>可以用Remove-migration命令删除最后一次的迁移脚本。</p><h3 id="生产迁移脚本"><a href="#生产迁移脚本" class="headerlink" title="生产迁移脚本"></a>生产迁移脚本</h3><p>EF Core中提供了Script-Migration命令来根据迁移代码生成SQL脚本，在【程序包管理器控制台】中输入Script-Migration并执行，一个包含完整的数据库操作脚本的SQL文件就会被创建和打开。</p><p>如果生产数据库已经处于某个迁移版本的状态，那么我们可以生成这个版本D到版本F的SQL脚本：Script-Migration D F。</p><p>还可以使用context.Database.Migrate()代码来对程序当前连接的数据库进行迁移。这种方式是直接在代码中完成数据库迁移，很多公司的安全审计要求提供的是明文的SQL语句。</p><h2 id="查询EF-Core生成的SQL语句"><a href="#查询EF-Core生成的SQL语句" class="headerlink" title="查询EF Core生成的SQL语句"></a>查询EF Core生成的SQL语句</h2><h3 id="使用简单日志查看SQL语句"><a href="#使用简单日志查看SQL语句" class="headerlink" title="使用简单日志查看SQL语句"></a>使用简单日志查看SQL语句</h3><p>只要在上下文的OnConfiguring方法中调用optionsBuilder类的LogTo方法，查询SQL语句，输出到控制台。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//连接数据库</span></span><br><span class="line">    <span class="keyword">base</span>.OnConfiguring(optionsBuilder);</span><br><span class="line">    <span class="built_in">string</span> connstr = <span class="string">&quot;Server=localhost;Database=student;Trusted_Connection=True;MultipleActiveResultSets=true;Encrypt=false;&quot;</span>;</span><br><span class="line">    optionsBuilder.UseSqlServer(connstr).LogTo(Console.WriteLine);</span><br><span class="line">    optionsBuilder.LogTo(message =&gt;  Console.WriteLine(message),LogLevel.Information);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记录到文件</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> StreamWriter _logStream = <span class="keyword">new</span> StreamWriter(<span class="string">&quot;mylog.txt&quot;</span>, append: <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">    =&gt; optionsBuilder.LogTo(_logStream.WriteLine);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.Dispose();</span><br><span class="line">    _logStream.Dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> ValueTask <span class="title">DisposeAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">base</span>.DisposeAsync();</span><br><span class="line">    <span class="keyword">await</span> _logStream.DisposeAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EF Core入门</title>
      <link href="/2025/03/28/asp.net%20core/EF%20Core%E5%85%A5%E9%97%A8/"/>
      <url>/2025/03/28/asp.net%20core/EF%20Core%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="EF-Core入门"><a href="#EF-Core入门" class="headerlink" title="EF Core入门"></a>EF Core入门</h1><p>不同的EF Core数据库提供的质量参次不齐，除了微软官方的Microsoft SQL Server的EF Core数据库提供程序之外，还存在着很多第三方的EF Core数据库提供程序，它们对于EF Core的支持大部分是一致的，但是会有细微的差别。</p><h2 id="EF-Core环境搭建"><a href="#EF-Core环境搭建" class="headerlink" title="EF Core环境搭建"></a>EF Core环境搭建</h2><p>无论是在控制台项目中还是在ASP.NET Core项目中，EF Core的用法都是一样的。<br>EF Core用于将对象和数据库中的表进行映射，因此在进行EF Core开发的时候，需要创建C#类（也叫作实体类）和数据库表两项内容。<br>在经典的EF Core使用场景下，由开发人员编写实体类，然后EF Core可以根据实体类数据库表。</p><h3 id="创建一个-NET-Core控制台项目，然后再项目中创建Book实体类。"><a href="#创建一个-NET-Core控制台项目，然后再项目中创建Book实体类。" class="headerlink" title="创建一个.NET Core控制台项目，然后再项目中创建Book实体类。"></a>创建一个.NET Core控制台项目，然后再项目中创建Book实体类。</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Book</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//主键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//标题</span></span><br><span class="line">    <span class="keyword">public</span> DateTime PubTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//发布日期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//单价</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 为项目安装NuGet包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.EntityFrameworkCore.SqlServer</span><br></pre></td></tr></table></figure><h3 id="我们先创建一个实现了IEntityTypeConfiguration接口的实现类的配置类BookEntityConfig-它用于配置实体类和数据库表的对应关系。"><a href="#我们先创建一个实现了IEntityTypeConfiguration接口的实现类的配置类BookEntityConfig-它用于配置实体类和数据库表的对应关系。" class="headerlink" title="我们先创建一个实现了IEntityTypeConfiguration接口的实现类的配置类BookEntityConfig,它用于配置实体类和数据库表的对应关系。"></a>我们先创建一个实现了IEntityTypeConfiguration接口的实现类的配置类BookEntityConfig,它用于配置实体类和数据库表的对应关系。</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">BookConfig</span>:<span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Book</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Book&gt; builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(<span class="string">&quot;T_Books&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过接口类型IEntityTypeConfiguration&lt;T&gt;的泛型参数类指定这个类要对哪个实体类进行配置，然后再Configure方法中对实体类和数据库表的关系做详细的配。<br>其中builder.ToTable(“T_Books”)表示这个实体类对应数据库中的名字为T_Books的表。<br>这里没有配置各个属性在数据库中的列名和数据库类型，EF Core将会默认把属性的名字作为列名，并且根据属性的类型来推断数据库表中各列的数据库表中各列的数据库类型。</p><h3 id="创建一个继承自DbContext类的MyDbContext类"><a href="#创建一个继承自DbContext类的MyDbContext类" class="headerlink" title="创建一个继承自DbContext类的MyDbContext类"></a>创建一个继承自DbContext类的MyDbContext类</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">EF_Core</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">MyDbContext</span>:<span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;Book&gt; Books &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;Person&gt; Persons &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连接数据库</span></span><br><span class="line">            <span class="keyword">base</span>.OnConfiguring(optionsBuilder);</span><br><span class="line">            <span class="built_in">string</span> connstr = <span class="string">&quot;Server=localhost;Database=student;Trusted_Connection=True;MultipleActiveResultSets=true;Encrypt=false;&quot;</span>;</span><br><span class="line">            optionsBuilder.UseSqlServer(connstr);</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从当前程序集中加载所有的IEntityTypeConfiguration</span></span><br><span class="line">            <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">            modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">this</span>.GetType().Assembly);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyDbContext中的Books属性对应数据库中的T_Books表，对Books的操作会反应到数据库的T_Books表中。这样继承自DbContext的类叫作“上下文”。</p><h3 id="开始创建程序对应的数据库和数据库表"><a href="#开始创建程序对应的数据库和数据库表" class="headerlink" title="开始创建程序对应的数据库和数据库表"></a>开始创建程序对应的数据库和数据库表</h3><p>EF Core这种根据实体类生成数据库表的操作也被叫作“迁移”（migration）。<br>为了使用EF Core生成数据库的工具，通过NuGet为项目安装之后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.EntityFrameworkCore.Tools</span><br></pre></td></tr></table></figure><p>再【程序包管理器控制台】中执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration 合理的变量名</span><br></pre></td></tr></table></figure><p>Add-Migration会自动再项目的Migrations文件夹中生成</p><p>打开<br><img src="/img%5CHello%5CEF.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">EF_Core.Migrations</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">InitialCreate</span> : <span class="title">Migration</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Up</span>(<span class="params">MigrationBuilder migrationBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            migrationBuilder.CreateTable(</span><br><span class="line">                name: <span class="string">&quot;T_Books&quot;</span>,</span><br><span class="line">                columns: table =&gt; <span class="keyword">new</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Id = table.Column&lt;<span class="built_in">long</span>&gt;(type: <span class="string">&quot;bigint&quot;</span>, nullable: <span class="literal">false</span>)</span><br><span class="line">                        .Annotation(<span class="string">&quot;SqlServer:Identity&quot;</span>, <span class="string">&quot;1, 1&quot;</span>),</span><br><span class="line">                    Title = table.Column&lt;<span class="built_in">string</span>&gt;(type: <span class="string">&quot;nvarchar(max)&quot;</span>, nullable: <span class="literal">false</span>),</span><br><span class="line">                    PubTime = table.Column&lt;DateTime&gt;(type: <span class="string">&quot;datetime2&quot;</span>, nullable: <span class="literal">false</span>),</span><br><span class="line">                    Price = table.Column&lt;<span class="built_in">double</span>&gt;(type: <span class="string">&quot;float&quot;</span>, nullable: <span class="literal">false</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                constraints: table =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    table.PrimaryKey(<span class="string">&quot;PK_T_Books&quot;</span>, x =&gt; x.Id);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            migrationBuilder.CreateTable(</span><br><span class="line">                name: <span class="string">&quot;T_Persons&quot;</span>,</span><br><span class="line">                columns: table =&gt; <span class="keyword">new</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Id = table.Column&lt;<span class="built_in">int</span>&gt;(type: <span class="string">&quot;int&quot;</span>, nullable: <span class="literal">false</span>)</span><br><span class="line">                        .Annotation(<span class="string">&quot;SqlServer:Identity&quot;</span>, <span class="string">&quot;1, 1&quot;</span>),</span><br><span class="line">                    Name = table.Column&lt;<span class="built_in">string</span>&gt;(type: <span class="string">&quot;nvarchar(max)&quot;</span>, nullable: <span class="literal">false</span>),</span><br><span class="line">                    Age = table.Column&lt;<span class="built_in">int</span>&gt;(type: <span class="string">&quot;int&quot;</span>, nullable: <span class="literal">false</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                constraints: table =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    table.PrimaryKey(<span class="string">&quot;PK_T_Persons&quot;</span>, x =&gt; x.Id);</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Down</span>(<span class="params">MigrationBuilder migrationBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            migrationBuilder.DropTable(</span><br><span class="line">                name: <span class="string">&quot;T_Books&quot;</span>);</span><br><span class="line"></span><br><span class="line">            migrationBuilder.DropTable(</span><br><span class="line">                name: <span class="string">&quot;T_Persons&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个文件中包含用来创建数据库表的表名、列名、列数据类型、主键等的代码。<br>上面的代码还没有执行，他们需要被执行后才会应用到数据库，因此我们接着在【程序包管理器控制台】中执行Update-database执行数据库迁移代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Update-database</span><br></pre></td></tr></table></figure><h3 id="SQLServer数据库"><a href="#SQLServer数据库" class="headerlink" title="SQLServer数据库"></a>SQLServer数据库</h3><p>查看SQLServer数据库，我们可以发现数据库student及数据库表T_Books,T_PersonT_Books,T_Persons已经创建成功，数据库表T_Books的结构也和实体类中配置的一致。</p><p><img src="/img%5CHello%5Csjk.png"></p><p>可以根据需要修改实体类的配置，进而修改数据库中的表。<br>生成的T_Books表中Title字段的类型为nvarchar(MAX),想把它修改为nvarchar(50),把Title字段设则为“不可为空”，并且想增加一个不为空且最大长度为20的AuthorName字符串类型的属性，可以修改Book实体类，为其增加一个AuthorName属性，为其添加一个AuthorName属性，然后修改BookEntityConfig的Configure方法。</p><p>添加AuthorName属性</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Book</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//主键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//标题</span></span><br><span class="line">    <span class="keyword">public</span> DateTime PubTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//发布日期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//单价</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> AuthorName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//作者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">BookConfig</span>:<span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Book</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Book&gt; builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(<span class="string">&quot;T_Books&quot;</span>);</span><br><span class="line">        builder.Property(e=&gt;e.Title).HasMaxLength(<span class="number">50</span>).IsRequired();</span><br><span class="line">        builder.Property(e=&gt;e.AuthorName).HasMaxLength(<span class="number">20</span>).IsRequired();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中HasMaxLength(50)用来配置属性的最大长度为50，IsRequired用来配置属性的值为“不可为空”。</p><p>完成修改后，再执行Add-Migration AddAuthorName_ModifyTitle<br>由于我们把现在的Title列的字段长度从MAX修改为了50，因此可能会造成数据库中旧数据的丢失，Add-Migration命令给出了“An operation was scaffolded that may result in the loss of data.”这个警告。<br>上面的命令执行完后，在项目文件夹下又生成了一个新的.cs文件，这个文件包含了修改T_Books表的Title列的长度、新增AuthorName列等的代码。</p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>TestDbContext类中的Books属性对应数据库中的T_Books表，Books属性是DbSet&lt;Book&gt;类型的。<br>因此我们只要操纵Books属性，就可以向数据库中增加数据，但是通过C#代码修改Books属性中的数据只是修改了内存中的数据，对Books属性做修改后，还需要调用异步方法<code>SaveChangesAsync把修改保存到数据库。其实DbContext中也有同步的保存方法SaveChanges,但是采用异步方法通常能提升系统的并发处理能力，因此我们推荐使用异步方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> EF_Core;</span><br><span class="line"><span class="comment">//Console.WriteLine(&quot;Hello World!&quot;);</span></span><br><span class="line"><span class="comment">//ctx = 逻辑上的数据库</span></span><br><span class="line"><span class="keyword">using</span> (MyDbContext ctx = <span class="keyword">new</span> MyDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">    d.Name = <span class="string">&quot;Trump&quot;</span>;</span><br><span class="line">    ctx.Dogs.Add(d);<span class="comment">//把d对象加入到Dogs这个逻辑上的列表中</span></span><br><span class="line"></span><br><span class="line">    ctx.Dogs.Add(d);<span class="comment">//把d对象加入到Dogs这个逻辑上的列表中</span></span><br><span class="line">    <span class="keyword">await</span> ctx.SaveChangesAsync();<span class="comment">//把逻辑上的数据库的变化应用到物理数据库中</span></span><br><span class="line"></span><br><span class="line">    Dog d2 = <span class="keyword">new</span> Dog();</span><br><span class="line">    d2.Name = <span class="string">&quot;Biden&quot;</span>;</span><br><span class="line">    ctx.Dogs.Add(d2);</span><br><span class="line"></span><br><span class="line">    Book book = <span class="keyword">new</span> Book();</span><br><span class="line">    book.Title = <span class="string">&quot;C#&quot;</span>;</span><br><span class="line">    book.AuthorName = <span class="string">&quot;Bill&quot;</span>;</span><br><span class="line">    book.Price = <span class="number">100</span>;</span><br><span class="line">    book.PubTime = DateTime.Now;</span><br><span class="line">    ctx.Books.Add(book);</span><br><span class="line">    <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就实现了不用编程写SQL语句，而是通过创建对象和为对象赋值的方式完成对数据库的操作。</p><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>Books属性和数据库中的T_Books表对应，Books属性是DbSet<Book>类型的，而DbSet实现了IEnumerable&lt;T&gt;接口，因此我们可以使用LINQ操作对DbSet进行数据查询。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//var b1 = new Book &#123; AuthorName = &quot;YOUXIANYU&quot;, Title = &quot;零基础学c#&quot;, Price = 100, PubTime = new DateTime(2019, 3, 1) &#125;;</span></span><br><span class="line"> <span class="comment">//var b2 = new Book &#123; AuthorName =&quot;Almngao&quot;, Title = &quot;零基础学c++&quot;, Price = 90, PubTime = new DateTime(2018, 3, 1) &#125;;</span></span><br><span class="line"> <span class="comment">//var b3 = new Book &#123; AuthorName = &quot;you&quot;, Title = &quot;零基础学c&quot;, Price = 50, PubTime = new DateTime(2016, 3, 1) &#125;;</span></span><br><span class="line"> <span class="comment">//var b4 = new Book &#123; AuthorName = &quot;yu&quot;, Title = &quot;零基础学java&quot;, Price = 80, PubTime = new DateTime(2015, 3, 1) &#125;;</span></span><br><span class="line"> <span class="comment">//var b5 = new Book &#123; AuthorName = &quot;xi&quot;, Title = &quot;零基础学python&quot;, Price = 60, PubTime = new DateTime(2014, 3, 1) &#125;;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//ctx.Books.AddRange(b1);</span></span><br><span class="line"> <span class="comment">//ctx.Books.AddRange(b2);</span></span><br><span class="line"> <span class="comment">//ctx.Books.AddRange(b3);</span></span><br><span class="line"> <span class="comment">//ctx.Books.AddRange(b4);</span></span><br><span class="line"> <span class="comment">//ctx.Books.AddRange(b5);</span></span><br><span class="line"> <span class="comment">//await ctx.SaveChangesAsync();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> books = ctx.Books.Where(b =&gt; b.Price &gt; <span class="number">80</span>);</span><br><span class="line"> <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> books)</span><br><span class="line"> &#123;</span><br><span class="line">     Console.WriteLine(b.Title);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> book=ctx.Books.Single(b=&gt;b.Title == <span class="string">&quot;零基础学c#&quot;</span>);</span><br><span class="line"> Console.WriteLine(book.AuthorName);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> book1 = ctx.Books.OrderBy(b =&gt; b.Price);</span><br><span class="line"> <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> book1)</span><br><span class="line"> &#123;</span><br><span class="line">     Console.WriteLine(b.Title+<span class="string">&quot;,&quot;</span>+b.Price);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> book2 = ctx.Books.GroupBy(b =&gt; b.AuthorName).Select(g =&gt; <span class="keyword">new</span></span><br><span class="line">&#123;</span><br><span class="line">    Name = g.Key,</span><br><span class="line">    BooksCount = g.Count(),</span><br><span class="line">    MaxPrice = g.Max(b =&gt; b.Price)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> e <span class="keyword">in</span> book2)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(e.Name + <span class="string">&quot;,&quot;</span> + e.BooksCount + <span class="string">&quot;,&quot;</span> + e.MaxPrice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="修改和删除数据"><a href="#修改和删除数据" class="headerlink" title="修改和删除数据"></a>修改和删除数据</h2><p>使用EF Core,还可以对已有的数据进行修改、删除操作。常规来讲，如果要对数据进行修改，我们首先需要把要修改的数据查询初来，然后对查询出来的数据进行修改，再执行SaveChangesAsync保存修改即可。</p><p>同样，要对数据进行删除，我们要先把待删除的数据查询出来，然后调用DbSet或者DbContextd的Remove方法把数据删除，再执行SaveChangesAsync方法保存结果到数据库。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = ctx.Books.Single(b =&gt; b.Title == <span class="string">&quot;零基础学java&quot;</span>);</span><br><span class="line">b.AuthorName = <span class="string">&quot;youxianyu&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d=ctx.Dogs.Single(b =&gt; b.Id == <span class="number">3</span>);</span><br><span class="line">ctx.Dogs.Remove(d);</span><br><span class="line"><span class="keyword">await</span> ctx.SaveChangesAsync();</span><br></pre></td></tr></table></figure><p>值得注意的是，无论是上面的修改数据的代码还是删除数据的代码，都是要先执行数据的查询操作，把数据查询出来，再执行修改或删除操作。这样在EF Core的底层其实发生了先执行Select的SQL语句，然后执行Update或者Delete的SQL语句。</p><p>批量删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除给定的数据</span></span><br><span class="line"><span class="keyword">await</span> ctx.Books.Where(<span class="keyword">static</span> x=&gt;x.Id==<span class="number">1</span>).ExecuteDeleteAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有价格大于10的数据</span></span><br><span class="line"><span class="keyword">await</span> ctx.Books.Where(b =&gt; b.Price &gt; <span class="number">10</span>).ExecuteDeleteAsync();</span><br><span class="line"><span class="comment">//批量更新</span></span><br><span class="line"><span class="keyword">await</span> ctx.Books</span><br><span class="line">    .Where(b =&gt; b.Title == <span class="string">&quot;零基础学&quot;</span>)</span><br><span class="line">    .ExecuteUpdateAsync(e =&gt; e.SetProperty(d =&gt; d.Price, d =&gt; d.Price + <span class="number">10</span>)</span><br><span class="line">    .SetProperty(d =&gt; d.Title, d =&gt; d.Title + <span class="string">&quot;C#&quot;</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EF Core </tag>
            
            <tag> ASP.NET Core </tag>
            
            <tag> Entity Framework Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志</title>
      <link href="/2025/03/24/asp.net%20core/%E6%97%A5%E5%BF%97/"/>
      <url>/2025/03/24/asp.net%20core/%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>日志（logging）是程序运行中的“黑匣子”，在程出现问题以后，我们可以通过分析日志来查询问题。</p><h2 id="NET-Core日子基本使用"><a href="#NET-Core日子基本使用" class="headerlink" title=".NET Core日子基本使用"></a>.NET Core日子基本使用</h2><p>.NET Core中的日志系统可以把日志记录到控制台、事件日志、调试窗口等地方，还可以使用第三方日志提供程序把日志记录到文件、日志服务器等地方。和配置系统一样，.NET Core中的日志提供了标准接口及官方的一些实现，同时允许开发人员编写第三方实现。<br>些简单的把日志输出到控制台的使用方式。<br>NuGet安装包<br>日志系统核心的开发包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.Extensions.Logging</span><br></pre></td></tr></table></figure><p>控制台输出日志包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.Extensions.Logging.Console</span><br></pre></td></tr></table></figure><p>声明一个类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Recording</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ILogger&lt;Recording&gt;logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Recording</span>(<span class="params">ILogger&lt;Recording&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Record</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        logger.LogDebug(<span class="string">&quot;开始执行数据库同步&quot;</span>);</span><br><span class="line">        logger.LogDebug(<span class="string">&quot;连接数据库成功&quot;</span>);</span><br><span class="line">        logger.LogWarning(<span class="string">&quot;数据库连接超时，重试第一次&quot;</span>);</span><br><span class="line">        <span class="comment">//······</span></span><br><span class="line">        logger.LogWarning(<span class="string">&quot;数据库连接超时，重试第二次&quot;</span>);</span><br><span class="line">        logger.LogError(<span class="string">&quot;数据库连接超时，重试失败&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            File.ReadAllText(<span class="string">&quot;E:/temp/3.txt&quot;</span>);</span><br><span class="line">            logger.LogDebug(<span class="string">&quot;读取文件成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            logger.LogError(ex, <span class="string">&quot;数据库同步失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LoggingDemo;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Logging;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Logging.Console;</span><br><span class="line"><span class="keyword">using</span> NLog.Fluent;</span><br><span class="line"><span class="comment">//DI</span></span><br><span class="line">ServiceCollection services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddLogging(logBuilder =&gt; &#123;</span><br><span class="line">    logBuilder.AddConsole();</span><br><span class="line">    <span class="comment">//最低输出日志级别</span></span><br><span class="line">    logBuilder.SetMinimumLevel(LogLevel.Trace);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">services.AddScoped&lt;Recording&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> sp=services.BuildServiceProvider())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> recording = sp.GetRequiredService&lt;Recording&gt;();</span><br><span class="line">    recording.Record();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文本日志提供程序NLog"><a href="#文本日志提供程序NLog" class="headerlink" title="文本日志提供程序NLog"></a>文本日志提供程序NLog</h2><p>.NET没有内置文本日志提供者。第三方Log4Net、NLog、Serilog等。<br>NLog,NuGet安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NLog.Extensions.Logging</span><br></pre></td></tr></table></figure><p>(using NLog.Extensions.Logging;)。项目根目录下建nlog.congig,注意文件大小写（考虑Linux）。<br>也可以是其他文件名，但是需要单独配置。<br>增加logBuilder.AddNLog()</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LoggingDemo;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Logging;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Logging.Console;</span><br><span class="line"><span class="keyword">using</span> NLog.Extensions.Logging;</span><br><span class="line"><span class="keyword">using</span> NLog.Fluent;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Hosting;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Hosting;</span><br><span class="line"><span class="keyword">using</span> NLog.Web;</span><br><span class="line"><span class="comment">//DI</span></span><br><span class="line">ServiceCollection services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddLogging(logBuilder =&gt; &#123;</span><br><span class="line">    logBuilder.AddConsole();</span><br><span class="line">    logBuilder.AddEventLog();</span><br><span class="line">    logBuilder.AddNLog();</span><br><span class="line">    <span class="comment">//最低输出日志级别</span></span><br><span class="line">    logBuilder.SetMinimumLevel(LogLevel.Trace);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">services.AddScoped&lt;Recording&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> sp=services.BuildServiceProvider())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> recording = sp.GetRequiredService&lt;Recording&gt;();</span><br><span class="line">    recording.Record();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目内新建项找到文本文件命名为nlog.config<br>属性设为较新复值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;nlog xmlns=&quot;http://www.nlog-project.org/schemas/NLog.xsd&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      autoReload=&quot;true&quot;</span><br><span class="line">      throwConfigExceptions=&quot;true&quot;</span><br><span class="line">      internalLogLevel=&quot;info&quot;</span><br><span class="line">      internalLogFile=&quot;E:\log\internal-nlog.txt&quot;&gt;</span><br><span class="line">&lt;!--autoReload：修改后自动加载，可能会有延迟--&gt;</span><br><span class="line">&lt;!--throwConfigExceptions：NLog日志系统抛出异常--&gt;</span><br><span class="line">&lt;!--internalLogLevel：内部日志的级别--&gt;</span><br><span class="line">&lt;!--internalLogFile：内部日志保存路径，日志的内容大概就是NLog的版本信息，配置文件的地址等等--&gt;</span><br><span class="line">&lt;!--输出日志的配置，用于rules读取--&gt;</span><br><span class="line">&lt;targets&gt;</span><br><span class="line">&lt;!--write logs to file--&gt;</span><br><span class="line">&lt;!--将日志写入文件中,fileName可以指定日志生成的路径--&gt;</span><br><span class="line">&lt;target xsi:type=&quot;File&quot; name=&quot;allfile&quot; fileName=&quot;D:\Log\nlog-all-$&#123;shortdate&#125;.log&quot;</span><br><span class="line"> layout=&quot;$&#123;longdate&#125;|$&#123;logger&#125;|$&#123;uppercase:$&#123;level&#125;&#125;|$&#123;message&#125; $&#123;exception&#125;&quot; /&gt;</span><br><span class="line">&lt;!--同样是将文件写入日志中，写入的内容有所差别，差别在layout属性中体现。写入日志的数量有差别，差别在路由逻辑中体现--&gt;</span><br><span class="line">&lt;target xsi:type=&quot;File&quot; name=&quot;ownFile-web&quot; fileName=&quot;D:\Log\nlog-my-$&#123;shortdate&#125;.log&quot;</span><br><span class="line"> layout=&quot;$&#123;longdate&#125;|$&#123;logger&#125;|$&#123;uppercase:$&#123;level&#125;&#125;|$&#123;message&#125; $&#123;exception&#125;&quot; /&gt;</span><br><span class="line">&lt;target xsi:type=&quot;Null&quot; name=&quot;blackhole&quot; /&gt;</span><br><span class="line">&lt;/targets&gt;</span><br><span class="line">&lt;rules&gt;</span><br><span class="line">&lt;!--路由顺序会对日志打印产生影响。路由匹配逻辑为顺序匹配。--&gt;</span><br><span class="line">&lt;!--All logs, including from Microsoft--&gt;</span><br><span class="line">&lt;logger name=&quot;*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;allfile&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--Skip Microsoft logs and so log only own logs--&gt;</span><br><span class="line">&lt;!--以Microsoft打头的日志将进入此路由，由于此路由没有writeTo属性，所有会被忽略--&gt;</span><br><span class="line">&lt;!--且此路由设置了final，所以当此路由被匹配到时。不会再匹配此路由下面的路由。未匹配到此路由时才会继续匹配下一个路由--&gt;</span><br><span class="line">&lt;logger name=&quot;Microsoft.*&quot; minlevel=&quot;Trace&quot;  final=&quot;true&quot; /&gt;</span><br><span class="line">&lt;!--上方已经过滤了所有Microsoft.*的日志，所以此处的日志只会打印除Microsoft.*外的日志--&gt;</span><br><span class="line">&lt;logger name=&quot;*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;ownFile-web&quot; /&gt;</span><br><span class="line">&lt;/rules&gt;</span><br><span class="line">&lt;/nlog&gt;</span><br></pre></td></tr></table></figure><p>在设定的路径找到日志<br>“D:\Log\nlog-my-${shortdate}.log”<br>“D:\Log\nlog-all-${shortdate}.log”</p><h2 id="日志分类、过滤"><a href="#日志分类、过滤" class="headerlink" title="日志分类、过滤"></a>日志分类、过滤</h2><p>NLog官方网址：<a href="https://nlog-project.org/%E5%AF%B9%E4%BD%BF%E7%94%A8NLog%E6%9C%89%E8%AF%A6%E7%BB%86%E7%9A%84%E8%AF%B4%E6%98%8E">https://nlog-project.org/对使用NLog有详细的说明</a></p><p>配置nlog.config</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;nlog xmlns=&quot;http://www.nlog-project.org/schemas/NLog.xsd&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      autoReload=&quot;true&quot;</span><br><span class="line">      throwConfigExceptions=&quot;true&quot;</span><br><span class="line">  internalLogFile=&quot;console-example-internal.log&quot;</span><br><span class="line">      internalLogLevel=&quot;off&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- enable asp.net core layout renderers --&gt;</span><br><span class="line">&lt;extensions&gt;</span><br><span class="line">&lt;add assembly=&quot;NLog.Web.AspNetCore&quot;/&gt;</span><br><span class="line">&lt;/extensions&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- the targets to write to --&gt;</span><br><span class="line">&lt;targets&gt;</span><br><span class="line">&lt;!-- File Target for all log messages with basic details --&gt;</span><br><span class="line">&lt;target xsi:type=&quot;File&quot; name=&quot;LoggingDemo&quot; fileName=&quot;logs/log-$&#123;shortdate&#125;.log&quot;</span><br><span class="line">layout=&quot;$&#123;longdate&#125;|$&#123;event-properties:item=EventId:whenEmpty=0&#125;|$&#123;level:uppercase=true&#125;|$&#123;logger&#125;|$&#123;message&#125; $&#123;exception:format=tostring&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- File Target for own log messages with extra web details using some ASP.NET core renderers --&gt;</span><br><span class="line">&lt;target xsi:type=&quot;File&quot; name=&quot;SytemServices&quot; fileName=&quot;logs/sysFile-$&#123;shortdate&#125;.log&quot; archiveAboveSize=&quot;1000&quot; maxArchiveFiles=&quot;3&quot;</span><br><span class="line">layout=&quot;$&#123;longdate&#125;|$&#123;event-properties:item=EventId:whenEmpty=0&#125;|$&#123;level:uppercase=true&#125;|$&#123;logger&#125;|$&#123;message&#125; $&#123;exception:format=tostring&#125;|url: $&#123;aspnet-request-url&#125;|action: $&#123;aspnet-mvc-action&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--Console Target for hosting lifetime messages to improve Docker / Visual Studio startup detection --&gt;</span><br><span class="line">&lt;target xsi:type=&quot;Console&quot; name=&quot;logconsole&quot; layout=&quot;$&#123;MicrosoftConsoleLayout&#125;&quot; /&gt;</span><br><span class="line">&lt;/targets&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- rules to map from logger name to target --&gt;</span><br><span class="line">&lt;rules&gt;</span><br><span class="line">&lt;!-- All logs, including from Microsoft --&gt;</span><br><span class="line">&lt;logger name=&quot;*&quot; minlevel=&quot;Warn&quot; maxlevel=&quot;Fatal&quot; writeTo=&quot;logconsole&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Suppress output from Microsoft framework when non-critical --&gt;</span><br><span class="line">&lt;logger name=&quot;SytemServices.*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;SytemServices&quot; final=&quot;true&quot; /&gt;</span><br><span class="line">&lt;!-- Keep output from Microsoft.Hosting.Lifetime to console for fast startup detection --&gt;</span><br><span class="line">&lt;logger name=&quot;*&quot; minLevel=&quot;Trace&quot; writeTo=&quot;LoggingDemo&quot; /&gt;</span><br><span class="line">&lt;/rules&gt;</span><br><span class="line">&lt;/nlog&gt;</span><br></pre></td></tr></table></figure><p>输出十次</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ServiceCollection services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddLogging(logBuilder =&gt; &#123;</span><br><span class="line">    <span class="comment">//logBuilder.AddConsole();</span></span><br><span class="line">    <span class="comment">//logBuilder.AddEventLog();</span></span><br><span class="line">    logBuilder.AddNLog();</span><br><span class="line">    <span class="comment">//最低输出日志级别</span></span><br><span class="line">    <span class="comment">//logBuilder.SetMinimumLevel(LogLevel.Trace);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">services.AddScoped&lt;Recording&gt;();</span><br><span class="line">services.AddScoped&lt;Test1&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> sp=services.BuildServiceProvider())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> recording = sp.GetRequiredService&lt;Recording&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> test1 = sp.GetRequiredService&lt;Test1&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        recording.Record();</span><br><span class="line">        test1.Record();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/%5Cimg%5CHello%5CNLOG.png"></p><h2 id="集中化日志"><a href="#集中化日志" class="headerlink" title="集中化日志"></a>集中化日志</h2><p>NLog也可以配置结构化日志，不过配置麻烦，推荐用Serilog。</p><p>NuGet安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using Serilog.Formatting.Json;</span><br><span class="line">using Serilog;</span><br><span class="line">Serilog.AspNetCore</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Serilog.Log.Logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">.MinimumLevel.Debug()</span><br><span class="line">.Enrich.FromLogContext()</span><br><span class="line">.WriteTo.Console(<span class="keyword">new</span> JsonFormatter())</span><br><span class="line">.CreateLogger();</span><br><span class="line">logBuilder.AddSerilog();</span><br></pre></td></tr></table></figure><p>要记录的结构化数据通过占位符来输出：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.LogWarning(<span class="string">&quot;新增用户&#123;@person&#125;&quot;</span>,<span class="keyword">new</span> &#123;Id=<span class="number">3</span>,Name=<span class="string">&quot;zack&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><p>同样可以输出到文件、数据库、MongoDB等。</p>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习XML</title>
      <link href="/2025/03/23/asp.net%20core/xml/"/>
      <url>/2025/03/23/asp.net%20core/xml/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h1><p>XML 指的是，可扩展性标记语言<br>XML被发明的目的是传输和存储数据，而不是展示数据;<br>XML的标签必须自定义，但是在写标签名的时候一定要有含义; XML是W3C推举的数据传输格式;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">user</span>&gt;</span>123<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">msg</span>&gt;</span>哈哈<span class="tag">&lt;/<span class="name">msg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="XML基本语法详解"><a href="#XML基本语法详解" class="headerlink" title="XML基本语法详解"></a>XML基本语法详解</h1><p>XML（Extensible Markup Language）是基于标签的语言，用于表示结构化的信息。它使用标签来定义、组织和引用数据，支持嵌套关系，使文档结构清晰明了。</p><p>以下是XML的基本语法及其组成部分：</p><ol><li>opening element<br>XML文件以一个特定的开始标签开头，通常为&lt;root&gt;，其中”root”是自定义的标签名称。根标签标识整个文档的开始，并且必须是一个有效且唯一的名字。</li></ol><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Tag names<br>XML中的每个元素由一个标签组成，通常包含名称和内容两部分。tag name表示元素的类型或名称。</li></ol><p>命名规则：</p><p>tag name必须是ASCII字符。<br>最多可以包含30个字符（字符编码为UTF-8）。<br>对于命名空间中的标签，应使用 xmlns&#x3D;”…”进行声明。<br>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element1</span>&gt;</span>内 容<span class="tag">&lt;/<span class="name">element1</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>标签嵌套<br>XML支持嵌套关系，允许在一个元素内部包含其他元素。这种结构通过嵌套的标签来表示。</li></ol><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span>子内容<span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>命名空间<br>为避免标签冲突（多个不同元素具有相同的名称），XML引入了命名空间的概念。使用 xmlns&#x3D;”…”指定一个唯一的标签集合，支持跨命名空间的引用。</li></ol><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;http://example.com/ns#element1&gt;根内容&lt;/http://example.com/ns#element1&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>自定义标签<br>XML允许创建自定义的新标签名称。这些标签必须在文件外部声明，并且通过 xmlns&#x3D;”…”指定。</li></ol><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ns:root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ns:child</span>&gt;</span>子内容<span class="tag">&lt;/<span class="name">ns:child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ns:root</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>注释<br>注释用于在文档中添加无关紧要的解释性说明，常见于示例或详细说明。</li></ol><p>单行注释</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是一个单行注释 --&gt;</span></span><br></pre></td></tr></table></figure><p>多行注释（仅限于XMLlight）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是一段多行注释 --&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li>自定义属性<br>在某些情况下，可以使用 name&#x3D;”value”的形式来附加信息到标签上。</li></ol><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;value&quot;</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br></pre></td></tr></table></figure><p>XML与HTML的区别<br>XML是标准化的结构化数据格式，常用于API开发和数据交换。<br>HTML主要用于网页的显示布局，强调内容可见性。<br>XML在结构上更灵活，可以嵌入其他数据类型。<br>总结：XML通过标签定义元素、嵌套关系和结构，提供清晰的数据组织方式。它支持扩展性和灵活性，适用于各种数据处理场景。</p><p>&lt;[CDATA]&gt;特殊字符实体化</p><p>遍历XML数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach($x-&gt;man as $v)&#123;</span><br><span class="line">    echo $v-&gt;name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加节点</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//创建节点</span><br><span class="line">$man=$x-&gt;addChild(&#x27;man&#x27;);</span><br><span class="line">//添加内容</span><br><span class="line">$man=$x-&gt;addChild(&#x27;name&#x27;,&#x27;you&#x27;);</span><br><span class="line">$man=$x-&gt;addChild(&#x27;age&#x27;,&#x27;19&#x27;);</span><br><span class="line"></span><br><span class="line">var——dump($x)</span><br><span class="line">//写入文件</span><br><span class="line">$x-&gt;asXML(.xml);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> XML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET Core配置系统</title>
      <link href="/2025/03/22/asp.net%20core/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"/>
      <url>/2025/03/22/asp.net%20core/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h1><p>.NET Core中提供了非常强大的配置系统以简化配置相关代码的编写方法。</p><h2 id="配置系统的基本使用"><a href="#配置系统的基本使用" class="headerlink" title="配置系统的基本使用"></a>配置系统的基本使用</h2><p>.NET Core中的配置系统支持非常丰富的配置源，包括文件（JSON、XML、INI等）、注册表、环境变量、命令行、Azure Key Vault等，<br>配置系统还支持自定义配置源。<br>.NET Core中读取配置有很多种方式，既可以通过IConfigurationRoot读取配置，也可以使用绑定的方式把配置读取为一个C#对象。</p><p>在项目根目录下添加一个JSON文件，命名为：config.json</p><p>因为程序在运行的时候默认加载EXE文件同文件夹下的配置文件，而不是项目中的config.json文件，所以我们需要把config.json文件设置为生成项目的时候自动被复制到生成目录。</p><p>.NET Core中配置系统的基础开发包是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.Extensions.Configuration,</span><br></pre></td></tr></table></figure><p>而读取JSON文件的开发包是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.Extensions.Configuration.Json</span><br></pre></td></tr></table></figure><p>,用NuGet安装这两个包。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUXIANYU&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="string">&quot;19&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Almango&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;proxy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;255.255.255.255&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;80&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>收到读取代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration.Json;</span><br><span class="line"></span><br><span class="line">ConfigurationBuilder configurationBuilder=<span class="keyword">new</span> ConfigurationBuilder();</span><br><span class="line">configurationBuilder.AddJsonFile(<span class="string">&quot;config.json&quot;</span>,optional:<span class="literal">false</span>,reloadOnChange:<span class="literal">true</span>);</span><br><span class="line">IConfigurationRoot configRoot= configurationBuilder.Build();</span><br><span class="line"><span class="built_in">string</span> name=configRoot[<span class="string">&quot;name&quot;</span>];</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;name=<span class="subst">&#123;name&#125;</span>&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> <span class="keyword">add</span>=configRoot.GetSection(<span class="string">&quot;proxy:address&quot;</span>).Value;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;address=<span class="subst">&#123;<span class="keyword">add</span>&#125;</span>&quot;</span>);</span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>绑定读取配置（*）<br>可以绑定一个类，自动完成配置的读取</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ConfigurationBuilder configurationBuilder=<span class="keyword">new</span> ConfigurationBuilder();</span><br><span class="line">configurationBuilder.AddJsonFile(<span class="string">&quot;config.json&quot;</span>,optional:<span class="literal">false</span>,reloadOnChange:<span class="literal">true</span>);</span><br><span class="line">IConfigurationRoot configRoot= configurationBuilder.Build();</span><br><span class="line"><span class="comment">/*string name=configRoot[&quot;name&quot;];</span></span><br><span class="line"><span class="comment">Console.WriteLine($&quot;name=&#123;name&#125;&quot;);</span></span><br><span class="line"><span class="comment">string add=configRoot.GetSection(&quot;proxy:address&quot;).Value;</span></span><br><span class="line"><span class="comment">Console.WriteLine($&quot;address=&#123;add&#125;&quot;);*/</span></span><br><span class="line"><span class="comment">/*Proxy proxy= configRoot.GetSection(&quot;proxy&quot;).Get&lt;Proxy&gt;();</span></span><br><span class="line"><span class="comment">Console.WriteLine($&quot;&#123;proxy.Address&#125;,&#123;proxy.Port&#125;&quot;);*/</span></span><br><span class="line">Config config = configRoot.Get&lt;Config&gt;();</span><br><span class="line">Console.WriteLine(config.Name);</span><br><span class="line">Console.WriteLine(config.Proxy.Port);</span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Config</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Add &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Address &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Proxy Proxy &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Proxy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Address &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Port &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConfigurationBuilder添加了一个待解析的配置文件。optional参数表示这个文件是否可选，如果它的值为trun,则当配置文件不存在的时候，程序不会报错；如果它的值为false,当配置文件不存在的时候，程序会报错。</p><p>IConfigurationRoot对象，我们能够通过他读取配置项，如果配置分级，也可以用“proxy：address”这种冒号分隔的方式读取配置项。</p><p>IConfigurationRoot中有一个GetConnectionString(string name)方法用于获取连接字符串，他读取“ConnectionStrings”节点下的名为name的值作为连接字符串。“ConnectionStrings”只是一个建议，不是.NET Core要求必须使用这个节点保存数据库连接字符串。</p><h2 id="使用选项方式读取配置"><a href="#使用选项方式读取配置" class="headerlink" title="使用选项方式读取配置"></a>使用选项方式读取配置</h2><p>使用选项方式读取配置是.NET Core中推荐的方式，因为他不及和依赖注入机制结合的更好，而且它可以实现配置修改后自动更新，用起来更方便。</p><blockquote><p>使用选项方式读取，和DI结合更好，且更好利用“reloadonchange”机制。<br>读取配置的时候，DI要声明IOptions&lt;T&gt;、IOptionsMonitor&lt;T&gt;、IOptionsSnapshot&lt;T&gt;等类型。IOptions&lt;T&gt;不会读取到新的值；和IOptionsMonitor相比，IOptionsSnapshot会在同一个范围内（比如ASP.NET Core一个请求中）保持一致。建议用IOptionsSnapshot。</p></blockquote><p>使用选项方式读取配置需要通过NuGet为项目安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.Extensions.Options</span><br></pre></td></tr></table></figure><p>由于这种方式是对绑定方式的封装，因此我们任然需要同时安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.Extensions.Configuration.Binder</span><br></pre></td></tr></table></figure><p>在读取配置的地方，用IOptionsSnapshot&lt;T&gt;注入。不要在构造函数里直接读取IOptionsSnapshot.Value,而是到用到的地方在读取，否则无法更新变化。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Logging&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;LogLevel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Warning&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;DB&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;DbType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SQLServre&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ConnectionString&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Data Source=.;Initial Catalog=DemoDB; Integrated Security=Ture&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Smtp&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;youxianyu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;UserName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zeng&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;AllowedHosts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>读取“DB”和“Smtp”这两部分<br>建立对应配置项的两个模型类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DbSettings</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> DbType &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ConnectionString &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SmtpSettings</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Server &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Username &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Password &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用选项方式读取配置的时候，需要和依赖注入一起使用，因此我们需要创建一个类用于获取注入的选项值。<br>声明接收选项注入的对象的类型不能直接使用DbSettings、SmtpSettings，而要使用IOptions&lt;T&gt;、IOptionsMonitor&lt;T&gt;、IOptionsSnapshot&lt;T&gt;等泛型接口类型，可以帮我们处理容器生命周期、配置刷新等。<br>IOptions&lt;T&gt;在配置改变后，我们不能读到新的值，必须重启程序才可以读到新的值；<br>IOptionsMonitor&lt;T&gt;在配置改变后，我们能读到新的值；IOptionsSnapshot&lt;T&gt;也是在配置改变后，我们能读到新的值，和IOptionsMonitor&lt;T&gt;不同的是，在同一个范围内IOptionsMonitor&lt;T&gt;会保持一致性。</p><p>由于IOptions&lt;T&gt;不监听配置的改变，因此它的资源占用会比较少，适用与对服务启动后就不会改变的值进行读取。由于IOptionsMonitor&lt;T&gt;可能会导致用一个请求过程中，配置的改变使读取同一个选项的值不一致，从而导致程序出错，因此如果我们需要在程序运行中读取修改后的值，建议使用IOptionsSnapshot&lt;T&gt;。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IOptionsSnapshot&lt;DbSettings&gt; optDbSettings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IOptionsSnapshot&lt;SmtpSettings&gt; optSmtpSettings;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span>(<span class="params">IOptionsSnapshot&lt;DbSettings&gt; optDbSettings, IOptionsSnapshot&lt;SmtpSettings&gt; optSmtpSettings</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.optDbSettings = optDbSettings;</span><br><span class="line">        <span class="keyword">this</span>.optSmtpSettings = optSmtpSettings;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> db=optDbSettings.Value;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;数据库：<span class="subst">&#123;db.DbType&#125;</span>,<span class="subst">&#123;db.ConnectionString&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> smtp = optSmtpSettings.Value;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;SMTP：<span class="subst">&#123;smtp.Server&#125;</span>,<span class="subst">&#123;smtp.Username&#125;</span>,<span class="subst">&#123;smtp.Password&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，通过构造方法注入IOptionsSnapshot<DbSettings>、IOptionsSnapshot<SmtpSettings>两个服务，我们可以通过IOptionsSnapshot&lt;T&gt;的Value属性获取DbSettings、SmtpSettings等具体配置模型对象的值。</p><p>编写注入服务到容器的代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Options;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration.Json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> 选项方式读取配置_ID;</span><br><span class="line"></span><br><span class="line">ConfigurationBuilder configBuilder= <span class="keyword">new</span> ConfigurationBuilder();</span><br><span class="line">configBuilder.AddJsonFile(<span class="string">&quot;config.json&quot;</span>, optional: <span class="literal">false</span>, reloadOnChange: <span class="literal">true</span>);</span><br><span class="line">IConfigurationRoot config = configBuilder.Build();</span><br><span class="line">ServiceCollection services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddOptions().Configure&lt;DbSettings&gt;(e=&gt;config.GetSection(<span class="string">&quot;DB&quot;</span>).Bind(e))</span><br><span class="line">    .Configure&lt;SmtpSettings&gt;(e=&gt; config.GetSection(<span class="string">&quot;SMTP&quot;</span>).Bind(e));</span><br><span class="line">services.AddSingleton&lt;Demo&gt;();</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> sp = services.BuildServiceProvider())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> scope = sp.CreateScope())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> spScope = scope.ServiceProvider;</span><br><span class="line">            <span class="keyword">var</span> demo = spScope.GetRequiredService&lt;Demo&gt;();</span><br><span class="line">            demo.Test();</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;按任意键继续...&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第2行代码中，把方法的reloadOnChange参数设定为true,以启动“修改后重新加载配置”的功能；在第5行代码中，通过AddOptions方法注册与选项相关的服务，然后使用第六行代码把DB节点的内容绑定到DbSettings类型的模型对象上。<br>由于IOptionsSnapshot&lt;T&gt;的生命周期为“范围”，因此Demo这个用与读取配置的类的生命周期不能是单例，我们在第8行代码中把Demo注册为瞬态服务。</p><h1 id="其他配置提供者"><a href="#其他配置提供者" class="headerlink" title="其他配置提供者"></a>其他配置提供者</h1><h2 id="命令行读取配置"><a href="#命令行读取配置" class="headerlink" title="命令行读取配置"></a>命令行读取配置</h2><p>配置框架还支持从命令行参数、环境变量等地方读取。<br>NuGet安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.Extensions.Configuration.CommandLine</span><br></pre></td></tr></table></figure><p>configBuilder.AddCommandLine(args)<br>参数支持多种格式，比如：server&#x3D;127、–server&#x3D;127.0.0.1、–server 127.0.0、（注意在键值之间加空格）、&#x2F;server&#x3D;127.0.0.1、&#x2F;server 127.0.0.1（主要在键值之间加空格）。格式不能混用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Options;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration.Json;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration.CommandLine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> 选项方式读取配置_ID;</span><br><span class="line">ServiceCollection services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddSingleton&lt;Demo&gt;();</span><br><span class="line">ConfigurationBuilder configBuilder= <span class="keyword">new</span> ConfigurationBuilder();</span><br><span class="line"></span><br><span class="line"><span class="comment">//configBuilder.AddJsonFile(&quot;config.json&quot;, optional: false, reloadOnChange: true);</span></span><br><span class="line">configBuilder.AddCommandLine(args);</span><br><span class="line">IConfigurationRoot config = configBuilder.Build();</span><br><span class="line">services.AddOptions().Configure&lt;DbSettings&gt;(e=&gt;config.GetSection(<span class="string">&quot;DB&quot;</span>).Bind(e))</span><br><span class="line">    .Configure&lt;SmtpSettings&gt;(e=&gt; config.GetSection(<span class="string">&quot;SMTP&quot;</span>).Bind(e));</span><br><span class="line">services.AddOptions().Configure&lt;nameSettings&gt;(e =&gt;config.Bind(e));</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> sp = services.BuildServiceProvider())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> scope = sp.CreateScope())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> spScope = scope.ServiceProvider;</span><br><span class="line">            <span class="keyword">var</span> demo = spScope.GetRequiredService&lt;Demo&gt;();</span><br><span class="line">            demo.Test();</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;按任意键继续...&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在项目的属性的<b>调试</b>中设置命令行参数，这样Visual Studio中调试、运行程序的时候，Visual Studio会自动把这里设定的参数以命令行参数的形式传递给程序。</p><h2 id="从环境变量读取配置"><a href="#从环境变量读取配置" class="headerlink" title="从环境变量读取配置"></a>从环境变量读取配置</h2><p>.NET Core中从环境变量读取配置需要安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.Extensions.Configuration.EnvironmentVariables</span><br></pre></td></tr></table></figure><p>然后调用AddEnvironmentVariables方法进行注册即可。AddEnvironmentVariables方法存在无参数和有prefix参数两个重载版本，无参数版本会将所有环境变量都加载进来，因此使用prefix参数的AddEnvironmentVartables重载方法进行注册。<br>prefix指的是环境变量名字的前缀。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConfigurationBuilder configBuilder= <span class="keyword">new</span> ConfigurationBuilder();</span><br><span class="line">configBuilder.AddEnvironmentVariables(<span class="string">&quot;TEST_&quot;</span>);</span><br><span class="line">IConfigurationRoot configRoot=configBuilder.Build();</span><br><span class="line"><span class="built_in">string</span> name =configRoot[<span class="string">&quot;Name&quot;</span>];</span><br><span class="line">Console.WriteLine(name);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LINQ学习</title>
      <link href="/2025/03/19/asp.net%20core/LINQ/"/>
      <url>/2025/03/19/asp.net%20core/LINQ/</url>
      
        <content type="html"><![CDATA[<h1 id="LINQ"><a href="#LINQ" class="headerlink" title="LINQ"></a>LINQ</h1><p>LINQ是.NET Core中提供的简化数据查询的技术。使用LINQ技术，可以用几行代码就实现复杂的数据查询。LINQ不仅可以对普通的.NET集合进行查询，而且在Entity Frameword Core中应用广泛，因此必须熟练掌握LINQ。</p><p>要想熟悉掌握LINQ就的熟悉掌握委托——&gt;Lambda——&gt;LINQ</p><p>委托的用法<br>委托类型规定了方法的返回值和参数的类型</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MyDelegate d1 = SayEnglish;</span><br><span class="line"><span class="built_in">string</span> s1 = d1(<span class="number">3</span>);</span><br><span class="line">Console.WriteLine(s1); <span class="comment">// Hello 3</span></span><br><span class="line">d1 = SayChinese;</span><br><span class="line"><span class="built_in">string</span> s2 = d1(<span class="number">10</span>);</span><br><span class="line">Console.WriteLine(s2); <span class="comment">// 你好 10</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">SayEnglish</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">$&quot;Hello <span class="subst">&#123;age&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">SayChinese</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">$&quot;你好 <span class="subst">&#123;age&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">int</span> n</span>)</span>;</span><br></pre></td></tr></table></figure><p>委托类型MyDelegate的变量d1可以指向与MyDelegate类型相容的方法，然后我们就可以像调用方法一样调用委托类型的变量。调用委托变量的时候执行的就是变量指向的方法。</p><p>在.NET中定义了最多可达16个参数的泛型类型委托Action(无返回值)和Fnc(有返回值)，因此一般我们不需要自定义委托类型，可以直接使用Action或者Func这两个委托类型。<br>委托变量不仅可以指向普通方法，也可以指向匿名方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">string</span>&gt; f1= <span class="built_in">delegate</span>(<span class="built_in">int</span> il, <span class="built_in">int</span> i2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">$&quot;<span class="subst">&#123;il&#125;</span>+<span class="subst">&#123;i2&#125;</span>=<span class="subst">&#123;il + i2&#125;</span>&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">string</span> s=f1(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">Console.WriteLine(s);</span><br></pre></td></tr></table></figure><p>定义匿名方法也可以采用Lambda表达式的语法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">string</span>&gt; f1= (il, i2) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">$&quot;<span class="subst">&#123;il&#125;</span>+<span class="subst">&#123;i2&#125;</span>=<span class="subst">&#123;il + i2&#125;</span>&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>俩段代码中,使用Lambda表达式,去掉了delegate关键字，并且省略了参数的数据类型，因为编译器能根据委托类型推断出参数的类型，然后用&#x3D;&gt;作为定义方法体的关键字。</p><p>但这段代码还可以进一步简化这些代码。如果&#x3D;&gt;之后方法体只有一行代码，并且方法有返回值，那么还可以省略方法体的花括号及return关键字。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">string</span>&gt; f1=(il,i2)=&gt;<span class="string">$&quot;<span class="subst">&#123;il&#125;</span>+<span class="subst">&#123;i2&#125;</span>=<span class="subst">&#123;il + i2&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure><p>方法没有返回值，方法体只有一个代码可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;<span class="built_in">int</span>,<span class="built_in">string</span>&gt; a1=(age,name)=&gt;Console.WriteLine(<span class="string">$&quot;年龄<span class="subst">&#123;age&#125;</span>,姓名<span class="subst">&#123;name&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果只有一个方法只有一个参数可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; f1=il=&gt;il*<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>Lambda表达式例子</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arrays=&#123;<span class="number">2</span>,<span class="number">8</span>,<span class="number">29</span>,<span class="number">19</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">99</span>,<span class="number">89</span>,<span class="number">105</span>,<span class="number">108</span>,<span class="number">81</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> nums2=MyWhere(arrays,n=&gt;n&gt;<span class="number">30</span>);</span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>,nums2));</span><br><span class="line"><span class="keyword">var</span> nums3 = MyWhere(arrays, n =&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>,nums3));</span><br><span class="line"><span class="function"><span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">MyWhere</span>(<span class="params">IEnumerable&lt;<span class="built_in">int</span>&gt; nums, Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; filter</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> n <span class="keyword">in</span> nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter(n)) <span class="keyword">yield</span> <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不用Lambda表达式，用匿名方法的写法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>,<span class="built_in">bool</span>&gt; f1= <span class="built_in">delegate</span>(<span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">30</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> nums2=MyWhere(arrays,f1);</span><br></pre></td></tr></table></figure><p>可见Lambda表达式让我们编写匿名方法更简单。</p><h1 id="LINQ-常用扩展方法"><a href="#LINQ-常用扩展方法" class="headerlink" title="LINQ 常用扩展方法"></a>LINQ 常用扩展方法</h1><p>LINQ中提供类似Where的扩展方法，简化数据处理。</p><h2 id="Where方法"><a href="#Where方法" class="headerlink" title="Where方法"></a>Where方法</h2><p>Where方法：每一项数据都会经过predicate的测试，如果针对一个元素，predicate执行的返回值为true,那么这个元素就会放到返回值中。<br>Where参数是一个lambda表达式格式的匿名方法，方法的参数e表示当前判断的元素对象。参数的名字不一定非要叫e，不过一般lambda表达式中的变量名长度都不长。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = <span class="keyword">new</span> List&lt;Employee&gt;();</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">1</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">28</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">10000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">2</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">18</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">20000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">3</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">20</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">30000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">4</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">22</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">40000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">5</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">24</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">50000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">6</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">26</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">60000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">7</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">27</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">70000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">8</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">19</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">80000</span> &#125;);</span><br><span class="line">IEnumerable&lt;Employee&gt; items1 = employees.Where(e =&gt; e.Age &gt; <span class="number">25</span>);</span><br><span class="line"><span class="keyword">foreach</span> (Employee e <span class="keyword">in</span> items1)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Gender &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;Id:<span class="subst">&#123;Id&#125;</span>,Name:<span class="subst">&#123;Name&#125;</span>,Age:<span class="subst">&#123;Age&#125;</span>,Gender=<span class="subst">&#123;Gender&#125;</span>,Salary=<span class="subst">&#123;Salary&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Count-方法：获取数据条数"><a href="#Count-方法：获取数据条数" class="headerlink" title="Count()方法：获取数据条数"></a>Count()方法：获取数据条数</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = <span class="keyword">new</span> List&lt;Employee&gt;();</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">1</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">28</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">10000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">2</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">18</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">20000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">3</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">20</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">30000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">4</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">22</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">40000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">5</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">24</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">50000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">6</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">26</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">60000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">7</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">27</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">70000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">8</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">19</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">80000</span> &#125;);</span><br><span class="line">IEnumerable&lt;Employee&gt; items1 = employees.Where(e =&gt; e.Age &gt; <span class="number">25</span>);</span><br><span class="line"><span class="keyword">foreach</span> (Employee e <span class="keyword">in</span> items1)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(employees.Count());</span><br><span class="line">Console.WriteLine(employees.Count(e=&gt;e.Age&gt;<span class="number">25</span>&amp;&amp;e.Salary&gt;<span class="number">50000</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Gender &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;Id:<span class="subst">&#123;Id&#125;</span>,Name:<span class="subst">&#123;Name&#125;</span>,Age:<span class="subst">&#123;Age&#125;</span>,Gender=<span class="subst">&#123;Gender&#125;</span>,Salary=<span class="subst">&#123;Salary&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Any-方法：是否至少有一条数据"><a href="#Any-方法：是否至少有一条数据" class="headerlink" title="Any()方法：是否至少有一条数据"></a>Any()方法：是否至少有一条数据</h2><p>满足条件返回true,不满足返回false</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(employees.Any(e=&gt;e.Salary&gt;<span class="number">80000</span>))</span><br><span class="line">Console.WriteLine(employees.Any(e=&gt;e.Salary&lt;<span class="number">10000</span>))</span><br></pre></td></tr></table></figure><h2 id="获取一条数据-LINQ中有4组获取一条数据的方法，分别是Single、SingleOrDefault、First和FirstOrDefault。"><a href="#获取一条数据-LINQ中有4组获取一条数据的方法，分别是Single、SingleOrDefault、First和FirstOrDefault。" class="headerlink" title="获取一条数据 LINQ中有4组获取一条数据的方法，分别是Single、SingleOrDefault、First和FirstOrDefault。"></a>获取一条数据 LINQ中有4组获取一条数据的方法，分别是Single、SingleOrDefault、First和FirstOrDefault。</h2><p>Single:如果确认有且只有一条满足要求的数据，那么就用Single方法。如果没有满足条件的数据，或条件的数据多于一条，Single方法就会抛出异常。</p><p>SingleOrDefault:如果确认最多只有一条满足要求的数据，那么就用SingleOrDefault方法。如果没有满足条件的数据，SingleOrDefault方法就会抛出异常。</p><p>First:如果满足条件的数据有一条或多条，First方法就会返回第一条数据；如果没有满足条件的数据，First方法就会抛出异常。</p><p>FirstOrDefault:如果满足条件的数据有一条或者多条，FirstOrDefault方法就会返回第一条数据；如果没有满足条件的数据，FirstOrDefault方法就会返回类型的默认值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = <span class="keyword">new</span> List&lt;Employee&gt;();</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">1</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">28</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">10000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">2</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">18</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">20000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">3</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">20</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">30000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">4</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">22</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">40000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">5</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">24</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">50000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">6</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">26</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">60000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">7</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">27</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">70000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">8</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">19</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">80000</span> &#125;);</span><br><span class="line"></span><br><span class="line">Employee e1 = employees.Single(e =&gt; e.Id == <span class="number">6</span>);</span><br><span class="line">Console.WriteLine(e1);</span><br><span class="line">Employee? e2 = employees.SingleOrDefault(e =&gt; e.Id == <span class="number">9</span>);</span><br><span class="line"><span class="keyword">if</span>(e2==<span class="literal">null</span>) Console.WriteLine(<span class="string">&quot;没有Id==9的数据&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> Console.WriteLine(e2);</span><br><span class="line">Employee e3 = employees.First(e =&gt; e.Age &gt; <span class="number">24</span>);</span><br><span class="line">Console.WriteLine(e3);</span><br><span class="line">Employee? e4 = employees.FirstOrDefault(e =&gt; e.Age &gt; <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (e4 == <span class="literal">null</span>) Console.WriteLine(<span class="string">&quot;没有大于30岁的数据&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> Console.WriteLine(e4);</span><br><span class="line">Employee e5 = employees.First(e =&gt; e.Salary &gt; <span class="number">99999</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Gender &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;Id:<span class="subst">&#123;Id&#125;</span>,Name:<span class="subst">&#123;Name&#125;</span>,Age:<span class="subst">&#123;Age&#125;</span>,Gender=<span class="subst">&#123;Gender&#125;</span>,Salary=<span class="subst">&#123;Salary&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>OrderBy方法可以对数据进行正向排序，而OrderByDescending方法则可以对数据继续逆向排序</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = <span class="keyword">new</span> List&lt;Employee&gt;();</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">1</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">28</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">10000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">2</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">18</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">20000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">3</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">20</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">30000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">4</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">22</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">40000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">5</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">24</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">50000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">6</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">26</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">60000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">7</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">27</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">70000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">8</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">19</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">80000</span> &#125;);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;--------按照年龄正序排列---------&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> orderedItems1 = employees.OrderBy(e =&gt; e.Age);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> orderedItems1)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;--------安照工资倒序排列---------&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> orderedIdems2 = employees.OrderByDescending(e =&gt; e.Salary);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> orderedIdems2)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Gender &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;Id:<span class="subst">&#123;Id&#125;</span>,Name:<span class="subst">&#123;Name&#125;</span>,Age:<span class="subst">&#123;Age&#125;</span>,Gender=<span class="subst">&#123;Gender&#125;</span>,Salary=<span class="subst">&#123;Salary&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限制结果集"><a href="#限制结果集" class="headerlink" title="限制结果集"></a>限制结果集</h2><p>限制结果集用来从集合中获取部分数据，其主要应用场景是分页查询，比如从第二页开始获取3条数据。<br>Skip(n)方法用于跳过n条数据，Take(n)方法用于获取n条数据。</p><p>Skip、Take方法也可以单独使用，employees.Skip(2)用于跳过2条数据,直到获取最后一条数据，反之employees.Take(2)获取前2条数据。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = <span class="keyword">new</span> List&lt;Employee&gt;();</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">1</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">28</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">10000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">2</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">18</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">20000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">3</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">20</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">30000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">4</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">22</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">40000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">5</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">24</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">50000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">6</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">26</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">60000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">7</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">27</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">70000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">8</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">19</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">80000</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> orderedItems3 = employees.Skip(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> orderedItems3)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> orderdItems4 = employees.Take(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> orderdItems4)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> orderdItems5 = employees.Skip(<span class="number">2</span>).Take(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> orderdItems5)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Gender &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;Id:<span class="subst">&#123;Id&#125;</span>,Name:<span class="subst">&#123;Name&#125;</span>,Age:<span class="subst">&#123;Age&#125;</span>,Gender=<span class="subst">&#123;Gender&#125;</span>,Salary=<span class="subst">&#123;Salary&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>在SQL中Max、Min、Avg、Sum、Count的聚合函数。LINQ中也有对应的方法，它们的名字分别是Max、Min、Average、Sum、Count,这些方法也可以和Where、Skip、Take等方法一起使用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = <span class="keyword">new</span> List&lt;Employee&gt;();</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">1</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">28</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">10000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">2</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">18</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">20000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">3</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">20</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">30000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">4</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">22</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">40000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">5</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">24</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">50000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">6</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">26</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">60000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">7</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">27</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">70000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">8</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">19</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">80000</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> maxAge = employees.Max(e =&gt; e.Age);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;最大年龄：<span class="subst">&#123;maxAge&#125;</span>&quot;</span>);</span><br><span class="line"><span class="built_in">long</span> minId = employees.Min(e =&gt; e.Id);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;最小Id：<span class="subst">&#123;minId&#125;</span>&quot;</span>);</span><br><span class="line"><span class="built_in">double</span> avgSalary = employees.Average(e =&gt; e.Salary);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;平均工资：<span class="subst">&#123;avgSalary&#125;</span>&quot;</span>);</span><br><span class="line"><span class="built_in">double</span> sumSalary = employees.Sum(e =&gt; e.Salary);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;工资总和：<span class="subst">&#123;sumSalary&#125;</span>&quot;</span>);</span><br><span class="line"><span class="built_in">int</span> count = employees.Count();</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;总条数：<span class="subst">&#123;count&#125;</span>&quot;</span>);</span><br><span class="line"><span class="built_in">int</span> minSalary2 = employees.Where(e =&gt; e.Age &gt; <span class="number">30</span>).Min(e =&gt; e.Salary);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;大于30岁的人群中的最低工资：<span class="subst">&#123;minSalary2&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Gender &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;Id:<span class="subst">&#123;Id&#125;</span>,Name:<span class="subst">&#123;Name&#125;</span>,Age:<span class="subst">&#123;Age&#125;</span>,Gender=<span class="subst">&#123;Gender&#125;</span>,Salary=<span class="subst">&#123;Salary&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果集合是int等值类型和集合，我们也可以使用没有参数的聚合函数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] scores = &#123; <span class="number">61</span>, <span class="number">90</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">38</span>, <span class="number">66</span>, <span class="number">80</span>, <span class="number">93</span>, <span class="number">55</span>, <span class="number">50</span>, <span class="number">89</span> &#125;;</span><br><span class="line"><span class="built_in">int</span> minScore = scores.Min();</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;最低成绩：<span class="subst">&#123;minScore&#125;</span>&quot;</span>);</span><br><span class="line"><span class="built_in">double</span> avgScore1 = scores.Where(i =&gt; i &gt; <span class="number">60</span>).Average();</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;合格成绩中的平局水平：<span class="subst">&#123;avgSalary&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>LINQ中支持类似于SQL中的GroupBy实现分组操作。GroupBy方法用来进行分组。<br>对序列中的元素进行分组。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;IGrouping&lt;TKey, TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(<span class="keyword">this</span> IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector);</span><br></pre></td></tr></table></figure><p>GroupBy方法的参数keySelector是分组条件表达式，GroupBy方法的返回值为IGrouping&lt;TKey, TSource&gt;类型的泛型IEnumerable。IGrouping是一个继承自IEnumerable的接口，IGrouping中唯一的成员就是Key属性，表示这一组的数据项。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = <span class="keyword">new</span> List&lt;Employee&gt;();</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">1</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">28</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">10000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">2</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">18</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">20000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">3</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">20</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">30000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">4</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">22</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">40000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">5</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">24</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">50000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">6</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">26</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">60000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">7</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">27</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">70000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">8</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">19</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">80000</span> &#125;);</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;IGrouping&lt;<span class="built_in">int</span>, Employee&gt;&gt; items = employees.GroupBy(e =&gt; e.Age);</span><br><span class="line"><span class="keyword">foreach</span> (IGrouping&lt;<span class="built_in">int</span>, Employee&gt; item <span class="keyword">in</span> items)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> age = item.Key;</span><br><span class="line">    <span class="built_in">int</span> count = item.Count();</span><br><span class="line">    <span class="built_in">int</span> maxSalary = item.Max(e =&gt; e.Salary);</span><br><span class="line">    <span class="built_in">double</span> avgSalary = item.Average(e =&gt; e.Salary);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;年龄：<span class="subst">&#123;item.Key&#125;</span>,人数：<span class="subst">&#123;count&#125;</span>,最高工资：<span class="subst">&#123;maxSalary&#125;</span>,平均工资：<span class="subst">&#123;avgSalary&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Gender &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;Id:<span class="subst">&#123;Id&#125;</span>,Name:<span class="subst">&#123;Name&#125;</span>,Age:<span class="subst">&#123;Age&#125;</span>,Gender=<span class="subst">&#123;Gender&#125;</span>,Salary=<span class="subst">&#123;Salary&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据性别进行分组</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = employees.GroupBy(e =&gt; e.Gender);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> items)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> gender = item.Key;</span><br><span class="line">    <span class="built_in">int</span> count = item.Count();</span><br><span class="line">    <span class="built_in">double</span> avgSalary = item.Average(e =&gt; e.Salary);</span><br><span class="line">    <span class="built_in">int</span> minAge = item.Min(e =&gt; e.Age);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;性别：<span class="subst">&#123;gender&#125;</span>,人数：<span class="subst">&#123;count&#125;</span>,平均值：<span class="subst">&#123;avgSalary:F&#125;</span>,最下年龄：<span class="subst">&#123;minAge&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于分组条件表达式用的bool类型的Gender属性，intem.Key就是bool类型。</p><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p>可以对集合使用Select方法进行投影操作，通俗来说就是把集合中的每一项逐项转换为另外一种类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = <span class="keyword">new</span> List&lt;Employee&gt;();</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">1</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">28</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">10000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">2</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">18</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">20000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">3</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">20</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">30000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">4</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">22</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">40000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">5</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">24</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">50000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">6</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">26</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">60000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">7</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">27</span>, Gender = <span class="literal">false</span>, Salary = <span class="number">70000</span> &#125;);</span><br><span class="line">employees.Add(<span class="keyword">new</span> Employee &#123; Id = <span class="number">8</span>, Name = <span class="string">&quot;Tim&quot;</span>, Age = <span class="number">19</span>, Gender = <span class="literal">true</span>, Salary = <span class="number">80000</span> &#125;);</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; ages = employees.Select(e =&gt; e.Age);</span><br><span class="line">Console.WriteLine(String.Join(<span class="string">&quot;,&quot;</span>,ages));</span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; names = employees.Select(e =&gt; e.Gender ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>,names));</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Gender &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;Id:<span class="subst">&#123;Id&#125;</span>,Name:<span class="subst">&#123;Name&#125;</span>,Age:<span class="subst">&#123;Age&#125;</span>,Gender=<span class="subst">&#123;Gender&#125;</span>,Salary=<span class="subst">&#123;Salary&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Select方法中使用匿名类型<br>使用Select方法从employees的每一项提取出Name、Age属性的值，并且把Gender转换为字符串,Select方法的返回值是一个匿名类型的IEnumerable类型，因此我们必须用var声明变量类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = employees.Select(e =&gt; <span class="keyword">new</span> &#123;e.Name, e.Age, XingBie = e.Gender ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>&#125;);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> items)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> name = item.Name;</span><br><span class="line">    <span class="built_in">int</span> age = item.Age;</span><br><span class="line">    <span class="built_in">string</span> xingbie = item.XingBie;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;名字=<span class="subst">&#123;name&#125;</span>,年龄=<span class="subst">&#123;age&#125;</span>,性别=<span class="subst">&#123;xingbie&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合转换"><a href="#集合转换" class="headerlink" title="集合转换"></a>集合转换</h2><p>集合操作的扩展方法的返回值大部分都是IEnumnerable&lt;T&gt;类型，但是有一些地方需要数组类型或者List&lt;T&gt;类型的变量，我们可以用ToArray和ToList方法分别把IEnumerable&lt;T&gt;转换为数组类型和List&lt;T&gt;类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee[] items1 = employees.Where(e =&gt; e.Salary &gt; <span class="number">30000</span>).ToArray();</span><br><span class="line">List&lt;Employee&gt; items2 = employees.Where(e =&gt; e.Salary &gt; <span class="number">3000</span>).ToList();</span><br></pre></td></tr></table></figure><h2 id="LINQ扩展方法的链式调用"><a href="#LINQ扩展方法的链式调用" class="headerlink" title="LINQ扩展方法的链式调用"></a>LINQ扩展方法的链式调用</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = employees.Where(e =&gt; e.Id &gt; <span class="number">2</span>).GroupBy(e =&gt; e.Age).OrderBy(g =&gt; g.Key).Take(<span class="number">3</span>)</span><br><span class="line">    .Select(g =&gt; <span class="keyword">new</span> &#123; Age = g.Key, Count = g.Count(), AvgSalary = g.Average(e =&gt; e.Salary) &#125;);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> items)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;年龄：<span class="subst">&#123;item.Age&#125;</span>,人数：<span class="subst">&#123;item.Count&#125;</span>,平均工资：<span class="subst">&#123;item.AvgSalary&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items1=employees.Where(e =&gt; e.Salary &gt; <span class="number">30000</span>).OrderBy(e=&gt;e.Age)</span><br><span class="line">    .Select(e =&gt; <span class="keyword">new</span> &#123;e.Name, e.Age, Gender = e.Gender ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><p>使用查询语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items2 = <span class="keyword">from</span> e <span class="keyword">in</span> employees</span><br><span class="line">    <span class="keyword">where</span> e.Salary &gt; <span class="number">3000</span></span><br><span class="line">    <span class="keyword">orderby</span> e.Age</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span> &#123; e.Name, e.Age, Gender = e.Gender ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步编程学习笔记</title>
      <link href="/2025/03/15/asp.net%20core/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2025/03/15/asp.net%20core/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要使用异步编程"><a href="#为什么要使用异步编程" class="headerlink" title="为什么要使用异步编程"></a>为什么要使用异步编程</h1><p>性能优化：</p><p>主线程利用率：异步编程允许主线程持续运行多个任务，避免因子线程阻塞而降低性能。<br>I&#x2F;O密集型任务处理：异步编程特别适合处理大量I&#x2F;O操作的任务，如文件读写、数据库查询等，这些操作可以独立于主线程运行，提升应用响应速度。<br>可扩展性：</p><p>多处理器支持：异步编程能够充分利用多处理器资源，每个CPU核同时处理不同的任务，从而提高系统的性能和稳定性。<br>高负载请求处理：在处理大量并发请求时，同步编程可能导致主线程被阻塞，而异步编程则能够有效地分担压力。<br>现代Web开发趋势：</p><p>技术兼容性：与主流Web框架（如React、Vue）的集成更加顺畅，使用async&#x2F;await关键字可以简化代码，提高开发效率。<br>用户体验提升：异步编程通过延迟加载等技术减少用户等待时间，提升应用体验。<br>资源利用效率：</p><p>多任务并行处理：主线程可以通过多线程或协 ordinates 执行多个任务，避免资源浪费，提高系统的吞吐量。<br>趋势适应性：</p><p>异步编程的流行：在现代应用开发中，异步编程因其简洁性和高效性而备受青睐，采用该模式可以与现有技术栈更好地结合。</p><h1 id="创建异步方法"><a href="#创建异步方法" class="headerlink" title="创建异步方法"></a>创建异步方法</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">await</span> DownloadHTmlAsync(<span class="string">&quot;http://www.ptpress.com.cn&quot;</span>, <span class="string">@&quot;E:\temp\1.txt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">DownloadHTmlAsync</span>(<span class="params"><span class="built_in">string</span> url,<span class="built_in">string</span> filename</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (HttpClient httpClient = <span class="keyword">new</span> HttpClient())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> html = <span class="keyword">await</span> httpClient.GetStringAsync(url);</span><br><span class="line">        <span class="keyword">await</span> File.WriteAllTextAsync(filename, html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>带返回值的<br>获取长度</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> I = <span class="keyword">await</span> DownloadHTmlAsync(<span class="string">&quot;http://www.ptpress.com.cn&quot;</span>, <span class="string">@&quot;E:\temp\1.txt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">DownloadHTmlAsync</span>(<span class="params"><span class="built_in">string</span> url,<span class="built_in">string</span> filename</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (HttpClient httpClient = <span class="keyword">new</span> HttpClient())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> html = <span class="keyword">await</span> httpClient.GetStringAsync(url);</span><br><span class="line">        <span class="keyword">await</span> File.WriteAllTextAsync(filename, html);</span><br><span class="line">        <span class="keyword">return</span> html.Length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>HttpClient: 提供一个类，用于从 URI 标识的资源发送 HTTP 请求和接收 HTTP 响应。<br>Flie: 提供用于创建、复制、删除、移动和打开单个文件的静态方法，并有助于创建 FileStream 对象。<br>GetStringAsync: 将 GET 请求发送到指定 URI 并在异步操作中以字符串的形式返回响应正文。</p></blockquote><blockquote><p>创建一个自定义的异步任务类：<br>创建一个继承自Task&lt; T &gt;的类，并在方法中添加[System.Threading.Await]或使用async关键字。</p></blockquote><blockquote><p>下载HTML内容：<br>在异步方法中，使用HttpClient来获取指定URL的HTML内容。这一步是非阻塞操作，不会阻塞主线程。</p></blockquote><blockquote><p>将HTML内容保存到文件：<br>使用File.WriteAllTextAsync将获取到的HTML内容写入指定的目标文件路径，并确保资源被正确关闭。</p></blockquote><h1 id="async-线程切换"><a href="#async-线程切换" class="headerlink" title="async 线程切换"></a>async 线程切换</h1><p>理解关键字“async”与“await”：</p><p>async用于定义一个可以执行异步操作的任务。<br>await用于等待该任务的完成。<br>线程切换的基本概念：</p><p>线程切换是程序运行时从一个线程切换到另一个线程的过程。<br>使用“async”和“await”，C#在主线程和异步任务之间自动进行线程切换。<br>await触发的线程切换过程：</p><p>当调用带有async关键字的任务，并使用await等待其完成时，C#会暂停主线程。<br>创建一个新的后台线程来执行该异步任务。<br>直到该后台线程完成或抛出异常，主线程才会重新启动。<br>嵌套使用“await”的情况：</p><p>在一个async任务内部再次调用另一个带有async和await的任务时，C#会创建新的线程并切换主从线程。<br>这种多层嵌套增强了代码的可读性和灵活性。<br>同步与错误处理：</p><p>await操作会阻塞主线程直到所有等待的任务完成或出现异常。<br>如果某个任务抛出异常，后续的所有await操作都会终止，并按照错误处理机制进行。<br>潜在的问题与优化：</p><p>当多个任务需要阻塞主线程时，可能会导致主线程被频繁切换，影响性能。这种情况下，可以考虑使用异步队列或其他结构来提高效率。<br>使用适当的同步和错误处理机制可以避免资源泄漏和其他潜在问题。<br>总结：</p><p>“async”与“await”通过自动管理线程切换，简化了编写异步操作的代码，提高了开发效率。<br>正确理解和使用这些关键字能够有效提升程序的性能和可维护性。</p><blockquote><p>await调用的等待期间，.NET会把当前的线程返回给线程池，等异步方法调用执行完毕后，框架会从线程池再取出来一个线程执行后续代码（不一定时同一个线程池）</p></blockquote><p>验证：在耗时异步（写入打字符串）操作前后分别打印线程Id</p><p>Thread.CurrentThread.ManagedThreadId获得当前线程Id。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    StringBuilder sb= <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sb.Append(<span class="string">&quot;youxianyu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> File.WriteAllTextAsync(<span class="string">@&quot;E:\temp\1.txt&quot;</span>, sb.ToString());</span><br><span class="line">    Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>总结：编译器把async拆分成多次方法调用，程序在运行的时候会通过线程池中取出空闲线程执行不同MoveNext调用的方法来避免线程的“空等”，从而提升系统的并发处理能力。</p><h1 id="异步方法不等于多线程"><a href="#异步方法不等于多线程" class="headerlink" title="异步方法不等于多线程"></a>异步方法不等于多线程</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;之前：&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    <span class="built_in">double</span> r=<span class="keyword">await</span> CalcAsync(<span class="number">500</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;r=<span class="subst">&#123;r&#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;之后：&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">double</span>&gt; <span class="title">CalcAsync</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">        Console.WriteLine(<span class="string">&quot;CalcAsync:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="built_in">double</span> result = <span class="number">0</span>;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n * n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result += rand.NextDouble();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步方法的代码并不会自动在新线程中执行，除非把代码放到新线程中执行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;之前：&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    <span class="built_in">double</span> r=<span class="keyword">await</span> CalcAsync(<span class="number">500</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;r=<span class="subst">&#123;r&#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;之后：&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">double</span>&gt; <span class="title">CalcAsync</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;CalcAsync:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="built_in">double</span> result = <span class="number">0</span>;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n * n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result += rand.NextDouble();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>可以看到Task.Run的线程ID和Main方法中的线程ID不同，这说明Task.Run中的代码被放到新线程中执行了。</p></blockquote><h1 id="为什么有的异步方法没标async"><a href="#为什么有的异步方法没标async" class="headerlink" title="为什么有的异步方法没标async"></a>为什么有的异步方法没标async</h1><p>有async</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> s1=<span class="keyword">await</span> ReadFileAsync(<span class="number">1</span>);</span><br><span class="line">    Console.WriteLine(s1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">ReadFileAsync</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> File.ReadAllTextAsync(<span class="string">&quot;e:/temp/1.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> File.ReadAllTextAsync(<span class="string">&quot;e:/temp/2.txt&quot;</span>);</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;num参数不正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有async<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> s1=<span class="keyword">await</span> ReadFileAsync(<span class="number">1</span>);</span><br><span class="line">    Console.WriteLine(s1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">ReadFileAsync</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> File.ReadAllTextAsync(<span class="string">&quot;e:/temp/1.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> File.ReadAllTextAsync(<span class="string">&quot;e:/temp/2.txt&quot;</span>);</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;num参数不正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>区别：<br>由于ReadFileAsync方法没有用async关键字修饰，因此我们没有看到ReadFileAsync方法的代码编译生成的类，ReadFileAsync内部也不像async方法那样复杂，而只是简单地调用File.ReadAllTextAsync方法。ReadFileAsync方法没有编译生成类，因此不会增加程序集的尺寸，而且运行效率更高。因此，如果一个异步方法只是对别的异步方法进行简单的调用，并没有太多复杂的逻辑，比如获取异步方法的返回值后再做进一步的处理，就可以去掉async、await关键字。</p><h2 id="不要用sleep"><a href="#不要用sleep" class="headerlink" title="不要用sleep"></a>不要用sleep</h2><p>如果想在异步编程方法中暂停一段时间，不要用Thread.Sleep(),因为它会阻塞调用线程，而要用await Task.Delay()。</p><p><img src="/img%5Cyouxin%5Casync.png"></p><h2 id="封装一个异步方法，下载给指定网址，如果下载失败，则稍等500ms再重试，如果重试三次仍然失败，则抛异常“下载失败”"><a href="#封装一个异步方法，下载给指定网址，如果下载失败，则稍等500ms再重试，如果重试三次仍然失败，则抛异常“下载失败”" class="headerlink" title="封装一个异步方法，下载给指定网址，如果下载失败，则稍等500ms再重试，如果重试三次仍然失败，则抛异常“下载失败”"></a>封装一个异步方法，下载给指定网址，如果下载失败，则稍等500ms再重试，如果重试三次仍然失败，则抛异常“下载失败”</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="keyword">await</span> ReadFileAsync(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">        Console.WriteLine(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">ReadFileAsync</span>(<span class="params"><span class="built_in">string</span> url, <span class="built_in">int</span> <span class="keyword">init</span>=<span class="number">0</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> html = <span class="keyword">await</span> httpClient.GetStringAsync(url);</span><br><span class="line">                <span class="keyword">return</span> html;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">init</span>++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">init</span> &gt;= <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;请求失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">await</span> Task.Delay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">await</span> ReadFileAsync(url, <span class="keyword">init</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;下载失败&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="用于获得提前终止执行的信号"><a href="#用于获得提前终止执行的信号" class="headerlink" title="用于获得提前终止执行的信号"></a>用于获得提前终止执行的信号</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">    cts.CancelAfter(<span class="number">3000</span>);</span><br><span class="line">    CancellationToken cToken= cts.Token;</span><br><span class="line">    <span class="keyword">await</span> DownLoadAsync(<span class="string">&quot;http://www.baidu.com&quot;</span>, <span class="number">10</span>,cts.Token);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">DownLoadAsync</span>(<span class="params"><span class="built_in">string</span> url, <span class="built_in">int</span> n, CancellationToken cancellationToken</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (HttpClient client = <span class="keyword">new</span> HttpClient())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> html = <span class="keyword">await</span> client.GetStringAsync(url);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;DateTime.Now&#125;</span>:<span class="subst">&#123;html&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (cancellationToken.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;请求被取消&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CancellationTokenSource:向 CancellationToken 发出应取消的信号。<br>CancelAfter:在此 CancellationTokenSource 上计划取消操作。<br>CancellationToken:传播应取消作的通知。<br>IsCancellationRequested:获取是否已为此令牌请求取消。</p></blockquote><h2 id="whenAll"><a href="#whenAll" class="headerlink" title="whenAll"></a>whenAll</h2><p>创建一个任务，该任务将在所有提供的任务完成时完成。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Task&lt;string&gt; t1= File.ReadAllTextAsync(@&quot;E:\temp\1.txt&quot;);</span></span><br><span class="line">    <span class="comment">//Task&lt;string&gt; t2 = File.ReadAllTextAsync(@&quot;E:\temp\2.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//string[] strs = await Task.WhenAll(t1, t2);</span></span><br><span class="line">    <span class="comment">//string a1= strs[0];</span></span><br><span class="line">    <span class="comment">//string a2 = strs[1];</span></span><br><span class="line">    <span class="comment">//Console.WriteLine(a1);</span></span><br><span class="line">    <span class="comment">//Console.WriteLine(a2);</span></span><br><span class="line">    <span class="built_in">string</span>[] files=Directory.GetFiles(<span class="string">@&quot;E:\temp&quot;</span>);</span><br><span class="line">    Task&lt;<span class="built_in">int</span>&gt;[] countTasks=<span class="keyword">new</span> Task&lt;<span class="built_in">int</span>&gt;[files.Length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; files.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> filename = files[i];</span><br><span class="line">        Task&lt;<span class="built_in">int</span>&gt; t= ReadCharsCount(filename);</span><br><span class="line">        countTasks[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span>[] counts=<span class="keyword">await</span> Task.WhenAll(countTasks);</span><br><span class="line">    <span class="built_in">int</span> c=counts.Sum();<span class="comment">//求和</span></span><br><span class="line">    Console.WriteLine(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">ReadCharsCount</span>(<span class="params"><span class="built_in">string</span> filename</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> s=<span class="keyword">await</span> File.ReadAllTextAsync(filename);</span><br><span class="line">    <span class="keyword">return</span> s.Length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>GetFiles:返回满足指定条件的文件的名称。<br>Directory:公开用于通过目录和子目录进行创建、移动和枚举的静态方法。 此类不能被继承。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web-API事件</title>
      <link href="/2025/03/08/JavaScript/%E4%BA%8B%E4%BB%B6/"/>
      <url>/2025/03/08/JavaScript/%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><p>理解事件监听的基本概念</p><p>事件监听是基于DOM节点的事件处理机制，允许在特定条件下触发用户自定义函数。<br>学习事件监听的三要素</p><p>触发源：事件发生的原因或条件。例如，“click”事件表示按钮被点击。<br>触发器：具体触发事件的那个DOM节点。例如，在document.getElementById(‘myButton’)中，’myButton’是触发器。<br>监听操作者：响应特定事件的代码或函数。例如，绑定在“click”事件上的回调函数。<br>实践实现事件监听</p><p>创建一个按钮元素并绑定事件监听：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myButton = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myButton&#x27;</span>);</span><br><span class="line">myButton.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按钮被点击了！&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><p>click事件：</p><p>触发条件：用户点击按钮、链接或其他元素。<br>应用场景：实现按钮点击功能、网页导航等。</p><p>doubleClick事件：</p><p>触发条件：用户双击按钮或元素。<br>应用场景：在需要区分单击和双击的场景中使用，如某些按钮设计要求不同的操作反应。</p><p>mousedown、mouseup、mouseup事件：</p><p>触发条件：键盘按下、保持按压以及释放键。<br>应用场景：处理键盘快捷键操作或特定的输入事件。</p><p>mousemove和mouseleave事件：</p><p>触发条件：鼠标悬停在或离开某个元素上。<br>应用场景：显示提示框、突出显示目标元素等。</p><p>mouseup事件：</p><p>触发条件：用户从键盘上释放按钮。<br>应用场景：适合处理需要在特定键释放后执行的操作，如加载图片或初始化某些功能。<br>通过绑定这些鼠标事件和回调函数，可以实现多种用户交互效果。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myButton&#x27;</span>);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;按钮被点击了！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;doubleClick&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;按钮被双击了！&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样，点击按钮时会显示“按钮被点击了！”，而双击则显示“按钮被双击了！”。</p><h2 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h2><p>焦点事件类型<br>焦点开始（focus）：</p><p>触发条件：用户点击某个元素并开始编辑它。<br>应用场景：突出显示目标元素，如在文本框上按下回车键时，光标会移至当前字段。</p><p>焦点结束（blur）：</p><p>触发条件：用户完成后停止对它的编辑或者退出页面。<br>应用场景：取消高亮显示，例如在输入字段末尾按回车键后，光标会移到下个字段或页面的某个地方。</p><p>焦点有效性（valid）：</p><p>触发条件：焦点丢失前检查元素是否依然有效。<br>应用场景：在表单提交时，确保所有字段都已填写完整并有效。</p><p>使用焦点事件<br>通过绑定这些事件，可以实现多种用户交互效果。例如：</p><p>示例 1：默认的焦点样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;textInput&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例 2：绑定焦点开始事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;textInput&#x27;</span>);</span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;focus&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;#ff99cc&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>示例 3：绑定焦点结束事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;textInput&#x27;</span>);</span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;blur&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>示例 4：绑定焦点有效性事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;textInput&#x27;</span>);</span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;valid&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;#ff99cc&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意事项<br>兼容性：不同浏览器对焦点事件的支持可能存在差异。确保在多浏览器环境中测试代码。<br>性能：频繁绑定和取消事件监听可能会影响性能，特别是在大量元素同时拥有焦点的情况下。</p><h1 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h1><p>为了实现用户点击按钮后，在短时间内显示输入字段的值并持续几秒的效果，我们可以使用键盘事件和setInterval函数。以下是详细的步骤：</p><p>创建HTML结构：<br>创建一个简单的网页，包含一个文本输入框和一个按钮。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;textInput&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;showInput()&quot;</span>&gt;</span>点击我看看<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>绑定键盘事件：<br>使用addEventListener绑定keydown事件到输入字段。在事件处理函数中，获取用户当前输入的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;textInput&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="variable language_">this</span>;</span><br><span class="line">    input.<span class="property">value</span> += e.<span class="property">key</span>; <span class="comment">// 例如加粗空格键会增加一个空格</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>绑定按钮点击事件：<br>在按钮的onclick事件中，调用新的函数showInput()，该函数负责显示当前输入值并设置时间间隔。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, showInput);</span><br></pre></td></tr></table></figure><p>实现即时反馈：<br>创建一个名为showInput的函数，它会使用setInterval每隔1秒调用自己以更新和显示输入内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;textInput&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> inputValue = input.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">updateInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">        input.<span class="property">value</span> = inputValue;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 设置时间间隔为1000毫秒，也就是1秒</span></span><br><span class="line">            <span class="built_in">setInterval</span>(updateInput, <span class="number">1000</span>);</span><br><span class="line">        &#125;, <span class="number">50</span>); <span class="comment">// 每次更新后等待50ms，避免频繁调用导致性能问题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">updateInput</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的脚本：<br>将上述步骤整合到一个JavaScript文件中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;textInput&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="variable language_">this</span>;</span><br><span class="line">    input.<span class="property">value</span> += e.<span class="property">key</span>; <span class="comment">// 添加输入字符</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, showInput);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;textInput&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> inputValue = input.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">updateInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">        input.<span class="property">value</span> = inputValue;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setInterval</span>(updateInput, <span class="number">1000</span>);</span><br><span class="line">        &#125;, <span class="number">50</span>); <span class="comment">// 等待50ms后设置间隔</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">updateInput</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试：</p><p>打开HTML文件。<br>用户输入一些字符，例如“Hello”然后回车。<br>点击按钮“点击我看看”，应该看到输入字段在1秒内自动更新并显示“Hello”。<br>优化性能：<br>在每次调用setInterval时设置一个50毫秒的延迟，避免频繁调用导致浏览器性能问题。</p><p>测试异常情况：</p><p>检查多个用户的连续输入是否会累积影响间隔。<br>确保即使在输入停止后，时间间隔也能正确释放。</p><h1 id="文本事件"><a href="#文本事件" class="headerlink" title="文本事件"></a>文本事件</h1><p>文本事件类型<br>根据MDNWeb Docs，textEvents 接口定义了以下四种事件：</p><p>focus：</p><p>触发条件：当某个元素的焦点被获取（即用户点击该元素）。<br>用途：在单个文本输入字段中快速切换焦点。<br>blur：</p><p>触发条件：当某个元素的模糊框消失或焦点离开时。<br>用途：在单个文本输入字段中快速取消焦点。<br>input：</p><p>触发条件：当用户开始输入字符（空格键后会立即激活）。<br>用途：捕获用户手动输入的字符序列。<br>output：</p><p>触发条件：当文本被复制到剪贴板或输出到指定位置时。<br>用途：捕获用户粘贴的内容。<br>实际应用示例<br>假设有一个简单的HTML页面，包含一个文本输入框和一个按钮。当用户点击按钮时，你会在输入字段中显示当前输入的值，并每隔一段时间重复一次效果（如上文中的“键盘事件”部分）。这里可以使用文本事件来实现即时反馈。</p><p>创建HTML结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>文本事件示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;textInput&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入您的内容...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;showText()&quot;</span>&gt;</span>显示文本<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建JavaScript脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;textInput&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, showText);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showText</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> text = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;textInput&#x27;</span>);</span><br><span class="line">    <span class="comment">// 使用setInterval每隔1秒调用函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">updateText</span>(<span class="params"></span>) &#123;</span><br><span class="line">        text.<span class="property">value</span> += <span class="string">&#x27; 输入内容：&#x27;</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setInterval</span>(updateText, <span class="number">500</span>);</span><br><span class="line">        &#125;, <span class="number">50</span>); <span class="comment">// 每次更新后等待50ms，避免频繁调用导致性能问题</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">updateText</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 完整代码<br>将上述步骤整合到一个完整的JavaScript文件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;textInput&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, showText);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showText</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> text = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;textInput&#x27;</span>);</span><br><span class="line">    <span class="comment">// 使用setInterval每隔1秒调用函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">updateText</span>(<span class="params"></span>) &#123;</span><br><span class="line">        text.<span class="property">value</span> += <span class="string">&#x27; 输入内容：&#x27;</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setInterval</span>(updateText, <span class="number">50</span>); <span class="comment">// 每次更新后等待50ms，避免频繁调用导致性能问题</span></span><br><span class="line">        &#125;, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">updateText</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化事件监听</span></span><br><span class="line"><span class="title function_">showText</span>();</span><br></pre></td></tr></table></figure><p> 测试效果<br>用户输入一些字符（例如“Hello”），然后按回车键。<br>点击按钮，“显示文本”按钮点击时，会在输入字段中看到即时反馈，并每隔1秒重复一次。</p><h1 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h1><p>获取事件对象的步骤<br>捕获事件：<br>使用适当的事件监听器来捕获特定类型的事件。例如，使用 onInput、onClick 等回调函数。</p><p>传递事件对象到回调函数：<br>当事件发生时，JavaScript 会将一个包含事件信息的实例传递给绑定的回调函数作为参数。这个参数即为事件对象。</p><p>访问事件属性：<br>使用事件对象的方法和属性来获取事件的具体信息。</p><p>示例：使用键盘事件获取事件对象<br>假设你有一个 keydown 事件监听器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleKeyPress</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// e 是一个键盘事件对象，包含以下属性：</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按下键的字符：&#x27;</span>, e.<span class="property">key</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按下键的时间（毫秒）：&#x27;</span>, e.<span class="property">time</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按下键的Unicode码点：&#x27;</span>, eunicodeCodePoint);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>const input &#x3D; document.getElementById(‘input’);<br>input.addEventListener(‘keydown’, handleKeyPress);<br>示例：使用文本事件获取事件对象<br>假设你有一个 textInput 的输入字段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;textInput&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, handleInput);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleInput</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// e 是一个 TextEvent 对象，包含以下属性：</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前输入内容为：&#x27;</span>, e.<span class="property">target</span>.<span class="property">value</span>);  <span class="comment">// 输出当前显示的文本内容</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发事件的时间（毫秒）：&#x27;</span>, e.<span class="property">time</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;事件来源的DOM元素：&#x27;</span>, e.<span class="property">target</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取事件对象的方法<br>通过回调函数传递事件对象：<br>在回调函数中，事件参数即为事件对象。你可以直接使用它来访问相关的属性和方法。</p><p>在事件监听器中获取事件对象：<br>有些事件监听器的构造函数（用于初始化事件）可以返回事件对象。例如，在 addEventListener 中，传入的回调函数本身就是一个事件监听器，它接收并处理触发事件时生成的事件实例。</p><p>示例：使用事件属性和方法<br>假设你有一个 click 事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击位置:&#x27;</span>, e.<span class="property">clientX</span>, <span class="string">&#x27;，&#x27;</span>，e.<span class="property">clientY</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发事件的DOM元素:&#x27;</span>, e.<span class="property">target</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;事件时间:&#x27;</span>, e.<span class="property">time</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>总结<br>通过在回调函数中传递事件对象，你可以利用 JavaScript 提供的各种属性和方法来获取和分析与事件相关的详细信息。这对于编写更复杂的互动应用非常有用。</p><p>文本事件中的事件对象提供了以下常用属性：</p><p>time：</p><p>获取事件发生的毫秒值。<br>value（仅适用于 input 事件）：</p><p>返回当前显示的文本内容。<br>sourceElement：</p><p>对应触发事件的具体元素，如点击或焦点变化时使用的元素。<br>blurEvent.sourceElement：</p><p>当模糊框消失或焦点离开时的触发元素。<br>text（仅适用于 output 事件）：</p><p>粘贴到剪贴板的内容。<br>这些属性可以通过在回调函数中传递事件对象来访问和分析，从而实现对文本输入、焦点管理和输出操作的详细监控和响应。</p><h1 id="环境对象"><a href="#环境对象" class="headerlink" title="环境对象"></a>环境对象</h1><p>目标：能够分析判断运行在不同环境中this所指代的对象</p><p>环境对象：指的是函数内部特殊的变量this，它代表着当前函数运行时所处的环境</p><p>作用：弄清楚this的指向，可以让我们代码更简洁</p><h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><p>事件流（Event Flow） 是一种程序执行的模式，特别是在处理复杂操作时。它是将任务分解为一系列事件的传递路径，确保每个步骤按顺序执行，并且能够有效地管理并行操作。</p><p>定义</p><p>事件流指的是在程序运行过程中，按照特定的顺序传递事件或任务，以便各个部分按需求完成其工作。它通过将任务分解为独立的事件处理，使程序更加灵活和易于管理。</p><p>核心思想</p><p>顺序性：每个事件必须按顺序执行。<br>并行性：允许在完成当前事件后，立即启动下一个事件。<br>可预测性：确保事件传递的路径是已知且固定的。</p><p>工作原理</p><p>事件流将任务分解为多个阶段，每个阶段对应一个事件。程序根据事件流的顺序执行这些阶段，确保每个阶段完成后才进行下一阶段的操作。</p><p>应用场景</p><p>复杂系统设计：在处理大量并行任务时，事件流能够有效地管理任务调度。<br>用户界面编程：用于分步完成操作，提高用户体验。<br>网络请求处理：将长任务分解为多个阶段，确保资源的高效利用。</p><p>优势</p><p>提升效率：通过明确的任务顺序，优化资源分配。<br>增强灵活性：支持任务的中断和恢复。<br>简化管理：每个事件独立处理，便于调试和维护。</p><p>实现方式</p><p>在编程中，可以使用循环或递归结构来模拟事件流。每次完成一个阶段后，自动启动下一个阶段，直到所有任务完成。</p><p>总结</p><p>事件流是一种高效的程序设计模式，通过将任务分解为独立的事件处理，确保顺序执行的同时，支持并行操作和灵活管理。它广泛应用于复杂系统的设计与实现中，有效提升了程序的效率和可靠性。</p><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>事件冒泡：全面解析与应用</p><p>定义与基本概念</p><p>事件冒泡是指在事件处理过程中，一个事件能够影响到比它更早触发的事件。这种机制允许我们在处理当前事件的同时，回溯并影响之前的事件，从而实现更加灵活和动态的交互。</p><p>事件冒泡的作用机制</p><p>事件传播：事件可以传递给父元素或上层组件，允许在多个层级之间共享状态。<br>事件优先级：浏览器根据事件的时间戳处理事件，确保先发生的事件先被处理。<br>事件回调：通过回调函数，可以在一个事件处理完成后，触发另一个事件的处理。<br>应用场景</p><p>动态布局调整：在响应式设计中，通过事件冒泡可以实时调整页面布局。<br>用户交互优化：例如，在滑动过程中实时更新相关元素的状态或信息。<br>组件间协作：多个组件之间通过事件冒泡传递状态和控制，实现协同工作。</p><p>实现示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleScroll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当前事件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前事件:&#x27;</span>, <span class="variable language_">window</span>.<span class="property">event</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯到父事件</span></span><br><span class="line">    <span class="keyword">let</span> event = <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">    <span class="keyword">while</span> (event.<span class="property">parentElement</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.<span class="property">parentElement</span>.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;myElement&#x27;</span>)) &#123;</span><br><span class="line">            event.<span class="property">parentElement</span>.<span class="property">style</span>改变；</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        event = event.<span class="property">parentElementEvent</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;处理后的事件:&#x27;</span>, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结<br>事件冒泡是一种强大的机制，使得前端开发变得更加灵活和高效。通过理解其基本原理和应用场景，开发者可以更好地设计响应式和交互丰富的网页界面。</p><h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>事件委托：全面解析与应用</p><p>定义与基本概念</p><p>“事件委托”是指一个组件或脚本将某个事件的处理权交给另一个组件、服务器端或其他处理逻辑。通过这种方式，可以在不同的层级之间共享和传递事件，实现更为灵活和复杂的交互。</p><p>事件委托的作用机制</p><p>事件转发：将当前事件的处理责任转移给另一个组件或服务。<br>协作处理：在多个组件协同工作时，通过事件委托实现信息共享和协同操作。<br>延迟响应：在某些情况下，事件被委托后，在后续的交互中再进行处理。</p><p>应用场景</p><p>动态布局调整：在响应式设计中，根据用户行为或系统状态实时调整页面布局。<br>用户交互优化：例如，在滑动过程中实时更新相关元素的状态或信息。<br>组件间协作：多个组件之间通过事件委托传递状态和控制，实现协同工作。</p><p>实现示例</p><p>在实际项目中，可以通过以下步骤实现事件委托：</p><p>定义需要转发的事件类型。<br>在目标组件或服务上注册该事件的处理函数。<br>在原组件或服务中触发此事件。</p><h1 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h1><p>选择事件 (querySelectorEvent)<br>定义：用于定位父元素的第一个子元素。<br>作用：在单击某个元素时，快速找到其第一个匹配的子元素，通常用于高阶选择操作（如多选框）。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">once</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span>, <span class="comment">// 3秒超时后放弃查找</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> selection = <span class="variable language_">document</span>.<span class="title function_">querySelectorEvent</span>(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;select&#x27;</span>, options);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (selection) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;选中子元素:&#x27;</span>, selection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件延迟（delayedEvent）<br>定义：用于将事件的处理延迟到后续操作完成后。<br>作用：在某个操作完成后才触发事件，避免重复或无效事件。<br>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里的 event 将被延迟到 timer 完成后触发</span></span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (timer === <span class="literal">undefined</span> || <span class="built_in">clearTimeout</span>(timer)) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事件组合（eventCombination）<br>定义：用于将多个事件合并为一个单一事件。<br>作用：简化逻辑，减少重复绑定和处理。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event1 = <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick);</span><br><span class="line"><span class="keyword">const</span> event2 = <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseover&#x27;</span>, onMouseOver);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击事件已处理&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onMouseOver</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;鼠标过上事件已处理&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以将两个事件合并为一个</span></span><br><span class="line">event1.<span class="title function_">handleCombination</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;同时点击和移动鼠标事件已处理&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事件重放（replayEvent）<br>定义：用于将特定事件重新触发，通常在模拟用户操作时使用。<br>作用：在某个元素失去焦点或其他状态后，重新触发原始事件。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 执行点击操作的逻辑</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按钮点击事件已处理&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在失去焦点时重放事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;losefocus&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">replay</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li>事件延迟与阻止（delayedBlock）<br>定义：用于将事件延迟到某个操作完成后，并在特定条件下阻止事件的触发。<br>作用：避免某些动作过早地响应用户操作，提升用户体验。</li></ol><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这个事件将在 timer 完成后被阻止</span></span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (timer === <span class="literal">undefined</span> || <span class="built_in">clearTimeout</span>(timer)) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.<span class="property">target</span>.<span class="property">value</span> === <span class="string">&#x27;按下&#x27;</span>) &#123;</span><br><span class="line">    e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事件过滤（eventFilter）</p><p>定义：用于判断事件是否需要被处理。<br>作用：在特定条件下避免触发事件，防止不必要的操作或异常。<br>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">target</span>.<span class="property">value</span> !== <span class="string">&#x27;按下&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按钮点击事件已处理&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 filter 阻止其他操作</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">eFilter</span>(e);</span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 处理事件</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不处理事件</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">event.<span class="property">filter</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;过滤器触发&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">target</span>.<span class="property">value</span>; <span class="comment">// 按下按钮才处理事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>事件跟踪（eventTracking）</p><p>定义：用于在 DOM 结构变化时动态绑定事件。<br>作用：避免因元素结构变化而导致的事件丢失或延迟。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加跟踪器</span></span><br><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick, &#123;</span><br><span class="line">  <span class="attr">once</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">targets</span>: [<span class="string">&#x27;button&#x27;</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击事件已处理&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构变化触发事件</span></span><br><span class="line">el.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;button&gt;按钮内容&lt;/button&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结构变化后的新点击事件已处理&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事件组合与延迟（eventCombinationAndDelay）<br>定义：用于将多个事件和延迟事件合并为一个单一的事件处理逻辑。<br>作用：简化代码，避免重复绑定和处理。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 延迟事件</span></span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (timer === <span class="literal">undefined</span> || <span class="built_in">clearTimeout</span>(timer)) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按钮点击事件已处理&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventCombination = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组合事件触发&#x27;</span>);</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 其他逻辑</span></span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="title function_">eventCombinationAndDelay</span>(e, <span class="function">() =&gt;</span> &#123; <span class="comment">// 迟延事件的处理</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组合与延迟事件已处理&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>总结<br>“其他事件”主要指除了 DOM 事件 外的事件类型，主要用于更复杂的交互逻辑或特定场景的处理。掌握这些事件可以帮助开发者更好地控制用户操作、优化用户体验，并实现跨组件的协作功能。</p><p>选择事件：用于高阶选择操作。<br>延迟事件：用于延迟事件处理。<br>事件组合：用于合并多个事件为一个。<br>事件重放：用于在失去焦点时重新触发事件。<br>事件过滤：用于在特定条件下避免触发事件。<br>事件跟踪：用于动态绑定事件。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web-API学习一</title>
      <link href="/2025/03/06/JavaScript/APIs/"/>
      <url>/2025/03/06/JavaScript/APIs/</url>
      
        <content type="html"><![CDATA[<h1 id="Web-API-基本认知"><a href="#Web-API-基本认知" class="headerlink" title="Web API 基本认知"></a>Web API 基本认知</h1><h3 id="作用和分类"><a href="#作用和分类" class="headerlink" title="作用和分类"></a>作用和分类</h3><p>作用：就是使用JS去操作HTML和浏览器</p><p>分类：DOM（文档对象模型）、BOM（浏览器对象模型）</p><h3 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h3><p>DOM（Document Object Model———— 文档对象模型）是用来呈现以及任意HTML或XML文档交互的API</p><p>白话文：DOM是浏览器提供的一套专门用来操作网页内容的功能<br>开发网页内容特效和实现用户交互</p><h3 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h3><p><img src="/img%5Cjs%5CDOM.png"></p><h3 id="DOM对象（重要）"><a href="#DOM对象（重要）" class="headerlink" title="DOM对象（重要）"></a>DOM对象（重要）</h3><p><b>DOM对象：浏览器根据html标签生成的JS对象</b></p><p>所有的标签属性都可以在这个对象上面找到<br>修改这个对象的属性会自动映射到标签身上</p><p><b>DOM的核心思想</b></p><p>把网页内容当做对象来处理</p><p><b>document对象</b></p><p>是DOM里提供的一个对象<br>所以它提供的属性和方法都是来访问和操作网页内容的<br>网页所有内容都在document里面</p><h1 id="获取DOM元素"><a href="#获取DOM元素" class="headerlink" title="获取DOM元素"></a>获取DOM元素</h1><h3 id="根据CSS选择器来获取DOM元素"><a href="#根据CSS选择器来获取DOM元素" class="headerlink" title="根据CSS选择器来获取DOM元素"></a>根据CSS选择器来获取DOM元素</h3><p>查询特定或所有DOM节点：</p><p>使用querySelector方法查找特定标签的节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headingNode = dom.<span class="title function_">querySelector</span>(<span class="string">&#x27;h1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用querySelectorAll方法获取所有DOM节点，适用于需要遍历和处理多个节点的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> allElements = dom.<span class="title function_">querySelectorAll</span>();</span><br></pre></td></tr></table></figure><p>参数：<br>包含一个或多个有效的CSS选择器字符串</p><p>返回值：<br>CSS选择器匹配的第一个元素，一个HTMLElement对象。</p><h1 id="操作元素内容"><a href="#操作元素内容" class="headerlink" title="操作元素内容"></a>操作元素内容</h1><p>能够修改元素的文本更换内容</p><p>DOM对象都是根据标签生成的，所以操作标签，本质上就是操作DOM对象<br>就是操作对象使用的点语言</p><p><b>.innerText属性</b></p><p>将文本内容添加&#x2F;更新到任意标签位置<br>显示纯文本，不解析标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    &lt;title&gt;<span class="title class_">Document</span>&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>我是文字内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//1.获取元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> box =<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//2.修改文字内容 对象。innerText 属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">innerText</span>) <span class="comment">//获取文字内容</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    box.<span class="property">innerText</span>=<span class="string">&#x27;我是一个盒子&#x27;</span><span class="comment">//修改文字内容</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><b>.innerHTML属性</b></p><p>innerHTML 属性<br>获取元素内容最简单的方法是使用 innerHTML 属性。<br>innerHTML 属性可用于获取或替换 HTML 元素的内容。<br>innerHTML 属性可用于获取或改变任何 HTML 元素，包括 <html> 和 <body>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>我是文字内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//1.获取元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> box =<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// //2.修改文字内容 对象。innerText 属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// console.log(box.innerText) //获取文字内容</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// box.innerText=&#x27;我是一个盒子&#x27;//修改文字内容</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//3.innerHTML 解析标签</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">innerHTML</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    box.<span class="property">innerHTML</span>=<span class="string">&#x27;&lt;b&gt;我要更换&lt;/b&gt;&#x27;</span> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="操作元素常用属性"><a href="#操作元素常用属性" class="headerlink" title="操作元素常用属性"></a>操作元素常用属性</h3><p>还可以通过JS设置&#x2F;修改标签元素属性，比如通过src更换图片<br>最常见的属性比如：href、title、src等</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取元素</span></span><br><span class="line"><span class="keyword">const</span> pic=<span class="variable language_">document</span>.<span class="title function_">querSelector</span>(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line"><span class="comment">//2.操作元素</span></span><br><span class="line">pic.<span class="property">src</span>=<span class="string">&#x27;&#x27;</span></span><br><span class="line">pic.<span class="property">tltle</span>=<span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>页面随机获取图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./&quot;</span><span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//取到N~M的随机整数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">function</span> <span class="title function_">getRandom</span>(<span class="params">N,M</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*(M-N+<span class="number">1</span>))+N</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//1.获取图片对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> img =<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//2.随机得到序号</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> random =<span class="title function_">getRandom</span>(<span class="number">1</span>,<span class="number">6</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//3.更换路径</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        img.<span class="property">src</span>=<span class="string">`./<span class="subst">$&#123;random&#125;</span>`</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="操作元素样式属性"><a href="#操作元素样式属性" class="headerlink" title="操作元素样式属性"></a>操作元素样式属性</h3><p>还可以通过JS设置&#x2F;修改标签元素的样式属性<br>比如通过滚轮图小圆点自动更换颜色样式</p><p><b>通过style属性操作CSS</b></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    &lt;style&gt;</span><br><span class="line">        .<span class="property">box</span>&#123;</span><br><span class="line">            <span class="attr">width</span>: 200px;</span><br><span class="line">            <span class="attr">height</span>: 200px;</span><br><span class="line">            background-<span class="attr">color</span>: aqua;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//1.获取元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> box=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//2.修改样式属性 对象.style.样式属性=&#x27;值+单位&#x27; </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        box.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&#x27;300px&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        box.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&#x27;300px&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//多组单词的采取 小驼峰命名法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        box.<span class="property">style</span>.<span class="property">backgroundColor</span>=<span class="string">&#x27;hotpink&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        box.<span class="property">style</span>.<span class="property">border</span>=<span class="string">&#x27;2px solid blue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><b>操作类名（className）操作CSS</b></p><p>操作类名（className）操作CSS<br>如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助于css类名的形式</p><p>注意：<br>由于class是关键字，所以使用className去代替<br>className是使用新值换旧值，如果需要添加一个类，需要保留之前的类名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    &lt;style&gt;</span><br><span class="line">        div&#123;</span><br><span class="line">            <span class="attr">width</span>: 200px;</span><br><span class="line">            <span class="attr">height</span>: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="property">box</span>&#123;</span><br><span class="line">            <span class="attr">width</span>: 300px;</span><br><span class="line">            <span class="attr">height</span>: 300px;</span><br><span class="line">            background-<span class="attr">color</span>: aqua;</span><br><span class="line">            <span class="attr">margin</span>: 100px auto;</span><br><span class="line">            <span class="attr">padding</span>: 10px;</span><br><span class="line">            <span class="attr">border</span>: 1px solid #<span class="number">000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//1.获取元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> div =<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//2.添加类名  class 是关键字 </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        div.<span class="property">className</span>=<span class="string">&#x27;box&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><b>通过classLidt操作类控制CSS</b></p><p>为了解决className容易覆盖以前的类名，我们可以通过classList方式追加和删除类名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    &lt;style&gt;</span><br><span class="line">        .<span class="property">box</span>&#123;</span><br><span class="line">            <span class="attr">width</span>: 200px;</span><br><span class="line">            <span class="attr">height</span>: 200px;</span><br><span class="line">            <span class="attr">color</span>: aqua;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="property">active</span>&#123;</span><br><span class="line">            <span class="attr">color</span>: aquamarine;</span><br><span class="line">            background-<span class="attr">color</span>: bisque;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//通过classList添加</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//1.获取元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//2.修改样式</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//追加类add()  类名不加点，并且是字符串</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        box.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//删除类 remove() 类名不加点，并且是字符串</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        box.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;box&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//切换类 toggle() 有就删掉，没有就加上</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        box.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;active&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="操作表单元素-属性"><a href="#操作表单元素-属性" class="headerlink" title="操作表单元素 属性"></a>操作表单元素 属性</h3><p>表单很多情况吗，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框<br>正常的有属性有取值的 跟其他的标签属性没有任何区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;电脑&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//1.获取元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> uname=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//2.获取值 获取表单里面的值 用的 uname.value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(uname.<span class="property">value</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//3.设置表单的值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    uname.<span class="property">value</span>= <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    uname.<span class="property">type</span>=<span class="string">&#x27;password&#x27;</span>     </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>复选框<br>比如：disabled、checked、selected</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;checked&quot;</span> name=<span class="string">&quot;&quot;</span> id=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ipt = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ipt.<span class="property">checked</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line"></span><br><span class="line">button.<span class="property">disabled</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p><b>自定义属性：</b><br>在html5中推出来了专门的data-自定义属性<br>在标签上一律以dataset对象方式获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">data-spm</span>=<span class="string">&quot;youxianyu&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-id</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-id</span>=<span class="string">&quot;3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-id</span>=<span class="string">&quot;4&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-id</span>=<span class="string">&quot;5&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> one = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(one.<span class="property">dataset</span>.<span class="property">id</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(one.<span class="property">dataser</span>.<span class="property">spm</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="间歇函数"><a href="#间歇函数" class="headerlink" title="间歇函数"></a>间歇函数</h3><p>定时器函数可以开启和关闭定时器</p><p>1.开启定时器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(函数，间隔时间)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeat</span>(<span class="params"></span>)&#123;</span><br><span class="line">    consoloe.<span class="title function_">log</span>(<span class="string">&#x27;youxianyu&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(repeat,<span class="number">1000</span>)</span><br><span class="line">========================</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;youxianyu&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>2.关闭定时器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer=<span class="built_in">setInterval</span>(函数，间隔时间)</span><br><span class="line"><span class="built_in">clearInterval</span>(变量名)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;youxianyu&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">clearInterval</span>(timer)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础阶段三</title>
      <link href="/2025/03/03/JavaScript/%E5%87%BD%E6%95%B0/"/>
      <url>/2025/03/03/JavaScript/%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数的概念与作用"><a href="#函数的概念与作用" class="headerlink" title="函数的概念与作用"></a>函数的概念与作用</h1><p>函数是程序中的一种基本结构，它允许我们把一组代码封装成一个独立的单位，并通过特定的名称调用这个单元。函数的作用主要有以下几点：</p><p>提高代码复用性: 将重复或相似的操作封装到一个函数中，可以避免代码冗余。<br>增强逻辑清晰度: 通过将具体操作抽象为函数，可以更清楚地表达程序的功能。<br>组织代码结构: 复杂的逻辑可以通过多个函数的调用来实现。</p><p>函数的基本定义</p><p>在JavaScript中，函数可以通过function关键字定义。一个基本的函数定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体内的操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;  <span class="comment">// 定义一个接受参数 `name` 的函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);  <span class="comment">// 执行特定操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的调用</p><p>一旦定义了一个函数，就可以通过调用来执行其中的操作。调用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">greet</span>(<span class="string">&quot;Alice&quot;</span>);  <span class="comment">// 调用 `greet` 函数，并传递参数 `&quot;Alice&quot;`</span></span><br></pre></td></tr></table></figure><p>注意事项:</p><p>必须在函数定义之前调用函数。<br>调用时可以不提供参数（如果函数没有默认参数），但必须遵循函数的定义。<br>函数的作用域与变量</p><p>JavaScript中的函数属于全局作用域，这意味着函数体内使用的变量会被视为全局变量。不过，为了更好地管理代码，我们可以使用以下方法：</p><p>使用括号()强制调用: 这可以避免某些特殊情况下全局作用域的识别。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>)) &#123;  <span class="comment">// 使用括号强制调用函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明确指定作用域: 使用const或let关键字定义变量时，可以指定其作用域。</p><p>函数的参数与返回值<br>参数传递<br>函数可以通过接受参数来接收外部的数据。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">greet</span>(<span class="string">&quot;Alice&quot;</span>);  <span class="comment">// 输出: &quot;Hello, Alice&quot;</span></span><br></pre></td></tr></table></figure><p>如果函数没有定义参数，也可以直接调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">greet</span>();  <span class="comment">// 输出: &quot;Hello, &quot;</span></span><br></pre></td></tr></table></figure><p>返回值<br>JavaScript的默认返回值是undefined。要让函数返回特定值，可以使用return关键字。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;  <span class="comment">// 返回两个数相乘的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="title function_">multiply</span>(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 结果为 `12`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);          <span class="comment">// 输出: &quot;12&quot;</span></span><br></pre></td></tr></table></figure><p>函数的高级特性<br>除了基本功能，JavaScript还支持一些更高级的功能：</p><ol><li>默认参数<br>可以在函数定义中为参数提供默认值。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name = <span class="string">&quot;World&quot;</span></span>) &#123;  <span class="comment">// 如果没有传递参数，则 `name` 的值为 `&quot;World&quot;`</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时：</p><p>调用一次，不传参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">greet</span>();  <span class="comment">// 输出: &quot;Hello, World&quot;</span></span><br></pre></td></tr></table></figure><p>调用两次，传参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">greet</span>(<span class="string">&quot;Alice&quot;</span>);  <span class="comment">// 输出: &quot;Hello, Alice&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>可选参数<br>可以定义函数接受任意数量的参数。</li></ol><p>使用…args接收多余参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">acceptAnyArgs</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args.<span class="property">length</span> + <span class="string">&#x27; arguments passed&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">acceptAnyArgs</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 输出: &quot;3 arguments passed&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>函数的表达式形式<br>可以将函数直接写成一个表达式：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">multiply</span> = (<span class="params">a, b</span>) =&gt; a * b;  <span class="comment">// 定义一个乘法函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiply</span>(<span class="number">2</span>, <span class="number">3</span>));      <span class="comment">// 输出: 6</span></span><br></pre></td></tr></table></figure><ol start="4"><li>闭包<br>闭包是指一个函数在执行过程中能够访问外部变量或内部变量的技术。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params">n</span>) &#123;  <span class="comment">// 内部函数可以访问 `x`</span></span><br><span class="line">        <span class="keyword">return</span> x + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">outer</span>(<span class="number">5</span>)(<span class="number">3</span>);  <span class="comment">// 输出: &quot;8&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);       <span class="comment">// 输出: undefined (因为 result 已被赋值，实际应输出 &quot;8&quot;)</span></span><br></pre></td></tr></table></figure><p>函数的常见使用场景<br>处理重复任务</p><p>如果需要多次执行相同的操作，可以通过函数将代码封装起来。<br>数据转换</p><p>对输入数据进行某种变换或计算，例如排序、统计等。<br>异步操作</p><p>使用 Promises 或 async&#x2F;await关键字时，通常会定义为 async function 并使用await关键字调用。<br>模块化代码</p><p>将逻辑拆分成多个函数，使得代码更易维护。<br>总结<br>函数是 JavaScript 编程中非常重要的基础概念。掌握如何定义和调用函数，能够显著提高代码的可读性和复用性。通过理解函数的基本知识和高级特性，你可以更好地编写高效的代码。</p><p>匿名函数的基本概念<br>匿名函数可以用来解决以下几种情况：</p><p>不需要为函数命名：当一个函数只需要在非常短的时间内使用时，没有必要定义一个命名函数。<br>避免名称冲突：通过不定义名字，可以避免与其他函数或变量产生命名冲突。<br>处理回调函数：匿名函数特别适合用于处理需要传递的回调函数（Callback）。<br>匿名函数的语法<br>匿名函数可以通过以下两种方式定义：</p><ol><li>使用 function 关键字<br>最传统的定义匿名函数的方式是使用 function 关键字：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greeting = <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的 greeting 函数是一个匿名函数，没有名称。</p><ol start="2"><li>使用 ES6 引擎的箭头函数语法<br>现代 JavaScript 提供了一种更简洁的方式来定义匿名函数，这就是 ES6 引入的 箭头函数（arrow function）：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">greeting</span> = (<span class="params">name</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>匿名函数的优势<br>无需声明函数名称：匿名函数不需要为函数起名字，因此可以避免命名冲突。<br>灵活性高：匿名函数可以立即定义并执行，适合处理复杂或动态生成的逻辑。<br>安全：匿名函数不会污染命名空间，避免全局变量的使用问题。<br>匿名函数的常见用途<br>回调函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The sum is <span class="subst">$&#123;a + b&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">func</span>(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 输出：8</span></span><br></pre></td></tr></table></figure><p>处理函数参数的默认值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a, b=<span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>)); <span class="comment">// 输出：2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出：5</span></span><br></pre></td></tr></table></figure><p>匿名函数的命名空间问题<br>因为匿名函数没有显式的名称，所以在 declare 语句中不会被记录到命名空间中。它们会被执行时的当前作用域所隔离。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Outer function: &#x27;</span> + outer2); <span class="comment">// 报错：Cannot read property &#x27;outer2&#x27; of null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inner function: &#x27;</span> + inner.<span class="property">name</span>); <span class="comment">// 报错：Cannot read property &#x27;name&#x27; of null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> anonymous = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Anonymous function: &#x27;</span> + (anonymous.<span class="property">name</span> || <span class="string">&#x27;No name&#x27;</span>)); </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">anonymous = <span class="title function_">outer</span>(); <span class="comment">// 输出：Anonymous function: No name</span></span><br></pre></td></tr></table></figure><p>总结<br>匿名函数 是一种非常灵活且有用的工具，特别适合在处理回调函数或需要临时定义的函数时使用。<br>使用箭头函数可以让匿名函数更简洁、高效。<br>匿名函数不会污染命名空间，因此在复杂的场景中可以更好地控制作用域问题。</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>理解对象的概念：</p><p>对象是将多种数据以键值对的形式封装在一起的数据结构。例如，学生对象包含了学号、姓名和成绩等信息。<br>创建对象的方法：</p><p>使用大括号初始化：const obj &#x3D; { name: “张三”, age: 18 };<br>键必须在值前面，以区分键名和值，并确保语法正确。<br>增删查改操作：</p><p>增：</p><p>使用 obj[newKey] &#x3D; value; 来添加新属性。例如：person.name &#x3D; “小明”;<br>查：</p><p>直接访问属性：obj.keyName<br>引用访问属性：obj[‘keyName’]，后者更灵活，适用于字符串键名的变更。<br>删：</p><p>使用 delete obj[key]; 或者 obj[key] &#x3D; undefined; 来删除属性。删除后需重新赋值以恢复属性。<br>改：</p><p>直接赋值：obj[key] &#x3D; value<br>赋值新对象：obj[key] &#x3D; { … }; 适用于嵌套结构。<br>实例应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">score</span>: [<span class="number">90</span>, <span class="number">85</span>, <span class="number">76</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="property">name</span>); <span class="comment">// 输出：张三</span></span><br><span class="line"><span class="keyword">delete</span> student.<span class="property">score</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="property">score</span>); <span class="comment">// 输出：undefined</span></span><br><span class="line">student.<span class="property">address</span> = &#123; <span class="attr">street</span>: <span class="string">&quot;北京&quot;</span>, <span class="attr">house</span>: <span class="string">&quot;东直门&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础阶段一</title>
      <link href="/2025/03/01/JavaScript/%E7%AE%80%E4%BB%8B/"/>
      <url>/2025/03/01/JavaScript/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript介绍"><a href="#JavaScript介绍" class="headerlink" title="JavaScript介绍"></a>JavaScript介绍</h1><h2 id="JavaScript（是什么？）"><a href="#JavaScript（是什么？）" class="headerlink" title="JavaScript（是什么？）"></a>JavaScript（是什么？）</h2><p>是一种运行在客户端（浏览器）的编程语言，实现人机交互效果。</p><h2 id="作用（做什么？）"><a href="#作用（做什么？）" class="headerlink" title="作用（做什么？）"></a>作用（做什么？）</h2><p>—— 网页特效（监听用户的一些行为让网页作出对应的发馈）<br>—— 表单验证（针对表单数据的合法性进行判断）<br>—— 数据交互（获取后台的数据，渲染到前端）</p><h2 id="js初体验"><a href="#js初体验" class="headerlink" title="js初体验"></a>js初体验</h2><p><img src="/img%5Cjs%5CSnipaste_2025-02-27_18-47-48.png"></p><p><b>JavaScript的书写位置</b></p><blockquote><p>JavaScript可以放在body部分也可以放在head部分</p></blockquote><p><b>外部 JavaScript 的优势</b></p><blockquote><p>在外部文件中放置脚本有如下优势：<br>分离了 HTML 和代码<br>使 HTML 和 JavaScript 更易于阅读和维护<br>已缓存的 JavaScript 文件可加速页面加载</p></blockquote><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>Window.alert(message（返回值）)方法</p><p><b>参数：message</b><br>显示在对话框中的字符串，传入其他类型值，也会转会成字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;Hello workd!&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>外部引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="comment">//外部引用</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/My.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>示例</p><p><img src="/img%5Cjs%5CSnipaste_2025-02-27_20-47-30.png"></p><h2 id="JavaScript-显示方案"><a href="#JavaScript-显示方案" class="headerlink" title="JavaScript 显示方案"></a>JavaScript 显示方案</h2><p>JavaScript 能够以不同方式“显示”数据：</p><p>使用 window.alert() 写入警告框<br>使用 document.write() 写入 HTML 输出<br>使用 innerHTML 写入 HTML 元素<br>使用 console.log() 写入浏览器控制台</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">```HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;&#x27;</span>).<span class="property">innerHtml</span>=<span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="JavaScript-关键词"><a href="#JavaScript-关键词" class="headerlink" title="JavaScript 关键词"></a>JavaScript 关键词</h1><p>JavaScript 语句常常通过某个关键词来标识需要执行的 JavaScript 动作。</p><p><img src="/img%5Cjs%5CSnipaste_2025-02-28_12-34-10.png"></p><h1 id="JavaScript-变量"><a href="#JavaScript-变量" class="headerlink" title="JavaScript 变量"></a>JavaScript 变量</h1><ol><li>变量声明<br>在 JavaScript 中，您可以使用 let、const 和 var 关键字来声明变量。</li></ol><p>let: 这是最常见的关键字，用于临时声明变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>; <span class="comment">// 变量 name 是一个字符串类型的值 25</span></span><br></pre></td></tr></table></figure><p>const: 该关键字用于最终声明变量。一旦赋值给 const，您就不能再修改该变量的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14159</span>; <span class="comment">// 变量 PI 是一个数字类型的值 3.14159</span></span><br></pre></td></tr></table></figure><p>var: 该关键字用于声明全局变量。不过，由于 var 的使用频率非常高，现在很少使用它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="string">&quot;Hello, World!&quot;</span>; <span class="comment">// 变量 greeting 是一个字符串类型的值 Hello, World!</span></span><br></pre></td></tr></table></figure><ol start="2"><li>变量类型</li></ol><p>JavaScript 不强制指定变量的类型。您可以在声明时直接赋值给变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>; <span class="comment">// num 是数字类型</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// name 是字符串类型</span></span><br></pre></td></tr></table></figure><p>如果在没有明确类型的情况下，JavaScript 会根据赋值的内容推断变量的类型。</p><ol start="3"><li>变量的作用域<br>全局变量: 使用 let 或 var 声明的变量属于全局作用域。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出是 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量: 使用 let 和函数括号 () 声明的变量属于该函数的作用域（局部作用域）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出是 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>块级变量: 使用 const 声明的变量属于该块级元素的作用域（块级作用域）。</p><ol start="4"><li>变量的赋值</li></ol><p>JavaScript 提供多种方式来赋值给变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接赋值</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作数运算符</span></span><br><span class="line"><span class="keyword">let</span> b = a; <span class="comment">// b 和 a 是同一个变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = a + <span class="number">5</span>; <span class="comment">// c = 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="literal">undefined</span>; <span class="comment">// 变量未被赋值，默认为 `undefined`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> e = <span class="literal">null</span>; <span class="comment">// 特殊情况，表示空对象或空值</span></span><br></pre></td></tr></table></figure><ol start="5"><li>注意事项</li></ol><p>JavaScript 的变量是弱引用，这意味着它们存储的是内存地址，而不是直接的值。如果主线程中的脚本退出，这些变量会丢失。</p><p>使用 let 和 const 声明变量时，默认情况下会在全局作用域或当前块级中声明变量。</p><p>示例代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量声明和赋值示例</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14159</span>; <span class="comment">// 最终声明变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">const</span> greeting = <span class="string">&quot;Hello!&quot;</span>; <span class="comment">// 块级常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 输出：25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">PI</span>);   <span class="comment">// 输出：3.14159</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JavaScript 的变量系统非常灵活，允许您在运行时动态地声明和修改变量。使用 let 和 const 是现代 JavaScript 开发中常用的实践，它们分别用于临时变量和最终声明变量。</p><h2 id="JavaScript-数组"><a href="#JavaScript-数组" class="headerlink" title="JavaScript 数组"></a>JavaScript 数组</h2><h3 id="一、数组的创建与初始化"><a href="#一、数组的创建与初始化" class="headerlink" title="一、数组的创建与初始化"></a>一、数组的创建与初始化</h3><p>空数组<br>初始化一个空数组非常简单，可以通过以下方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = []; <span class="comment">// 创建一个空数组</span></span><br></pre></td></tr></table></figure><p>初始化数组</p><p>使用[]构造函数初始化数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [](); <span class="comment">// 初始化一个空数组</span></span><br></pre></td></tr></table></figure><p>将多个元素放入数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;橘子&#x27;</span>]; <span class="comment">// 直接将元素赋值给数组</span></span><br></pre></td></tr></table></figure><p>利用字符串拆分<br>可以通过split()方法将一个字符串按指定分隔符分割成多个元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;one,two,three&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>); <span class="comment">// 结果：[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</span></span><br></pre></td></tr></table></figure><p>推、弹出和删除数组</p><p>使用push()向数组末尾添加元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">push</span>(<span class="string">&#x27;apple&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用pop()移除并返回数组最后一个元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastElement = arr.<span class="title function_">pop</span>(); <span class="comment">// 返回&#x27;apple&#x27;</span></span><br></pre></td></tr></table></figure><p>使用unshift()移除并返回数组第一个元素（只能添加到数组头部）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstElement = arr.<span class="title function_">unshift</span>(<span class="string">&#x27;banana&#x27;</span>); <span class="comment">// 结果：[&#x27;banana&#x27;, &#x27;one&#x27;]</span></span><br></pre></td></tr></table></figure><p>数组长度属性<br>获取或设置数组的长度：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>); <span class="comment">// 输出当前数组长度</span></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">3</span>; <span class="comment">// 将数组长度设为3</span></span><br></pre></td></tr></table></figure><p>处理超出索引范围的情况</p><p>使用arr[undefined]或arr[number outside of bounds]时会返回undefined：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">10</span>]); <span class="comment">// 输出undefined（假设arr有3个元素）</span></span><br></pre></td></tr></table></figure><p>要避免这样的问题，可以使用for…of循环或者检查索引的有效性。</p><h3 id="二、数组的遍历与操作"><a href="#二、数组的遍历与操作" class="headerlink" title="二、数组的遍历与操作"></a>二、数组的遍历与操作</h3><p>使用for…in循环<br>对数组中的每个键进行遍历：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// 输出：0, 1, 2等数字索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用forEach()方法<br>遍历并执行某个函数操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第<span class="subst">$&#123;index&#125;</span>个元素是：<span class="subst">$&#123;element&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>条件遍历与过滤</p><p>使用filter()创建一个新的数组，包含所有符合条件的元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> evenNumbers = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>); <span class="comment">// 筛选出偶数</span></span><br></pre></td></tr></table></figure><p>find()和findIndex()方法用于查找满足条件的第一个元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstEven = arr.<span class="title function_">find</span>(<span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>高阶数组操作</p><p>map()：创建一个新数组，将原数组中的每个元素转换成新的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squaredNumbers = arr.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num * num); <span class="comment">// 筛选出平方后的数</span></span><br></pre></td></tr></table></figure><p>reduce()（或fold）：将数组中的所有元素依次累积，得到一个单一的返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, current</span>) =&gt;</span> acc + current, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>遍历索引与值对</p><p>使用indexOf()和lastIndexOf()方法查找特定值的位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index = arr.<span class="title function_">indexOf</span>(<span class="string">&#x27;apple&#x27;</span>); <span class="comment">// 查找第一个出现的&#x27;apple&#x27;</span></span><br><span class="line"><span class="keyword">let</span> lastIndex = arr.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;banana&#x27;</span>); <span class="comment">// 查找最后一个出现的&#x27;banana&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="三、数组的扩展与裁剪"><a href="#三、数组的扩展与裁剪" class="headerlink" title="三、数组的扩展与裁剪"></a>三、数组的扩展与裁剪</h3><p>数组扩展</p><p>使用unshift()将元素添加到数组头部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">unshift</span>(<span class="string">&#x27;new element&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用push()或直接赋值的方式在数组末尾增加元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">push</span>(<span class="string">&#x27;add element&#x27;</span>); <span class="comment">// 或者 arr = [1,2,3];</span></span><br></pre></td></tr></table></figure><p>数组裁剪<br>通过截取操作符（…）移除数组中的某些元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArr = [...arr, <span class="string">&#x27;a&#x27;</span>, ...arr]; <span class="comment">// 在原数组末尾添加与之相同的元素</span></span><br></pre></td></tr></table></figure><p>删除重复项<br>使用unique()方法去除数组中所有重复的值，保留第一个出现的位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uniqueArray = arr.<span class="title function_">unique</span>(); <span class="comment">// 去除重复项并返回新数组</span></span><br></pre></td></tr></table></figure><h3 id="四、处理特殊情况"><a href="#四、处理特殊情况" class="headerlink" title="四、处理特殊情况"></a>四、处理特殊情况</h3><p>空值和无效索引</p><p>使用hasOwnProperty()检查是否是自己具有的属性，避免访问不存在的元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;index&#x27;</span>)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用for…of循环遍历数组<br>对数组中的每个元素进行处理，较为简洁和高效的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决NaN类型的问题<br>遇到无法被转换为数字的字符串时，使用Number()函数或强制类型转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="title class_">Number</span>(<span class="string">&#x27;apple&#x27;</span>); <span class="comment">// 结果：NaN（表示无效）</span></span><br></pre></td></tr></table></figure><p>避免数组未初始化问题<br>使用|| null强制进行类型转换和赋值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="literal">undefined</span> || arr[<span class="literal">undefined</span>] ? <span class="string">&#x27;默认值&#x27;</span> : <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h3 id="五、优化与性能考虑"><a href="#五、优化与性能考虑" class="headerlink" title="五、优化与性能考虑"></a>五、优化与性能考虑</h3><p>避免重复计算<br>在频繁操作数组时，尽量提前处理数据或缓存结果，减少不必要的计算。</p><p>使用内置方法代替循环<br>对于需要遍历和操作的情况，优先使用forEach(), map(), filter()等内置方法，这些方法经过优化，比自定义循环更高效。</p><p>避免不必要的数组创建<br>多次使用push()或unshift()会导致多个小数组合并成一个大数组，可以考虑一次性完成所有操作。</p><p>处理多维数组时的性能优化<br>如果频繁操作二维或三维数组，可以尝试将它们转换为单维数组处理，并根据具体需求进行分析和优化。</p><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>创建与初始化：灵活使用[], push(), unshift()等方法。<br>遍历：利用for…in, forEach(), indexOf(), lastIndexOf()等方法高效处理数组元素。<br>高阶操作：熟练运用map(), filter(), reduce(), find()和findIndex()进行复杂的数据转换与查询。<br>扩展与裁剪：合理使用数组扩展和裁剪方法，避免不必要的重复计算。</p><h2 id="使用-const-关键字声明变量"><a href="#使用-const-关键字声明变量" class="headerlink" title="使用 const 关键字声明变量"></a>使用 const 关键字声明变量</h2><p>使用 const 关键字声明的变量是不可变的，一旦赋值后不能再被修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">PI</span>); <span class="comment">// 输出: 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">PI</span> = <span class="string">&quot;2&quot;</span>; <span class="comment">// 这条语句会报错，因为 `const` ·· declare immutable variable</span></span><br></pre></td></tr></table></figure><p>使用 !+ 运算符和 let 关键字<br>使用 !+ 运算符可以强制变量为数值类型，但仍然可以通过后续赋值来修改其值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = !+ <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 将字符串转为数字并存储到 `greeting` 变量中。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting); <span class="comment">// 输出: 72（&#x27;H&#x27;的ASCII码）</span></span><br><span class="line"></span><br><span class="line">greeting = !+ <span class="string">&quot;World&quot;</span>; <span class="comment">// 可以修改变量值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting); <span class="comment">// 输出: 87</span></span><br></pre></td></tr></table></figure><p>使用 var 关键字<br>使用 var 关键字声明的变量在现代JavaScript中不被推荐，因为它可能导致代码不可变。建议使用 const 或 let。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span>; <span class="comment">// 这条语句会报错，因为 `var` declare immutable variable</span></span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>在JavaScript中，“常量”通常指的是使用 const 关键字声明的不可变变量。<br>使用 !+ 运算符可以在当前语境下强制变量为数值类型，但并不阻止后续赋值修改该变量的值。</p><h2 id="js数据类型分为两大类"><a href="#js数据类型分为两大类" class="headerlink" title="js数据类型分为两大类"></a>js数据类型分为两大类</h2><p>Primitive 类型：</p><p>这些是不可变的数据类型，包括：<br>number（数字）<br>string（字符串）<br>boolean（布尔值）<br>null<br>undefined<br>symbol（符号值）<br>map（映射）<br>Object 对象：</p><p>这些是可变的，可以包含属性，并且在运行时可以被修改。构造出来的对象属于这一类。<br>详细说明：<br>Primitive 类型：这些是不可变的值，一旦赋值后无法再改变。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">5</span>; <span class="comment">// 原始数值类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num); <span class="comment">// 输出: &quot;number&quot;</span></span><br></pre></td></tr></table></figure><p>Object 对象：这些是可以被修改和扩展的对象。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// 输出: &quot;John&quot;</span></span><br></pre></td></tr></table></figure><p>注意事项：<br>null 和 undefined 是两种不同的值，null 表示没有值，而 undefined 表示变量未被赋值。<br>symbol 类型主要用于性能优化和不可变属性的实现。</p><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串（Template Literals）</p><p>定义：一种语法糖，允许在字符串内直接嵌入表达式或变量，而无需使用拼接符或其他方法手动拼接。<br>语法结构：使用反斜杠\$开始模板字符串，并在其内部插入变量或表达式的计算结果。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用模板字符串拼接输出</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Name is <span class="subst">$&#123;name&#125;</span> and age is <span class="subst">$&#123;age&#125;</span>`</span>); <span class="comment">// 输出: Name是Alice，age是30</span></span><br></pre></td></tr></table></figure><p>优势：简化手动拼接字符串的操作，提高代码的简洁性和可读性。</p><p>注意事项：</p><p>反斜杠前面要加反斜杠（如\$）以表示模板字符串开始。<br>忽略符号问题时，记得检查引号和反斜杠是否匹配。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>JavaScript 可以将不同类型的数据相互转换：</p><p>使用 typeof 操作符可以获取变量的类型。<br>使用布尔值 (true&#x2F;false) 可以强制类型转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str); <span class="comment">// 输出: &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str === <span class="number">42</span>); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="string">&quot;3.14&quot;</span>; <span class="comment">// 字符串到数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num + <span class="string">&quot; + 5 = &quot;</span> + (num + <span class="number">5</span>)); <span class="comment">// 输出: 8.14</span></span><br></pre></td></tr></table></figure><ol start="3"><li>布尔值和 NaN<br>NaN 表示“不是一个数字”，它是一个特殊的数值类型。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span>); <span class="comment">// 输出: NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> === <span class="title class_">NaN</span>); <span class="comment">// 输出: false (因为NaN不能比较)</span></span><br></pre></td></tr></table></figure>布尔值 (true&#x2F;false) 是特殊类型的变量，它们是 boolean 类型。</li></ol><p>隐式转换（Implicit Conversion）和显式转换（Explicit Conversion）是JavaScript中处理数据类型时的两种方式。以下是它们的区别及示例：</p><h3 id="隐式转换："><a href="#隐式转换：" class="headerlink" title="隐式转换："></a>隐式转换：</h3><p>定义： 隐式转换是指在编程过程中，不同数据类型的变量或值会自动地转换为相同的数据类型，以便进行运算或操作。<br>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式转换示例 1: 字符串和数字相加</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;5&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a + <span class="number">3</span>); <span class="comment">// 输出是&quot;8&quot;</span></span><br></pre></td></tr></table></figure><p>这里，“5”被隐式地转换为数字5，然后与3相加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式转换示例 2: 字符串比较</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b &gt; <span class="string">&quot;banana&quot;</span>); <span class="comment">// 输出是false</span></span><br></pre></td></tr></table></figure><p>这里，“apple”被隐式地转换为字符串“apple”，与“banana”进行比较。</p><h3 id="显式转换："><a href="#显式转换：" class="headerlink" title="显式转换："></a>显式转换：</h3><p>定义： 显式转换是指通过特定的函数或运算符将数据从一种类型强制转换到另一种类型。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式转换示例 1: 使用Number()函数将字符串转换为数字</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="string">&quot;7&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(c)); <span class="comment">// 输出是7</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式转换示例 2: 使用强制类型转换运算符++</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+“<span class="number">5</span>”); <span class="comment">// 输出是5</span></span><br><span class="line"><span class="variable constant_">JAVASCRIPT</span></span><br><span class="line"><span class="comment">// 显式转换示例 3: 使用parseInt()将字符串转换为整数</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="string">&quot;10&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(d, <span class="number">10</span>)); <span class="comment">// 输出是10</span></span><br></pre></td></tr></table></figure><p>总结：</p><p>隐式转换在编程过程中自动发生，无需额外的代码。它适用于运算和比较操作。<br>显式转换需要通过特定函数或运算符来完成，可以更精确地控制数据类型，但可能增加代码复杂性。</p><h2 id="逻辑运算符与优先级"><a href="#逻辑运算符与优先级" class="headerlink" title="逻辑运算符与优先级"></a>逻辑运算符与优先级</h2><h3 id="值解释（Value-Interpretation）"><a href="#值解释（Value-Interpretation）" class="headerlink" title="值解释（Value Interpretation）"></a>值解释（Value Interpretation）</h3><p>在 JavaScript 中，许多操作都会涉及对不同类型的值进行“值解释”。这种解释过程确保运算可以在统一的数据类型下执行。</p><p>示例：</p><p>比较运算符：当使用 &#x3D;&#x3D; 或 &#x3D;&#x3D;&#x3D; 进行比较时，JavaScript 会将两个操作数转换为相同的数据类型（通常是数值或字符串）后再进行比较。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;5&quot;</span> == <span class="number">5</span>); <span class="comment">// 输出：true (值解释)</span></span><br></pre></td></tr></table></figure><p>字符串拼接：当使用 + 运算符将一个数值和一个字符串相加时，JavaScript 会将数值转换为字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> + <span class="string">&quot;2&quot;</span>); <span class="comment">// 输出：&quot;5&quot;</span></span><br></pre></td></tr></table></figure><p>布尔运算：在条件运算中（如 &amp;&amp;, ||, 和 !），JavaScript 会将某些值解释为布尔值。例如，数字、空字符串、数组等会被转换为 true 或 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> || <span class="string">&quot;hello&quot;</span>); <span class="comment">// 输出：&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p>总结：</p><p>值解释确保运算可以在一致的数据类型下执行。<br>不同类型的值在运算中会自动转换，但这种转换是隐式的，不是显式的。</p><h3 id="逻辑运算符的优先级"><a href="#逻辑运算符的优先级" class="headerlink" title="逻辑运算符的优先级"></a>逻辑运算符的优先级</h3><p>JavaScript 的逻辑运算符 (&amp;&amp;, ||, 和 !) 的优先级低于算术、比较和字符串操作符。理解这一点可以帮助你准确预测表达式的执行顺序。</p><p>示例：<br>以下表达式中，typeof null 和 typeof undefined 分别会被计算为 “object” 和 “undefined”：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">&#x27;undefined&#x27;</span>; <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure><p>运算符优先级总结（从高到低）：<br>算术运算符 (+, -, *, &#x2F;, %, ** 等)<br>比较运算符 (&gt;, &lt;, &#x3D;&#x3D;, &#x3D;&#x3D;&#x3D;, !&#x3D;, !&#x3D;&#x3D;)<br>运算符 (&amp;, |, ^, ~)<br>字符串操作符 ([], ., () 等)<br>逻辑运算符 (&amp;&amp;, ||, !)<br>括号</p><p>示例：</p><p>以下表达式的执行顺序遵循运算符的优先级：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> + <span class="number">3</span> &gt; <span class="number">5</span> &amp;&amp; <span class="string">&quot;10&quot;</span> &lt; <span class="string">&quot;2&quot;</span>); <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure><p>首先计算 2 + 3（结果为 5）。<br>然后比较 5 &gt; 5，结果为 false。<br>最后执行逻辑与运算 (&amp;&amp;)，因为前一个条件为 false，整个表达式的结果为 false。</p><h3 id="运算符优先级总结"><a href="#运算符优先级总结" class="headerlink" title="运算符优先级总结"></a>运算符优先级总结</h3><p>以下是 JavaScript 中主要运算符的优先级（从高到低）：</p><p>算术运算符：<br>+, -, *, &#x2F;, %, **<br>比较运算符：<br>&lt;, &gt;, &#x3D;&#x3D;, &#x3D;&#x3D;&#x3D;, !&#x3D;, !&#x3D;&#x3D;<br>运算符：<br>&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;,<br>字符串操作符：<br>[], ., ()<br>逻辑运算符：<br>&amp;&amp;, ||  !<br>括号 (())：用于改变执行顺序</p><p>示例：</p><p>以下表达式中，typeof null &#x3D;&#x3D;&#x3D; ‘object’ &amp;&amp; typeof undefined &#x3D;&#x3D;&#x3D; ‘undefined’ 的优先级如下：</p><p>首先计算 typeof null（结果为 “object”）。<br>然后计算 typeof undefined（结果为 “undefined”）。<br>最后执行逻辑与运算 (&amp;&amp;)。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>问题1：为什么 null || undefined 的结果是 undefined？<br>这是因为逻辑或运算符 (||) 在遇到 false（或空值）时会优先返回后面的值。在 JavaScript 中：</p><p>typeof null &#x3D;&#x3D;&#x3D; ‘object’，但在逻辑运算中会被解释为 false。<br>typeof undefined &#x3D;&#x3D;&#x3D; ‘undefined’。</p><p>因此：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> || <span class="literal">undefined</span>; <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure><p>问题2：为什么 “5” + “6” 的结果是 “11”？<br>这是因为字符串拼接的优先级低于算术加法。JavaScript 会将两个字符串相加，而不是尝试将它们转换为数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;5&quot;</span> + <span class="string">&quot;6&quot;</span>); <span class="comment">// 输出：&quot;11&quot;</span></span><br></pre></td></tr></table></figure><p>问题3：为什么 0 || “” 的结果是 “”？<br>这是因为逻辑或运算符 (||) 在遇到 false（或空值）时会优先返回后面的值。在这里：</p><p>0 被视为 false。<br>“ “ 被视为非空字符串，因此会被返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> || <span class="string">&quot;&quot;</span>); <span class="comment">// 输出：&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础阶段二</title>
      <link href="/2025/03/01/JavaScript/%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/"/>
      <url>/2025/03/01/JavaScript/%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="分支语句和循环语句"><a href="#分支语句和循环语句" class="headerlink" title="分支语句和循环语句"></a>分支语句和循环语句</h1><h2 id="逐步解决方案"><a href="#逐步解决方案" class="headerlink" title="逐步解决方案"></a>逐步解决方案</h2><p>步骤 1：理解分支语句</p><p>条件判断：使用 if 和 else if 进行多层条件判断。<br>嵌套结构：可以将分支语句嵌入到其他分支中，实现复杂的逻辑。</p><p>步骤 2：理解循环语句<br>重复执行：使用 for, while 或 do…while 循环控制程序的执行次数。<br>条件判断：根据特定条件决定是否继续执行循环体。</p><p>步骤 3：结合分支与循环<br>嵌套结构：将分支语句嵌入到循环体内，或者反过来使用循环来处理分支中的逻辑。</p><p>步骤 4：应用示例 - 计算最大公约数（GCD）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">gcd</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (b !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示全部 (9)<br>步骤 5：应用示例 - 统计元音字母数量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countVowels</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> vowels = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>]);</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vowels.<span class="title function_">has</span>(char)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示全部 (11)<br>步骤 6：应用示例 - 计算阶乘</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Factorial not defined for negative values.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示全部 (11)<br>最终答案<br>通过掌握分支语句和循环语句的使用，可以有效地解决问题。以下是对问题的逐步解答：</p><p>分支语句：用于在程序运行中根据条件执行不同的代码块。<br>循环语句：用于重复执行同一段代码，直到满足特定条件。<br>嵌套结构：将分支和循环嵌入到其他结构中，实现复杂的逻辑控制。</p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>什么是 Switch 语句？</p><p>Switch 语句是一种控制结构，用于根据一个表达式的结果来执行不同的代码块。它类似于其他编程语言中的多路选择（如 C 语言的 switch-case）。</p><p>基本语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">value1</span>:</span><br><span class="line">        <span class="comment">// 执行的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">value2</span>:</span><br><span class="line">        <span class="comment">// 执行的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="comment">// 默认执行的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能说明<br>expression：一个表达式，其结果决定了执行哪个 case。<br>value1, value2 等：可能是一个具体的值或一个模式匹配的结果。<br>break;：结束当前的 case，并执行下一个代码块。<br>与 if-else 的区别<br>Switch 语句允许多个 case，并且每个 case 可以有复杂的模式匹配（如正则表达式）。此外，switch 语句还能使用 default 标识符来处理所有未匹配的情况。</p><p>示例 1：简单 switch 语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (age) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>-<span class="number">19</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;小于20岁的人&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">20</span>-<span class="number">29</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;20岁到29岁的年轻人&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;其他人&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p>TEXT<br>20岁到29岁的年轻人<br>示例 2：使用正则表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(str) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="regexp">/^H/</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;以H开头的字符串&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;不以H开头的字符串&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p>TEXT<br>以H开头的字符串<br>示例 3：组合 switch 和 if</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> score = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(score) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">90</span>-<span class="number">100</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;满分&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">80</span>-<span class="number">89</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;一般&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 4：使用 switch 处理不同类型的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="string">&quot;integer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(data) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;integer&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;float&#x27;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据类型为 number&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据类型为 string&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;未知的数据类型&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型为 number</span><br></pre></td></tr></table></figure><p>总结</p><p>Switch 语句非常适合处理需要根据多个条件执行不同代码块的场景，尤其是当这些条件可以使用正则表达式或复杂的模式匹配时。它使得代码更加清晰和易于维护。</p><p>在实际项目中，switch 语句通常用于：</p><p>根据数据类型（如 number, string, object 等）进行分类。<br>根据输入的值范围（如年龄、分数等）进行分组处理。<br>处理需要多个分支条件的情况，且这些条件可以复用。</p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>三元运算符是一种在JavaScript中用于在两种情况之间选择一个值的运算符。它是一种简洁的条件表达式，可以将一个 if 语句压缩为一行代码。</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? expression_if_true : expression_if_false</span><br></pre></td></tr></table></figure><p>condition：一个需要进行判断的表达式（通常是布尔值）。<br>expression_if_true：如果 condition 为真时执行的表达式。<br>expression_if_false：如果 condition 为假时执行的表达式。</p><p>功能</p><p>三元运算符可以将一个复杂的 if…else 结构简化为一行代码，同时保持逻辑清晰。</p><p>使用示例<br>简单条件判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a &gt; <span class="number">0</span> ? <span class="string">&quot;a is positive&quot;</span> : <span class="string">&quot;a is not positive&quot;</span>); <span class="comment">// 输出：&quot;a is positive&quot;</span></span><br></pre></td></tr></table></figure><p>注意事项<br>优先级：三元运算符的优先级低于算术运算符（如 +, -, *, &#x2F; 等），但高于比较运算符。因此，在复杂的表达式中，可能需要使用括号来明确运算顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> + <span class="number">5</span> &gt; <span class="number">2</span> ? <span class="string">&quot;真&quot;</span> : <span class="string">&quot;假&quot;</span>); <span class="comment">// 输出：&quot;真&quot;</span></span><br></pre></td></tr></table></figure><p>简洁性：虽然三元运算符可以简化代码，但它并不总是更适合所有情况。在复杂的逻辑中，if…else 结构可能更清晰易读。</p><p>总结</p><p>三元运算符是一种非常有用的工具，可以帮助我们将 if…else 结构压缩为一行代码，并且保持逻辑清晰。它特别适合简单的条件判断场景，但在处理复杂的逻辑时，可能会显得不够直观。因此，在使用三元运算符时，请注意以下几点：</p><p>使用括号明确运算顺序。<br>在复杂的逻辑中，优先选择清晰的 if…else 结构。<br>三元运算符可以与数组或对象进行结合（如练习题中的 map 或 filter 方法）。</p><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><h3 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h3><p>使用循环结构逐个访问数组中的每个元素。</p><p>步骤：</p><p>初始化一个变量作为索引，通常从0开始。<br>确定循环结束条件，通常是索引小于数组长度。<br>在每次迭代中，访问当前索引对应的元素，并执行需要的操作。<br>更新索引值，继续下一个循环。<br>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>通过函数自身调用来逐层处理数组中的每个元素。</p><p>步骤：</p><p>定义一个递归函数，接受数组和当前索引作为参数。<br>在函数中检查是否完成了所有元素的遍历（结束条件）。<br>如果未完成，执行当前操作，并递归调用自己，处理下一个元素。<br>更新递归时使用的索引值。<br>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">recursiveLoop</span>(<span class="params">array, index = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= array.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(array[index]);</span><br><span class="line">    <span class="title function_">recursiveLoop</span>(array, index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="title function_">recursiveLoop</span>(array);</span><br></pre></td></tr></table></figure><p>总结<br>循环遍历适合处理大部分数组操作，因为它简单且效率高。而递归遍历适用于需要逐层处理或分阶段完成任务的情况，但需注意避免栈溢出问题。</p><p>通过理解和实践这两种方法，可以更好地掌握数组遍历的实现与应用。</p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><ol><li>增（Insert）<br>push(): 将元素添加到数组末尾。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">4</span>); <span class="comment">// 现在arr是[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>unshift(): 将元素插入到数组最前面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="number">0</span>); <span class="comment">// 现在arr是[0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>splice(index, [number]): 删除指定索引处的元素，并将新元素插入到该位置之前的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>); <span class="comment">// 现在arr是[1, 4, 2, 3]</span></span><br></pre></td></tr></table></figure><ol start="2"><li>删（Delete）<br>pop(): 删除并返回数组的最后一个元素。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">poppedValue = arr.<span class="title function_">pop</span>(); <span class="comment">// poppedValue是3，现在arr是[1, 2]</span></span><br></pre></td></tr></table></figure><p>indexOf(element): 返回指定元素的第一个索引位置。如果找不到该元素，则返回-1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">index = arr.<span class="title function_">indexOf</span>(<span class="number">2</span>); <span class="comment">// index是1</span></span><br></pre></td></tr></table></figure><p>splice(index, removeItemCount&#x3D;0): 删除指定索引处的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 现在arr是[2, 3]</span></span><br></pre></td></tr></table></figure><ol start="3"><li>改（Update）<br>直接赋值: 访问数组中特定索引的位置并将其值修改。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">4</span>; <span class="comment">// 现在arr是[4, 2, 3]</span></span><br></pre></td></tr></table></figure><p>使用slice()和concat(): 复制数组的一部分，修改后的内容再合并回原数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> updatedPart = arr.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 取前两个元素</span></span><br><span class="line">updatedPart[<span class="number">0</span>] = <span class="number">5</span>; <span class="comment">// 修改第一个元素为5</span></span><br></pre></td></tr></table></figure><p>arr &#x3D; updatedPart.concat(arr.slice(1)); &#x2F;&#x2F; 现在arr是[5, 3]</p><ol start="4"><li>查（Search）</li></ol><p>indexOf(element): 返回指定元素的第一个索引位置，或-1表示不存在。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">index = arr.<span class="title function_">indexOf</span>(<span class="number">2</span>); <span class="comment">// index是1</span></span><br></pre></td></tr></table></figure><p>includes(element): 返回布尔值，判断数组中是否存在该元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">includes</span>(<span class="number">4</span>)); <span class="comment">// 输出false</span></span><br></pre></td></tr></table></figure><p>通过这些方法的学习和实践，可以高效地进行数组的增删改查操作。选择合适的方法根据具体需求，既能提高代码效率，也能让代码更加简洁易懂。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型，partial类，枚举，结构</title>
      <link href="/2025/02/21/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/%E6%B3%9B%E5%9E%8B%EF%BC%8Cpartial%E7%B1%BB%EF%BC%8C%E6%9E%9A%E4%B8%BE%EF%BC%8C%E7%BB%93%E6%9E%84/"/>
      <url>/2025/02/21/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/%E6%B3%9B%E5%9E%8B%EF%BC%8Cpartial%E7%B1%BB%EF%BC%8C%E6%9E%9A%E4%B8%BE%EF%BC%8C%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型（generic）无处不在"><a href="#泛型（generic）无处不在" class="headerlink" title="泛型（generic）无处不在"></a>泛型（generic）无处不在</h1><p>为什么需要泛型：避免成员膨胀或者类型膨胀<br>正交性：泛型类型（类&#x2F;接口&#x2F;委托&#x2F;···）、泛型成员（属性&#x2F;方法&#x2F;字段&#x2F;···）<br>类型方法的参数推断<br>泛型与委托、lambda表达式</p><p>泛型基本使用<br><img src="/img%5CHello%5CSnipaste_2025-02-21_13-19-57.png"></p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型有良好的正交性</p><p><img src="/img%5CHello%5CSnipaste_2025-02-21_13-34-30.png"></p><h2 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h2><p><img src="/img%5CHello%5CSnipaste_2025-02-21_13-45-15.png"></p><h2 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h2><p><img src="/img%5CHello%5CSnipaste_2025-02-21_14-50-02.png"></p><h1 id="partial类"><a href="#partial类" class="headerlink" title="partial类"></a>partial类</h1><p>减少类的派生<br>partial类与Entity Framework<br>partial类与Windows Forms,WPF,ASP.NET Core</p><p>步骤一：理解“Partial”在编程中的常见用法</p><p>“Partial”通常用于表示某种部分性、不完整或偏导数的概念。在数学中，偏导数指的是多变量函数对其中一个变量的导数。<br>步骤二：查找C#中的相关类型和命名conventions</p><p>在C#标准库中，没有名为“Partial”的内置类型。<br>第三方库或自定义项目可能会引入名为“Partial”的类或结构。<br>步骤三：推测“Partial”类可能的功能</p><p>假设这是一个自定义的数据结构，用于表示某种部分状态、记录变化或者存储中间结果。<br>可能与多线程、事件处理或其他需要部分执行的结果相关。<br>步骤四：验证假设</p><p>查找项目文档或代码库中的定义，确认“Partial”类的具体用途和实现细节。<br>如果找不到明确的定义，可能需要进一步询问开发者或查看使用场景。<br>总结：</p><p>在C#中，“Partial”作为一个类名通常没有标准的意义。它可能是自定义的、用于特定业务逻辑的数据结构。为了确切理解它的作用，请参考项目文档或相关代码。</p><h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><p>人为限定取值范围的整数<br>整数值的对应<br>比特位式用法</p><p><img src="/img%5CHello%5CSnipaste_2025-02-21_15-32-17.png"></p><h1 id="结构体（struct）"><a href="#结构体（struct）" class="headerlink" title="结构体（struct）"></a>结构体（struct）</h1><p>值类型，可装&#x2F;拆箱<br>可实现接口，不能派生自类&#x2F;结构体<br>不能有显示无参构造器</p><p><img src="/img%5CHello%5CSnipaste_2025-02-21_15-47-39.png"></p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> charp编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp入门详解学习笔记</title>
      <link href="/2025/02/08/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/02/08/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="用C-编写的各类应用程序，用Visual-Studio写出Hello-word"><a href="#用C-编写的各类应用程序，用Visual-Studio写出Hello-word" class="headerlink" title="用C#编写的各类应用程序，用Visual Studio写出Hello word!!!."></a>用C#编写的各类应用程序，用Visual Studio写出Hello word!!!.</h1><h1 id="第一个：Console"><a href="#第一个：Console" class="headerlink" title="第一个：Console"></a>第一个：Console</h1><p>打开Visual Studio新建项目选择<b>控制台应用</b><br>会自动帮我们生成最基本的C#的Main方法，在Main中输入Console.WrinteLine(“Hello World!”);按ctrl+F5进行调式。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">namespace</span> <span class="title">Console_Hello_world</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           Console.WrinteLine(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="第二个：Windows-Forms-Old"><a href="#第二个：Windows-Forms-Old" class="headerlink" title="第二个：Windows Forms(Old)"></a>第二个：Windows Forms(Old)</h1><p>打开Visual Studio新建项目选择<b>Windows窗体应用(.NET Framework)</b><br>会自动生成一个Form1的窗口<br>如下：<br><img src="/img%5CHello%5CForm-helloworld.png"></p><p>在工具箱中搜索button和Textbox，将其拖到窗体上。</p><p><img src="/img%5CHello%5CForm-helloworld-2.png"></p><p>左边没有工具箱，在菜单栏中选择视图选选卡，在下拉列表中选着工具箱。</p><p>属性面板中可以看到按钮的各种属性，选择button，在属性面板中将Text改为“Click Me!” </p><p><img src="/img%5CHello%5CForm-helloworld-3.png"></p><p>在属性面板中选择事件按钮</p><p><img src="/img%5CHello%5CForm-helloworld-4.png"></p><p>双击按钮的“Click”事件<br><img src="/img%5CHello%5CForm-helloworld-5.png"></p><p>VS会自动生成一个方法，我们只需要在方法中输入Console.WriteLine(“Hello World!”);即可。</p><p><img src="/img%5CHello%5CForm-helloworld-6.png"></p><p>运行程序，点击按钮，Form1会显示“Hello World!”</p><p><img src="/img%5CHello%5CForm-helloworld-7.png"></p><h1 id="第三个：WPF-Windows-Presentation-Foundation"><a href="#第三个：WPF-Windows-Presentation-Foundation" class="headerlink" title="第三个：WPF(Windows Presentation Foundation)"></a>第三个：WPF(Windows Presentation Foundation)</h1><p>WPF是微软推出的基于.NET Framework的可视化开发框架，可以用来开发桌面应用程序、移动应用程序、Web应用程序、游戏等。</p><p>打开Visual Studio新建项目选择<b>WPF应用程序(.NET Framework)</b><br>会自动生成一个MainWindow的窗口<br>在工具箱中搜索button和Textbox，将其拖到窗体上。<br>步骤和FrameWork Forms类似 </p><p><img src="/img%5CHello%5CWPF-helloworld.png"></p><p><img src="/img%5CHello%5CWPF-helloworld-2.png"></p><p><img src="/img%5CHello%5CWPF-helloworld-3.png"></p><p><img src="/img%5CHello%5CWPF-helloworld-4.png"></p><p><img src="/img%5CHello%5CWPF-helloworld-5.png"></p><h1 id="第四个：ASP-NET-Web-FormS-Old"><a href="#第四个：ASP-NET-Web-FormS-Old" class="headerlink" title="第四个：ASP.NET Web FormS(Old)"></a>第四个：ASP.NET Web FormS(Old)</h1><p>打开Visual Studio新建项目选择<b>ASP.NET Web Forms 应用程序</b></p><p>选择空模板，勾选web窗体，点击确定。</p><p>右击项目，选择添加新项，选择Web窗体，命名为“Default.aspx”，点击添加。<br><img src="/img%5CHello%5CNET-Web-helloworld.png"></p><p>就可以使用HTML、CSS、JavaScript来编写网页了。<br><img src="/img%5CHello%5CFramework-web-helloworld.png"></p><h1 id="第五个：ASP-NET-MVC-Model-View-Controller"><a href="#第五个：ASP-NET-MVC-Model-View-Controller" class="headerlink" title="第五个：ASP.NET MVC(Model-View-Controller)"></a>第五个：ASP.NET MVC(Model-View-Controller)</h1><p>打开Visual Studio新建项目选择<b>ASP.NET MVC 应用(模型-视图-控制器)</b></p><p>选择自带的模板HomeController.cs,在index视图中输入“Hello World!”</p><p>也可以zip下载模板，解压后打开解决方案，找到HomeController.cs，在index视图中输入“Hello World!”<br><img src="/img%5CHello%5CMVC-helloworld.png"></p><p><img src="/img%5CHello%5CMVC-helloworld-2.png"></p><p><img src="/img%5CHello%5CMVC-helloworld-5.png"></p><p><img src="/img%5CHello%5CMVC-helloworld-4.png"></p><h1 id="类库的引用"><a href="#类库的引用" class="headerlink" title="类库的引用"></a>类库的引用</h1><li>类库引用是使用命名空间的物理基础。在C#中，我们可以将代码分成多个文件，每个文件都有自己的命名空间。当我们需要使用某个类库时，我们需要引用它的命名空间。例如，我们需要使用System.IO命名空间，我们可以这样写：using System.IO;。这样，我们就可以在程序中使用System.IO命名空间中的类和方法了。</li><li>不同技术类型的项目会默认引用不同的类库，如Windows Forms项目默认引用System.Windows.Forms命名空间，WPF项目默认引用System.Windows命名空间，ASP.NET Web Forms项目默认引用System.Web命名空间，ASP.NET MVC项目默认引用System.Web.Mvc命名空间。</li><li>DLL引用(黑河引用，无源代码)</li><ol><li>定义与作用<br>DLL 是一个用于存储代码和数据资源的文件，能够在不同应用程序之间动态地共享代码。<br>它类似于 C# 类库（如 System.Collections.Generic），但通常用于外部调用或框架。</li><li>功能特点<br>二进制文件：DLL 是二进制文件，包含类型、静态成员和方法的二进制表示。<br>动态链接：DLL 允许应用程序在运行时动态加载其代码，而不必将其作为可执行文件直接编译。</li><li>类型与结构<br>DLL 文件通常以 .dll 扩展名标识，并由一个或多个 assembly 组成。<br>类型和方法是通过 DLL 中的类型表实现的，允许在 C# 程序中引用外部库。</li><li>常见用途<br>调用外部库：DLL 是大多数 .NET 框架（如 mscorlib、System.Web）的默认形式。例如，mscorlib.dll 包含基础数据类型和方法。<br>框架与组件：许多框架提供 DLL 文件，允许 C# 程序调用其功能。</li><li>管理与使用<br>编译与加载：DLL 是通过编译器在运行时动态加载的。C# 编译器会将类库编译为 DLL。<br>引用方式：在 C# 代码中，可以使用 using 语句或名称空间来引用 DLL 提供的功能。</li><li>常见问题<br>如果项目无法找到 DLL 文件，通常表示路径错误或依赖的 DLL 缺少。检查路径和更新依赖是常见的解决方案。<br>DLL 文件的安全性通常较低，因为它们可以在系统中加载任何代码。因此，在生产环境中应谨慎处理。<br>总结<br>DLL 是 C# 程序中调用外部库或框架的核心工具，通过二进制文件存储代码和数据资源，并在运行时动态加载。理解 DLL 的作用对于编写高效的 .NET 应用程序至关重要。</li></ol><li>NuGet 包管理器</li><p>NuGet 是 Microsoft 提供的 .NET 包管理器，它可以帮助我们轻松地安装、更新和引用第三方类库。</p><ol><li>定义与作用<br>NuGet 是 Microsoft 提供的 .NET 包管理器，它可以帮助我们轻松地安装、更新和引用第三方类库。NuGet 包管理器可以帮助我们管理 .NET 项目的依赖项，包括 NuGet 包。</li><li>功能特点<br>NuGet 包管理器可以帮助我们管理 .NET 项目的依赖项，包括 NuGet 包。<br>NuGet 包可以帮助我们快速、轻松地安装、更新和引用第三方类库。<br>NuGet 包可以帮助我们管理 NuGet 包的版本，包括 NuGet 包依赖项。</li><li>常见用途<br>NuGet 包管理器可以帮助我们管理 .NET 项目的依赖项，包括 NuGet 包。<br>NuGet 包可以帮助我们快速、轻松地安装、更新和引用第三方类库。<br>NuGet 包可以帮助我们管理 NuGet 包的版本，包括 NuGet 包依赖项。</li><li>管理与使用<br>NuGet 包管理器可以帮助我们管理 .NET 项目的依赖项，包括 NuGet 包。<br>NuGet 包可以帮助我们快速、轻松地安装、更新和引用第三方类库。<br>NuGet 包可以帮助我们管理 NuGet 包的版本，包括 NuGet 包依赖项。</li><li>常见问题<br>NuGet 包管理器的安装与使用需要一定的时间，但随着 NuGet 包的增多，它的使用效率会越来越高。<br>NuGet 包管理器的依赖项管理功能可以帮助我们管理 NuGet 包的版本，包括 NuGet 包依赖项。  </li><li>总结<br>NuGet 包管理器是 Microsoft 提供的 .NET 包管理器，它可以帮助我们轻松地安装、更新和引用第三方类库。NuGet 包管理器的安装与使用需要一定的时间，但随着 NuGet 包的增多，它的使用效率会越来越高。NuGet 包管理器的依赖项管理功能可以帮助我们管理 NuGet 包的版本，包括 NuGet 包依赖项。</li></ol><li>项目引用(百盒引用，有源代码)</li><ol><li>定义与作用<br>项目引用是指在一个项目中引用另一个项目的输出文件。</li><li>功能特点<br>项目引用可以帮助我们在一个项目中调用另一个项目的功能。</li><li>常见用途<br>项目引用可以帮助我们在一个项目中调用另一个项目的功能。</li><li>管理与使用<br>项目引用可以帮助我们在一个项目中调用另一个项目的功能。</li><li>常见问题<br>项目引用的管理与使用需要一定的时间，但随着项目的增多，它的使用效率会越来越高。</li><li>总结<br>项目引用是指在一个项目中引用另一个项目的输出文件。项目引用可以帮助我们在一个项目中调用另一个项目的功能。项目引用的管理与使用需要一定的时间，但随着项目的增多，它的使用效率会越来越高。</li></ol><li>依赖关系管理(高内聚低耦合) </li><p>依赖关系管理是指管理项目之间的依赖关系，包括 NuGet 包依赖项、项目依赖项和外部 DLL 依赖项。</p><ol><li>定义与作用<br>依赖关系管理是指管理项目之间的依赖关系，包括 NuGet 包依赖项、项目依赖项和外部 DLL 依赖项。</li><li>功能特点<br>依赖关系管理可以帮助我们管理项目之间的依赖关系。</li><li>常见用途<br>依赖关系管理可以帮助我们管理项目之间的依赖关系。</li><li>管理与使用<br>依赖关系管理可以帮助我们管理项目之间的依赖关系。</li><li>常见问题<br>依赖关系管理的管理与使用需要一定的时间，但随着项目的增多，它的使用效率会越来越高。</li><li>总结</li></ol><h1 id="类的三大成员"><a href="#类的三大成员" class="headerlink" title="类的三大成员"></a>类的三大成员</h1><li>属性(Properties)</li><p>属性是类的成员，它可以获取或设置类的状态。    </p><ol><li>定义与作用<br>属性是类的成员，它可以获取或设置类的状态。</li><li>功能特点<br>属性可以帮助我们在类的外部访问类的状态。</li><li>常见用途<br>属性可以帮助我们在类的外部访问类的状态。</li><li>管理与使用<br>属性的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li><li>常见问题<br>属性的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li><li>总结<br>属性是类的成员，它可以获取或设置类的状态。属性可以帮助我们在类的外部访问类的状态。属性的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li></ol><li>方法(Methods)</li>方法是类的成员，它可以执行一些操作。               <ol><li>定义与作用<br>方法是类的成员，它可以执行一些操作。</li><li>功能特点<br>方法可以帮助我们在类的外部执行一些操作。</li><li>常见用途<br>方法可以帮助我们在类的外部执行一些操作。</li><li>管理与使用<br>方法的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li><li>常见问题<br>方法的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li><li>总结<br>方法是类的成员，它可以执行一些操作。方法可以帮助我们在类的外部执行一些操作。方法的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li></ol><li>事件(Events)</li>事件是类的成员，它可以通知其他对象发生了某些事件。               <ol><li>定义与作用<br>事件是类的成员，它可以通知其他对象发生了某些事件。</li><li>功能特点<br>事件可以帮助我们在类的外部通知其他对象发生了某些事件。</li><li>常见用途<br>事件可以帮助我们在类的外部通知其他对象发生了某些事件。</li><li>管理与使用<br>事件的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li><li>常见问题<br>事件的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li><li>总结<br>事件是类的成员，它可以通知其他对象发生了某些事件。事件可以帮助我们在类的外部通知其他对象发生了某些事件。事件的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li></ol><h1 id="构成C-语言的基本元素"><a href="#构成C-语言的基本元素" class="headerlink" title="构成C#语言的基本元素"></a>构成C#语言的基本元素</h1><li>关键字(Keywords)</li>关键字是C#语言的基本元素，它是C#语言的核心。关键字是C#语言的基本语法单位，它是C#语言的构建块。关键字的作用是用来定义程序的结构、控制流、数据类型、方法、变量、常量、运算符、命名空间、类、接口、结构、枚举、委托等。<b>在MSDN文档有对关键字的详细介绍。</b>             <li>运算符(Operators)</li>运算符是C#语言的基本元素，它是C#语言的核心。运算符是C#语言的基本语法单位，它是C#语言的构建块。运算符的作用是用来执行各种操作，如算术运算、赋值运算、逻辑运算、比较运算、位运算、条件运算等。<b>在MSDN文档有对运算符的详细介绍。</b><li>标识符(Identifiers)</li><ol><li>什么是合法标识符？<br>标识符是不能和关键字重组（关键字已经被赋予了特殊的含义）、不能以数字开头、不能包含特殊字符。<br>标识符可以由字母、下划线或者汉字（但不建议使用汉字）开头。<br>标识符的命名规范：</li></ol><ul><li>标识符的命名必须遵循驼峰命名法。</li><li>标识符的命名必须见名知意。</li><li>标识符的命名必须简短、易于理解。</li></ul><li>标点符号(Punctuation)</li>标点符号是C#语言的基本元素，它是C#语言的核心。标点符号是C#语言的基本语法单位，它是C#语言的构建块。标点符号的作用是用来定义程序的语法结构。<b>在MSDN文档有对标点符号的详细介绍。</b><li>文本(Text)</li><li>注释与空白(Comments and Whitespace)</li>![](img\Hello\tokne.png)<h1 id="初始类型、变量和方法"><a href="#初始类型、变量和方法" class="headerlink" title="初始类型、变量和方法"></a>初始类型、变量和方法</h1><li>初始类型(Primitive Types)</li><p><img src="/img%5CHello%5Ctype.png"></p><li>变量(Variables)</li><p>变量的声明<br>变量的使用</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x;</span><br><span class="line">x = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><li>方法(Methods)</li><p>方法的声明<br>方法的调用</p><p><img src="/img%5CHello%5Cfangfa.png"></p><li>程序=数据+算法</li><p><b>有了变量和方法，我们就可以编写有意义的程序了。</b></p><h1 id="C-语言的类型系统"><a href="#C-语言的类型系统" class="headerlink" title="C#语言的类型系统"></a>C#语言的类型系统</h1><h2 id="C-的五大数据类型"><a href="#C-的五大数据类型" class="headerlink" title="C#的五大数据类型"></a>C#的五大数据类型</h2><li>类（Class）：如Windows、Form、Console、String等</li><li>结构体（Structures）：如Int32、Int64、Single、Double等</li><li>枚举（Enumerations）：如HorizontalAlignment、Visibility等</li><li>接口（Interfaces）：如IEnumerable、IDisposable等</li><li>委托（Delegates）：如EventHandler、Func等</li><h2 id="C-类型的派生谱系"><a href="#C-类型的派生谱系" class="headerlink" title="C#类型的派生谱系"></a>C#类型的派生谱系</h2><p><img src="/img%5CHello%5CObject.png"></p><h1 id="变量、对象与内存"><a href="#变量、对象与内存" class="headerlink" title="变量、对象与内存"></a>变量、对象与内存</h1><h2 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h2><blockquote><p>变量&#x3D;以变量名所对应的内存地址为起点、以其他数据类型所要求的存储空间为长度的一块内存区域</p></blockquote><li>表面上来看，变量的用途是存储数据</li><li>实际上，变量表示了存储位置，并且每个变量都有一个类型，与决定什么样的值能供存入变量</li><li>变量一共有7种</li>静态变量、实例变量(成员变量、字段)、数组元素、值参数、(ref)引用参数、(out)输出参数、局部参数<li>狭义的变量指局部变量、因为其它种类的变量都有自己的约定名称（局部变量就是方法体里的声明的变量）</li><li>变量的声明</li>有效的修饰符组合opt类型变量名初始化器opt<h2 id="值类型的变量"><a href="#值类型的变量" class="headerlink" title="值类型的变量"></a>值类型的变量</h2><li>以byte/sbtye/short/ushort/为例</li><li>值类型没有实例、所谓的“实例”与变量合而为一</li><h2 id="引用类型的变量"><a href="#引用类型的变量" class="headerlink" title="引用类型的变量"></a>引用类型的变量</h2><li>引用类型变量与实例的关系：引用类型变量里存储的数据是对象的内存地址<h1 id="装箱与拆箱（Boxing-Unboxing）"><a href="#装箱与拆箱（Boxing-Unboxing）" class="headerlink" title="装箱与拆箱（Boxing&amp;Unboxing）"></a>装箱与拆箱（Boxing&amp;Unboxing）</h1><li>装箱：将值类型转换为引用类型</li><li>拆箱：将引用类型转换为值类型</li><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>操作符预览：<br><img src="/img%5CHello%5CCAHOZUOFU.png"></p><p>操作符优先级从上往下依次降低，同一行的操作符优先级相同。<br>相同操作符在表达式中运算顺序是从左往右决定。</p><p>但赋值和lanbda表达式的优先级不同。<br>他是从右往左运算的。</p><h1 id="Typeof操作符"><a href="#Typeof操作符" class="headerlink" title="Typeof操作符:"></a>Typeof操作符:</h1><p><img src="/img%5CHello%5CSnipaste_2025-02-11_11-48-57.png"></p><h1 id="var和new的组合"><a href="#var和new的组合" class="headerlink" title="var和new的组合"></a>var和new的组合</h1><p>将 var 和 new 结合使用在 C# 中是一种常见的语法糖，提供了更加简洁和清晰的代码写法。具体来说：</p><p>语义上的优化：</p><p>使用 var new Type obj &#x3D; new Type(); 可以让编译器更清楚地理解变量是在初始化哪个对象或数组中。<br>保持一致性：</p><p>这种组合使得在定义和初始化对象时的代码风格一致，有助于提高可读性和维护性。<br>多态性的支持：</p><p>当目标类型是多态类型时，结合 var 和 new 可以更自然地处理继承或接口实现的情况。<br>扩展性和灵活性：</p><p>这种语法糖允许在初始化复杂的对象、数组或其他结构时保持代码的简洁和可读性。</p><h1 id="checked操作符"><a href="#checked操作符" class="headerlink" title="checked操作符"></a>checked操作符</h1><p><img src="/img%5CHello%5CSnipaste_2025-02-11_13-04-03.png"></p><h1 id="逻辑“与”、“XOR”、“OR”运算符"><a href="#逻辑“与”、“XOR”、“OR”运算符" class="headerlink" title="逻辑“与”、“XOR”、“OR”运算符"></a>逻辑“与”、“XOR”、“OR”运算符</h1><p> <img src="/img%5CHello%5CSnipaste_2025-02-11_15-28-48.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-11_15-34-07.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-11_15-38-04.png"></p><h1 id="null合并运算符"><a href="#null合并运算符" class="headerlink" title="null合并运算符"></a>null合并运算符</h1><p><img src="/img%5CHello%5CSnipaste_2025-02-11_15-58-53.png"></p><h1 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h1><p><img src="/img%5CHello%5CSnipaste_2025-02-11_16-08-30.png"></p><h1 id="操作符的本质"><a href="#操作符的本质" class="headerlink" title="操作符的本质"></a>操作符的本质</h1><li>操作符不能脱离与它关联的数据类型</li>可以说操作符就是与固定数据类型相关联的一套基本算法的简记法为自定义数据类型创造操作符<p><img src="/img%5CHello%5Ccao.png"></p><p><img src="/img%5CHello%5CSnipaste.png"></p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><li>隐式类型转换</li>不丢失精度的转换<p><img src="/img%5CHello%5CSnipaste_2025-02-11_14-11-41.png"></p><p>子类向父类的转换</p><p>装箱</p><li>显式类型转换</li>有可能丢失精度（甚至发生错误）拆箱使用Convert类ToString()方法与各数据类型的Parse/TryParse方法<h1 id="表达式的定义"><a href="#表达式的定义" class="headerlink" title="表达式的定义"></a>表达式的定义</h1><li>算法逻辑的最基本（最小）单元，表达一定的算法意图</li><li>因为操作符有优先级，所以表达式也有优先级</li><h1 id="C-语言中表达式的分类"><a href="#C-语言中表达式的分类" class="headerlink" title="C#语言中表达式的分类"></a>C#语言中表达式的分类</h1><li>A value.Every value has an associated type.任何能得到值的运算（回顾操作符和结果类型）</li><li>A variable.Every variable has an associated type.</li><li>A namespace</li><li>A type.</li><li>A method group. 例如：Console.WriteLine,这是一组方法，重载决策决定具体调用哪个方法</li><li>A null literal.</li><li>An anonymous function.</li><li>A property access.</li><li>An event access.</li><li>An indexer access.</li><li>Nothing.对返回值为void的方法的调用</li><h1 id="符合表达式的求值"><a href="#符合表达式的求值" class="headerlink" title="符合表达式的求值"></a>符合表达式的求值</h1><p>操作符的优先级和同优先级操作符的运算方向</p><h1 id="C-语言对语句的定义"><a href="#C-语言对语句的定义" class="headerlink" title="C#语言对语句的定义"></a>C#语言对语句的定义</h1><li>C#语言的语句除了能够让程序员“顺序地（sequentially）”表达算法思想，还能通过条件判断、跳转和循环等方法控制程序逻辑的走向</li><li>简言之就是：陈述算法思想，控制逻辑走向，完成有意义的动作（action）</li><li>C#语言的语句由分号（;）结尾，但由分号结尾的不一定都是语句</li><li>语句一定是出现在方法体里</li><h1 id="什么是字段"><a href="#什么是字段" class="headerlink" title="什么是字段"></a>什么是字段</h1><p>字段是类型的成员，写在类里面的才是字段，写在函数里面叫局部变量</p><p>字段（field）是一种表示与对象或类型（类与结构体）关联的变量<br>字段是类型的成员，也叫“成员变量”<br>与对象关联的字段亦称“实例字段”<br>与类相关联的字段称为“静态字段”，由static修饰</p><h1 id="字段的初始化"><a href="#字段的初始化" class="headerlink" title="字段的初始化"></a>字段的初始化</h1><p>无显示初始化时，字段获得其类型的默认值，所以字段“永远都不会被初始化”<br>实例字段初始化的时机————对象创建时<br>静态字段初始化的时机————类型被加载（load）时</p><h1 id="readonly-只读字段"><a href="#readonly-只读字段" class="headerlink" title="readonly(只读字段)"></a>readonly(只读字段)</h1><p><b>“readonly”字段在C#编程中有着广泛的应用价值。它不仅有助于提高代码的质量和可维护性，还能有效保障数据的一致性和安全性，适用于多个领域和技术栈中的开发实践。</b></p><p>声明上下文 </p><p>只能在模块级别使用 ReadOnly。 这意味着 ReadOnly 元素的声明上下文必须是类、结构或模块，不能是源文件、命名空间或过程。</p><p>组合修饰符</p><p>不能在同一过程声明中同时指定 ReadOnly 和 Static。</p><p>赋值</p><p>使用 ReadOnly 属性的代码无法设置其值。 但能够访问基础存储的代码可随时赋值或更改值。<br>只能在 ReadOnly 变量的声明中或在定义它的类或结构的构造函数中为其赋值</p><p><img src="/img%5CHello%5CSnipaste_2025-02-15_21-00-06.png"></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p><img src="/img%5CHello%5CSnipaste_2025-02-15_22-54-28.png"></p><p>什么是属性<br><img src="/img%5CHello%5CSnipaste_2025-02-15_22-33-04.png"></p><p><img src="/img%5CHello%5CSnipaste_2025-02-15_22-33-00.png"></p><p>属性的声明</p><p><img src="/img%5CHello%5CSnipaste_2025-02-15_22-32-53.png"></p><p>动态属性</p><p><img src="/img%5CHello%5CSnipaste_2025-02-15_22-53-36.png"></p><h1 id="常量（const）"><a href="#常量（const）" class="headerlink" title="常量（const）"></a>常量（const）</h1><p><img src="/img%5CHello%5CSnipaste_2025-02-15_23-07-18.png"></p><h1 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h1><p> 引用参数是用ref修饰符声明的形参。与值形参不同，引用形参并不创建新的存储位置。相反，引用形参表示的存储位置恰是方法调用中作为实参给出的那个变量所表示的存储位置。</p><p> 当形参为引用形参时，方法调用中的对应实参必须由关键字ref并后接一个与形参类型相同的variable-reference（变量引用）组成。变量在可以作为引用形参传递之前，必须先明确赋值。</p><p> 在方法内部，引用形参始终被认为是明确赋值的。<br> 声明为迭代器的方法不能有引用形参。</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_10-35-37.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_10-52-51.png"></p><p> 不创建新对象只改变对象值</p><h1 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h1><p> 用out修饰符声明的形参是输出形参。类似于引用形参，输出形参不创建新的内存位置。相反，输出形参表的存储位置恰是在该方法调用中作为实参给出的那个变量所表示的存储位置。</p><p> 当形参为输出形参时，方法调用中的相应实参必须由关键字out并后接一个与形参类型相同的varable-reference组成。变量在可以作为输出形参传递之前不一定需要明确赋值，但是在将变量作为输出形参传递的调用之后，该变量被认为是明确赋值的。</p><p> 在方法内部，与局部变量相同，输出形参最初被认为是未赋值的，因而必须在使用它的值之前明确赋值。</p><p> 在方法返回之前，该方法的每个输出形参都必须明确赋值。</p><p> 声明为部分方法或迭代器的方法不能有输出形参。</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_11-34-04.png"></p><p> 如何使用引用类型参数<br> <img src="/img%5CHello%5CSnipaste_2025-02-16_12-05-39.png"></p><h1 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h1><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_13-16-35.png"></p><h1 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h1><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_13-30-20.png"></p><h1 id="扩展方法（this参数）"><a href="#扩展方法（this参数）" class="headerlink" title="扩展方法（this参数）"></a>扩展方法（this参数）</h1><p> 方法必须是公有、静态的、即被public static所修饰<br> 必需是形参列表中的第一个，由this修饰<br> 必需由一个静态类（一般类名为SomeTypeExtension）来统一收纳对SomeType类型的扩展方法</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_15-23-17.png"></p><h1 id="什么是委托"><a href="#什么是委托" class="headerlink" title="什么是委托"></a>什么是委托</h1><p> 委托（delegate）是函数指针的“升级版”</p><p> 一切皆地址<br> 变量（数据）是以某个地址为起点的一段内存中所存储的值<br> 函数（算法）是以某个地址为起点的一段内存中所存储的一组机器语言指令</p><p> 直接调用与间接调用<br> 直接调用：通过函数名来调用函数，CPU通过函数名直接获得函数所在地址并开始执行,返回<br> 间接调用：通过函数指针来调用函数，CPU通过读取函数指针存储的值获得函数所在地址并开始执行，返回</p><p> Action委托</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_16-18-04.png"></p><p> Func委托</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_16-29-37.png"></p><h1 id="委托的声明（自定义委托）"><a href="#委托的声明（自定义委托）" class="headerlink" title="委托的声明（自定义委托）"></a>委托的声明（自定义委托）</h1><p> 委托是一种类（class）,类是数据类型所以委托也是一种数据类型<br> 它的声明方式与一般的类不同，主要是为了照顾可读性和C&#x2F;C++传统<br> 注意声明委托的位置<br> 委托与所封装的方法必需“类型兼容”</p><p><img src="/img%5CHello%5CSnipaste_2025-02-16_19-14-44.png"></p><h1 id="委托的一般使用"><a href="#委托的一般使用" class="headerlink" title="委托的一般使用"></a>委托的一般使用</h1><p> 实例：把方法当作参数传给另一个方法<br> 正确使用1：模板方法，“借用”指定的外部方法来产生结果<br> 相当于“填空题”<br> 常位于代码中部<br> 委托有返回值</p><p> 正确使用2：回调（callback）方法，调用指定的外部方法<br> 相当于“流水线”<br> 常位于代码末尾<br> 委托无返回值</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-18-32.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-18-44.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-18-56.png"></p><h1 id="委托的高级使用"><a href="#委托的高级使用" class="headerlink" title="委托的高级使用"></a>委托的高级使用</h1><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-17-11.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-16-05.png"></p><p> 同步</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-28-48.png"></p><p> 间接同步<br> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-32-52.png"></p><p> 多播的多播</p><p> 一个主委托对象可以容纳多个其他的子委托对象，当调用主委托对象，会将所有子委托全部按序运行</p><p> 异步</p><p> 隐式异步</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-39-00.png"></p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="事件专用委托定义"><a href="#事件专用委托定义" class="headerlink" title="事件专用委托定义"></a>事件专用委托定义</h2> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params">Object? sender,EventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="为了能够满足两个条件："><a href="#为了能够满足两个条件：" class="headerlink" title="为了能够满足两个条件："></a>为了能够满足两个条件：</h2><p> 事件对应的委托，不应该被类外界调用，只能由某个操作触发<br> 事件对应的委托，不应该被类外界直接赋值，只能够通过+、-增减委托方法<br> <figure class="highlight csharp"><figcaption><span>事件最终写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Player</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">public</span> evnet EventHandler OnAttack = unll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 总结：类内定义、类内触发、只能加减、不可赋值</p><p> 事件是在程序运行过程中触发的特定动作。它可以是用户操作（如点击按钮）引起的，也可以是数据处理、集合遍历等引起的。<br> 每个事件包含一个事件触发器和相应的响应代码。</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-17_10-39-58.png"></p><p>事件的运用</p><p><b>事件对应的委托，不应该被类外界直接赋值，只能够通过+、-增减委托方法</b></p><p> ![]  (img\Hello\Snipaste_20 25-02-17_11-56-33.png)</p><p> 第一种：✨<br> 事件响应者和事件拥有者是完全分开的<br> 由事件处理器订阅事件<br> <img src="/img%5CHello%5CSnipaste_2025-02-17_12-49-52.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-17_12-47-14.png"></p><p> 第二种：✨✨</p><p> 事件的拥有者同时也是事件的响应者<br> <img src="/img%5CHello%5CSnipaste_2025-02-17_12-59-06.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-17_13-16-43.png"></p><p> 第三种：✨✨✨</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-17_13-19-28.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-17_13-37-12.png"></p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> charp编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#&#92;WPF分布类和方法</title>
      <link href="/2025/02/02/csharp%E5%88%86%E5%B8%83%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95/"/>
      <url>/2025/02/02/csharp%E5%88%86%E5%B8%83%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="分布类和方法"><a href="#分布类和方法" class="headerlink" title="分布类和方法"></a>分布类和方法</h1><h2 id="分部类（Partial-Class）"><a href="#分部类（Partial-Class）" class="headerlink" title="分部类（Partial Class）"></a>分部类（Partial Class）</h2><p><b>定义：</b></p><blockquote><p>分部类是一种设计模式，用于将一个大型的、复杂的类拆分成多个较小的部分。这些部分可以是功能模块、数据逻辑或行为集等。</p></blockquote><p><b>特点：</b></p><li>代码可读性：通过将大类分割成小类，代码更加简洁易懂。</li><li>复用性：不同分部类可以被其他地方使用，提高代码的复用性。</li><li>扩展性：如果需要新增功能或修改现有逻辑，只需在相应的分部类中进行改动。</li><p><b>示例：</b></p><p>假设有一个 Person 类，表示一个人的属性和行为。将其分为以下几个分部类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> PartialName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> PartialAge &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params"><span class="built_in">string</span> newName, <span class="built_in">int</span> newAge</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = newName;</span><br><span class="line">        age = newAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>这里，PartialName 和 PartialAge 是分部类，分别对应 name 和 age 属性。</b></p><h2 id="WPF-中的分部类"><a href="#WPF-中的分部类" class="headerlink" title="WPF 中的分部类"></a>WPF 中的分部类</h2><p>在 WPF 中，分部类的概念不直接存在。但可以通过自定义控件或逻辑来实现类似的功能。例如：</p><p>将一个复杂的动画逻辑拆分为多个分部类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AnimationPart1</span> : <span class="title">IAnimationSegment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> StartTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> EndTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">ValueAt</span>(<span class="params"><span class="built_in">double</span> time</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (time &lt; StartTime) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (time &gt; EndTime) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 其他逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-中的分部类"><a href="#C-中的分部类" class="headerlink" title="C# 中的分部类"></a>C# 中的分部类</h2><p><b>在 C# 中，分部类是完全支持的设计模式。通过将一个大的类拆分成多个小的类，可以提高代码的组织性和可维护性。</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分部类 1：PersonName</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">PartialName</span> : <span class="title">INameSegment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">ValueAt</span>(<span class="params"><span class="built_in">double</span> time</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实现特定的行为或属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分部类 2：PersonAge</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">PartialAge</span> : <span class="title">IAgeSegment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">ValueAt</span>(<span class="params"><span class="built_in">double</span> time</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实现特定的行为或属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><b>定义：</b></p><blockquote><p>方法是程序设计中的一种基本结构，用于将一组逻辑操作抽象为一个名称，可以被其他代码调用。</p></blockquote><p><b>特点：</b></p><li>代码复用性：将重复的逻辑提取为方法。</li><li>可读性：通过命名和注释提高代码的可读性。</li><li>参数传递：支持传入零个或多个参数，并返回结果。</li><p><b>示例：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span>(<span class="params"><span class="built_in">int</span> radius</span>) <span class="comment">// 使用方法绘制圆</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 绘制圆的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span>(<span class="params"><span class="built_in">int</span> width, <span class="built_in">int</span> height</span>) <span class="comment">// 使用方法绘制矩形</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 绘制矩形的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WPF-中的方法"><a href="#WPF-中的方法" class="headerlink" title="WPF 中的方法"></a>WPF 中的方法</h2><p>在 WPF 中，方法也是常用的编程工具。例如：</p><p>通过编写自定义动画或逻辑。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PartialKey</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">StartValue</span>&gt;</span>0<span class="tag">&lt;/<span class="name">StartValue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EndValue</span>&gt;</span>1<span class="tag">&lt;/<span class="name">EndValue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TimeSpan</span>&gt;</span>0,1<span class="tag">&lt;/<span class="name">TimeSpan</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">InterpolationModeLinear</span>&gt;</span><span class="tag">&lt;/<span class="name">InterpolationModeLinear</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PartialKey</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="C-中的方法"><a href="#C-中的方法" class="headerlink" title="C# 中的方法"></a>C# 中的方法</h2><p>在 C# 中，方法是实现功能的核心。例如：</p><p>使用重载（Overloading）来支持不同的参数组合。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawCircle</span>(<span class="params"><span class="built_in">int</span> radius</span>) <span class="comment">// 单参版本</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawEllipse</span>(<span class="params"><span class="built_in">int</span> width, <span class="built_in">int</span> height</span>) <span class="comment">// 双参版本</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分部类和方法的关系"><a href="#分部类和方法的关系" class="headerlink" title="分部类和方法的关系"></a>分部类和方法的关系</h2><table>    <tr>        <th>比较项目</th>        <th>分部类</th>        <th>方法</th>    </tr>    <tr>        <td>功能</td>        <td>拆分大型类的功能</td>        <td>实现单个逻辑功能</td>    </tr>    <tr>        <td>应用场景</td>        <td>类型化问题（属性、行为等）</td>        <td>组合式问题（逻辑步骤）</td>    </tr>    <tr>        <td>灵活性</td>        <td>有，可以根据需要设计</td>        <td>有，可以通过重载实现多种逻辑</td>    </tr>    <tr>        <td>复用性</td>        <td>高，其他地方可以使用</td>        <td>高，方法参数可传递信息</td>    </tr>    </table>        <h2 id="WPF-和-C-中的分部类和方法的区别"><a href="#WPF-和-C-中的分部类和方法的区别" class="headerlink" title="WPF 和 C# 中的分部类和方法的区别"></a>WPF 和 C# 中的分部类和方法的区别</h2><li>WPF 是基于XAML和XML配置的语言，主要依赖于自定义属性（&lt;PartialKey&gt;）和动画分段（&lt;key&gt;, &lt;keyPosition&gt;）等特性来实现复杂的动画效果。</li>分部类在WPF 中并不直接存在，而是通过自定义属性或逻辑来实现部分功能。<li>C# 是一种面向对象的语言，支持传统的分部类设计模式和方法开发。在C# 中，分部类和方法是标准的编程工具，适用于多种场景。</li>    <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><li>分部类 和 方法 都是一种将大型或复杂的逻辑拆分成更小、更易管理的方式。</li><li>分部类适合在 C# 等面向对象的语言中使用，而 WPF 则依赖于 XML 和自定义属性来实现类似的功能。</li><li>在WPF 中，部分功能可以通过 PartialKey 或动画分段（如 keyPosition）来实现；而在C# 中，则可以利用分部类和方法来实现更复杂的逻辑。</li>]]></content>
      
      
      <categories>
          
          <category> WPF </category>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> WPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WPF表示模式与框架模式 | MVC&#92;MVVM</title>
      <link href="/2025/02/01/WPF/%E8%A1%A8%E7%A4%BA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/02/01/WPF/%E8%A1%A8%E7%A4%BA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="表象模式-构架模式-设计模式"><a href="#表象模式-构架模式-设计模式" class="headerlink" title="表象模式 | 构架模式 | 设计模式"></a>表象模式 | 构架模式 | 设计模式</h1><h2 id="表象模式（Presentation-Mode）"><a href="#表象模式（Presentation-Mode）" class="headerlink" title="表象模式（Presentation Mode）"></a>表象模式（Presentation Mode）</h2><p><b>定义：</b><br>表现模式的核心思想是将数据的展示逻辑与业务逻辑分离，通过独立的“表现层”来统一显示业务对象的信息。</p><p><b>目标：</b></p><p>将对数据的处理和显示逻辑独立出来。<br>提高代码的复用性。<br>显现数据的一致性和完整性。</p><p><b>主要特点：</b></p><p>数据中立：表现模式不关心数据如何存储或传输，只负责将数据以用户友好的方式展示。<br>事务隔离：业务逻辑与显示逻辑分离，避免事务处理对显示逻辑的干扰。<br>增强可读性：通过统一的数据格式和布局，提高代码的可读性和维护性。</p><p><b>示例：</b></p><p>假设有一个订单列表页面，表现模式会负责如何显示订单信息。它可能包括以下操作：<br>显示订单的基本信息（如编号、客户名称、金额）。<br>格式化订单日期为“年&#x2F;月&#x2F;日”格式。<br>显示订单的图片（如果有的话）。</p><h2 id="构架模式（Framework-Pattern）"><a href="#构架模式（Framework-Pattern）" class="headerlink" title="构架模式（Framework Pattern）"></a>构架模式（Framework Pattern）</h2><p><b>定义：</b><br>构架模式是一种通用的设计模式，用于将系统的组件分解为独立的部分，并通过这些部分来实现系统的功能。其核心思想是模块化开发，每个模块负责特定的功能。</p><p><b>目标：</b></p><p>提高系统的可扩展性。<br>显现系统的各个功能部分之间的依赖关系。<br>便于测试和维护。</p><p><b>特点：</b></p><p>模块化设计：将系统划分为独立的功能模块，每个模块负责特定的功能。<br>组件化开发：各个模块可以灵活地组合和配置，以适应不同的需求。<br>清晰的接口定义：通过明确的接口定义模块之间的交互方式，提高系统的可扩展性和维护性。</p><p><b>示例：</b></p><p>在构建一个复杂的订单管理系统时，构架模式可能会将系统分解为以下几个部分：</p><p>订单管理模块：负责处理订单的增删改查操作。<br>客户管理模块：负责管理客户的 registration 和信息更新。<br>支付 gateway 模块：负责处理订单的支付流程。<br>统计与报告模块：负责生成销售统计报表。</p><h2 id="设计模式（Design-Pattern）"><a href="#设计模式（Design-Pattern）" class="headerlink" title="设计模式（Design Pattern）"></a>设计模式（Design Pattern）</h2><p><b>定义：</b><br>设计模式是一个抽象的概念，指一组为了解决某一类问题的常用结构。它是软件工程中的一个重要概念，广泛应用于面向对象编程中。</p><p><b>特点：</b></p><p>标准化的命名和表达：每个模式都有一个标准名称和抽象的行为描述。<br>解决常见问题：设计模式通常用于解决特定类型的问题（如创建对象、对象获取、事务隔离等）。<br>可扩展性：在遵循模式的前提下，系统可以灵活地添加功能。</p><p><b>常见的设计模式：</b></p><p>工厂模式（Factory Pattern）<br>构造模式（Constructor Pattern）<br>表现模式（Presentation Mode）<br>行为模式（Behavioral Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>适配器模式（Adapter Pattern）</p><p><b>表现模式与构架模式的区别</b></p><table>    <tr>        <th>特性</th>        <th>表现模式</th>        <th>构架模式</th>    </tr>    <tr>        <td>功能分离</td>        <td>数据展示与业务逻辑分离</td>        <td>系统功能模块化，独立开发</td>    </tr>    <tr>        <td>目标</td>        <td>提高代码复用性和数据一致性</td>        <td>提高系统的可扩展性、测试性和维护性</td>    </tr>    <tr>        <td>依赖关系</td>        <td>强调事务隔离和数据的一致性</td>        <td>通过明确的接口定义功能模块之间的关系</td>    </tr>    <tr>        <td>实现方式</td>        <td>使用“表现层”或“数据绑定层”来管理显示逻辑</td>        <td>通过创建功能模块，将系统分解为独立的部分</td>    </tr>    </table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>表现模式主要用于分离数据展示和业务逻辑，提高代码的复用性和可读性。<br>构架模式则用于系统模块化设计，每个模块负责特定的功能。<br>设计模式是软件工程中的一个抽象概念，广泛应用于解决常见问题。</p><p><b>在实际项目中，通常会结合使用这些模式，例如：</b></p><p>使用构架模式来实现系统的模块化设计。<br>在某个模块中使用表现模式来分离显示逻辑和业务逻辑。<br>使用设计模式（如工厂模式或构造模式）来简化对象的创建或管理。<br>通过组合使用这些模式，可以提高系统的复用性、可维护性和扩展性。</p><h1 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h1><p><b>什么是 MVC 模式？</b></p><p>MVC 是一种软件架构设计模式，最初由IBM在数据库应用中提出，后来被扩展到Web和 GUI 开发领域。它将一个应用程序分解为三个主要部分：</p><li><b>模型（Model）</b>：负责处理数据逻辑、业务功能以及与控制器之间的通信。</li><li><b>视图（View）</b>：负责显示数据的呈现方式，通常是HTML页面或使用前端框架构建的组件。</li><li><b>控制器（Controller）</b>：接收用户输入并传递数据到模型和视图。</li><h2 id="MVC-在-GUI-开发中的应用"><a href="#MVC-在-GUI-开发中的应用" class="headerlink" title="MVC 在 GUI 开发中的应用"></a>MVC 在 GUI 开发中的应用</h2><p>MVC 模式在 GUI 应用开发中非常流行，原因如下：</p><li><b>分隔数据逻辑与呈现逻辑</b>：将处理数据的逻辑（模型）与显示数据的部分（视图）分开，使得代码更容易维护和复用。</li><li><b>响应式设计</b>：控制器可以实时更新视图，确保用户界面的动态性。这在前端开发中尤为重要，例如处理用户的点击事件、输入字段更改等。</li><li><b>分离 concerns</b>：每个部分有明确的责任，模型负责业务逻辑，视图负责数据展示，控制器负责用户交互，这样每个部分的功能更集中，易于理解和维护。</li><h2 id="MVC-模式的优点"><a href="#MVC-模式的优点" class="headerlink" title="MVC 模式的优点"></a>MVC 模式的优点</h2><li><b>代码复用性</b>：相同的模型可以被多个视图使用，减少了重复代码。</li><li><b>可扩展性</b>：新增功能时，只需修改模型或控制器，不影响视图。</li><li><b>易测试性</b>：每个部分相对独立，便于单元测试和集成测试。</li><li><b>用户体验一致</b>：通过视图组件化，可以为用户提供标准化的界面元素。</li><h2 id="MVC-模式的挑战"><a href="#MVC-模式的挑战" class="headerlink" title="MVC 模式的挑战"></a>MVC 模式的挑战</h2><li><b>学习曲线</b>：MVC 模式需要开发者理解三个分隔的部分及其交互机制，初期可能会有一定的学习成本。</li><li><b>复杂性</b>：在大型项目中，如果模型和控制器过于复杂，可能会增加维护难度。</li><li><b>性能优化</b>：由于数据传输的多级化（模型-控制器-视图），可能会影响性能，需要进行适当的缓存策略设计。</li><h2 id="MVC-模式的变种"><a href="#MVC-模式的变种" class="headerlink" title="MVC 模式的变种"></a>MVC 模式的变种</h2><p>除了标准的 MVC 模式，还有一些变种被应用在特定领域：</p><li><b>MVIA（Model-View-Interface-Aggregator）</b>：常用于图形界面编程语言如 Smalltalk 中。它将模型、视图、接口和聚合器分开。</li><li><b>V Model</b>：一种适用于前端框架的模式，类似于 MVC，广泛应用于React等框架中。</li><h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><p>在构建一个简单的电商网站时：</p><li><b>模型（Model）</b>：管理订单信息、商品库存、用户数据等。</li><li><b>视图（View）</b>：展示商品列表页面或购物车内容。</li><li><b>控制器（Controller）</b>：处理用户的搜索输入、添加商品点击事件、订单提交等功能。</li><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>MVC 模式在 GUI 开发中确实是一个指导模式，帮助开发者将数据逻辑与用户界面分离，实现高效的代码结构和良好的用户体验。理解并应用 MVC 模式能够显著提高开发效率和代码质量。</p><p>因此，MVC 模式是图形用户界面（GUI）开发中非常重要的设计模式之一。</p><br><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p><b>MVVM（Model-View-ViewModel）模式</b></p><p>MVVM（Model-View-ViewModel）是一种设计模式，通常用于前端开发，特别是在Vue.js等框架中被广泛使用。它是对MVC（Model-View-Controller）模式的一种扩展和优化，主要针对视图层与数据绑定的问题。</p><h2 id="MVVM的核心思想"><a href="#MVVM的核心思想" class="headerlink" title="MVVM的核心思想"></a>MVVM的核心思想</h2><p>在MVC模式中，模型（Model）、视图（View）和控制器（Controller）是分离的三者关系：</p><li><b>模型</b>：负责存储和管理业务逻辑相关的静态或动态数据。</li><li><b>视图</b>：负责将模型的数据呈现给用户。</li><li><b>控制器</b>：负责处理用户的输入事件，并根据业务逻辑更新模型。</li>    <p>然而，MVC模式的一个缺点是，当需要对视图进行动态绑定时，需要通过useEffect等函数手动渲染更新后的视图，这会导致代码冗余、难以维护。</p><p>MVVM模式解决了这个问题，它将模型与视图的绑定关系和数据的双向通信结合起来，提供了更高效的方式来管理数据和视图的动态更新。</p><h2 id="MVVM的主要组件"><a href="#MVVM的主要组件" class="headerlink" title="MVVM的主要组件"></a>MVVM的主要组件</h2><li><b>模型（Model）</b>：<p>负责存储和管理业务逻辑相关的静态或动态数据。<br>模型的数据可以通过命令（Command）的方式被控制器或其他组件访问和修改。</li></p><li><b>命令（Command）</b>：<p>用于将模型中的数据传递给视图层，并在视图层完成操作后，将结果反馈回模型。</li></p><li><b>管理器（Manager）</b>：<p>负责对命令的执行进行监控。<br>管理器确保命令的执行顺序和依赖关系。</li></p><li><b>镜像层（Mirror）</b>：<p>管理器与模型之间的一个中间层，负责将模型的数据传递给视图层，并根据视图层的反馈更新模型。</li></p><li><b>绑定层（Binding）</b>：<p>将数据从模型传递到视图组件中的组件属性上。<br>它可以用来实现单点绑定或多点绑定，并支持动态键值对。</li></p><h2 id="MVVM的工作流程"><a href="#MVVM的工作流程" class="headerlink" title="MVVM的工作流程"></a>MVVM的工作流程</h2><li><b>创建模型、命令和管理器</b>：<p>在组件的生命周期开始时，初始化模型、命令和管理器实例。</li></p><li><b>绑定视图与模型</b>：<p>使用&lt;mx:Binding&gt;标签将模型的数据传递到视图组件中的属性上。<br>确保数据双向绑定，即当视图更新时，模型也会同步更新；反之亦然。</li></p><li><b>绑定命令与管理器</b>：<p>使用useCommand &#x3D; true标记的命令实例绑定到管理器。<br>这些命令会通过useMirror传送到镜像层，并在视图层完成操作后反馈回模型。</li></p><li><b>绑定视图与命令</b>：<p>在视图组件中使用&lt;mx:Command&gt;标签，将数据传递给命令实例。<br>命令完成后，使用管理器来更新模型。</li></p><h2 id="MVVM的优势"><a href="#MVVM的优势" class="headerlink" title="MVVM的优势"></a>MVVM的优势</h2><li><b>数据一致性</b>：通过镜像层和绑定层的双向通信机制，确保模型、视图和命令之间的数据一致性。</li><li><b>组件化开发</b>：每个组件（模型、命令、管理器）都有明确的功能边界，便于理解和维护。</li><li><b>动态绑定</b>：能够实现视图与模型的双向数据绑定，避免手动渲染的问题。</li><h2 id="MVVM与MVC的区别"><a href="#MVVM与MVC的区别" class="headerlink" title="MVVM与MVC的区别"></a>MVVM与MVC的区别</h2><li><b>数据绑定</b>：<p>MVC模式需要通过useEffect等函数手动渲染更新后的视图，导致代码冗余。<br>MVVM模式通过镜像层和绑定层实现自动化的数据绑定和双向通信。</li></p><li><b>命令执行</b>：<p>MVC模式没有内置的命令机制，无法直接将模型的数据传递给视图或组件。<br>MVVM模式引入了命令机制，允许开发者更灵活地处理业务逻辑。</li></p><h2 id="MVVM的使用场景"><a href="#MVVM的使用场景" class="headerlink" title="MVVM的使用场景"></a>MVVM的使用场景</h2><p>MVVM模式非常适合需要对视图和数据进行深度绑定的应用场景，例如：</p><li><b>高级表格（Grid）</b>：实现动态列添加/删除、数据排序等操作。</li><li><b>组件化布局</b>：实现响应式设计中的自动缩放或布局调整。</li><li><b>数据可视化</b>：实现动态图表的数据更新。</li><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>MVVM模式通过将模型、命令和管理器结合在一起，实现了数据的双向绑定和高效的业务逻辑处理。它非常适合需要深度数据绑定和复杂组件化开发的应用场景。</p>]]></content>
      
      
      <categories>
          
          <category> MVVM </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> MVVM </tag>
            
            <tag> MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WPF概述三层架构、高内聚，低耦合、数据交互容器与载体。</title>
      <link href="/2025/02/01/WPF/WPF%E6%A6%82%E8%BF%B0/"/>
      <url>/2025/02/01/WPF/WPF%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="WPF技术概述"><a href="#WPF技术概述" class="headerlink" title="WPF技术概述"></a>WPF技术概述</h1><p><b>WPF全称为Windows Presentation Foundation,是一种基于XAML、.NET和向量绘图技术的表层开发框架，广泛用于软件图形界面的开发，是一种<mark>专门用来编写程序表示层的技术和工具。</mark></b></p><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p><b>在WPF（Windows Presentation Foundation）中，应用程序通常被划分为三层架构：<code>UI Layer、Business Layer 和 Network Layer</code>。每层都有其特定的功能和作用。</b></p><p><b>UI Layer（用户界面层）：</b></p><blockquote><p>负责显示应用程序的图形用户界面（GUI），包括窗体、控件和布局。<br>使用XAML定义界面元素和样式，使用C#或VB.NET编写用户交互逻辑。<br>处理用户的交互操作，如点击按钮、输入文本等。</p></blockquote><p><b>Business Layer（业务逻辑层）：</b></p><blockquote><p>负责应用程序的核心功能和数据管理，与数据库交互执行查询和更新操作。<br>使用Entity Framework进行ORM，提供 fluent API 或 WLINQ实现业务逻辑。<br>处理事务控制、错误处理和状态管理，确保数据的一致性和完整性。</p></blockquote><p><b>Network Layer（网络层）：</b></p><blockquote><p>负责数据的传输和通信，从客户端发送请求到服务器或从服务器返回响应。<br>使用.NET Core或其他网络库如DotNet&#x2F;Transport、Netty或GlassFish实现网络功能。<br>处理HTTP请求的生命周期，包括解析、数据传输、响应生成和错误处理。</p></blockquote><p><b>通过这三层架构的设计，WPF使得应用程序结构清晰、功能分明。UI Layer展示用户界面，Business Layer管理核心业务逻辑，Network Layer负责数据通信。各层之间相互关联，共同支撑整个应用的运行。理解和实现这三层架构是掌握WPF开发的关键。</b></p><h2 id="高内聚，低耦合"><a href="#高内聚，低耦合" class="headerlink" title="高内聚，低耦合"></a>高内聚，低耦合</h2><p><b>“高内聚，低耦合”</b>是一个软件设计模式中的核心概念，尤其是在遵循“开闭原则”时被广泛采用。这种设计理念强调使系统中的各个组件或部分之间的依赖尽可能少（低耦合），同时在每个组件内部实现功能的集中和独立（高内聚）。在WPF（Windows Presentation Foundation）中的三层架构中，“高内聚，低耦合”体现在以下几个方面：</p><p><b>1. 高内聚（High Cohesion）</b></p><blockquote><p>每一层的功能模块都被高度集中，其职责范围明确且相互之间依赖较少。具体来说：</p></blockquote><li><b>UI Layer</b>：负责显示和管理用户界面，包括窗体、控件、布局等。它的核心功能是展示图形内容，与其他层的交互主要通过中间层（如ViewModel）。</li><li><b>Business Layer</b>：负责应用的核心业务逻辑，如数据处理、事务管理、业务流程等。它依赖ORM（Object-Relational Mapping）技术与数据库交互，但对其它层的关系有限。</li><li><b>Network Layer</b>：专注于数据传输和通信，处理HTTP请求、数据发送/接收、认证等操作。这部分通常使用现成的库或框架来实现。</li><p><b>由于每一层的功能都非常集中，彼此之间的依赖关系弱，高内聚特性得以体现。</b></p><br><p><b>2. 低耦合（Low Coupling）</b></p><blockquote><p>各层之间的依赖关系尽可能少，相互之间几乎独立。具体来说：</p></blockquote><li><b>UI Layer</b>：与Business Layer和Network Layer之间的依赖仅限于中间层（如ViewModel或ViewModelBase），这些中间层负责传递数据和控制流。</li><li><b>Business Layer</b>：与UI和Network Layer之间的依赖也主要通过中间层实现，例如通过集合或事件来同步UI的变化。</li><li><b>Network Layer</b>：通常与其他两层的交互非常有限，主要处理本层特定的功能。</li><blockquote><p>低耦合特性使得每一层可以独立地被修改、升级或替换，而不会影响到整个系统的功能。</p></blockquote><br><h2 id="三层架构在“高内聚，低耦合”中的体现"><a href="#三层架构在“高内聚，低耦合”中的体现" class="headerlink" title="三层架构在“高内聚，低耦合”中的体现"></a>三层架构在“高内聚，低耦合”中的体现</h2><p><b>在WPF的三层架构中，“高内聚，低耦合”的特点具体体现在以下几个方面：</b></p><ol><b>UI Layer：</b>    <li>高内聚：仅负责显示和管理用户界面，与其他层的交互通过ViewModel或ViewModelBase实现。</li>    <li>低耦合：与业务逻辑（如数据查询）和网络操作之间的依赖关系非常弱。</li></ol><ol><b>Business Layer：</b>    <li>高内聚：主要负责应用的核心业务逻辑，如数据处理、事务管理等。它依赖ORM技术将数据库表映射到实体类，并通过中间层传递数据。</li>    <li>低耦合：与其他两层的依赖有限，通常通过ViewModel或ViewModelBase与UI Layer交互。</li>    </ol><ol><b>Network Layer：</b></b>P    <li>高内聚：专注于数据传输和通信，处理HTTP请求、数据发送/接收等操作。这部分功能较为独立，与其他层的依赖较少。</li>    <li>低耦合：与UI和业务层之间的交互主要通过中间层实现（如HttpBinding框架），不影响其核心逻辑。</li>    </ol> <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><b>在WPF的三层架构中，“高内聚，低耦合”的设计原则确保了各层功能的独立性和模块化。这种设计方式的优势在于：</b></p><blockquote><p>易于维护：每一层的功能清晰明确，可以独立地进行修改或升级。<br>扩展性强：新增功能时，只需在特定层中实现即可，无需影响其他层。<br>可重用性高：各层的设计较为通用，适合多种应用场景。<br>通过“高内聚，低耦合”的设计思想，WPF的三层架构实现了高效、稳定且易于维护的应用开发。</p></blockquote><h1 id="数据交互容器与载体"><a href="#数据交互容器与载体" class="headerlink" title="数据交互容器与载体"></a>数据交互容器与载体</h1><ol><li>数据容器</li></ol><blockquote><p>数据容器是指提供统一数据访问策略的组件或类，它负责将业务逻辑层、ViewModel（视图模型）和数据源连接起来。在WPF中，数据容器通常是一个自定义的数据访问接口或组件，用于管理与不同数据源（如数据库、云存储等）的交互。</p></blockquote><p><b>数据容器的主要职责包括：</b></p><li>定义与数据源的交互规则（如序列化/反序列化规则、过滤规则等）。</li><li>管理多个数据源之间的切换和协作。</li><li>提供数据访问权限，确保不同组件可以安全地访问数据源。</li><p><b>示例：</b></p><blockquote><p>在WPF中，数据容器可能是一个自定义的类或组件（如 DataContext 或 DataContextComp），它包含了对数据源的操作逻辑，并将这些操作与业务逻辑层和ViewModel结合在一起。</p></blockquote><ol start="2"><li>载体</li></ol><p>载体是指在视图模型（ViewModel）中使用桥梁（Bridge）将业务逻辑层的数据操作映射到数据容器的逻辑。载体负责通过桥梁将业务逻辑的操作结果传递给数据容器，或者从数据容器获取数据并返回给业务逻辑。</p><p>在WPF中，载体通常是一个自定义的组件或类，它包含了对桥梁（如 ILookupBridge、IlooDataAccessBridge）的引用，并负责管理与数据源的交互。载体将业务逻辑和数据源连接起来，确保数据操作的正确性和一致性。</p><p>示例：</p><p>载体可能是一个自定义的组件或类（如 UserDetailBridge），它包含了对桥梁的引用，并通过桥梁将用户的搜索结果传递给数据容器（如 DataContext 或 DataContextComp）。</p><ol start="3"><li>IlooDataAccessBridge</li></ol><p>在WPF中，IlooDataAccessBridge 是一个重要的桥梁接口，用于实现业务逻辑层与数据源之间的交互。它通过以下方式将业务逻辑和数据容器连接起来：</p><li>定义如何从数据源获取数据（如查询、更新等）。</li><li>定义如何将业务逻辑操作的结果映射到数据容器的逻辑中。</li><li>提供数据的序列化和反序列化功能。</li><p><b>示例：</b></p><p>在 UserDetailBridge 中，你可以定义一个方法来查询数据库中的用户信息：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserDetailBridge</span> <span class="title">implements</span> <span class="title">IlooDataAccessBridge</span>&lt;<span class="title">User</span>, <span class="title">IDetailsUser</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IBridgeBridge bridge;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">GetUserInfo</span>(<span class="params"><span class="built_in">int</span> userId</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> bridge.ExecuteScalar(<span class="string">&quot;SELECT * FROM Users WHERE Id = ? &quot;</span>, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>数据容器与载体的关系<blockquote><p>数据容器和载体在WPF中通常结合使用，以实现高效的业务逻辑操作。具体关系如下：</p></blockquote></li></ol><p>数据容器负责管理与数据源的交互策略（如序列化、反序列化规则）。<br>载体（通过桥梁）将业务逻辑的操作结果传递给数据容器，并从数据容器获取数据。</p><p><b>示例：</b></p><p>在WPF中，数据容器和载体可能结合在一起使用如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserDetailBridge</span> <span class="title">implements</span> <span class="title">IlooDataAccessBridge</span>&lt;<span class="title">User</span>, <span class="title">IDetailsUser</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IBridgeBridge bridge;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> DataContext dataContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">GetUserInfo</span>(<span class="params"><span class="built_in">int</span> userId</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> bridge.ExecuteScalar(<span class="string">&quot;SELECT * FROM Users WHERE Id = ? &quot;</span>, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserDetailContainer</span> : <span class="title">IlooDataContextComp</span>&lt;<span class="title">IDetailsUser</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDetailContainer</span>(<span class="params">IBridgeBridge bridge</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bridge != <span class="literal">null</span>)</span><br><span class="line">            bridge.SetBridge(bridge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>总结</li></ol><blockquote><p>数据容器：提供统一的策略和管理逻辑，将业务逻辑与数据源连接起来。<br>载体：通过桥梁将业务逻辑的操作结果传递给数据容器，并从数据容器获取数据。<br>IlooDataAccessBridge：是实现业务逻辑层与数据源交互的核心桥梁。<br>通过合理使用这些组件，可以更好地组织WPF应用的代码结构，提高数据访问的效率和可维护性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> WPF </category>
          
          <category> .NET </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> WPF </tag>
            
            <tag> 三层架构 </tag>
            
            <tag> 高内聚 </tag>
            
            <tag> 低耦合 </tag>
            
            <tag> 数据交互容器与载体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 列表</title>
      <link href="/2025/01/29/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E5%88%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/"/>
      <url>/2025/01/29/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E5%88%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="列表的基本用法"><a href="#列表的基本用法" class="headerlink" title="列表的基本用法"></a>列表的基本用法</h1><p><b>创建列表</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建空列表</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并初始化列表</span></span><br><span class="line">List&lt;<span class="built_in">string</span>&gt; names = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p><b>添加元素</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">numbers.Add(<span class="number">10</span>);       <span class="comment">// 在末尾添加单个元素</span></span><br><span class="line">numbers.AddRange(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">20</span>, <span class="number">30</span> &#125;); <span class="comment">// 添加多个元素</span></span><br></pre></td></tr></table></figure><p><b>访问元素</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> first = numbers[<span class="number">0</span>];  <span class="comment">// 通过索引访问（类似数组）</span></span><br></pre></td></tr></table></figure><p><b>删除元素</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">numbers.Remove(<span class="number">20</span>);      <span class="comment">// 删除第一个匹配的元素</span></span><br><span class="line">numbers.RemoveAt(<span class="number">0</span>);     <span class="comment">// 删除指定索引的元素</span></span><br><span class="line">numbers.Clear();         <span class="comment">// 清空列表</span></span><br></pre></td></tr></table></figure><p><b>遍历列表</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> numbers)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用属性和方法"><a href="#常用属性和方法" class="headerlink" title="常用属性和方法"></a>常用属性和方法</h1><blockquote><p>属性&#x2F;方法说明<br>Count获取列表中的元素数量（实际存储的元素数）<br>Capacity获取或设置列表的内部容量（动态扩容时的预分配大小）<br>Add(T item)在列表末尾添加元素<br>Insert(int index, T item)在指定位置插入元素<br>Contains(T item)检查元素是否存在<br>IndexOf(T item)返回元素的第一个匹配项的索引<br>Sort()对列表元素排序（需元素实现 IComparable 接口或提供自定义比较器）<br>Find(Predicate&lt;T&gt; match)查找第一个符合条件的元素<br>ForEach(Action&lt;T&gt; action)对每个元素执行操作</p></blockquote><p><b> 示例代码</b></p><p><b>动态操作列表</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;<span class="built_in">string</span>&gt; fruits = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span> &#125;;</span><br><span class="line">fruits.Add(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">fruits.Insert(<span class="number">1</span>, <span class="string">&quot;Mango&quot;</span>);</span><br><span class="line">fruits.Remove(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> fruit <span class="keyword">in</span> fruits)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(fruit); <span class="comment">// 输出：Apple, Mango, Cherry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 LINQ 查询列表</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> evenNumbers = numbers.Where(n =&gt; n % <span class="number">2</span> == <span class="number">0</span>).ToList(); <span class="comment">// 筛选偶数</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, evenNumbers)); <span class="comment">// 输出：2, 8</span></span><br></pre></td></tr></table></figure><p>最佳实践<br>预分配容量<br>如果已知元素数量，初始化时指定容量以减少动态扩容的开销：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(<span class="number">100</span>); <span class="comment">// 初始容量为 100</span></span><br><span class="line">避免频繁插入/删除</span><br><span class="line">若需要频繁在中间插入或删除元素，考虑使用 LinkedList&lt;T&gt;。</span><br></pre></td></tr></table></figure><p>使用集合初始化器<br>简化代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">结合 LINQ</span><br><span class="line">使用 LINQ 方法（如 Where, Select, OrderBy）简化复杂查询。</span><br></pre></td></tr></table></figure><p><b> 常见问题<br>如何高效复制列表？</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; copy = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(originalList); <span class="comment">// 通过构造函数复制</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; copy2 = originalList.ToList();      <span class="comment">// 使用 LINQ 的 ToList()</span></span><br></pre></td></tr></table></figure><p>如何将列表转换为数组？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] array = numbers.ToArray();</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>List&lt;T&gt; 是 C# 中最常用的集合类型之一，适用于需要动态调整大小的场景。通过灵活的方法和 LINQ 集成，它可以高效处理大多数集合操作。在使用时需注意容量管理和性能优化，结合具体需求选择合适的数据结构。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 运算符重载</title>
      <link href="/2025/01/28/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2025/01/28/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符重载（Operator-Overloading）"><a href="#运算符重载（Operator-Overloading）" class="headerlink" title="运算符重载（Operator Overloading）"></a>运算符重载（Operator Overloading）</h1><p><b>在 C# 中，运算符重载（Operator Overloading） 是一种允许你为自定义的类或结构体重新定义运算符行为的特性。通过运算符重载，你可以让自定义类型像内置类型（如 int、string）一样，直接使用 +、-、&#x3D;&#x3D; 等运算符进行操作，使代码更简洁、直观。</b></p><p>核心要点<br>目的<br>让自定义类型支持运算符操作，提升代码可读性。例如，用 a + b 代替 a.Add(b)。</p><p>实现方式<br>通过定义 public static 方法，并使用 operator 关键字声明要重载的运算符：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 <span class="keyword">operator</span> 运算符(参数) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="可重载的运算符"><a href="#可重载的运算符" class="headerlink" title="可重载的运算符"></a>可重载的运算符</h2><p><b>算术运算符：+, -, *, &#x2F;, %</p><p>比较运算符：&#x3D;&#x3D;, !&#x3D;, &lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;</p><p>逻辑运算符：!,&amp;, |, ^</p><p>位运算符： &lt; &lt;, &gt;&gt;</p><p>类型转换运算符：implicit（隐式转换）和 explicit（显式转换）</p><p>其他：true, false, ++, –</p><p>不可重载的运算符：<br>&amp; &amp;, ||, &#x3D;, new, is, as, ??, &#x3D;&gt;, . 等。</b></p><br><p><b>简单示例<br>假设有一个表示二维向量的类 Vector，重载 + 运算符实现向量相加：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Vector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 + 运算符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Vector <span class="keyword">operator</span> +(Vector v1, Vector v2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector(v1.X + v2.X, v1.Y + v2.Y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 ToString 方便输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span> =&gt; <span class="string">$&quot;(<span class="subst">&#123;X&#125;</span>, <span class="subst">&#123;Y&#125;</span>)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Vector v1 = <span class="keyword">new</span> Vector(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">Vector v2 = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Vector sum = v1 + v2; <span class="comment">// 直接使用 + 运算符</span></span><br><span class="line">Console.WriteLine(sum); <span class="comment">// 输出 &quot;(4, 6)&quot;</span></span><br></pre></td></tr></table></figure><p><b>关键规则<br>必须为静态方法<br>运算符重载的方法必须是 public static。</p><p>参数和返回类型</p><p>运算符的操作数必须包含当前类型（例如 Vector + Vector）。</p><p>返回类型可以是任意类型，但通常与当前类型一致。</p><p>成对重载</p><p>若重载 &#x3D;&#x3D;，必须同时重载 !&#x3D;。</p><p>若重载 &lt;，通常需要重载 &gt;、 &lt;&#x3D;、&gt;&#x3D;。</p><p>重写 Equals 和 GetHashCode<br>如果重载了比较运算符（如 &#x3D;&#x3D;），必须同时重写 Equals() 和 GetHashCode()，确保逻辑一致。</p><p>典型应用场景<br>数学对象<br>复数、矩阵、多项式等需要算术运算的类型。</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line">Complex c1 = <span class="keyword">new</span> Complex(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Complex c2 = <span class="keyword">new</span> Complex(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">Complex sum = c1 + c2; <span class="comment">// 直接相加</span></span><br></pre></td></tr></table></figure><p><b>物理量<br>距离、速度、温度等需要运算符操作的物理量。</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line">Distance d1 = <span class="keyword">new</span> Distance(<span class="number">10</span>, Unit.Meter);</span><br><span class="line">Distance d2 = <span class="keyword">new</span> Distance(<span class="number">5</span>, Unit.Meter);</span><br><span class="line">Distance total = d1 + d2; <span class="comment">// 自动单位转换并相加</span></span><br></pre></td></tr></table></figure><p><b>自定义逻辑<br>例如重载 + 合并集合，或重载 &#x3D;&#x3D; 比较对象的业务逻辑等价性。</p><p>注意事项<br>避免滥用<br>运算符的行为必须符合直觉。例如，+ 不应被重载为减法操作。</p><p>性能优化<br>避免在运算符重载中执行复杂操作（如数据库查询）。</p><p>隐式&#x2F;显式转换<br>使用 implicit 或 explicit 定义类型转换时需谨慎，确保不会导致歧义。</b></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><b>运算符重载让自定义类型可以像内置类型一样使用运算符，使代码更简洁、直观。但需遵循语义合理性（如 + 表示加法）和一致性原则（如成对重载 &#x3D;&#x3D; 和 !&#x3D;）。正确使用时，能大幅提升代码可读性；滥用则会导致代码难以维护。</b></p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 索引器的使用</title>
      <link href="/2025/01/28/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E7%B4%A2%E5%BC%95%E5%99%A8/"/>
      <url>/2025/01/28/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E7%B4%A2%E5%BC%95%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是索引器？"><a href="#什么是索引器？" class="headerlink" title="什么是索引器？"></a>什么是索引器？</h1><p><b>索引器（Indexer）是 C# 中的一种特殊成员，允许对象像数组或集合一样通过索引（如 []）访问内部元素。</p><p>类似于属性（Property），但通过索引参数访问数据。</p><p>常用于封装集合类（如自定义列表、字典），使其可以通过索引直接操作元素。</b></p><h1 id="如何定义和使用索引器？"><a href="#如何定义和使用索引器？" class="headerlink" title="如何定义和使用索引器？"></a>如何定义和使用索引器？</h1><p>语法结构</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line"><span class="keyword">public</span> 返回类型 <span class="keyword">this</span>[参数类型 index]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="comment">/* 返回 index 对应的值 */</span> &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; <span class="comment">/* 设置 index 对应的值 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">示例代码</span><br><span class="line">csharp</span><br><span class="line">复制</span><br><span class="line"><span class="keyword">class</span> <span class="title">StringCollection</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>[] _data = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义索引器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= _data.Length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException();</span><br><span class="line">            <span class="keyword">return</span> _data[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= _data.Length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException();</span><br><span class="line">            _data[index] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用索引器</span></span><br><span class="line"><span class="keyword">var</span> collection = <span class="keyword">new</span> StringCollection();</span><br><span class="line">collection[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span>;  <span class="comment">// 通过索引赋值</span></span><br><span class="line">Console.WriteLine(collection[<span class="number">0</span>]);  <span class="comment">// 通过索引取值</span></span><br></pre></td></tr></table></figure><br><p><b>关键点</p><p>使用 this 关键字定义。</p><p>支持多个参数（如多维索引）：public int this[int x, int y] { … }。</p><p>可以重载（不同参数类型或数量）。</b></p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p><b>适合使用索引器的场景<br>封装集合类<br>当类内部包含数组、列表或其他集合时，通过索引器提供类似数组的访问方式。</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] _items;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _items[index]; &#125; <span class="keyword">set</span> &#123; _items[index] = <span class="keyword">value</span>; &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line">键值对访问</span><br><span class="line">类似字典的键值访问，例如通过字符串索引：</span><br><span class="line"></span><br><span class="line">csharp</span><br><span class="line">复制</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Config</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; _settings = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">string</span> key]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _settings[key]; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _settings[key] = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><b>数学结构</p><p>表示矩阵、向量等数学结构时，通过多维索引访问元素：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[,] _matrix = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">int</span> row, <span class="built_in">int</span> col]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _matrix[row, col]; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _matrix[row, col] = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><b>简化代码<br>当需要通过索引直接操作对象内部数据时，索引器比方法调用更直观：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line"><span class="comment">// 使用索引器</span></span><br><span class="line">myObject[<span class="number">5</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 对比方法</span></span><br><span class="line">myObject.SetValue(<span class="number">5</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><br><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p><b>索引器参数类型<br>可以是任意类型（如 int、string、enum 等），但需确保逻辑合理。</p><p>异常处理<br>在 get 和 set 中需检查索引有效性，避免越界错误。</p><p>不可静态<br>索引器不能声明为 static。</p><p>与属性的区别</p><p>属性通过名称访问（如 obj.Name），索引器通过参数访问（如 obj[0]）。</p><p>索引器可以有多个参数，属性没有参数。</b></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><b>索引器用于让对象支持类似数组的索引访问，适用于封装集合或需要直接通过索引操作数据的场景。合理使用索引器可以提升代码的可读性和易用性，但需注意边界检查和参数逻辑。</b></p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 虚方法和隐藏方法-抽象类和密封类</title>
      <link href="/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E8%99%9A%E6%96%B9%E6%B3%95%E5%92%8C%E9%9A%90%E8%97%8F%E6%96%B9%E6%B3%95/"/>
      <url>/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E8%99%9A%E6%96%B9%E6%B3%95%E5%92%8C%E9%9A%90%E8%97%8F%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="虚方法和隐藏方法"><a href="#虚方法和隐藏方法" class="headerlink" title="虚方法和隐藏方法"></a>虚方法和隐藏方法</h1><h2 id="虚方法（Virtual-Method）"><a href="#虚方法（Virtual-Method）" class="headerlink" title="虚方法（Virtual Method）"></a>虚方法（Virtual Method）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><b>定义</b></h3><p><b>在 C# 中，虚方法是在基类中使用virtual关键字修饰的方法。它允许派生类重写（override）该方法的实现。虚方法提供了一种多态性的机制，使得在运行时可以根据对象的实际类型来调用相应的方法。</b></p><li><b>示例</b></li><blockquote><p>考虑一个简单的动物类层次结构。首先有一个基类Animal：</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The animal makes a sound.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">然后有一个派生类Dog，它重写了MakeSound方法：</span><br><span class="line">csharp</span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The dog barks.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h2><p>当通过基类引用指向派生类对象时，调用虚方法会根据对象的实际类型（即派生类类型）来执行相应的方法。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">animal.MakeSound(); <span class="comment">// 输出 &quot;The dog barks.&quot;</span></span><br></pre></td></tr></table></figure><p>这展示了多态性，因为即使animal被声明为Animal类型，但实际执行的是Dog类中重写后的MakeSound方法。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>虚方法在基类中定义了一个基本的方法框架，派生类可以根据自己的需求进行定制化的重写。重写方法时，必须使用override关键字，并且方法签名（方法名称、参数列表和返回类型）必须与基类中的虚方法完全一致。</p><br><h1 id="隐藏方法（Method-Hiding）"><a href="#隐藏方法（Method-Hiding）" class="headerlink" title="隐藏方法（Method Hiding）"></a>隐藏方法（Method Hiding）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>当派生类中定义了一个与基类中方法同名的方法，但没有使用override关键字（或者基类方法不是虚方法）时，就发生了方法隐藏。方法隐藏是通过在派生类方法前使用new关键字来显式地表示这种隐藏意图。</p><li><b>示例</b></li><p>假设还是刚才的Animal类，但是这次MakeSound方法不是虚方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The animal makes a sound.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">然后在派生类Cat中隐藏这个方法：</span><br><span class="line">csharp</span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The cat meows.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用方式-1"><a href="#调用方式-1" class="headerlink" title="调用方式"></a>调用方式</h2><p>与虚方法不同，隐藏方法的调用取决于引用变量的类型，而不是对象的实际类型。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br><span class="line">animal.MakeSound(); <span class="comment">// 输出 &quot;The animal makes a sound.&quot;</span></span><br><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.MakeSound(); <span class="comment">// 输出 &quot;The cat meows.&quot;</span></span><br></pre></td></tr></table></figure><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><p><b>方法隐藏可能会导致一些意外的行为，因为它不像虚方法那样遵循多态性原则。一般来说，如果想要实现多态性，应该优先考虑使用虚方法和重写，而方法隐藏主要用于在派生类中提供一个与基类同名但行为不同的方法，并且明确地表明这种行为是独立于基类方法的意图。</b></p><h1 id="抽象类（Abstract-Class）"><a href="#抽象类（Abstract-Class）" class="headerlink" title="抽象类（Abstract Class）"></a>抽象类（Abstract Class）</h1><h2 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h2><p><b>抽象类是使用 abstract 关键字修饰的类，它不能被实例化，主要用于作为其他类的基类，为派生类提供一个通用的模板或框架。</p><p>抽象类可以包含抽象方法、非抽象方法、属性、字段等成员。抽象方法是使用 abstract 关键字修饰的方法，它只有方法声明，没有方法体，派生类必须实现这些抽象方法。</b></p><li>示例代码</li><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义抽象类 Animal</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 抽象方法，派生类必须实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The animal is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Dog 继承自抽象类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实现抽象方法 MakeSound</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The dog barks.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不能实例化抽象类</span></span><br><span class="line">        <span class="comment">// Animal animal = new Animal(); // 这行代码会编译错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以使用派生类实例化</span></span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.MakeSound(); <span class="comment">// 输出: The dog barks.</span></span><br><span class="line">        dog.Eat(); <span class="comment">// 输出: The animal is eating.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p><b>Animal 是一个抽象类，其中包含一个抽象方法 MakeSound 和一个非抽象方法 Eat。<br>Dog 类继承自 Animal 类，必须实现 MakeSound 方法。<br>在 Main 方法中，不能直接实例化抽象类 Animal，但可以实例化派生类 Dog，并调用其方法。</b></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><b>当你需要定义一组相关类的通用行为，但某些行为的具体实现需要由派生类来完成时，可以使用抽象类。例如，图形类可以定义为抽象类，其中包含计算面积的抽象方法，不同的图形（如圆形、矩形）继承自该抽象类并实现具体的计算方法。</b></p><h1 id="密封类（Sealed-Class）"><a href="#密封类（Sealed-Class）" class="headerlink" title="密封类（Sealed Class）"></a>密封类（Sealed Class）</h1><h2 id="定义与特点-1"><a href="#定义与特点-1" class="headerlink" title="定义与特点"></a>定义与特点</h2><p><b>密封类是使用 sealed 关键字修饰的类，它不能被继承，即不能有派生类。<br>密封类通常用于防止其他类继承和修改其行为，从而保证类的安全性和稳定性。密封类可以包含各种成员，与普通类的区别在于它不能作为基类。</b></p><li>示例代码</li><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义密封类 Circle</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="built_in">double</span> radius</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">CalculateArea</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试继承密封类，会导致编译错误</span></span><br><span class="line"><span class="comment">// class DerivedCircle : Circle &#123; &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">double</span> area = circle.CalculateArea();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;The area of the circle is: <span class="subst">&#123;area&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h2><p><b>Circle 是一个密封类，它包含一个私有字段 radius、一个构造函数和一个计算面积的方法 CalculateArea。<br>尝试定义一个继承自 Circle 的类 DerivedCircle 会导致编译错误，因为密封类不能被继承。<br>在 Main 方法中，可以正常实例化密封类 Circle 并调用其方法。</p><h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><p>当你希望某个类的实现细节不被其他类修改，或者某个类的设计已经是最终版本，不需要再进行扩展时，可以使用密封类。例如，一些工具类、单例类等可以设计为密封类。<br>综上所述，抽象类用于提供通用的抽象模板，促进代码的复用和多态性；而密封类用于限制类的继承，保证类的安全性和稳定性。</b></p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 继承</title>
      <link href="/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/"/>
      <url>/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><b>在 C# 中，继承是面向对象编程的一个核心概念，它允许一个类（子类或派生类）继承另一个类（父类或基类）的属性和方法，从而实现代码的复用和扩展。以下从多个方面详细介绍 C# 中的继承：<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>继承建立了类与类之间的一种 “is - a” 关系，即子类是父类的一种特殊类型。通过继承，子类可以拥有父类的成员（字段、属性、方法等），并且可以添加自己特有的成员或重写父类的成员以实现不同的行为。</p><p>语法示例</p><p>以下是一个简单的继承示例，展示了如何定义父类和子类：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个父类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Name&#125;</span> is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个子类 Dog，继承自 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Bark</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Name&#125;</span> is barking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">&quot;Buddy&quot;</span>);</span><br><span class="line">        dog.Eat(); </span><br><span class="line">        dog.Bark(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>在上述代码中：</p><blockquote><p>Animal 是父类，包含一个属性 Name 和一个方法 Eat。<br>Dog 是子类，使用 : 符号表示继承自 Animal 类。子类 Dog 不仅继承了父类的 Name 属性和 Eat 方法，还添加了自己特有的方法 Bark。<br>在 Dog 类的构造函数中，使用 base(name) 调用父类的构造函数来初始化从父类继承的属性。</b></p></blockquote><h2 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h2><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p><b>C# 只支持单继承，即一个类只能直接继承自一个父类。但可以通过接口实现多继承的效果，一个类可以实现多个接口。例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ICanFly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ICanSwim</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Swim</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实现多个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Duck</span> : <span class="title">ICanFly</span>, <span class="title">ICanSwim</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The duck is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Swim</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The duck is swimming.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问修饰符与继承"><a href="#访问修饰符与继承" class="headerlink" title="访问修饰符与继承"></a>访问修饰符与继承</h2><p><b>父类的 public 成员可以在子类中直接访问。<br>父类的 protected 成员只能在父类本身、子类和同一个程序集内的其他类中访问。例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> protectedField = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Child</span> : <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintProtectedField</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(protectedField); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>父类的 private 成员不能被子类直接访问。</p></blockquote><h2 id="方法重写（Override）"><a href="#方法重写（Override）" class="headerlink" title="方法重写（Override）"></a>方法重写（Override）</h2><p><b>子类可以重写父类的虚方法（使用 virtual 关键字修饰的方法），以实现不同的行为。重写时需要使用 override 关键字。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing a shape.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing a circle.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承的优点</p><p>代码复用：避免了重复编写相同的代码，提高了开发效率。例如，多个不同类型的动物类都可以继承自 Animal 类，复用 Eat 方法。</p><p>可维护性：如果需要修改父类的某个通用功能，只需要在父类中修改一次，所有子类都会受到影响，减少了代码的维护成本。</p><p>扩展性：子类可以在继承父类的基础上添加新的功能，实现对现有代码的扩展。</b></p><br><h1 id="base关键字"><a href="#base关键字" class="headerlink" title="base关键字"></a>base关键字</h1><h2 id="调用父类的构造函数"><a href="#调用父类的构造函数" class="headerlink" title="调用父类的构造函数"></a>调用父类的构造函数</h2><p><code>在子类的构造函数中，可以使用 base 关键字来调用父类的构造函数，以完成父类成员的初始化。这在子类需要继承父类的某些初始化逻辑时非常有用。</code></p><p><b>示例代码</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> studentId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类的构造函数，使用 base 调用父类的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age, <span class="built_in">string</span> studentId</span>) : <span class="title">base</span>(<span class="params">name, age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.studentId = studentId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 Student 类的构造函数中，base(name, age) 调用了父类 Person 的构造函数，将 name 和 age 参数传递给父类构造函数进行初始化。这样可以避免在子类中重复编写父类成员的初始化代码。</p></blockquote><h2 id="访问父类的方法和属性"><a href="#访问父类的方法和属性" class="headerlink" title="访问父类的方法和属性"></a>访问父类的方法和属性</h2><p><code>当子类中重写了父类的方法或属性时，可以使用 base 关键字来访问父类的原始实现。</code></p><p><b>示例代码</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing a shape.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 base 调用父类的 Draw 方法</span></span><br><span class="line">        <span class="keyword">base</span>.Draw();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing a circle.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 Circle 类中重写了 Draw 方法。通过 base.Draw()，可以先调用父类 Shape 的 Draw 方法，然后再执行子类特有的绘制逻辑。这使得子类可以在父类的基础上进行功能扩展。</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><b>访问权限：base 只能访问父类中可访问的成员。即父类的 public 和 protected 成员可以通过 base 访问，而 private 成员不能通过 base 访问。<br>调用时机：在子类构造函数中使用 base 调用父类构造函数时，base 语句必须是构造函数中的第一条语句。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>base 关键字为子类提供了一种方便的方式来与父类进行交互。它可以帮助我们在子类中复用父类的构造逻辑，并且在重写方法时能够访问父类的原始实现，从而实现代码的复用和功能的扩展。</b></p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 堆栈和静态类型</title>
      <link href="/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E5%A0%86%E6%A0%88%E5%92%8C%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E5%A0%86%E6%A0%88%E5%92%8C%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="堆栈和静态储区"><a href="#堆栈和静态储区" class="headerlink" title="堆栈和静态储区"></a>堆栈和静态储区</h1><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><b>概念</b></h3><li><b>值类型：</b></li><blockquote><p>值类型变量直接包含它们的数据。当你声明一个值类型变量时，这个变量本身存储了实际的值。例如，C# 中的基本数据类型（如int、double、bool等）都是值类型。如果有一个int变量num &#x3D; 5;，变量num存储的就是数字5这个值。值类型在内存中的存储相对简单，通常存储在栈（Stack）上。</p></blockquote><li><b>引用类型：</b></li><blockquote><p>引用类型变量存储的是一个引用，这个引用指向存储数据的实际内存位置（通常是堆 - Heap）。例如，在 C# 中，类（Class）、接口（Interface）、委托（Delegate）等都是引用类型。当你创建一个类的对象时，例如MyClass myObj &#x3D; new MyClass();，变量myObj存储的是指向MyClass对象在堆内存中实际存储位置的引用。</p></blockquote><h3 id="内存分配和管理"><a href="#内存分配和管理" class="headerlink" title="内存分配和管理"></a><b>内存分配和管理</b></h3><li><b>值类型：</b></li><p><code>如前面提到的，值类型一般存储在栈上。当一个值类型变量进入作用域（例如在一个方法内部声明）时，它会在栈上分配内存，当变量离开作用域时，其占用的栈内存会被自动释放。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">int</span> num2 = num1;</span><br><span class="line">        num2 = <span class="number">20</span>;</span><br><span class="line">        Console.WriteLine(num1); </span><br><span class="line">        <span class="comment">// 输出10，因为num1和num2是两个独立的值类型变量，num2的修改不影响num1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，num1和num2都是int值类型变量，它们在栈上有各自独立的存储空间。当num2被赋值为20时，num1的值不受影响。</p></blockquote><li><b>引用类型：</b></li><p><code>引用类型的对象本身存储在堆中，而引用变量存储在栈上。当你创建一个引用类型的对象时，会在堆中分配内存来存储对象的数据，同时在栈上创建一个引用变量来指向堆中的对象。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass obj1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">        obj1.Value = <span class="number">10</span>;</span><br><span class="line">        MyClass obj2 = obj1;</span><br><span class="line">        obj2.Value = <span class="number">20</span>;</span><br><span class="line">        Console.WriteLine(obj1.Value); </span><br><span class="line">        <span class="comment">// 输出20，因为obj1和obj2指向同一个堆中的对象，修改obj2会影响obj1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里，obj1和obj2是引用变量，它们指向同一个MyClass对象在堆中的存储位置。当通过obj2修改Value属性时，obj1所指向的对象的属性也被修改了，因为它们引用的是同一个对象。</p></blockquote><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><b>参数传递</b></h3><li><b>值类型：</b></li><p><code>当一个值类型变量作为参数传递给一个方法时，实际上是将变量的值复制一份传递给方法。方法内部对参数的修改不会影响原始变量的值。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModifyValue</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> originalNum = <span class="number">10</span>;</span><br><span class="line">        ModifyValue(originalNum);</span><br><span class="line">        Console.WriteLine(originalNum); </span><br><span class="line">        <span class="comment">// 输出10，因为在ModifyValue方法中修改的是复制后的num，而不是originalNum</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><li><b>引用类型：</b></li><p><code>当一个引用类型变量作为参数传递给一个方法时，传递的是引用的副本。这意味着方法内部可以通过这个引用访问和修改原始对象。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModifyObject</span>(<span class="params">MyClass obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.Value = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">        MyClass originalObj = <span class="keyword">new</span> MyClass();</span><br><span class="line">        originalObj.Value = <span class="number">10</span>;</span><br><span class="line">        ModifyObject(originalObj);</span><br><span class="line">        Console.WriteLine(originalObj.Value); </span><br><span class="line">        <span class="comment">// 输出20，因为在ModifyObject方法中通过引用修改了originalObj指向的对象的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a><b>性能差异</b></h3><li><b>值类型：</b></li><blockquote><p>由于值类型数据存储在栈上，访问速度通常比较快。而且值类型的内存管理相对简单，在变量离开作用域时自动释放内存，不需要像引用类型那样进行复杂的垃圾回收（Garbage Collection）操作。</p></blockquote><li><b>引用类型：</b></li><blockquote><p>引用类型的存储和访问涉及到堆和栈的交互。从栈上的引用变量访问堆中的对象可能会稍微慢一些。并且，引用类型对象的生命周期由垃圾回收机制管理，当对象不再被引用时，垃圾回收器会在合适的时间回收对象占用的堆内存，这个过程可能会带来一定的性能开销。不过，引用类型的灵活性使得它们在面向对象编程中非常重要，例如用于实现复杂的数据结构和对象之间的关系。</p></blockquote><br><h1 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h1><h2 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h2><blockquote><p>在 C# 中，栈（Stack）是一种用于存储数据的数据结构，它主要用于存储方法（函数）调用的相关信息，包括局部变量、方法参数、返回地址等。栈的操作遵循 “后进先出”（LIFO - Last In First Out）原则，就像一摞盘子，最后放上去的盘子最先被拿下来。</p></blockquote><blockquote><p>栈在内存中有一个固定的大小（这个大小由操作系统和编译器等因素决定），并且是自动管理内存的。当一个方法被调用时，系统会在栈上为这个方法分配一块内存区域，用于存储该方法所需的信息。当方法执行结束后，这块内存区域会被自动释放，栈顶指针会相应地调整，使得栈恢复到之前的状态。</p></blockquote><h2 id="栈在内存中的存储方式"><a href="#栈在内存中的存储方式" class="headerlink" title="栈在内存中的存储方式"></a>栈在内存中的存储方式</h2><blockquote><p>栈通常存储在内存的较高地址区域。它的内存布局是从高地址向低地址增长的。例如，当一个新的方法被调用时，新的栈帧（Stack Frame）会在栈顶创建。栈帧包含了这个方法的所有局部变量和调用信息。</p></blockquote><blockquote><p>假设一个简单的 C# 程序，在Main方法中调用了另一个方法SomeMethod，当SomeMethod被调用时，一个新的栈帧会在栈顶被创建，用于存储SomeMethod的局部变量和其他相关信息。当SomeMethod执行完毕，这个栈帧会被销毁，栈顶指针会回到Main方法栈帧的位置。</p></blockquote><h2 id="栈在方法调用中的作用"><a href="#栈在方法调用中的作用" class="headerlink" title="栈在方法调用中的作用"></a>栈在方法调用中的作用</h2><h3 id="参数传递："><a href="#参数传递：" class="headerlink" title="参数传递："></a>参数传递：</h3><blockquote><p>当一个方法被调用时，方法的参数会被压入栈中。例如，对于一个方法void MyMethod(int a, int b)，当调用MyMethod(3, 5)时，值3和5会按照从右到左的顺序（在 C# 中一般是这个顺序）被压入栈中。这是因为在方法内部，参数的访问通常是从左到右的，先压入b的值5，再压入a的值3，这样在方法内部就可以按照正确的顺序访问参数。</p></blockquote><h3 id="局部变量存储："><a href="#局部变量存储：" class="headerlink" title="局部变量存储："></a>局部变量存储：</h3><blockquote><p>方法内部的局部变量也存储在栈中。例如，在一个方法void AnotherMethod()中有一个局部变量int localVar &#x3D; 10，这个localVar变量会在AnotherMethod的栈帧中分配一个存储位置，用于存放值10。</p></blockquote><h3 id="返回地址存储："><a href="#返回地址存储：" class="headerlink" title="返回地址存储："></a>返回地址存储：</h3><blockquote><p>当一个方法被调用时，调用该方法的指令的下一条指令的地址（即返回地址）会被存储在栈中。这样，当被调用的方法执行完毕后，系统可以根据这个返回地址回到调用者继续执行后面的指令。例如，在Main方法中调用SomeFunction，当SomeFunction被调用时，Main方法中调用SomeFunction指令的下一条指令的地址会被存储在栈中，当SomeFunction执行结束后，程序会根据这个地址回到Main方法继续执行。</p></blockquote><h3 id="访问速度："><a href="#访问速度：" class="headerlink" title="访问速度："></a>访问速度：</h3><blockquote><p>一般来说，栈的访问速度相对较快。因为栈的内存布局比较规整，而且不需要像堆那样进行复杂的内存管理操作（如垃圾回收）来查找和释放内存。数据在栈上的存储和访问比较直接，而堆中的对象可能因为垃圾回收等操作而导致存储位置发生变化，从而影响访问速度。</p></blockquote><br><h1 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h1><p><code>在 C# 中，堆（Heap）是用于动态内存分配的重要内存区域，主要用于存储引用类型的对象。下面将从堆的基本概念、堆内存分配、垃圾回收机制、堆与栈的对比等方面详细介绍。</code></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>堆是一块较大的内存区域，它与栈不同，栈主要用于存储局部变量和方法调用信息，遵循后进先出（LIFO）原则。而堆用于存储引用类型的对象，其内存分配和释放由垃圾回收器（Garbage Collector，GC）负责管理，不遵循 LIFO 原则。</p></blockquote><h2 id="堆内存分配"><a href="#堆内存分配" class="headerlink" title="堆内存分配"></a>堆内存分配</h2><p><code>当使用 new 关键字创建一个引用类型的对象时，系统会在堆上为该对象分配内存。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在堆上创建一个 Person 对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.Name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        person.Age = <span class="number">25</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上述代码中，new Person() 语句会在堆上分配一块内存，用于存储 Person 对象的 Name 和 Age 字段。同时，栈上的 person 变量存储的是指向堆上该 Person 对象的引用。</p></blockquote><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p><code>垃圾回收器（GC）负责自动回收堆上不再被引用的对象所占用的内存。其主要工作流程如下：<br>标记阶段：GC 会从根对象（如全局变量、静态变量、当前执行栈中的变量等）开始遍历所有可达的对象，并将这些对象标记为 “存活”。<br>清除阶段：未被标记为 “存活” 的对象被视为垃圾对象，GC 会回收这些对象所占用的内存。<br>压缩阶段：为了减少内存碎片，GC 可能会对堆上的存活对象进行移动和整理，使它们在内存中连续存储。</code></p><li><b>例如：</b></li>    <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass obj1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">        obj1.Value = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 现在 obj1 指向一个新的对象，原来的对象不再被引用</span></span><br><span class="line">        obj1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">        obj1.Value = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 之前创建的第一个 MyClass 对象成为了垃圾，等待垃圾回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>垃圾回收器会在合适的时机（如堆空间不足、手动触发等）对这些垃圾对象进行回收。</p></blockquote><h2 id="堆与栈的对比"><a href="#堆与栈的对比" class="headerlink" title="堆与栈的对比"></a>堆与栈的对比</h2><table>    <tr>        <th>对比项</th>        <th>堆</th>        <th>栈</th>    </tr>    <tr>        <td>存储内容</td>        <td>引用类型的对象</td>        <td>值类型的变量、方法调用信息（如局部变量、返回地址等）</td>    </tr>    <tr>        <td>内存管理</td>        <td>由垃圾回收器自动管理</td>        <td>自动分配和释放，方法执行结束后，栈上的内存自动回收</td>    </tr>    <tr>    <td>分配和访问速度</td>    <td>相对较慢，因为涉及复杂的内存管理和对象查找</td>    <td>相对较快，内存分配和释放简单直接</td>    </tr>    <tr>        <td>内存布局</td>        <td>不遵循特定顺序，可能会产生内存碎片</td>        <td>遵循后进先出（LIFO）原则，内存布局较为规整</td>    </tr>    </table>        <h2 id="堆的性能影响因素"><a href="#堆的性能影响因素" class="headerlink" title="堆的性能影响因素"></a>堆的性能影响因素</h2><blockquote><p>象创建频率：频繁创建和销毁对象会增加垃圾回收的负担，影响性能。可以考虑对象池技术来复用对象，减少对象创建和销毁的次数。<br>大对象分配：大对象（如大型数组）会被分配到特殊的大对象堆（LOH）中，大对象堆的垃圾回收机制与普通堆不同，频繁分配大对象可能会导致内存碎片化和性能问题。<br>垃圾回收策略：不同的垃圾回收模式（如工作站模式、服务器模式）适用于不同的应用场景，选择合适的垃圾回收模式可以提高性能。<br>综上所述，了解 C# 中堆的工作原理和特点，有助于编写高效、稳定的代码。</p></blockquote><br><h1 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h1><p><code>C# 中，静态类型是一个重要的概念，它贯穿于语言的多个方面，下面从静态类型的定义、静态成员、静态类以及静态类型检查几个方面详细介绍：</code></p><h2 id="静态类型的定义"><a href="#静态类型的定义" class="headerlink" title="静态类型的定义"></a>静态类型的定义</h2><p><code>静态类型指的是在编译时就确定变量、表达式或参数的类型。在 C# 里，当你声明一个变量时，必须明确指定它的类型，编译器会在编译阶段进行类型检查，确保代码中所有操作都符合该类型的定义。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个 int 类型的变量</span></span><br><span class="line"><span class="built_in">int</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 声明一个 string 类型的变量</span></span><br><span class="line"><span class="built_in">string</span> message = <span class="string">&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在上述代码中，number 被明确指定为 int 类型，message 被指定为 string 类型，编译器在编译时会根据这些类型信息来验证对它们的操作是否合法。例如，不能直接将一个字符串赋值给 int 类型的变量，否则会产生编译错误。</p></blockquote><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><h3 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a><b>静态字段</b></h3><p><code>静态字段属于类本身，而不是类的实例。无论创建多少个类的实例，静态字段在内存中只有一份副本。可以通过类名直接访问静态字段。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 静态字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> StaticField = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过类名访问静态字段</span></span><br><span class="line">        Console.WriteLine(MyClass.StaticField); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a><b>静态方法</b></h3><p><code>静态方法同样属于类本身，不能通过类的实例来调用，只能通过类名调用。静态方法只能直接访问类的静态成员，不能直接访问实例成员。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过类名调用静态方法</span></span><br><span class="line">        <span class="built_in">int</span> result = Calculator.Add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(result); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a><b>静态属性</b></h3><p><code>静态属性和静态字段类似，也是属于类本身。可以通过类名来访问静态属性，并且可以在属性的访问器中添加自定义的逻辑。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Count</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; count = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过类名访问静态属性</span></span><br><span class="line">        Counter.Count = <span class="number">5</span>;</span><br><span class="line">        Console.WriteLine(Counter.Count); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h2><p><code>静态类是一种特殊的类，它只能包含静态成员，不能被实例化。静态类常用于创建工具类，提供一组相关的静态方法和属性。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MathUtils</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Square</span>(<span class="params"><span class="built_in">double</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num * num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> Pi &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="number">3.14159</span>; &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过类名调用静态方法</span></span><br><span class="line">        <span class="built_in">double</span> result = MathUtils.Square(<span class="number">4</span>);</span><br><span class="line">        Console.WriteLine(result); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过类名访问静态属性</span></span><br><span class="line">        Console.WriteLine(MathUtils.Pi); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态类型检查"><a href="#静态类型检查" class="headerlink" title="静态类型检查"></a>静态类型检查</h2><p><code>静态类型检查是 C# 编译器在编译阶段进行的一项重要工作。它会检查代码中变量的使用是否符合其声明的类型，确保类型安全。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 下面这行代码会产生编译错误，因为不能将 int 类型赋值给 string 类型的变量</span></span><br><span class="line"><span class="comment">// string str = num; </span></span><br></pre></td></tr></table></figure><blockquote><p>编译器会在编译时发现上述代码的类型不匹配问题，并给出相应的错误信息，从而避免在运行时出现类型相关的异常。这种静态类型检查机制有助于提高代码的可靠性和可维护性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 匿名类型</title>
      <link href="/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>在 C# 中，匿名类型是一种可以在不定义具体类型（如类）的情况下创建对象的方式。匿名类型提供了一种便捷的方法来封装一组只读属性，通常用于临时的数据存储和传递。</code></p><p><b>匿名类型的实例是由编译器自动生成的类型，其类型名对于开发者是不可见的。例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> &#123; Name = <span class="string">&quot;John&quot;</span>, Age = <span class="number">30</span> &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里创建了一个匿名类型的对象person，它有两个属性Name和Age。var关键字让编译器根据初始化表达式来推断变量<br>的类型。</p></blockquote><p><b>属性访问</b></p><p><b>可以通过对象实例来访问其属性。例如，对于上面的person对象，可以这样访问属性：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(person.Name); </span><br><span class="line">Console.WriteLine(person.Age);</span><br></pre></td></tr></table></figure><p><b>由于匿名类型的属性是只读的，不能对其进行重新赋值。例如，下面的代码是错误的：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.Name = <span class="string">&quot;Jane&quot;</span>; <span class="comment">// 编译错误，因为匿名类型的属性是只读的</span></span><br></pre></td></tr></table></figure><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p><code>LINQ 查询结果的临时存储：在 LINQ（Language - Integrated Query）中，经常会使用匿名类型来存储查询结果。例如，假设有一个List&lt;int&gt;类型的列表numbers，要获取其中每个数字的平方和立方并存储为一个新的对象集合，可以这样做：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> n <span class="keyword">in</span> numbers</span><br><span class="line">             <span class="keyword">select</span> <span class="keyword">new</span> &#123; Square = n * n, Cube = n * n * n &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里result是一个包含匿名类型对象的集合，每个对象都有Square和Cube两个属性，分别存储数字的平方和立方。</p></blockquote><p><code>作为方法返回值的临时类型：当需要从一个方法返回一组简单的数据，但又不想专门为此定义一个类时，可以使用匿名类型。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">object</span> <span class="title">GetData</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> &#123; Message = <span class="string">&quot;Success&quot;</span>, StatusCode = <span class="number">200</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>调用GetData方法时，会返回一个匿名类型的对象，包含Message和StatusCode两个属性。</p></blockquote><h2 id="匿名类型的限制"><a href="#匿名类型的限制" class="headerlink" title="匿名类型的限制"></a>匿名类型的限制</h2><p><code>不能跨方法共享：因为匿名类型是由编译器在编译时生成的临时类型，其类型定义只在定义它的方法内部有效。如果要在多个方法之间传递数据，最好使用自定义的类或结构。</code></p><p><code>缺少类型名称：由于没有明确的类型名称，不能将匿名类型用作方法参数的类型声明（除非使用object等更通用的类型来接收），也不能用于继承等面向对象的高级特性。例如，不能这样定义一个方法：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessData</span>(<span class="params"><span class="keyword">new</span> &#123; Name = <span class="string">&quot;&quot;</span>, Age = <span class="number">0</span> &#125;</span>) <span class="comment">// 编译错误，不能使用匿名类型作为参数类型</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 构造函数的使用，this关键字</title>
      <link href="/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="什么是构造函数？"><a href="#什么是构造函数？" class="headerlink" title="什么是构造函数？"></a>什么是构造函数？</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><b>定义</b></h3><p><code>在 C# 中，构造函数是一种特殊的方法，它与类同名，并且没有返回类型（甚至不能是 void）。构造函数主要用于在创建类的对象时初始化对象的状态。例如，当你创建一个Person类的对象时，可以使用构造函数来初始化Person对象的姓名、年龄等属性。</code></p><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a><b>默认构造函数</b></h3><p><code>如果一个类中没有定义任何构造函数，C# 编译器会自动提供一个默认构造函数。这个默认构造函数没有参数，并且它的作用是初始化对象的成员变量为它们的默认值（例如，数值类型为 0，引用类型为null）。</code></p><p><b>例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> myVariable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">        <span class="comment">// 此时obj.myVariable的值为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="带参数的构造函数"><a href="#带参数的构造函数" class="headerlink" title="带参数的构造函数"></a><b>带参数的构造函数</b></h3><p><code>可以定义带参数的构造函数来根据传入的参数初始化对象的属性。</code></p><p><b>例如，定义一个Rectangle类来表示矩形，有width和height两个属性：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Width &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Height &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"><span class="built_in">int</span> width, <span class="built_in">int</span> height</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Width = width;</span><br><span class="line">        Height = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Rectangle rect = <span class="keyword">new</span> Rectangle(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 此时rect.Width的值为5，rect.Height的值为3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="构造函数的重载"><a href="#构造函数的重载" class="headerlink" title="构造函数的重载"></a><b>构造函数的重载</b></h3><p><code>C# 允许在一个类中定义多个构造函数，只要它们的参数列表不同（参数个数、参数类型或者参数顺序不同）。这被称为构造函数的重载。</code></p><p><b>例如，对于上面的Rectangle类，可以添加一个默认构造函数：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Width &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Height &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Width = <span class="number">0</span>;</span><br><span class="line">        Height = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"><span class="built_in">int</span> width, <span class="built_in">int</span> height</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Width = width;</span><br><span class="line">        Height = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Rectangle rect1 = <span class="keyword">new</span> Rectangle();</span><br><span class="line">        <span class="comment">// rect1.Width和rect1.Height的值都为0</span></span><br><span class="line">        Rectangle rect2 = <span class="keyword">new</span> Rectangle(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// rect2.Width的值为5，rect2.Height的值为3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a><b>构造函数的继承</b></h3><p><code>在派生类中，如果没有显式地调用基类的构造函数，编译器会默认调用基类的无参数构造函数。</code></p><p><b>例如，有一个基类Shape和一个派生类Circle：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = <span class="string">&quot;Shape&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Radius &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="built_in">double</span> radius</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle(<span class="number">2.0</span>);</span><br><span class="line">        <span class="comment">// circle.Name的值为&quot;Shape&quot;，这是因为默认调用了基类Shape的无参数构造函数</span></span><br><span class="line">        <span class="comment">// circle.Radius的值为2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><blockquote><p>如果基类没有无参数构造函数，并且派生类需要调用基类的有参数构造函数，可以使用base关键字在派生类的构造函数中显式地调用基类构造函数。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Radius &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="built_in">double</span> radius</span>) : <span class="title">base</span>(<span class="params"><span class="string">&quot;Circle&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle(<span class="number">2.0</span>);</span><br><span class="line">        <span class="comment">// circle.Name的值为&quot;Circle&quot;，通过base关键字调用了基类Shape的有参数构造函数</span></span><br><span class="line">        <span class="comment">// circle.Radius的值为2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><hr><h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><h2 id="含义和用途"><a href="#含义和用途" class="headerlink" title="含义和用途"></a><b>含义和用途</b></h2><p><code>在 C# 中，this是一个引用当前类的实例的关键字。它主要用于在类的内部区分成员变量和局部变量，尤其是当它们名称相同时。例如，当一个类的方法参数与类的成员变量同名时，使用this可以明确地引用成员变量。</code></p><p><b>例如，有一个Person类，包含name属性和一个方法来设置name属性：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetName</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><blockquote><p>在SetName方法中，参数name是局部变量，this.name引用的是类中的成员变量name。当调用SetName方法并传入一个字符串时，这个字符串会被赋值给成员变量name。</p></blockquote><h3 id="在构造函数中的使用"><a href="#在构造函数中的使用" class="headerlink" title="在构造函数中的使用"></a><b>在构造函数中的使用</b></h3><p><code>this也常用于在一个类的构造函数中调用其他构造函数。这在构造函数重载的情况下很有用，可以避免代码重复。</code></p><p><b>例如，对于一个Rectangle类，有两个构造函数，一个接收长和宽，另一个只接收边长（用于创建正方形）：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"><span class="built_in">int</span> width, <span class="built_in">int</span> height</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"><span class="built_in">int</span> sideLength</span>) : <span class="title">this</span>(<span class="params">sideLength, sideLength</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><blockquote><p>在第二个构造函数中，通过this(sideLength, sideLength)调用了第一个构造函数，这样就可以复用设置width和height的代码。</p></blockquote><h3 id="在链式调用中的应用"><a href="#在链式调用中的应用" class="headerlink" title="在链式调用中的应用"></a><b>在链式调用中的应用</b></h3><p><b>可以在方法返回当前类的实例时使用this来实现链式调用。例如，在一个Calculator类中：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Calculator <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        result += num;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetResult</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以这样使用：Calculator calc &#x3D; new Calculator().Add(5).Add(3).GetResult();，这里Add方法返回this，使得可以连续调用Add方法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp public与private说明 set-get方法</title>
      <link href="/2025/01/26/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%AC%E6%9C%89%E8%AF%B4%E6%98%8E/"/>
      <url>/2025/01/26/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%AC%E6%9C%89%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="set-get方法的使用"><a href="#set-get方法的使用" class="headerlink" title="set-get方法的使用"></a>set-get方法的使用</h1><p><code>在 C# 中，get 和 set 主要用于定义属性（Property），属性是一种用于封装字段（Field）的成员，它提供了对字段的访问控制，使得可以更安全、更方便地读取和修改字段的值。以下是关于 get 和 set 的详细介绍：</code></p><p><b>1. 属性的基本概念</b></p><blockquote><p>属性结合了字段和方法的优点，从外部看它就像一个字段，可以像访问字段一样访问属性；但在内部，它通过 get 和 set 访问器来控制对字段的读写操作。</p></blockquote><p><b>2. 完整属性定义（包含 get 和 set）</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 私有字段，用于存储数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共属性，用于封装 _name 字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get 访问器用于获取属性的值</span></span><br><span class="line">            <span class="keyword">return</span> _name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// set 访问器用于设置属性的值</span></span><br><span class="line">            <span class="comment">// value 是一个隐式参数，代表要设置的值</span></span><br><span class="line">            _name = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 设置属性值，调用 set 访问器</span></span><br><span class="line">        person.Name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取属性值，调用 get 访问器</span></span><br><span class="line">        Console.WriteLine(person.Name); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>在上述代码中：</b></p><blockquote><p>_name 是一个私有字段，用于实际存储数据。<br>Name 是一个公共属性，它封装了 _name 字段。<br>get 访问器用于返回 _name 字段的值，当从外部读取 Name 属性时，会执行 get 访问器中的代码。<br>set 访问器用于设置 _name 字段的值，当从外部给 Name 属性赋值时，会执行 set 访问器中的代码，value 是一个隐式参数，它代表要设置的新值。</p></blockquote><p><b>3. 只读属性（只包含 get 访问器）</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> _radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="built_in">double</span> radius</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只读属性，只有 get 访问器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Area</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.PI * _radius * _radius;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 可以读取 Area 属性的值</span></span><br><span class="line">        Console.WriteLine(circle.Area); </span><br><span class="line">        <span class="comment">// 下面这行代码会报错，因为 Area 是只读属性</span></span><br><span class="line">        <span class="comment">// circle.Area = 100; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，Area 属性只有 get 访问器，没有 set 访问器，所以它是只读的。外部代码只能读取该属性的值，不能对其进行赋值操作。</p></blockquote><p><b>4. 自动实现属性（简化属性定义）</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Book</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自动实现属性，编译器会自动生成一个隐藏的私有字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Author &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.Title = <span class="string">&quot;C# Programming&quot;</span>;</span><br><span class="line">        book.Author = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Title: <span class="subst">&#123;book.Title&#125;</span>, Author: <span class="subst">&#123;book.Author&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在自动实现属性中，不需要显式定义私有字段，编译器会自动生成一个隐藏的私有字段。可以直接使用 get 和 set 访问器，代码更加简洁。</p></blockquote><p><b>5. 访问修饰符与 get、set</b></p><blockquote><p>可以为 get 和 set 访问器分别指定不同的访问修饰符，以实现更细粒度的访问控制。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _age = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 类内部可以调用私有 set 访问器</span></span><br><span class="line">        Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 可以读取 Age 属性的值</span></span><br><span class="line">        Console.WriteLine(student.Age); </span><br><span class="line">        <span class="comment">// 下面这行代码会报错，因为 set 访问器是私有的</span></span><br><span class="line">        <span class="comment">// student.Age = 21; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，Age 属性的 set 访问器被声明为 private，这意味着只有在 Student 类内部才能修改 Age 属性的值，外部代码只能读取该属性的值。</p></blockquote><br><hr><h1 id="Csharp-public与private的权限控制"><a href="#Csharp-public与private的权限控制" class="headerlink" title="Csharp public与private的权限控制"></a>Csharp public与private的权限控制</h1><p><b>访问修饰符的概念</b></p><p><code>在 C# 中，访问修饰符用于控制类、成员（如字段、方法、属性等）的可访问性。<mark>public</mark>和<mark>private</mark>是两种最常用的访问修饰符。它们定义了代码中的哪些部分可以访问特定的类成员。</code></p><p><b>private访问修饰符</b></p><blockquote><p>含义：private是最严格的访问级别。被标记为private的成员只能在其所属的类内部访问。</p></blockquote><p><b>示例代码：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> myPrivateVariable;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MyPrivateMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这个方法可以访问myPrivateVariable</span></span><br><span class="line">        myPrivateVariable = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">AnotherClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myObj = <span class="keyword">new</span> MyClass();</span><br><span class="line">        <span class="comment">// 下面这行代码会导致编译错误，因为myPrivateVariable是私有的，不能在MyClass外部访问</span></span><br><span class="line">        <span class="comment">// myObj.myPrivateVariable = 5;</span></span><br><span class="line">        <span class="comment">// 下面这行代码会导致编译错误，因为MyPrivateMethod是私有的，不能在MyClass外部访问</span></span><br><span class="line">        <span class="comment">// myObj.MyPrivateMethod();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>用途：</b></p><blockquote><p>用于隐藏类的内部实现细节。例如，一个类可能有一些内部的计数器或者状态变量，这些变量不应该被外部代码随意修改，就可以将它们声明为private。这样可以确保类的完整性和一致性，防止外部代码对内部数据进行不恰当的操作。<br>限制对方法的访问。有些方法可能只是为了辅助类内部的其他方法而存在，不应该被外部调用，将这些方法声明为private可以避免它们被误用。</p></blockquote><p><b>public访问修饰符</b></p><blockquote><p>含义：public提供了最广泛的访问级别。被标记为public的成员可以从任何其他类访问，无论是在同一个程序集中还是在引用了该程序集的其他程序集中。</p></blockquote><p><b>示例代码：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> myPublicVariable;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyPublicMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这个方法可以被其他类访问</span></span><br><span class="line">        myPublicVariable = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">AnotherClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myObj = <span class="keyword">new</span> MyClass();</span><br><span class="line">        myObj.myPublicVariable = <span class="number">5</span>;</span><br><span class="line">        myObj.MyPublicMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>用途：</b></p><blockquote><p>当需要向外部提供类的功能或者数据时使用。例如，一个表示图形的类可能有一个public方法用于绘制图形，或者一个表示数据库连接的类可能有public属性用于获取连接字符串。这些public成员构成了类与外部世界交互的接口，其他类可以通过这些接口来使用该类的功能。</p></blockquote><p>protected（受保护的）</p><p>含义：被 protected 修饰的成员可以在其所属的类内部以及该类的派生类中访问。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> myProtectedVariable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyDerivedClass</span> : <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyDerivedMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可以访问myProtectedVariable，因为MyDerivedClass继承自MyBaseClass</span></span><br><span class="line">        myProtectedVariable = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>internal（内部的）</p><p>含义：被 internal 修饰的成员可以在同一程序集（一个.dll 或.exe 文件）内的任何类中访问。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyInternalClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">MyInternalMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有另一个类在相同的程序集中，就可以访问MyInternalClass和MyInternalMethod，但如果在其他程序集中则无法访问。</p><p>protected internal（受保护的内部）</p><p>含义：这是一种组合修饰符。被 protected internal 修饰的成员可以在其所属的类内部、该类的派生类中或者同一程序集内的任何类中访问。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyBaseClass2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">internal</span> <span class="built_in">int</span> myProtectedInternalVariable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyDerivedClass2</span> : <span class="title">MyBaseClass2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyDerivedMethod2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可以访问myProtectedInternalVariable，因为是派生类</span></span><br><span class="line">        myProtectedInternalVariable = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，在同一程序集中的其他类也可以访问myProtectedInternalVariable。</p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp类的定义和使用</title>
      <link href="/2025/01/26/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/01/26/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><p><code>在 C# 中，类是一种用户定义的数据类型，它是面向对象编程的基本构建块。类用于封装数据（通过字段）和行为（通过方法）。定义一个类的基本语法如下：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类的成员（字段、方法、属性等）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>例如，定义一个简单的Person类：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 字段，用于存储人的姓名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="comment">// 方法，用于打印问候语</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Hello, my name is <span class="subst">&#123;Name&#125;</span>.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h1><p><b>字段</b></p><p><code>字段是类中的变量，用于存储数据。它们可以有不同的访问修饰符，如public、private、protected等。public字段可以从类的外部访问，而private字段只能在类的内部访问。例如，在上面的Person类中，Name是一个public字段。</code></p><p><b>方法</b></p><p><code>方法是类中的函数，用于定义类的行为。方法可以接受参数并返回一个值。例如，Person类中的SayHello方法没有参数，并且返回类型为void（即不返回任何值）。如果一个方法要返回一个值，需要在方法声明中指定返回类型。</code></p><p><b>例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>属性</b><br>属性提供了一种灵活的方式来访问和修改类中的数据。属性在形式上类似于字段，但实际上它们包含了get（用于获取值）和set（用于设置值）访问器。例如，我们可以为Person类的Name字段添加属性：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样，我们可以通过属性来访问和修改_name字段，并且可以在get和set访问器中添加额外的逻辑，如数据验证。</p></blockquote><p><b>构造函数</b></p><p><code>构造函数是一种特殊的方法，用于在创建类的对象时初始化对象的状态。构造函数的名称与类名相同，并且没有返回类型（甚至不能是void）。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>现在，当我们创建一个Person对象时，必须提供姓名和年龄：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><b>访问修饰符</b></p><blockquote><p>public：公开的，类的外部可以访问。例如，public方法和字段可以在其他类中通过对象实例来访问。<br>private：私有的，只能在类的内部访问。通常用于封装类的内部实现细节，防止外部代码的非法访问。<br>protected：受保护的，只能在类的内部以及该类的派生类中访问。用于在继承关系中控制成员的访问权限。<br>internal：内部的，在同一个程序集（Assembly）内可以访问。这对于组织代码和限制访问范围很有用。</p></blockquote><p><b>继承</b></p><p><code>C# 支持类的继承，它允许一个类（派生类或子类）继承另一个类（基类或父类）的成员。继承的语法如下：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 派生类的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>例如，定义一个Student类继承自Person类：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> School;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age, <span class="built_in">string</span> school</span>) : <span class="title">base</span>(<span class="params">name, age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        School = school;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里，Student类继承了Person类的Name和Age字段以及相关方法。并且Student类有自己的字段School。构造函数中的base(name, age)用于调用基类Person的构造函数来初始化继承的成员。</p></blockquote><p><b>多态性</b></p><p><code>多态性是面向对象编程的重要概念，C# 通过方法重写（Override）来实现多态。在基类中定义一个虚方法（使用virtual关键字），然后在派生类中重写该方法（使用override关键字）。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">double</span> <span class="title">Area</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="built_in">double</span> r</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Area</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当我们有一个Shape类型的数组，其中包含不同的形状（如Circle）对象时，通过调用Area方法，会根据对象的实际类型（多态）来执行正确的Area计算方法。</p></blockquote><br><hr><h1 id="车辆类与向量类的定义和使用"><a href="#车辆类与向量类的定义和使用" class="headerlink" title="车辆类与向量类的定义和使用"></a>车辆类与向量类的定义和使用</h1><p><b>车辆类（Vehicle Class）</b></p><p><b>定义和基本属性</b></p><p><code>首先，车辆类可以包含车辆的基本属性，如品牌（brand）、型号（model）、颜色（color）、速度（speed）等。在 C# 中，可以这样定义车辆类：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Brand &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Model &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> speed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Speed</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> speed; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里，Brand、Model和Color是公共属性，可以直接读写。Speed属性是通过一个私有字段speed来实现的，并且在设置速度时进行了简单的验证，确保速度不小于 0。</p></blockquote><p><b>方法</b></p><p><code>车辆类可以有一些方法，比如加速（Accelerate）和减速（Decelerate）方法。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//... 前面定义的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>(<span class="params"><span class="built_in">double</span> increment</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Speed += increment;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Decelerate</span>(<span class="params"><span class="built_in">double</span> decrement</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Speed -= decrement;</span><br><span class="line">        <span class="keyword">if</span> (Speed &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Speed = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这些方法可以改变车辆的速度属性。Accelerate方法将速度增加指定的增量，Decelerate方法将速度减少指定的减量，并确保速度不会小于 0。</p></blockquote><br><p><b>向量类（Vector Class）</b></p><p><b>定义和基本操作</b></p><p><code>在数学和编程中，向量是一个很重要的概念。在 C# 中，可以定义一个二维向量类，包含 x 和 y 两个分量。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Vector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这是一个简单的向量类定义，有两个公共属性X和Y来表示向量的两个分量，并且通过构造函数来初始化这两个分量。</p></blockquote><p><b>向量运算方法</b></p><p><b>向量类可以有一些方法来进行向量运算，比如向量加法和减法。</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Vector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//... 前面定义的属性和构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector <span class="title">Add</span>(<span class="params">Vector other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector(X + other.X, Y + other.Y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector <span class="title">Subtract</span>(<span class="params">Vector other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector(X - other.X, Y - other.Y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Add方法用于将当前向量和另一个向量相加，返回一个新的向量。Subtract方法用于将当前向量减去另一个向量，也返回一个新的向量。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp面向对象概念引入</title>
      <link href="/2025/01/26/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5%E5%BC%95%E5%85%A5/"/>
      <url>/2025/01/26/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5%E5%BC%95%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象编程（Object-Oriented-Programming）"><a href="#面向对象编程（Object-Oriented-Programming）" class="headerlink" title="面向对象编程（Object - Oriented Programming）"></a>面向对象编程（Object - Oriented Programming）</h1><h2 id="面向对象概念引入："><a href="#面向对象概念引入：" class="headerlink" title="面向对象概念引入："></a>面向对象概念引入：</h2><p> <b>从实际生活场景类比引入</b></p><p><code>想象我们要开发一个汽车管理系统。在现实生活中，汽车是一个具有多种属性和行为的实体。汽车有颜色（如红色、蓝色）、品牌（如丰田、宝马）、速度（如 0 - 200km/h）等属性，还有启动、加速、刹车等行为。</code></p><p><b>在 C# 中，我们可以把汽车抽象成一个<mark>类（class）</mark>，就像创建一个汽车的蓝图。这个类可以定义汽车的各种属性和行为。例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 汽车的属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Brand;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Speed;</span><br><span class="line">    <span class="comment">// 汽车的行为（方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The car has started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Speed += <span class="number">10</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;The <span class="subst">&#123;Brand&#125;</span> car&#x27;s speed is now <span class="subst">&#123;Speed&#125;</span> km/h.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Brake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Speed -= <span class="number">5</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;The <span class="subst">&#123;Brand&#125;</span> car&#x27;s speed is now <span class="subst">&#123;Speed&#125;</span> km/h.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里，Color、Brand和Speed是汽车类的属性，用来描述汽车的状态。Start、Accelerate和Brake是方法，代表汽车可以执行的行为。这就是面向对象编程中类的概念，它是对象的模板，定义了对象具有什么和能做什么。<br>通过简单程序结构引入对象和类的关系</p></blockquote><br><p><b>当我们有了汽车类这个蓝图后，就可以创建汽车对象。在 C# 中，使用<mark>new</mark>关键字来创建对象。例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Car myCar = <span class="keyword">new</span> Car();</span><br><span class="line">        myCar.Color = <span class="string">&quot;Red&quot;</span>;</span><br><span class="line">        myCar.Brand = <span class="string">&quot;Toyota&quot;</span>;</span><br><span class="line">        myCar.Speed = <span class="number">0</span>;</span><br><span class="line">        myCar.Start();</span><br><span class="line">        myCar.Accelerate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个Main方法中，Car myCar &#x3D; new Car();这一行创建了一个Car类的对象myCar。然后我们可以像设置变量一样设置对象的属性，如myCar.Color &#x3D; “Red”;。并且可以调用对象的方法，如myCar.Start();和myCar.Accelerate();。这就像根据汽车蓝图制造出了一辆具体的汽车，然后可以对这辆汽车进行各种操作，比如改变它的颜色、启动它、让它加速等。这体现了对象是类的实例的概念，每个对象都有自己独立的属性值，可以执行类中定义的方法。</p></blockquote><br><p><b>引入封装概念以增强数据安全性和程序可维护性</b></p><p><code>在上面的例子中，汽车的属性是直接可访问的，这在某些情况下可能会导致问题。例如，外部代码可能会不小心设置不合理的速度值。为了更好地控制对数据的访问，C# 提供了封装机制。</code></p><p><b>我们可以把属性设为<mark>private（私有）</mark>，然后通过公共<mark>（public）</mark>的方法来访问和修改这些属性。例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> color;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> brand;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> speed;</span><br><span class="line">    <span class="comment">// 公共属性（用于访问私有属性）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> color; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; color = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Brand</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> brand; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; brand = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Speed</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> speed; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 汽车的行为（方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The car has started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Speed += <span class="number">10</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;The <span class="subst">&#123;Brand&#125;</span> car&#x27;s speed is now <span class="subst">&#123;Speed&#125;</span> km/h.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Brake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Speed -= <span class="number">5</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;The <span class="subst">&#123;Board&#125;</span> car&#x27;s speed is now <span class="subst">&#123;Speed&#125;</span> km/h.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里，color、brand和speed是私有属性，外部代码不能直接访问它们。通过定义公共属性Color、Brand和Speed，外部代码可以安全地获取和设置这些属性的值。而且在Speed属性的set方法中，我们可以添加逻辑来确保速度值不会被设置为负数，这增强了数据的安全性和程序的可维护性，体现了封装的概念。</p></blockquote><br><p><b>引入继承来展示代码复用和层次结构</b></p><p><code>假设我们要创建一个跑车（Sports Car）类，跑车也是汽车，它具有汽车的基本属性和行为，但还有一些特殊的功能，比如涡轮增压（Turbo Boost）。</code></p><p><b>在 C# 中，我们可以使用继承来创建跑车类。跑车类（SportsCar）可以继承汽车类（Car）的属性和方法，并添加自己的新方法。例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SportsCar</span> : <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurboBoost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Speed += <span class="number">50</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;The <span class="subst">&#123;Brand&#125;</span> sports car&#x27;s speed after turbo boost is <span class="subst">&#123;Speed&#125;</span> km/h.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里，SportsCar类继承了Car类，它自动拥有了Car类的Color、Brand、Speed属性和Start、Accelerate、Brake方法。同时，它还添加了自己的TurboBoost方法。这体现了继承的概念，通过继承可以复用代码，并且可以构建层次化的类结构，使得程序更加清晰和易于维护。</p></blockquote><br><p><b>引入多态来展示方法的灵活性和动态性</b></p><p><code>假设我们有一个方法，它的功能是让汽车显示自己的信息。在汽车类（Car）中，我们可以定义一个方法：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DisplayInfo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;This is a <span class="subst">&#123;Brand&#125;</span> car with color <span class="subst">&#123;Color&#125;</span> and speed <span class="subst">&#123;Speed&#125;</span> km/h.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>对于跑车类（SportsCar），我们可以重写（override）这个方法来显示更详细的信息：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SportsCar</span> : <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">DisplayInfo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;This is a sports <span class="subst">&#123;Brand&#125;</span> car with color <span class="subst">&#123;Color&#125;</span>, speed <span class="subst">&#123;Speed&#125;</span> km/h and turbo boost function.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>现在，如果我们有一个方法，它接受一个Car类型的对象，并调用这个对象的DisplayInfo方法：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Car myCar = <span class="keyword">new</span> Car();</span><br><span class="line">        myCar.Color = <span class="string">&quot;Red&quot;</span>;</span><br><span class="line">        myCar.Brand = <span class="string">&quot;Toyota&quot;</span>;</span><br><span class="line">        myCar.Speed = <span class="number">0</span>;</span><br><span class="line">        SportsCar mySportsCar = <span class="keyword">new</span> SportsCar();</span><br><span class="line">        mySportsCar.Color = <span class="string">&quot;Blue&quot;</span>;</span><br><span class="line">        mySportsCar.Brand = <span class="string">&quot;Ferrari&quot;</span>;</span><br><span class="line">        mySportsCar.Speed = <span class="number">0</span>;</span><br><span class="line">        DisplayCarInfo(myCar);</span><br><span class="line">        DisplayCarInfo(mySportsCar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisplayCarInfo</span>(<span class="params">Car car</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        car.DisplayInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在DisplayCarInfo方法中，它并不知道传入的是普通汽车对象还是跑车对象，但是会根据对象的实际类型来调用相应的DisplayInfo方法。如果是普通汽车对象，就调用Car类的DisplayInfo方法；如果是跑车对象，就调用SportsCar类的DisplayInfo方法。这体现了多态的概念，同一个方法在不同的对象中有不同的行为，增加了程序的灵活性和可扩展性。</p></blockquote><br><hr><h1 id="使用面向对象有什么好处？"><a href="#使用面向对象有什么好处？" class="headerlink" title="使用面向对象有什么好处？"></a>使用面向对象有什么好处？</h1><h2 id="提高代码的可维护性"><a href="#提高代码的可维护性" class="headerlink" title="提高代码的可维护性"></a>提高代码的可维护性</h2><p><b>封装性的优势：</b></p><blockquote><p>通过封装，将数据和操作数据的方法组合在一个类中，并隐藏内部细节。例如，在一个复杂的企业资源规划（ERP）系统中，有一个 “员工” 类，其中包含员工的工资、绩效等敏感数据。这些数据可以被封装为私有属性，只能通过特定的公共方法（如获取工资、更新绩效）来访问和修改。这样，当系统的业务逻辑发生变化，比如工资计算方式改变时，只需要修改 “员工” 类内部的相关方法，而不会影响到系统中其他依赖这个类的部分。</p></blockquote><p><b>层次结构便于管理：</b></p><blockquote><p>面向对象的继承和多态特性使得代码具有清晰的层次结构。以图形绘制系统为例，有一个基类 “图形”，它定义了基本的绘制方法和通用属性（如颜色）。从这个基类派生出来的 “圆形”“方形” 等类可以继承这些基本的功能，并添加自己特有的属性和方法（如圆形的半径、方形的边长）。当需要对系统进行维护，比如优化绘制算法时，开发人员可以很容易地定位到相关的类层次结构部分进行修改，而不会干扰到其他不相关的图形类。</p></blockquote><h2 id="增强代码的复用性"><a href="#增强代码的复用性" class="headerlink" title="增强代码的复用性"></a>增强代码的复用性</h2><p><b>继承实现代码复用：</b></p><blockquote><p>继承允许一个类（派生类）继承另一个类（基类）的属性和方法。例如，在开发一个游戏时，有一个 “角色” 基类，它包含了角色的基本属性（如生命值、攻击力）和通用方法（如移动、攻击）。当创建 “战士”“法师” 等不同类型的角色类时，它们可以继承 “角色” 基类的这些属性和方法，而不需要重新编写相同的代码。这大大减少了代码的冗余，提高了开发效率。</p></blockquote><p> <b>组件化开发便于复用：</b></p><blockquote><p>面向对象编程鼓励将功能划分为独立的类，这些类可以像组件一样在不同的项目中被复用。比如，一个开发好的 “文件读取” 类，可以在多个需要读取文件的应用程序中使用。只要这个类的接口（公共方法和属性）设计合理，就可以方便地集成到新的项目中，而不需要重新编写文件读取相关的代码。</p></blockquote><h2 id="更好地模拟现实世界"><a href="#更好地模拟现实世界" class="headerlink" title="更好地模拟现实世界"></a>更好地模拟现实世界</h2><p><b>自然地抽象现实事物：</b></p><blockquote><p>面向对象编程能够将现实世界中的事物抽象为类和对象。例如，在一个交通模拟系统中，可以将汽车、行人、交通信号灯等都看作对象。汽车对象有品牌、速度、位置等属性，以及启动、加速、刹车等方法；行人对象有姓名、行走速度、目的地等属性和行走、等待等方法；交通信号灯对象有颜色、切换时间等属性和变色方法。通过这些对象之间的交互，可以很自然地模拟出交通场景，使得程序的设计和理解更加贴近现实。</p></blockquote><p><b>方便处理复杂关系：</b></p><blockquote><p>面向对象可以很好地处理现实世界中事物之间的复杂关系。以生态系统模拟为例，动物类和植物类之间存在捕食、共生等关系。可以通过对象之间的方法调用和消息传递来模拟这种关系。比如，动物对象的 “进食” 方法可能会涉及到对植物对象的 “被吃” 方法的调用，这种方式能够更直观地表示和处理复杂的生态关系。</p></blockquote><h2 id="利于团队协作开发"><a href="#利于团队协作开发" class="headerlink" title="利于团队协作开发"></a>利于团队协作开发</h2><p><b>分工明确：</b></p><blockquote><p>在团队开发中，面向对象的编程方式使得不同的开发人员可以负责不同的类或类层次结构。例如，在一个大型的电子商务系统开发中，一个开发人员可以负责 “用户” 类相关的功能，包括用户注册、登录、信息修改等；另一个开发人员可以专注于 “商品” 类相关的部分，如商品添加、删除、展示等。每个开发人员只需要关注自己负责的类的内部实现和对外接口，降低了开发过程中的沟通成本。</p></blockquote><p><b>易于集成与测试：</b></p><blockquote><p>由于类是相对独立的单元，它们之间的接口清晰，这使得在集成各个部分的代码时更加容易。而且，在测试阶段，可以对每个类进行单元测试，检查其功能是否符合预期。例如，在开发一个软件系统时，对于 “订单处理” 类，可以独立地编写测试用例来验证订单的创建、修改、删除等功能是否正确，然后再将这个类集成到整个系统中进行系统测试。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp  try-catch-finally语句处理异常</title>
      <link href="/2025/01/25/csharp%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/"/>
      <url>/2025/01/25/csharp%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1>Csharp 使用try-catch-finally语句处理异常</h1><p>在 C# 编程中，<code>try - catch - finally</code>语句是一种强大的机制，用于处理程序运行时可能出现的异常情况。异常是在程序执行过程中出现的错误或意外情况，例如试图访问不存在的文件、数组越界、除数为零等操作。使用<code>try - catch - finally</code>可以让程序在遇到这些异常时采取适当的措施，而不是直接崩溃。</p><p><b>try 块</b><br>功能：try块是包含可能会抛出异常的代码部分。这是异常处理的起点，当程序执行到try块中的代码时，会监控其中的操作是否会引发异常。</p><li>示例：</li><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    Console.WriteLine(numbers[<span class="number">3</span>]);<span class="comment">// 这里会抛出IndexOutOfRangeException异常，因为数组最大索引是2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，代码试图访问数组numbers中不存在的索引（索引为 3，而数组长度为 3，有效索引范围是 0 - 2），这会导致一个<code>IndexOutOfRangeException</code>异常。</p><li>catch 块</li><p>功能：catch块用于捕获try块中抛出的特定类型的异常。当try块中的代码抛出异常后，程序会查找匹配的catch块来处理该异常。可以有多个catch块，每个catch块可以处理不同类型的异常。</p><li>示例：</li><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    Console.WriteLine(numbers[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IndexOutOfRangeException ex)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;数组索引超出范围，异常信息： &quot;</span> + ex.Message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，catch块捕获了<code>IndexOutOfRangeException</code>类型的异常。ex是异常对象，通过它可以访问异常的详细信息，如Message属性包含了异常的文本描述。当异常被捕获后，catch块中的代码会被执行，这里是打印出异常信息。</p><p><b>finally 块，</b></p><p>功能：finally块中的代码无论try块中是否抛出异常都会被执行。它通常用于清理资源，例如关闭文件、释放数据库连接、释放内存等操作，以确保程序的资源得到正确的管理。</p><li>示例：</li><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    FileStream fileStream = <span class="keyword">new</span> FileStream(<span class="string">&quot;test.txt&quot;</span>, FileMode.Open);</span><br><span class="line">    <span class="comment">// 这里可能会有读取文件等操作，如果出现异常，文件流应该被正确关闭</span></span><br><span class="line">    <span class="comment">// 假设这里有一些可能导致异常的代码，比如读取文件内容时文件格式错误</span></span><br><span class="line">    <span class="comment">// 具体的读取文件操作代码省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileNotFoundException ex)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;文件未找到，异常信息： &quot;</span> + ex.Message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 关闭文件流，无论是否出现异常</span></span><br><span class="line">    <span class="keyword">if</span> (fileStream!= <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fileStream.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，try块尝试打开一个文件流。如果文件不存在，会抛出<code>FileNotFoundException</code>异常并被catch块捕获处理。无论是否出现异常，finally块中的代码都会尝试关闭文件流（这里需要注意的是，在实际代码中，更推荐使用using语句来自动管理文件流等资源，using语句在内部也使用了try - finally机制）。</p><p><b>异常类型的层次结构和匹配规则</b></p><p>在 C# 中，所有异常类型都派生自<code>System.Exception</code>类。当抛出一个异常时，catch块会按照从上到下的顺序查找匹配的异常类型来处理。</p><blockquote><p>例如，System.ArithmeticException是一个抽象类，DivideByZeroException派生自它。如果有一个try块抛出了DivideByZeroException异常，并且有一个catch块捕获System.ArithmeticException，另一个catch块捕获DivideByZeroException，那么会优先匹配DivideByZeroException的catch块，因为它是最具体的匹配。</p></blockquote><li>示例：</li><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> result = a / b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (DivideByZeroException ex)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;除数不能为零，异常信息： &quot;</span> + ex.Message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArithmeticException ex)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;算术异常，异常信息： &quot;</span> + ex.Message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，try块中除法运算除数为零会抛出DivideByZeroException，它会被第一个catch块捕获，而不会匹配第二个catch块，因为DivideByZeroException更具体地匹配了抛出的异常类型。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数clac(),css 媒体查询</title>
      <link href="/2025/01/24/css/clac(),css%20%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"/>
      <url>/2025/01/24/css/clac(),css%20%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:59px;color:#0DE6FE;font-family:华文行楷">calc</h1><p>在 CSS 中，calc() 是一个非常有用的函数，它允许你在 CSS 属性值中进行数学计算。这使得你可以根据不同的长度单位（如像素、百分比等）动态地计算属性值，为网页布局提供了更大的灵活性。以下是关于 calc() 的详细介绍：</p><p><b>基本语法</b></p><li>calc() 函数的基本语法如下：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calc(expression)</span><br></pre></td></tr></table></figure><blockquote><p>其中 expression 是一个数学表达式，该表达式可以包含加（+）、减（-）、乘（*）、除（&#x2F;）四种基本运算符，同时可以使用不同的长度单位，如 px、%、em、rem 等。需要注意的是，运算符前后必须有空格。<br>示例代码及解释</p></blockquote><ol><li>使用 calc() 进行宽度计算<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">800px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: lightgray;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 子元素宽度为父元素宽度减去40px */</span></span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">40px</span>);</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: lightblue;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>在上述代码中，.child 元素的宽度通过 calc(100% - 40px) 计算得出，即父元素宽度减去 40px。这样可以确保子元素在父元素内部有一定的左右边距。</p></blockquote><ol start="2"><li>使用 calc() 进行高度计算<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">html</span>,</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 元素高度为视口高度的50%加上20px */</span></span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">50vh</span> + <span class="number">20px</span>);</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: lightgreen;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>在这个例子中，.box 元素的高度通过 calc(50vh + 20px) 计算，即视口高度的 50% 再加上 20px。</p></blockquote><br><p><b>注意事项</b></p><li>运算符前后的空格：在 calc() 函数中，运算符（+、-、*、/）前后必须有空格，否则表达式将无效。例如，calc(100% - 40px) 是正确的，而 calc(100%-40px) 是错误的。</li><li>计算规则：乘法和除法运算符的优先级高于加法和减法运算符。例如，calc(10px + 5 * 2px) 会先计算 5 * 2px，再加上 10px，结果为 20px。</li><li>兼容性：calc() 函数在现代浏览器中得到了广泛支持，但在一些旧版本的浏览器中可能存在兼容性问题。在使用时，建议进行兼容性测试。</li><br><h1 style="font-size:30px;color:#220DFE;font-family:华文行楷">媒体查询</h1><p>CSS 媒体查询是实现网页响应式设计的关键技术，它能让网页在不同设备和屏幕尺寸下都有良好的显示效果。以下从基础概念、语法、常见应用场景和注意事项等方面详细介绍 CSS 媒体查询的学习要点。</p><p><b>基础概念</b></p><blockquote><p>媒体查询允许你根据设备的各种特性（如屏幕宽度、高度、分辨率、设备方向等）来应用不同的 CSS 样式。通过媒体查询，可以为不同的设备环境定制特定的样式规则，从而实现网页在多种设备上的自适应布局。</p></blockquote><p><b>基本语法</b></p><li>媒体查询使用 @media 规则，其基本语法如下：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> media_type <span class="keyword">and</span> (media_feature) &#123;</span><br><span class="line">    <span class="comment">/* 当条件满足时应用的 CSS 规则 */</span></span><br><span class="line">    selector &#123;</span><br><span class="line">        property: value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>media_type（媒体类型）：指定适用的设备类型，常见值有：<br>all：适用于所有设备，是默认值。<br>screen：用于计算机屏幕、平板电脑、智能手机等。<br>print：用于打印机和打印预览。<br>speech：用于屏幕阅读器等语音合成设备。<br>media_feature（媒体特性）：描述设备的具体特性，通常以括号包裹。常见的媒体特性有：<br>width、min-width 和 max-width：分别表示屏幕宽度、最小屏幕宽度和最大屏幕宽度。例如 (min-width: 768px) 表示屏幕宽度大于等于 768 像素。<br>height、min-height 和 max-height：分别表示屏幕高度、最小屏幕高度和最大屏幕高度。<br>orientation：表示设备的方向，值为 portrait（竖屏）或 landscape（横屏）。</p></blockquote><p><b>逻辑运算符</b></p><p>可以使用逻辑运算符组合多个媒体特性或媒体类型，使查询条件更灵活：</p><p><code>and：</code>用于连接多个媒体特性，表示所有条件都必须满足。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1023px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码表示在屏幕设备且宽度在 768px 到 1023px 之间时，将 body 元素的字体大小设置为 16px。<br>,（逗号）：表示或的关系，只要其中一个条件满足即可。例如：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">767px</span>), print &#123;</span><br><span class="line">    <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段代码表示在屏幕设备宽度小于等于 767px 或者在打印时，隐藏 sidebar 元素。<br>not：用于取反查询结果。例如：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">    <span class="comment">/* 样式规则 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>表示除了屏幕设备且宽度大于等于 768px 的情况外，应用这些样式。<br>常见应用场景</p></blockquote><ol><li>响应式布局</li></ol><p>根据不同屏幕宽度调整页面布局。例如，在小屏幕设备上采用单列布局，大屏幕设备上采用多列布局：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 小屏幕设备（宽度小于 768px） */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">767px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.column</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 中等屏幕设备（宽度在 768px 到 1023px 之间） */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1023px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.column</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 大屏幕设备（宽度大于等于 1024px） */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">1024px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.column</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">33.33%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>字体大小调整</li></ol><p>在不同屏幕尺寸下调整字体大小以提高可读性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 小屏幕设备 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">767px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 大屏幕设备 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">1024px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>图片显示优化</li></ol><p>根据设备分辨率和屏幕大小显示不同尺寸的图片，节省带宽：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 小屏幕设备 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">767px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.image</span> &#123;</span><br><span class="line">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;small-image.jpg&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 大屏幕设备 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">1024px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.image</span> &#123;</span><br><span class="line">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;large-image.jpg&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意事项</b></p><li>媒体查询顺序：媒体查询的顺序很重要，因为后面的规则可能会覆盖前面的规则。一般建议按照从小到大（或从大到小）的屏幕尺寸顺序编写媒体查询。</li><li>浏览器兼容性：现代浏览器对媒体查询的支持很好，但在一些旧版本浏览器中可能存在兼容性问题。可以使用 CSS 前缀或借助 CSS 预处理器（如 Sass、Less）来处理兼容性。</li><li>性能考虑：过多复杂的媒体查询可能会影响页面性能，尤其是在移动设备上。尽量保持媒体查询简洁，避免不必要的嵌套和复杂逻辑。</li>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.14学习笔记</title>
      <link href="/2025/01/24/css/%E5%AD%A6%E4%B9%A0css.14/"/>
      <url>/2025/01/24/css/%E5%AD%A6%E4%B9%A0css.14/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:30px;color:#F30000;font-family:华文行楷">伸缩容器，伸缩项目</h1><li><b>伸缩容器</b>：开启了<code>flex</code>的元素，就是：伸缩容器。</li><blockquote><p>1.给元素设置：<mark>dispay:flex</mark>或<mark>display:inline-flex</mark>，该元素就变为了伸缩容器。<br>2.<mark>display:inline-flex</mark>很少使用，因为可以给多个伸缩容器的父容器，也设置为伸缩容器。<br>3.一个元素可以同时是：伸缩容器、伸缩项目。</p></blockquote><li><b>伸缩项目</b>:伸缩容器所有<mark>子元素</mark>自动成为了：伸缩项目。</li><blockquote><p>1.仅伸缩容器的<mark>子元素</mark>成为了伸缩项目，孙子元素、重孙子元素等后代，不是伸缩项目。<br>2.无论原来是哪种元素（快、行内块、行内），一旦成为了伸缩项目，全都会“块状化”。</p></blockquote><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">主轴与侧轴</h1><li><b>主轴</b>：伸缩项目沿着主轴排列，主轴默认是水平的，默认方向是：从左到右（左边是起点，右边是终点）。</li><li><b>侧轴</b>：与主轴垂直的就是侧轴，侧轴默认是垂直的，默认方向是：从上到下（上边是起点，下边是终点）。</li><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">主轴方向</h1><li>属性名：<code>flex-direction</code></li><li>常用值如下:</li><ol>    <li><code>row</code>：主轴方向水平从左到右--默认值</li>    <li><code>row-reverse</code>：主轴方向水平从右到左。</li>    <li><code>column</code>：主轴方向垂直从上到下。</li>    <li><code>column-reverse</code>：主轴方向垂直从下到上。</li>    </ol> <blockquote><p>注意：改变了主轴的方向，侧轴方向也会随之改变。</p></blockquote><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">主轴换行方式</h1><li>属性名：<mark>flex-wrap</mark></li><li>常用值如下：</li><ol>    <li><code>nowrap</code>：默认值，不换行。</li>    <li><code>wrap</code>：自动换行，伸缩容器不够自动换行。</li>    <li><code>wrap-reverse</code>：反向换行。</li>    </ol>        <h1 style="font-size:30px;color:#F30000;font-family:华文行楷">主轴对齐方式</h1><li>属性名</li>：<mark>justify-content</mark></li><li>常用值如下：</li><ol>    <li><code>flex-start</code>：主轴起点对齐。--默认值</li>    <li><code>flex-end</code>：主轴终点对齐。</li>    <li><code>center</code>：居中对齐</li>    <li><code>space-between</code>：均匀分布，两端对齐（最常用）。</li>    <li><code>space-around</code>：均匀分布，两端距离是中间距离的一半。</li>    <li><code>space-evenly</code>：均匀分布，两端距离与中间距离一致。</li>    </ol><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">侧轴对齐方式</h1>        <p><b>只有一行的情况</b></p><li>所需属性：<mark>align-items</mark></li><li>常用值如下：</li><ol>    <li><code>flex-start</code>：侧轴的起点对齐。</li>    <li><code>flex-end</code>：侧轴的终点对齐。</li>    <li><code>center</code>：侧轴的中点对齐。</li>    <li><code>baseline</code>：伸缩项目的第一行文字的基线对齐。</li>    <li><code>stretch</code>：如果伸缩项目未设置高度，将占满整个容器的高度。--默认值</li>    </ol><p><b>多行的情况</b></p><li>所需属性：<mark>align-content</mark></li><li>常用值如下：</li><ol>    <li><code>flex-start</code>：与侧轴的起点对齐。</li>    <li><code>flex-end</code>：与侧轴的终点对齐。</li>    <li><code>center</code>：与侧轴的中点对齐。</li>    <li><code>space-between</code>：与侧轴两端对齐，中间平均分布。</li>    <li><code>space-around</code>：伸缩项目间的距离相等，比距边缘大一倍。</li>    <li><code>space-evenly</code>：在侧轴上完全平分</li>    <li><code>stretch</code>：占满整个侧轴。--默认值</li>    </ol><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">伸缩盒模型_伸</h1> <p><b><mark>flex-grow</mark></b></p><li>概念：<code>flex-grow</code>定义伸缩项目的放大比例，默认为0，即：纵使主轴存在剩余空间，也不拉伸（放大）。</li><li>规则：</li><ol>    <li>若所有伸缩项目的<code>flex-grow</code>值为1，则：它们将等分剩余空间（如果有空间的话）。</li>    <li>若三个伸缩项目的<code>flex-grow</code>值分别为：1、2、3，则：分别瓜分到：1/6、2/6、3/6的空间。</li>    </ol><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">伸缩盒模型_缩</h1> <p><b><mark>flex-shrink</mark></b></p><li>概念：<code>flex-shrink</code>定义了项目的压缩比例，默认为1，即：如果空间不足，该项目将会缩小。</li><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">flex符合属性</h1><p><mark>flex</mark>是复合属性，复合了：<code>flex-grow、flex-shrink、flex-bassis</code>三个属性，默认值为0、0、auto。</p><li>如果写<code>flex:1 1 auto</code>，则可简写为：<code>flex:auto</code></li><li>如果写<code>flex:1 1 0</code>，则可简写为：<code>flex:auto</code></li><li>如果写<code>flex:0 0 auto</code>，则可简写为：<code>flex:1</code></li><li>如果写<code>flex:0 1 auto</code>，则可简写为：<code>flex:0 auto -- 即flex初始值</code></li><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">项目排序</h1><li><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认值为0。</li><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">单独对齐</h1><li>通过<code>align-self</code>属性，可以单独调整某个伸缩项目的对齐方式。</li><li>默认值为auto,表示继承父元素的align-items属性。</li>    ]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.13学习笔记</title>
      <link href="/2025/01/23/css/%E5%AD%A6%E4%B9%A0css.13/"/>
      <url>/2025/01/23/css/%E5%AD%A6%E4%B9%A0css.13/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:30px;color:#B72795;font-family:华文行楷">CSS 动画</h1><p><b>相较于传统的脚本实现动画技术，使用 CSS 动画有三个主要优点：</b></p><p>1.能够非常容易地创建简单动画，你甚至不需要了解 JavaScript 就能创建动画。</p><p>2.动画运行效果良好，甚至在低性能的系统上。渲染引擎会使用跳帧或者其他技术以保证动画表现尽可能的流畅。而使  用 JavaScript 实现的动画通常表现不佳（除非经过很好的设计）。</p><p>3.让浏览器控制动画序列，允许浏览器优化性能和效果，如降低位于隐藏选项卡中的动画更新频率。</p><br><p>CSS 动画是网页设计中用于创建动态和交互效果的强大工具，以下是关于 CSS 动画的学习内容：</p><p style="font-size:20px"><b>基本概念</b></p><li><b>关键帧</b>：CSS 动画通过定义关键帧来描述动画的不同状态。关键帧使用@keyframes规则来创建，它允许你指定动画在不同时间点的属性值。</li><li><b>动画属性</b>：通过一系列 CSS 动画属性来控制动画的行为，包括动画名称、持续时间、播放次数、播放方向、延迟时间等。</li><br><p style="font-size:20px"><b>主要属性</b></p><p><b>@keyframes</b></p><li><b>语法</b>：<code>@keyframes animationName &#123; keyframe-selector &#123; property: value; &#125; &#125;</code></li><br><li><b>描述</b>：用于定义动画的关键帧。animationName是动画的名称，keyframe-selector可以是百分比（如0%、50%、100%）或from、to关键字，用于指定动画在不同时间点的状态。</li><br><p><b>animation-name</b></p><li><b>语法</b>：<code>animation-name: none | &lt;single-animation-name&gt;#</code></li><br><li><b>描述</b>：指定要应用的动画名称，对应@keyframes中定义的名称。</li><br><p><b>animation-duration</b></p><li><b>语法</b>：<code>animation-duration: &lt;time&gt;#</code></li><br><li><b>描述</b>：指定动画完成一个周期所需的时间，以秒（s）或毫秒（ms）为单位。</li><br>    <p><b>animation-timing-function</b></p><li><b>语法</b>：<code>animation-timing-function: ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(n,n,n,n)</code></li><br><li><b>描述</b>：控制动画的速度曲线，与过渡的时间函数类似。</li><br>    <p><b>animation-delay</b></p><li><b>语法</b>：<code>animation-delay: &lt;time&gt;</code></li><br><li><b>描述</b>：指定动画开始前的延迟时间。</li><br>    <p><b>animation-iteration-count</b></p><li><b>语法</b>：<code>animation-iteration-count: infinite | &lt;number&gt;</code></li><br><li><b>描述</b>：指定动画的播放次数，infinite表示无限循环播放。</li><br>    <p><b>animation-direction</b></p><li><b>语法</b>：<code>animation-direction: normal | reverse | alternate | alternate-reverse</code></li><br><li><b>描述</b>：控制动画的播放方向，normal为正向播放，reverse为反向播放，alternate表示在奇数次迭代时正向播放，偶数次迭代时反向播放，alternate-reverse则相反。</li><br>    <li><b>示例</b></li>    <p>以下是一个简单的 CSS 动画示例，让一个方块在页面上从左到右移动并旋转：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义关键帧 */</span></span><br><span class="line"><span class="keyword">@keyframes</span> moveAndRotate &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0</span>) <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">200px</span>) <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 应用动画 */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="comment">/* 应用动画属性 */</span></span><br><span class="line">  <span class="attribute">animation-name</span>: moveAndRotate;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">3s</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease-in-out;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">0s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-direction</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意事项</b></p><li>性能考虑：与过渡类似，复杂的动画可能会对性能产生影响，尤其是在移动设备上。尽量避免过度使用动画，或者对大量元素同时应用复杂动画。</li><li>兼容性处理：不同浏览器对 CSS 动画的支持可能存在差异，需要使用浏览器前缀来确保在各种浏览器中都能正常显示。例如，-webkit-animation用于 WebKit 内核的浏览器。</li><li>可访问性：确保动画不会影响网站的可访问性，例如，对于有视觉障碍的用户，动画可能会造成困扰。可以提供关闭动画的选项，或者确保动画不会干扰用户对内容的理解和操作。</li>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.12学习笔记</title>
      <link href="/2025/01/23/css/%E5%AD%A6%E4%B9%A0css.12/"/>
      <url>/2025/01/23/css/%E5%AD%A6%E4%B9%A0css.12/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:30px;color:#00633D;font-family:华文行楷">CSS 过渡</h1><p>CSS 过渡是 CSS 中一项非常实用的特性，它可以在元素的属性值发生变化时创建平滑的过渡效果，提升用户体验。以下是关于 CSS 过渡的学习内容：</p><p style="font-size:24px"><b>基本概念</b></p><li><b>过渡属性</b>：CSS 过渡主要通过transition属性来实现，它是一个复合属性，用于设置过渡效果的各个方面，包括过渡的属性、持续时间、过渡函数和延迟时间。</li><br><li><b>过渡效果触发</b>：通常在元素的状态发生改变时触发过渡效果，比如鼠标悬停（:hover）、获取焦点（:focus）、激活（:active）等伪类状态变化，或者通过 JavaScript 动态修改元素的属性值。</li><br><p style="font-size:24px"><b>transition属性</b></p><li><b>语法</b>：<code>transition: property duration timing-function delay</code>;</li><li><b>property</b>：指定要应用过渡效果的 CSS 属性名称。可以是具体的属性，如width、height、color等，也可以使用all表示所有可过渡的属性。</li><li><b>duration</b>：指定过渡效果持续的时间，以秒（s）或毫秒（ms）为单位。</li><li><b>timing-function</b>：指定过渡的时间函数，用于控制过渡的速度曲线。常见的值有ease（默认值，慢 - 快 - 慢）、linear（匀速）、ease-in（慢 - 快）、ease-out（快 - 慢）、ease-in-out（慢 - 快 - 慢）等，还可以使用cubic-bezier()函数自定义曲线。</li><li><b>delay</b>：指定过渡效果开始前的延迟时间，以秒（s）或毫秒（ms）为单位。</li><br><li><b>示例</b></li><li>以下是一个简单的 CSS 过渡示例，当鼠标悬停在一个按钮上时，按钮的背景颜色和宽度会在 1 秒内平滑过渡：</li>    <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: background-color <span class="number">1s</span>, width <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><li>可以给过渡效果添加延迟，让过渡在鼠标悬停一段时间后才开始：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: background-color <span class="number">1s</span> <span class="number">0.5s</span>, width <span class="number">1s</span> <span class="number">0.5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><li>使用ease-in时间函数让宽度变化的过渡效果以慢 - 快的方式进行：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">1s</span> ease-in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p style="font-size:24px"><b>注意事项</b></p><li><b>兼容性</b>：CSS 过渡在大多数现代浏览器中都得到了很好的支持，但在一些旧版本的浏览器中可能存在兼容性问题。可以使用浏览器前缀（如-webkit-、-moz-等）来提高兼容性。</li><li><b>可过渡属性</b>：并非所有的 CSS 属性都可以进行过渡，只有具有中间值的属性才能实现过渡效果。例如，display属性就不能直接过渡，因为它的值没有中间状态。</li><li><b>性能优化</b>：过度使用复杂的过渡效果可能会影响页面性能，特别是在移动设备上。尽量避免对大量元素同时应用过渡效果，或者使用过于复杂的过渡函数。</li>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.11学习笔记</title>
      <link href="/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.11/"/>
      <url>/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.11/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:30px;color:#F56262;font-family:华文行楷">CSS 3D</h1><p>CSS 3D 是 CSS（层叠样式表）的一个重要特性，它允许开发人员在网页上创建具有三维空间效果的元素，为用户带来更加丰富和沉浸式的视觉体验。以下是对 CSS 3D 几个关键方面的详细解释：</p><p style="font-size:20px"><b>一、核心概念</b></p><p><b>1.三维空间坐标系</b>：</p><li>在 CSS 3D 中，使用三维空间坐标系，由 x、y 和 z 轴组成。</li><li>x 轴是水平轴，从左到右为正方向。</li><li>y 轴是垂直轴，从上到下为正方向。</li><li>z 轴是深度轴，从屏幕外向屏幕内为正方向。</li><br><p><b>2.视角与透视</b>：</p><li>Perspective（透视）：该属性定义了观察 3D 场景的距离，它影响元素在 3D 空间中的呈现效果。</li><li>可以通过设置父元素的 perspective 属性来实现透视效果，例如 perspective: 500px;。较小的值会使元素的 3D 效果更强烈，而较大的值会使元素看起来更扁平。</li><li>还可以使用 perspective-origin 属性来改变透视的原点，默认是元素的中心（50% 50%），可以调整为其他位置，如 perspective-origin: top left;。</li><p><b>3.变换（Transforms）：</b></p><li>translate3d(x, y, z)：将元素在 3D 空间中沿 x、y 和 z 轴进行平移。例如，transform: translate3d(50px, 100px, 20px); 会将元素在 x 轴上移动 50 像素，y 轴上移动 100 像素，z 轴上移动 20 像素。</li><li>rotateX(angle)、rotateY(angle)、rotateZ(angle)：分别将元素绕 x、y、z 轴旋转指定的角度。例如，transform: rotateX(45deg); 会使元素绕 x 轴旋转 45 度。</li><li>scale3d(sx, sy, sz)：按比例缩放元素在 x、y 和 z 轴上的尺寸。例如，transform: scale3d(1.5, 1.2, 0.8); 会将元素在 x 轴上放大 1.5 倍，y 轴上放大 1.2 倍，z 轴上缩小到 0.8 倍。</li><li>可以组合使用这些变换，例如 transform: translate3d(50px, 100px, 20px) rotateY(45deg); 会先平移元素，再绕 y 轴旋转。</li><br><p><b>4.变换风格（Transform Style）：</b></p><li>transform-style: preserve-3d：该属性用于指定子元素是否在 3D 空间中呈现。设置为 preserve-3d 时，子元素会保留 3D 特性，可以创建更复杂的 3D 结构，例如 3D 立方体。</li><li>transform-style: flat：这是默认值，子元素会被平面化，不具有 3D 效果。</li><br><p style="font-size:20px"><b>二、元素的 3D 定位与布局</b></p><p><b>绝对定位（Absolute Positioning）：</b></p><li>通常将元素的位置设置为 absolute 或 fixed 以方便在 3D 空间中对其进行精确的定位和变换。</li><br><p><b>层叠顺序（Stacking Order）：</b></p><li>使用 z-index 属性可以控制元素在 3D 空间中的层叠顺序。较高的 z-index 值的元素会显示在较低 z-index 值的元素前面。</li><br><p style="font-size:20px"><b>三、背面可见性（Backface Visibility）</b></p><li>backface-visibility：该属性决定元素的背面是否可见。</li><li>backface-visibility: visible; 表示元素的背面可见，当元素旋转时可以看到其背面。</li><li>backface-visibility: hidden; 表示元素的背面不可见，常用于创建具有双面效果的元素，当旋转时只显示正面。</li>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.10学习笔记</title>
      <link href="/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.10/"/>
      <url>/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.10/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:30px;color:#3A4973;font-family:华文行楷">CSS 2D</h1><p>CSS 2D 是指使用 CSS 实现的二维变换，它允许开发者对 HTML 元素进行平面内的各种变换操作，从而实现丰富的页面效果。以下是更详细的解释：</p><p style="font-weight:bold;font-size:20px">一、基本变换函数</p><p><b>translate(x, y)：</b></p><li>功能：将元素在二维平面上进行平移。</li><li>参数：</li><br><p>1.x：元素在水平方向（X 轴）上的移动距离。可以是像素值（如 50px）、百分比（如 50%）或其他长度单位。正值表示向右移动，负值表示向左移动。</p><p>2.y：元素在垂直方向（Y 轴）上的移动距离。可以是像素值、百分比或其他长度单位。正值表示向下移动，负值表示向上移动。</p><li>示例：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">100px</span>, <span class="number">50px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：上述代码会将 .element 类的元素在水平方向向右移动 100 像素，在垂直方向向下移动 50 像素。</p></blockquote><p><b>rotate(angle)：</b></p><li>功能：将元素绕其中心点旋转一定角度。</li><li>参数：</li><br><p>angle：旋转的角度，单位是度（deg）。正值表示顺时针旋转，负值表示逆时针旋转。</p><li>示例：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：该代码将 .element 类的元素顺时针旋转 45 度。</p></blockquote><p><b>scale(x, y)：</b></p><li>功能：对元素进行缩放操作。</li><li>参数：</li><br><p>x：元素在水平方向（X 轴）上的缩放比例。可以是小数（如 0.5 表示缩小到原来的 50%）或大于 1 的数（如 2 表示放大到原来的 2 倍）。<br>y：元素在垂直方向（Y 轴）上的缩放比例。如果不指定 y 值，元素将在 X 和 Y 轴上按照 x 的比例进行缩放。</p><li>示例：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：此代码将 .element 类的元素在水平方向放大到原来的 1.5 倍，在垂直方向放大到原来的 2 倍。</p></blockquote><p><b>skew(x-angle, y-angle)：</b></p><li>功能：使元素在二维平面上产生倾斜效果。</li><li>参数：</li><br><p>x-angle：元素在水平方向（X 轴）上的倾斜角度，单位是度（deg）。正值表示向右侧倾斜，负值表示向左侧倾斜。<br>y-angle：元素在垂直方向（Y 轴）上的倾斜角度，单位是度（deg）。正值表示向下方倾斜，负值表示向上方倾斜。</p><li>示例：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>, <span class="number">10deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：.element 类的元素将在水平方向倾斜 30 度，在垂直方向倾斜 10 度。</p></blockquote><p style="font-weight:bold;font-size:20px">二、transform-origin 属性</p><li>功能：设置元素变换的原点位置，默认是元素的中心（50% 50%）。</li><li>参数：</li><br><p>可以使用长度单位（如 px）、百分比或关键字（如 top、bottom、left、right、center）来指定位置。</p><li>示例：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">transform-origin</span>: top left;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：对于 .element 类的元素，首先将变换原点设置为左上角，然后进行 45 度的旋转操作。由于变换原点改变，元素将以左上角为中心进行旋转。</p></blockquote><p style="font-weight:bold;font-size:20px">三、组合使用变换函数</p><li>可以将多个变换函数组合使用，它们会按照顺序依次对元素进行操作。</li><li>示例：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">100px</span>, <span class="number">50px</span>) <span class="built_in">rotate</span>(<span class="number">45deg</span>) <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：对于 .element 类的元素，先将其向右平移 100 像素、向下平移 50 像素，然后顺时针旋转 45 度，最后将其放大到原来的 1.5 倍。</p></blockquote><h1 style="font-size:30px;color:#3A4973;font-family:华文行楷">应用场景</h1><p><b>动态效果增强</b></p><li>动画效果：通过 CSS 2D 变换可以创建各种吸引人的动画效果，如元素在页面上的平滑移动、旋转、缩放等，使页面更具吸引力。</li><li>交互效果：为按钮、链接、图标等添加点击、悬停等交互效果，当用户与页面元素交互时，通过 2D 变换来改变元素的外观，使页面更加生动有趣。</li><p><b>布局调整</b></p><li>响应式设计：在响应式布局中，利用 CSS 2D 变换调整元素的位置和大小，以适应不同屏幕尺寸和分辨率的设备，确保页面在各种设备上都能保持良好的显示效果。</li><li>创意布局：实现一些非传统的布局方式，如倾斜的文本、旋转的图片等，为页面带来独特的视觉风格，突破传统矩形布局的限制。</li><b>UI 元素设计</b><li>按钮和图标：为按钮和图标添加阴影、立体效果等，使用 CSS 2D 变换可以让它们看起来更加立体和吸引人，增强用户对可交互元素的感知。</li><li>导航菜单：创建具有动态效果的导航菜单，如悬停时弹出的下拉菜单、旋转的选项卡等，提升导航的易用性和视觉效果。</li><b>兼容性</b><li>虽然大多数现代浏览器都支持 CSS 2D 变换，但在一些较旧的浏览器或特定版本中可能存在兼容性问题。为了确保兼容性，可能需要使用浏览器前缀（如 -webkit-、-moz- 等），也可以使用工具如 Autoprefixer 来自动添加这些前缀。</li>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.9学习笔记</title>
      <link href="/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.9/"/>
      <url>/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.9/</url>
      
        <content type="html"><![CDATA[<div style="font-size:50px;font-family:华文楷体;color:#B4A8FC">CSS 渐变</div><br></br><p style="font-size:25px"><b>1.线性渐变</b></p><li>多个颜色之间的渐变，默认<b>从上到下</b>渐变。</li><blockquote><p>background-image:linear-gradient( , , );</p></blockquote><li>使用关键词设置线性<b>渐变的方向</b>。</li><blockquote><p>background-image:linear-gradient(to top, , , );<br>background-image:linear-gradient(to  right top, , , ); </p></blockquote><li>使用角度设置线性<b>2.渐变的方向</b>。</li><blockquote><p>background-imge:linear-gradient(30deg, , , );</p></blockquote><li>调整开始<b>渐变的位置</b>。</li><blockquote><p>background-imge:linear-gradient(red 50px, , , );</p></blockquote><p style="font-size:25px"><b>3.径向渐变</b></p><li>使用像素值值调整渐变圆的圆心位置。</li><blockquote><p>background-image:radial-gradient(at 100px 50px, , , );</p></blockquote><li>调整渐变形状为正圆。</li><blockquote><p>background-image:radial-gradient(circle, , , );</p></blockquote><li>调整形状的半径</li>。<blockquote><p>background-image:radial-gradient(100px, , , );<br>background-image:radial-gradient(50px,100px, , , );</p></blockquote><p style="font-size:25px"><b>4.重复渐变</b></p><blockquote><p>在渐变类型前面加上 repeating</p></blockquote><div style="font-size:50px;font-family:华文楷体;color:#B4A8FC">web 字体</div><p><b>基本用法</b></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@font-face&#123;</span><br><span class="line">     font-family:&quot;&quot;;</span><br><span class="line">     font-display:swap;</span><br><span class="line">     src:url(./  );</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.8学习笔记</title>
      <link href="/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.8/"/>
      <url>/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.8/</url>
      
        <content type="html"><![CDATA[<p style="font-size:30px;color:#43E2FE;font-family:华文楷体">CSS3长度单位</p><p><mark>vm</mark>视口宽度的百分之多少<mark>10vw</mark>就是视口宽度的<mark>10%</mark><br><mark>vh</mark>视口宽度的百分之多少<mark>10vw</mark>就是视口高度的<mark>10%</mark></p><p style="font-size:30px;color:#43E2FE;font-family:华文楷体"><mark>box-sizing</mark>怪异盒模型</p><p>使用<mark>box-sizing</mark>属性可以设置和模型的俩种类型</p><details><mark>width</mark>和<mark>height</mark>设置的是盒子内容区的大小。（默认值） <summary><b>content-box</b></summary></details><details><mark>width</mark>和<mark>height</mark>设置的是盒子总大小（怪异盒模型） <summary><b>border-box</b></summary></details>   <p style="font-size:30px;color:#43E2FE;font-family:华文楷体"><mark>resize</mark>调整盒子大小</p><p>使用<mark>resize</mark>属性可以可以控制是否允许用户调节元素尺寸。</p><p><b>none:</b>不允许用户调整元素大小。（默认）<br><b>both:</b>用户可以调节元素的宽度和高度。<br><b>horizontal:</b>用户可以调节元素的宽度。<br><b>vertical:</b>用户可以调节元素的高度。</p><p style="font-size:30px;color:#43E2FE;font-family:华文楷体"><mark>box-shadow</mark>盒子阴影</p><div>使用<mark>box-shadow</mark>属性为盒子添加阴影。</div><br><details><code>box-shadow: h-shadow v-shadow blur spread color inset;</code><summary><b>语法</b></summary></details><li>各个值的含义：</li><b>h-shadow</b>:水平阴影的位置，必须填写，可以为负值<b>v-shadow</b>:垂直阴影的位置，必须填写，可以为负值<b>blur</b>:可选，模糊距离<b>spread</b>:可选，隐隐的外延值<b>color</b>:可选，阴影的颜色<b>inset</b>:可选，将外部阴影该为内部阴影<blockquote><p>默认值：box-shadow:none表示没有阴影</p></blockquote><p style="font-size:30px;color:#43E2FE;font-family:华文楷体"><mark>opacity</mark>盒子阴影</p><p><b>opacity</b>属性能为整个元素添加透明度效果，值是0到1之间的小数，0是完全透明，1表示完全不透明。</p><p style="font-size:30px;color:#43E2FE;font-family:华文楷体"><mark>background-origin</mark>设置背景图的原点。</p><li>语法</li><p>1.<b>padding-box:</b>从<b>padding</b>区域开始显示背景图像。–默认值<br>2.<b>border-box:</b>从<b>border</b>区域开始显示背景图像。<br>3.<b>content-box:</b>从<b>content</b>区域开始显示背景图像。</p><hr><p style="font-size:30px;color:#43E2FE;font-family:华文楷体"><mark>background-clip</mark>设置背景图的向外裁剪的区域。</p><li>语法</li><p>1.<b>padding-box:</b>从<b>padding</b>区域开始向外裁剪背景。–默认值<br>2.<b>border-box:</b>从<b>border</b>区域开始向外裁剪背景。<br>3.<b>content-box:</b>从<b>content</b>区域开始向外裁剪背景。<br>4.<b>text:</b>背景图只呈现在文字上。</p><p style="font-size:30px;color:#43E2FE;font-family:华文楷体"><mark>background-size</mark>设置背景图的尺寸。</p><li>语法</li><p>1.用长度指定背景图片大小，不允许负值。</p><blockquote><p>background-size:300px 200px;</p></blockquote><p>2.用百分比指定背景图片大小，不允许负责。</p><blockquote><p>background-size:100% 100%;</p></blockquote><p>3.<b>auto</b>：背景图片的真实大小，–默认值<br>4.<b>contain</b>：将背景图片等比缩放，是北京图片的宽高，与容器的款或高相等，再将完整背景图片包含在容器内，但要注意：可能会造成容器里部分区域没有背景图片。</p><blockquote><p>background-size:contain:</p></blockquote><p>5.<b>cover</b>：将背景图片等比例缩放，直到完全覆盖容器，图片会尽可能全的显示在元素上，但要注意：背景图片有可能显示不完整。–相对比较好的选择</p><blockquote><p>background-size:cover;</p></blockquote><hr><p style="font-size:30px;color:#43E2FE;font-family:华文楷体">边框圆角</p><li>同时设置四个角的圆角：</li><blockquote><p>border-radius:10px;</p></blockquote><hr><p style="font-size:30px;color:#43E2FE;font-family:华文楷体">文本阴影</p><details>text-shadow:h-shahow v-shadow blur color;<summary>语法</summary></details><p style="font-size:30px;color:#43E2FE;font-family:华文楷体">文本换行</p></li>常用值如下</li>:<b>normal</b>:文本超出边界自动换行，文本中的换行被浏览器识别为一个空格。（默认值）<b>pre</b>:原样输出，与pre标签的效果相同。<b>pre-wrap</b>:在pre效果的基础上，超出元素边界自动换行。<b>pre-line</b>:在pre效果的基础上，超出元素边界自动换行，且识别文本中的换行，空格会忽略。<b>nowrap</b>:强制不换行。<p style="font-size:30px;color:#43E2FE;font-family:华文楷体">文本溢出</p><li>常用值如下</li>:<b>clip</b>:党内联内容溢出时，将溢出部分裁切掉。（默认值）<b>ellipsis</b>:当内联内容溢出快容器时，将溢出部分替换为···。<blockquote><p>要使得text-overflow属性生效，快容器必须显式定义overflow为非visible值，white-space为nowrap值。</p></blockquote><hr><p style="font-size:30px;color:#43E2FE;font-family:华文行楷">CSS3 多列布局</p><p>CSS 多列布局是一种用于将网页内容排列成多列显示的技术，能够在有限的空间内更高效地展示信息，以下是关于 CSS 多列布局的学习内容：</p><li><b>基本概念</b></li><li>多列布局属性：CSS 通过一系列属性来实现多列布局，主要用于控制列的数量、宽度、间距以及列之间的分隔线等。</li><li>应用场景：多列布局常用于新闻列表、文章排版、产品展示等场景，使内容呈现更加清晰、有条理，提高可读性和视觉效果。</li><br><li><b>主要属性</b></li><p><b>column-count</b></p><li>语法：<code>column-count: auto | &lt;integer&gt;</code></li><li>描述：指定元素要划分的列数，auto为默认值，表示根据其他属性自动计算列数，&lt;integer&gt;为具体的列数。</li><br><p><b>column-width</b></p><li>语法：column-width: auto | &lt;length&gt;</li><li>描述：指定每列的宽度，auto表示由浏览器根据容器大小和其他属性自动确定列宽，&lt;length&gt;为具体的宽度值，如100px、20em等。</li><br><p><b>column-gap</b></p><li>语法：column-gap: normal | &lt;length&gt;</li><li>语法：column-gap: normal | &lt;length&gt;</li><li>描述：设置列与列之间的间隙宽度，normal的默认值通常为1em，也可以指定具体的长度值。</li><br><p><b>column-rule</b></p><li>语法：column-rule: &lt;column-rule-width&gt; || &lt;column-rule-style&gt; || &lt;column-rule-color&gt;</li><li>语法：column-rule: &lt;column-rule-width&gt; || &lt;column-rule-style&gt; || &lt;column-rule-color&gt;</li><li>描述：是一个复合属性，用于设置列之间的分隔线，分别对应分隔线的宽度、样式和颜色。例如column-rule: 1px solid black表示 1 像素宽、实线、黑色的分隔线。</li><br><p><b>column-span</b></p><li>语法：column-span: none | all</li><li>描述：指定元素是否跨越所有列，none表示元素不跨越列，在所在列显示，all表示元素跨越所有列。</li><br><li>示例</li><p>以下是一个简单的 CSS 多列布局示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.multicol</span> &#123;</span><br><span class="line">  <span class="comment">/* 设置3列布局 */</span></span><br><span class="line">  <span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="comment">/* 列之间的间隙为20px */</span></span><br><span class="line">  <span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="comment">/* 列之间的分隔线为1px实线灰色 */</span></span><br><span class="line">  <span class="attribute">column-rule</span>: <span class="number">1px</span> solid gray;</span><br><span class="line">&#125;</span><br><span class="line">让一个标题跨越所有列：</span><br><span class="line">css</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">column-span</span>: all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意事项</b></p><li>内容适配：多列布局中的内容应根据列宽自动换行和调整，确保内容在不同列中完整显示，避免出现截断或显示不完整的情况。对于图像等元素，可能需要设置max-width: 100%等属性来使其适应列宽。</li><li>兼容性问题：多列布局在不同浏览器中的支持存在一定差异，特别是在一些旧版本浏览器中。在实际应用中，需要进行充分的测试，并根据需要使用浏览器前缀来提高兼容性，如-webkit-column-count、-moz-column-count等。</li><li>复杂布局处理：对于复杂的多列布局需求，可能需要结合其他 CSS 布局技术，如 Flexbox 或 Grid 布局来实现更精细的排版效果。同时，要注意多列布局与其他布局方式之间的相互影响，避免出现布局混乱的问题。</li>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识HTML.4学习笔记</title>
      <link href="/2025/01/21/html/%E5%AD%A6%E4%B9%A0html.4/"/>
      <url>/2025/01/21/html/%E5%AD%A6%E4%B9%A0html.4/</url>
      
        <content type="html"><![CDATA[<p style="font-size:30px;color:#8DFEF6">列表标签</p><br><p>datalist:用于搜索框的关键字提示</p><p>details:用于展示问题和答案，或对专有名词进行解释</p><p>summary:写在detaisls的里面，用于指定问题或专用名词</p><p style="font-size:30px;color:#8DFEF6">文本标签</p><br>ruby:包裹需要注音的文字rt:写注音，rt标签写在ruby的里面<p style="font-size:30px;color:#8DFEF6">文本标记</p><br>mark:标记<p style="font-size:30px;color:#8DFEF6">表单功能</p><br><p>placeholder:提示文字（注意：不是默认值，value是默认值），适用于<mark>文字输入类</mark>的表单控件。</p><p>required:表示输入项必填，适用于<mark>除按钮外</mark>其他表单控件。</p><p>autofocus:自动获取焦点，适用于所有表单控件。</p><p>autocomplete:自动完成，可以设置为<mark>on</mark>或<mark>off</mark>，适用于<make>文字输入类</make>的表单控件。</p><p>pattern:填写正则表达式，是用于输入类表单控件。        注意：多行输入不可用，且空的输入框不会验证，往往与<mark>required</mark>配合。</p>          <p style="font-size:30px;color:#8DFEF6">input属性值</p><p><br></br><br>email:邮箱类型的输入框，表单提交时会验证格式，输入为空则不验证格式。<br>url:url类型的输入框，表单提交时会验证格式，输入为空则不验证格式。<br>number:数字类型的输入框，表单提交时会验证格式，输入为空则不验证格式。<br>search:搜索类型的输入框，表单提交时不会验证格式。<br>tel:电话类型的输入框，表单提交时不会验证格式，在移动端使用时，会唤起数字键盘。<br>range:范围选择框，默认值为<make>50</make>，表单提交时不会验证格式。<br>color:颜色选择框，默认值为黑色，表单提交时不会验证格式。<br>date:日期选择框，默认值为空，表单提交时不会验证格式。<br>month:月份选择框，默认值为空，表单提交时不会验证格式。<br>week:周选择框，默认值为空，表单提交时不会验证格式。<br>time:时间选则框，默认值为空，表单提交时不会验证格式。<br>datetime-local:日期➕时间选择框，默认值为空，表单提交时不会验证格式。</p><p style="font-size:30px;color:#8DFEF6">form属性</p><blockquote><p>novalidate:如果给form标签设置了该属性值，表单提交的时候不再进行验证。</p></blockquote><p style="font-size:30px;color:#8DFEF6">视频标签</p><p>&lt;video&gt;标签用来定义视频，他是双标签。</p><p><br></br></p><p>src:URL地址  视频地址<br>width:像素值  设置视频播放器的宽高<br>height:像素值  设置视频播放器的高度<br>controls:向用户显示视频控件（比如播放&#x2F;暂停按钮）<br>muted:视频静音<br>autoplay:视频自动播放<br>loop:循环播放<br>poster:URL地址   视频封面<br>preload:  auto&#x2F;metadta&#x2F;none  如果使用autoplay,则忽略该属性。</p>]]></content>
      
      
      <categories>
          
          <category> HTML基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio Code </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.7学习笔记</title>
      <link href="/2025/01/19/css/%E5%AD%A6%E4%B9%A0css.7/"/>
      <url>/2025/01/19/css/%E5%AD%A6%E4%B9%A0css.7/</url>
      
        <content type="html"><![CDATA[<p style="font-size:40px;color:#0F7369;font-family:华文楷体">CSS 相对定位</p><p><b>1.如何设置相对定位？</b></p><ul>    <li>给元素设置<code>position:relative</code>即可实现相对定位。</li>    <li>可以使用<code>left、right、top、bottom</code>四个属性调整位置。</li>    </ul>  <p><b>2.相对定位的参考点在哪里？</b></p><ul>    <li>相对自己原来的位置</li>    </ul><p><b>3.相对定位的特点</b></p><ol>    <li>不会脱离文档流，元素位置的变化，只是视觉效果上的变化，不会对其他元素产生任何影响。</li>    <li>定位元素的显示<b>层级</b>比普通元素高，无论什么定位，显示层级都是一样的。</li>    <p>默认规则是：<p>    <ul>        <li>定位的元素会盖在普通元素之上。</li>        <li>都发生定位的俩个元素，后写的元素会盖在先写的元素之水上。</li>        </ul>    <li><code>left</code>不能和<code>right</code>一起设置，<code>top</code>和<code>bottom</code>不能一起设置。</li>    <li>相对定位的元素，也能继续浮动，但不推荐这样做。</li>    <li>想对行为的元素，也能通过<code>margin</code>调整位置，但不推荐这样做。</li>    </ol>    <blockquote><p>绝大多数情况下，相对定位，会与绝对定位配合使用。</p></blockquote><p style="font-size:40px;color:#0F7369;font-family:华文楷体">CSS 绝对定位</p><p>如何设置绝对定位？</p><ul>    <li>给元素设置<code>position:absolute</code>即可实现绝对定位。</li>    <li>可以使用<code>left、right、top、bottom</code>四个属性调整位置。</li>    </ul>    <p>绝对定位的参考点在哪里？</p>    <li>参考它的包含块。</li>    </ul><blockquote><p>什么是包含块？</p><p> 1.对于没有脱离文档流的元素：包含块就是父元素；<br>    2.对于脱离文档流的元素：包含块是第一个拥有定位属性的祖先元素（如果所有祖先都没定位，那包含快就是整个页面）。</p></blockquote><p>绝对定位元素的特点：</p><ol>    <li>脱离文档流，会对后面的兄弟元素、父元素有影响。</li>    <li><code>left</code>不能和<code>right</code>一起设置，<code>top</code>和<code>bottom</code>不能一起设置。</li>    <li>绝对定位、浮动不能同时设置，如果同时设置，浮动失效，以绝对定位为主。</li>    <li>绝对定位的元素，也能用过<code>margin</code>调整位置，但不推荐这样做。</li>    <li>无论是什么元素（行内、行内块、块级）设置为绝对定位之后，都变成了绝对定位元素。</li>    </ol> <blockquote><p>何为定位元素？–默认宽、高都被内容所撑开，且能自用设置宽高。</p></blockquote><p style="font-size:40px;color:#0F7369;font-family:华文楷体">CSS 固定定位</p>    <p><b>如何设置为固定定位？</b></p><ul>    <li>给元素设置<code>position:fixed</code>即可实现固定定位。</li>    <li>可以使用<code>left、right、top、bottom</code>四个属性调整位置。</li>    <p>固定定位的参考点在哪里？</p>    <li>参考它的<b>视口</b>        </ul> <blockquote><p>什么是视口？–对于PC浏览器来说，视口就是我们看网页的那扇“窗户”。</p></blockquote><p><b>固定定位元素的特点</b></p><ol>    <li>脱离文档流，会对后面的兄弟元素、父元素有影响。</li>    <li><code>left</code>不能和<code>right</code>一起设置，<code>top</code>和<code>bottom</code>不能一起设置。</li>    <li>固定定位、浮动不能同时设置，如果同时设置，浮动失效，以固定定位为主。</li>    <li>固定定位的元素，也能用过<code>margin</code>调整位置，但不推荐这样做。</li>    <li>无论是什么元素（行内、行内块、块级）设置为绝对定位之后，都变成了固定定位元素。</li>    </ol>    <p style="font-size:40px;color:#0F7369;font-family:华文楷体">CSS 粘性定位</p><p><b>如何设置为粘性定位？</b></p><ul>    <li>给元素设置<code>position:sticky</code>即可实现粘性定位。</li>    <li>可以使用<code>left、right、top、bottom</code>四个属性调整位置，不过最常用的是<code>top</code>值。</li>    </ul><p><b>粘性定位的参考点在哪里？</b></p><ul>    <li>离他最近的一个拥有“滚动机制”的祖先元素，即使这个祖先不是最近的真实可滚动祖先。</li>    </ul>    <p> <b>粘性定位元素的特点</b></p> <ul> <li>不会脱离文档流，它是一种专门用于窗口滚动是的新的定位方式。</li> <li>最常用的值是<code>top</code>值。</li> <li>粘性定位和浮动可以同时设置，但不推荐这样做。</li> <li>粘性定位的元素，也能通过<code>margin</code>调整位置，但不推荐这样做。</li> </ul><p style="font-size:40px;color:#0F7369;font-family:华文楷体">CSS 定位的特殊应用</p><blockquote><p>1.发生固定定位、绝对定位后，元素都变成了定位元素，默认宽高被内容撑开，且依然可以设置宽高。<br>2.发生相对定位后，元素依然是之前的显示模式。<br>3.以下所说的特殊应用，只针对<code>绝对定位</code>和<code>固定定位</code>的元素，不包括相对定位的元素。</p></blockquote><p><b>让定位元素的款充满包含块</b><br>1.快宽想与包含块一致，可以给定位元素同时设置<code>left</code>和<code>right</code>为0。<br>2.高度想与包含块一致，<code>top</code>和<code>bottom</code>设置为0。</p><p><b>让定位元素在包含块中居中</b><br>方案一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">left:0;</span><br><span class="line">right:0;</span><br><span class="line">top:0;</span><br><span class="line">bottom:0;</span><br><span class="line">margin:0;</span><br></pre></td></tr></table></figure><p>方案二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left:50%;</span><br><span class="line">top:50;</span><br><span class="line">margin-left:负的宽度一半;</span><br><span class="line">margin-top:负的高度一半;</span><br></pre></td></tr></table></figure><blockquote><p>该定位的元素必须设置宽高！！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.6学习笔记</title>
      <link href="/2025/01/19/css/%E5%AD%A6%E4%B9%A0css.6/"/>
      <url>/2025/01/19/css/%E5%AD%A6%E4%B9%A0css.6/</url>
      
        <content type="html"><![CDATA[<h6 style="font-size:50px;color:#54E4E9;font-family:华文楷体">CSS 浮动（float）</h6><blockquote><p>现在浮动是主流的页面布局方式之一。</p></blockquote><p><b>1.元素浮动后的特点</b></p><lo>    <li>脱离文档流</li>    <li>不管浮动前是什么元素，浮动后：默认宽与高都是被内容撑开（尽可能小），而且可以设置宽高。</li>    <li>不会独占一行，可以与其他元素共用一行。</li>    <li>不会<code>margin</code>合并，也不会<code>margin</code>塌陷，能够完美地设置四个方向的<code>margin</code><code>padding</code>。</li>    <li>不会像行内块一样被当作文本处理（没有行内块的空白问题）。</li>    </lo>    <br><p><b>2.浮动后会有哪些影响</b><br><b>对兄弟元素的影响</b>:后面的兄弟元素，会占据浮动元素之前的位置，在浮动元素的下面；对前面的兄弟无影响。<br><b>对父元素的影响</b>:不能撑起父元素的高度，导致父元素高度塌陷；但父元素的宽高依然束缚浮动的元素。</p><p><b>3.解决浮动产生的影响（清除浮动）</b></p><p>解决方案：<br>        1.方案一：给父元素指定高度。<br>        2.方案二：给父元素也设置浮动，带来其他影响。<br>        3.方案三：给父元素设置<code>overflow:hidden</code>。<br>        4.方案四：在所有浮动元素的最后面，添加一个块级元素，并给该块级元素设置<code>clear:both</code>。<br>        5.方案五：给浮动元素的父元素，设置伪元素，通过伪元素清除浮动，原理与方案四相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.parent::after&#123;</span><br><span class="line">     contert:&#x27;&#x27;;</span><br><span class="line">     display:block;</span><br><span class="line">     clear:both;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>布局中的一个原则：设置浮动的时候，兄弟元素要么全都浮动，要么全都不浮动。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.5学习笔记</title>
      <link href="/2025/01/18/css/%E5%AD%A6%E4%B9%A0css.5/"/>
      <url>/2025/01/18/css/%E5%AD%A6%E4%B9%A0css.5/</url>
      
        <content type="html"><![CDATA[<h6 style="font-size:50px;color:#7C5E17;font-family:华文楷体">CSS盒子模型</h6><ol>    <li style="font-size:25px;"><b>CSS长度单位</b></li>    </ol>    <ol>    <li><code>px</code>:像素。</li>    <li><code>em</code>:相对元素<code>font-size</code>的倍数。</li>    <li><code>rem</code>:相对根字体大小，html标签就是根.</li>    <li><code>%</code>:相对父元素计算。</li>    </ol><blockquote><p>CSS中设置长度，必须加单位，否则样式无效！</p></blockquote><br><br><p style="font-size:30px;color:#26F0E6;font-family:华文楷体">盒子模型的组成</p><p><code>CSS</code>会把所有的<code>HTML</code>元素都看成一个<b>盒子</b>，所有的样式也都是基于这个盒子。</p><ol>    <li><b>margin（外边距）</b>：盒子与外界的距离。（不会影响盒子大小，但会影响盒子的位置）</li>    <li><b>border（边框）</b>:盒子的边框。</li>    <li><b>padding（内边距）</b>:紧贴内容的补白区域。</li>    <li><b>contert（内容）</b>:元素中的文本或后代元素都是它的内容。</li>    </ol><blockquote><p>盒子的大小&#x3D;content+左右padding+左右border。</p></blockquote><br><p style="font-size:30px;color:#26F0E6;font-family:华文楷体">margin注意事项</p><blockquote><p>1.子元素的<code>margin</code>,是参考父元素的<code>content</code>计算的。（因为是父亲的content中承装着子元素）<br>2.上<code>margin</code>、左<code>margin</code>:影响自己的位置；下<code>margin</code>、右<code>margin</code>:影响后面兄弟元素的位置。<br>3.块级元素、行内块级元素，均可完美地设置四个方向的<code>margin</code>；但行内元素，左右<code>margin</code>可以完美设置，上下<code>margin</code>设置无效。<br>4.<code>margin</code>的值也可以是<code>auto</code>,如果给一个<b>块级元素</b>设置左右<code>margin</code>都为<code>auto</code>,该块级元素会在父元素中水平居中。<br>5.<code>margin</code>的值可以是负值。</p></blockquote><p style="font-size:25px;color:#26F0E6;font-family:华文楷体">margin塌陷问题</p><p>什么是<code>margin</code>塌陷？</p><p>&nbsp;&nbsp;第一个元素的<b>上</b><code>margin</code>会作用在父元素上，最后一个子元素的<b>下</b><code>margin</code>会作用在父元素上。<br><br><br>如何解决<code>margin</code>塌陷？</p><ul>    <li>方案一：给父元素设置不为0的<code>padding</code>。</li>    <li>方案二：给父元素设置宽度不为0的<code>border</code>。</li>    <li>方案三：给父元素设置css样式<code>overflow:hidden</code></li>    </ul>    <blockquote><p>处理内容溢出：也是加上voerflow:hidden.</p></blockquote><blockquote><p>隐藏元素的方式<br>vidibility:hidden<br>display:none</p></blockquote><p style="font-size:30px;color:#26F0E6;font-family:华文楷体">布局小技巧</p><p>1.行内元素、行内块元素，可以被父元素当做文本处理。</p><blockquote><p>即：可以像处理文本对齐一样，去处理：行内、行内块在父元素中的对齐。<br>例如：text-align、line-height、text-indent等。</p></blockquote><p>2.如何让子元素，在父亲中<b>水平居中：</p><ul>    <li>若子元素为块元素，给父元素加上：<code>margin:0 auto;</code>。</li>    <li>若子元素为行内元素、行内块元素，给父元素加上：<code>text-align:center</code></li>    </ul><p> 3.如何让子元素，在父亲中<b>垂直居中</b>:<br>    <ul><br>        <li>若子元素为块元素，给子元素加上：<code>margin-top</code>，值为：（父元素<code>content</code>-子元素盒子总高）&#x2F;2。</li><br>        <li>若子元素为行内元素、行内块元素：<br>            让父元素的<code>height=line-height</code>，每个子元素都加上：<code>vertical-align:middle;</code>。<br>            补充：若想绝对垂直居中，父元素<code>font-size</code>设置为<code>0</code>。</li><br>    </ul></p>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.4学习笔记</title>
      <link href="/2025/01/18/css/%E5%AD%A6%E4%B9%A0css.4/"/>
      <url>/2025/01/18/css/%E5%AD%A6%E4%B9%A0css.4/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:30px;color:#7DFFB5;font-family:华文楷体">CSS列表属性</h1><p><b>列表相关的属性，可以作用在<code>ul</code>、<code>ol</code>、<code>li</code>元素上。</b></p><table border="1">    <tr>        <th>CSS属性名</th>        <th>功能</th>        <th>属性值</th>    </tr>        <tr>            <th><code>tlst-style-type</code></th>            <th>设置列表符号</th>            <th>常用属性如下：                <code>none</code>：不显示前面的标识（很常用！）                <code>square</code>:实心方块                <code>disc</code>：圆形                <code>decimal</code>:数字                <code>lower-roman</code>:小写罗马字                <code>upper-roman</code>:大写罗马字                <code>lower-alpha</code>:小写字母                <code>upper-alpha</code>:大写字母</th>     </tr>         <tr>        <th><code>list-style-position</code></th>        <th>设置列表符号的位置</th>        <th><code>inside</code>:在<code>li</code>的里面            <code>outside</code>:在<code>li</code>的外边</th>    </tr>    <tr>        <th><code>list-style-image</code></th>        <th>自定义列表符号</th>        <th><code>url（图片地址）</code></th>    </tr>    <tr>        <th><code>list-style</code></th>        <th>符合属性</th>        <th>没有数量、顺序的要求</th>    </tr>        </table><h1 style="font-size:30px;color:#7DFFB5;font-family:华文楷体">CSS表格属性</h1><p><b>1.边框相关属性（其他元素也能用）：</b></p><table>    <tr>        <th>CSS属性名</th>        <th>功能</th>        <th>属性值</th>    </tr>    <tr>        <td><code>border-width</code></td>        <td>边框宽度</td>        <td><code>CSS</code>中可用的长度值</td>    </tr>    <tr>        <td><code>bordet-color</code></td>        <td>边框颜色</td>        <td><code>CSS</code>中可用的颜色值</td>    </tr>    <tr>        <td><code>border-style</code></td>        <td>边框风格</td>        <td><code>none</code>默认值            <code>solid</code>实线            <code>dashed</code>虚线            <code>dotted</code>点线            <code>double</code>双实线        </td>    </tr>    <tr>        <td><code>border</code></td>        <td>边框复合属性</td>        <td>没有书量、顺序的要求</td>    </tr>    </table><h1 style="font-size:30px;color:#7DFFB5;font-family:华文楷体">表格独有属性（只有<code>table</code>表情才能使用）：</h1><table>    <tr>        <th>CSS属性名</th>        <th>功能</th>        <th>属性值</th>    </tr>    <tr>        <td><code>table-layout</code></td>        <td>设置了列宽度</td>        <td><code>auto</code>:自动，类款根据内容计算（默认值）            <code>fixed</code>:固定列宽，平均分。</td>    </tr>    <tr>        <td><code>borber-spacing</code></td>        <td>单元格间距</td>        <td><code>CSS</code>中可用的长度值。        生效的前提：单元格边框不能合并</td>    </tr>    <tr>        <td><code>borer-collapse</code></td>        <td>合并单元格边框</td>        <td><code>collapse</code>:合并            <code>separate</code>:不合并</td>    </tr>    <tr>        <td><code>empty-cells</code></td>        <td>隐藏没有内容的单元格</td>        <td><code>show</code>:显示，默认            <code>hide</code>:隐藏</td>    </tr>    <tr>        <td><code>caption-side</code></td>        <td>设置表格标题位置</td>        <td><code>top</code>:上面（默认值）            <code>bottom</code>在表格下面</td></table>    <h1 style="font-size:30px;color:#7DFFB5;font-family:华文楷体">CSS背景属性</h1><table>    <tr>        <th>CSS属性名</th>        <th>功能</th>        <th>属性值</th>    </tr>    <tr>        <td><code>background-color</code></td>        <td>设置背景颜色</td>        <td>符合<code>CSS</code>中的颜色规范的值。默认背景颜色是<code>transparent</code>。</td>    </tr>    <tr>        <td><code>background-image</code></td>        <td>设置背景图片</td>        <td><code>url（图片地址）</code></td>    </tr>    <tr>        <td><code>background-repeat</code></td>        <td>设置背景重复方式</td>        <td><code>repeat</code>:重复，铺满整个元素，默认值<code>repeat-x</code>只在水平方向重复。<code>repeat-y</code>只在垂直方向重复<code>no-repeat</code>:不重复。</td>    </tr>    <tr>        <td><code>background-position</code></td>        <td>设置背景图位置</td>        <td><b>通过关键字设置位置</b>：写两个值，用空格隔开。 水平：<code>left、center、right、</code>垂直：<code>top、center、bottom</code>如果只取一个值，另一个方向的值取center            <b>通过长度指定坐标位置</b>:以元素左上角，为坐标原点，设置图标左上角位置。俩个值，分别是<code>x,y坐标。</code>只写一个值，会被当做x坐标，y坐标取center</td>    </tr>    <tr>        <td><code>background</code></td>        <td>符合属性</td>        <td>没有数量和顺序要求</td>    </tr>    </table> <h1 style="font-size:30px;color:#7DFFB5;font-family:华文楷体">CSS鼠标属性</h1><table>    <tr>        <th>CSS属性名</th>        <th>功能</th>        <th>属性值</th>    </tr>    <tr>        <td><code>cursor</code></td>        <td>设置鼠标光标的样式</td>        <td><code>pointer</code>:小手        <code>move</code>:移动图标        <code>text</code>:文字选择器        <code>crosshair</code>:十字架        <code>wait</code>:等待        <code>hrlp</code>:帮助</td>    </tr>    </table>        ]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.3学习笔记</title>
      <link href="/2025/01/17/css/%E5%AD%A6%E4%B9%A0css.3/"/>
      <url>/2025/01/17/css/%E5%AD%A6%E4%B9%A0css.3/</url>
      
        <content type="html"><![CDATA[<h2 style="font-size:45px;color:#5274E3;font-family:华文楷体">CSS 常用文本样式</h2><p style="font-size:20px;font-family:华文楷体"><b>以下是一些常用的 CSS 文本样式：</b></p>   <ul>        <li style="font-size:25px"><b>字体样式</b></li><br>    <li><b>字体类型：</b></li>    <li><b><code>font-family: 'Arial', sans-serif;</code></b>：设置字体为 Arial，如果没有 Arial 字体，则使用系统默认的无衬线字体。</li>    <li><b><code>font-family: 'Times New Roman', serif;</code></b>：设置字体为 Times New Roman，如果没有该字体，则使用系统默认的有衬线字体。</li><br>    <li><b>字体大小：</b></li>    <li><b><code>font-size: 16px;</code></b>：将字体大小设置为 16 像素。</li>    <li><b><code>font-size: 1.2em;</code></b>：字体大小相对于其父元素字体大小的 1.2 倍，这是一种相对单位，常用于保持文本在不同屏幕和设备上的可读性。</li><br>    <li><b>字体粗细：</b></li>    <li><b><code>font-weight: normal;</code></b>：正常粗细，等同于 <b><code>font-weight: 400;</code></b>。</li>    <li><b><code>font-weight: bold;</code></b>：加粗，等同于 <b><code>font-weight: 700;</code></b>，常用于突出显示标题或重要信息。</li>    <li><b><code>font-weight: 100;</code></b>：最细的字体粗细，数值越大，字体越粗，一般有 100、200、300、400、500、600、700、800、900 等等级别。</li><br><hr>    <li style="font-size:25px"><b>文本排版</b></li><br>    <li><b>文本对齐：</b></li>    <li><b><code>text-align: left;</code></b>：文本左对齐，常用于段落文本的默认对齐方式。</li>    <li><b><code>text-align: center;</code></b>：文本居中对齐，适用于标题、重要提示等需要突出显示的文本。</li>    <li><b><code>text-align: right;</code></b>：文本右对齐，可用于一些特定的布局需求，如表格中的数据对齐。</li>    <li><b><code>text-align: justify;</code></b>：两端对齐，常用于报纸、书籍等排版，使文本的左右两端都对齐，但可能会导致单词间距不均匀。</li><br>    <li><b>文本缩进：</b></li>    <li><b><code>text-indent: 2em;</code></b>：首行缩进 2 个字符宽度，符合中文排版习惯，常用于段落首行缩进，增强文本的层次感。</li><br>    <li><b>行高：</b></li>    <li><b><code>line-height: 1.5;</code></b>：行高是字体大小的 1.5 倍，合适的行高可以使文本更易读，避免行与行之间过于拥挤或过于疏远。</li>    <li><b><code>line-height: 24px;</code></b>：将行高固定为 24 像素，适用于需要精确控制行间距的场景。</li><br><hr>    <li style="font-size:25px"><b>文本修饰</b></li><br>    <li><b>文本颜色：</b></li>    <li><b><code>color: #ff0000;</code></b>：设置文本颜色为红色，使用十六进制颜色代码。</li>    <li><b><code>color: rgb(0, 0, 255);</code></b>：设置文本颜色为蓝色，使用 RGB 颜色模式。</li>    <li><b><code>color: rgba(0, 128, 0, 0.5);</code></b>：设置文本颜色为半透明的绿色，其中 0.5 表示透明度。</li><br>    <li><b>文本装饰：</b></li>    <li><b><code>text-decoration: none;</code></b>：去除文本装饰，常用于链接，使其看起来像普通文本。</li>    <li><b><code>text-decoration: underline;</code></b>：给文本添加下划线，可用于强调或表示链接。</li>    <li><b><code>text-decoration: overline;</code></b>：给文本添加上划线，较少使用，可用于一些特殊效果。</li>    <li><b><code>text-decoration: line-through;</code></b>：给文本添加删除线，表示文本被删除或不再有效。</li><br><hr>    <li style="font-size:25px"><b>其他</b></li><br>    <li><b>字母间距：</b></li>    <li><b><code>letter-spacing: 1px;</code></b>：字母间距增加 1 像素，可以使文本看起来更宽敞，常用于标题或需要强调的文本。</li><br>    <li><b>单词间距：</b></li>    <li><b><code>word-spacing: 2px;</code></b>：单词间距增加 2 像素，对英文等以空格分隔单词的语言有效，可改善文本的视觉效果。</li>    <li><b>文本转换：</b></li>    <li><b><code>text-transform: uppercase;</code></b>：将文本转换为大写，常用于标题或缩写词。</li>    <li><b><code>text-transform: lowercase;</code></b>：将文本转换为小写。</li>    <li><b><code>text-transform: capitalize;</code></b>：将每个单词的首字母大写，适用于标题或需要突出显示的文本。。</li>    </ul><p style="font-size:30px;font-weight: bold;font-family:华文楷体">vertical-align</p><ul>    <li>属性名：<code>vertical-align</code>。</li>    <li>作用:用于指定<code>同一行元素之间</code>，或<code>表格单元格</code>内文字的<code>垂直对齐方式</code>。</li>    <li>常用值：</li>    </ul>    <ol>    <li><code>baseline</code>(默认值)：使元素的基线与父元素的基线对齐。</li>    <li><code>top</code>:使元素的<code>顶部</code>与其<code>所在行的顶部</code>对齐。</li>    <li><code>middle</code>:使元素的<code>中部</code>与<code>父元素的基线</code>加上父元素字母<code>x</code>的一半。</li>    <li><code>bottom</code>:使元素的<code>底部</code>与其<code>所在行的底部</code>对齐。</li>    </ol><blockquote><p>注意：<code>vertical-align</code>不能控制块元素。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.2学习笔记</title>
      <link href="/2025/01/17/css/%E5%AD%A6%E4%B9%A0css.2/"/>
      <url>/2025/01/17/css/%E5%AD%A6%E4%B9%A0css.2/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:45pxpx;color:#47F1EF;font-family:华文楷体">伪类选择器</h1><ul>    <li>概念</li>    </ul><blockquote><p>作用：选中特殊状态的元素。<br>如何理解“伪”？-虚假的，不是真的。<br>如何理解“伪类”？-像类（class），但不是类，是元素的特殊状态。</p></blockquote><ul>    <li>常用伪类选择器</li>    </ul>    <p><b>一、动态伪类：</b></p><ol>    <li><code>:link</code>超链接<code>未被访问</code>的状态。</li>    <li><code>:visted</code>超链接<code>访问过</code>的状态。</li>    <li><code>:hover</code>鼠标<code>悬停</code>在元素上的状态。</li>    <li><code>:active</code>元素激活的状态。</li>    <li><code>:focus</code>获取焦点的元素。</li>    </ol>    <blockquote><p>表达类元素才能使用<code>:focus</code>伪类。<br>当用户：点击元素、触摸元素、或通过键盘的“tab”建等方式，选择元素时，就是获得焦点。</p></blockquote><p><b>二、常用结构伪类：</b></p><ul type="circle">    <li>常用的</li>    </ul>     <ol>    <li><code>:first-child</code>所用兄弟元素中的<code>第一个。</code></li>    <li><code>:last-child</code>所有元素中的<code>最后一个。</code></li>    <li><code>:nth-child(n)</code>所有兄弟元素中的<code>第n个。</code></li>    <li><code>:first-of-type</code>所有同类型兄弟元素的<code>第一个。</code></li>    <li><code>:last-of-type</code>所有同类型兄弟中的最后一个。</li>    <li><code>:nth-of-type(n)</code>所有同类型兄弟元素中的<code>第n个。</code>    </ol>  <p><b>三、否定伪类：</b></p> <blockquote><p><code>:not(选择器)</code>派纯满足括号中条件的元素。</p></blockquote><p><b>四、UI伪类</b></p><ol>    <li><code>:checked</code>被选中的复选框或单选框按钮。</li>    <li><code>:enable</code>可用的表单元素（没有<code>didabled</code>属性）。</li>    <li><code>:disabled</code>不可用的表单元素（有<code>didabled</code>属性）。</li>    </ol><p style="font-size:25px"><b>伪元素选择器</b></p><ul>    <li>作用：<code>选中元素</code>中的一些特殊位置。</li>    <li>常用伪元素：<li>    <ol>        <li><code>::first-letter</code>选中元素中的<code>第一个文字</code>。</li>        <li><code>::first-line</code>选中元素中的<code>第一行文字</code>。</li>        <li><code>::selection</code> 选中<code>被鼠标选中的</code>内容。</li>        <li><code>::placeholder</code>选中输入框的<code>提示文字</code>。</li>        <li><code>::before</code>在元素<code>最开始</code>的位置，创建一个子元素（必须用<code>content</code>属性指定内容）。</li>        <li><code>::after</code>在元素<code>最后</code>的位置，创建一个子元素（必须用<code>content</code>属性指定内容）。</li>              </ol></ul><p><b>选择器优先级</b></p><p><b>CSS选择器优先级是指当多个CSS规则应用于同一个元素时，用来决定哪个规则生效的顺序。优先级从高到低依次为：</b></p><p><b>一、内联样式（Inline styles）</b></p><li>内联样式是直接在HTML元素的<code>style</code>属性中定义的样式。例如<code>&lt;div  style="color: red;"&gt;内容&lt;/div"&gt;</code>，这种样式具有最高的优先级，因为它直接作用于元素本身，能够覆盖外部样式表和内部样式表中的其他选择器定义的样式。</li><p><b>二、ID选择器（ID selectors）</b></p><li>ID选择器使用<code>#</code>加元素的ID值来选择元素，如<code>#header&#123;background-color: blue;&#125;</code>。在页面中，ID应该是唯一的，所以ID选择器的优先级很高。它仅次于内联样式，能够覆盖类选择器、属性选择器等定义的样式。</li><p><b>三、类选择器、属性选择器和伪类选择器（Class selectors, Attribute selectors, and Pseudo-classes）</b></p><ol>       <li><b>类选择器</b>：使用<code>.</code>加类名来选择元素，如<code>.container&#123;width: 100px;&#125;</code>。它可以为具有相同类名的多个元素设置统一的样式。</li>    <li><b>属性选择器</b>：通过元素的属性来选择元素，例如<code>input[type="text"]&#123;border: 1px solid black;&#125;</code>，它选择所有<code>type</code>属性为<code>text</code>的<code>input</code>元素。</li><li><b>伪类选择器</b>：用于定义元素的特殊状态，如<code>:hover</code>（鼠标悬停时）、<code>:active</code>（元素被激活时）等，例如<code>a:hover&#123;color: green;&#125;</code>。这三者优先级相同，都高于标签选择器和通配符选择器。</li>    <p><b>四、标签选择器和伪元素选择器（Type selectors and Pseudo-elements）</b></p><ol>    <li><b>标签选择器</b>：直接使用元素的标签名来选择元素，如<code>div&#123;margin: 10px;&#125;</code>，它会选择页面上所有的<code>div</code>元素。</li><li><b>伪元素选择器</b>：用于选择元素的特定部分，如<code>::before</code>和<code>::after</code>。例如<code>div::before&#123;content: "前缀";&#125;</code>，会在<code>div</code>元素内容前插入“前缀”文本。它们的优先级相同，低于类选择器等。</li>    <p><b>五、通配符选择器、继承样式和浏览器默认样式<code>（Universal selectors, Inherited styles, and Default browser styles</code>）</b></p><ol>        <li><b>通配符选择器</b>：使用<code>*</code>来选择页面上所有的元素，如<code>*&#123;box-sizing: border-box;&#125;</code>，它的优先级很低。</li>    <li><b>继承样式</b>：某些CSS属性（如<code>color、font-size</code>等）会从父元素继承到子元素，这种继承而来的样式优先级也很低。</li>    <li><b>浏览器默认样式</b>：浏览器自身为元素定义的一些初始样式，如果没有其他样式覆盖，这些默认样式会生效，它的优先级是最低的。</li>    <blockquote><p>当优先级相同时，CSS规则的定义顺序也会影响最终生效的样式。在同一个CSS文件中，后定义的规则会覆盖先定义的规则；如果多个CSS文件同时作用于页面，后加载的CSS文件中的规则会覆盖先加载的CSS文件中的规则（前提是选择器优先级相同）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.1学习笔记</title>
      <link href="/2025/01/16/css/%E5%AD%A6%E4%B9%A0css.1/"/>
      <url>/2025/01/16/css/%E5%AD%A6%E4%B9%A0css.1/</url>
      
        <content type="html"><![CDATA[<p style="text-align:center;color:#DB7A0B;font-family:华文楷体;font-size:60px">入门CSS</p><div>S<h1 style="color:#47F1EF;font-size:39px;font-family:华文楷体">CSS简介</h1></div><p style="font-size:30px;font-family:华文楷体"><b>1.什么是 CSS？</b></p><ul>    <li>CSS 指的是层叠样式表* (Cascading Style Sheets)</li>    <li>CSS 描述了<b>如何在屏幕、纸张或其他媒体上显示 HTML 元素</b></li>    <li>CSS <b>节省了大量工作</b>。它可以同时控制多张网页的布局</li>    <li>外部样式表存储在<b> CSS 文件中</b></li></ul><h1 style="color:#47F1EF;font-size:39px;font-family:华文楷体">CSS 语法</h1><p style="font-size:19px">CSS（层叠样式表）用于设置HTML页面中元素的样式，其语法主要包括以下几个部分：</p><p style="font-size:20px"><b>1.选择器</b></p><div>    <p>选择器用于选择页面中的元素，以便为其应用样式。常见的选择器类型有：</p>    <ul>        <li><b>元素选择器</b>：直接使用元素名称，如p选择页面中所有的&lt;p&gt;元素。</li>        <li><b>类选择器</b>：以<code>.</code>开头，如<code>.my-class</code>选择页面中所有<code>class="my-class"</code>的元素。</li>        <li><b>ID选择器</b>:以<code>#</code>开头，如<code>#my-id</code>选择页面中<code>id="my-id"</code>的元素。</li>        <li><b>属性选择器</b>:以<code>[attribute]</code>形式，如<code>[type="text"]</code>选择所有<code>type</code>属性值为<code>text</code>的元素。</li>        <li><b>伪类选择器</b>:以<code>:</code>开头，如<code>:hover</code>选择鼠标悬停的元素，<code>:nth-child(n)</code>选择其父元素的第<code>n</code>个子元素等。</li>        <li><b>伪元素选择器</b>:以<code>:before</code>在元素内容前插入内容，<code>::after</code>在元素内容后插入内容等。</li>        <li><b>组合选择器</b>:可以将多个选择器组合使用，如<code>div p</code>选择<code>&lt;div&gt;</code>元素内的所有<code>&lt;p&gt;</code>元素，<code>.class1.class2</code>选择同时具有<code>class1</code>和<code>class2</code>类的元素等。</li>        </ul>        </div><p style="font-size:20px"><b>2.声明器</b></p><p>选择器后面跟着一个花括号<code>&#123;&#125;</code>，里面包含一个或多个声明，用于定义元素的样式。每个声明由属性和值组成，属性和值之间用英文冒号<code>:</code>分隔，每个声明之间用英文分号<code>;</code>分隔。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="font-size:25px"><b>示例:</b></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选择所有段落元素，设置字体颜色为红色，字体大小为16px */</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择id为&quot;header&quot;的元素，设置背景颜色为蓝色，文字颜色为白色 */</span></span><br><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择类名为&quot;highlight&quot;的元素，鼠标悬停时设置背景颜色为黄色 */</span></span><br><span class="line"><span class="selector-class">.highlight</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择所有input元素，且type属性值为&quot;text&quot;，设置边框为1px实线黑色 */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;text&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CSS的语法简洁而强大，通过合理使用选择器和声明块，可以灵活地为HTML页面中的元素设置各种样式。</p></blockquote><h1 style="color:#47F1EF;font-size:39px;font-family:华文楷体">CSS 样式</h1><p>有三种主要的插入CSS样式表的方法，分别是内联样式、内部样式表和外部样式表。以下是详细介绍：</p><p style="font-size:20px"><b>1. 内联样式（Inline CSS）</b></p><ul>    <li><b>定义</b>:直接在HTML元素的标签中使用<code>style</code>属性来添加CSS样式。</li>    <li><b>使用方法</b>:在元素标签中添加<code>style="样式规则"</code>，样式规则中包含属性和值，属性和值之间用英文冒号分隔，多个样式规则之间用英文分号分隔。例如：</li>    </ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red; font-size: 16px;&quot;</span>&gt;</span>这是一段红色的文本，字体大小为16px。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul>    <li><b>特点</b>:</li>   <ul type="circle">    </ul>        <li>优点：可以直接在元素上应用样式，对于单个元素的样式修改非常方便，可以快速看到效果。</li>        <li>缺点：样式与结构混合，违反了CSS与HTML分离的原则，不利于维护和重用。当需要对多个元素应用相同的样式时，代码会变得冗余。</li></ul>        <p style="font-size:20px"><b>2. 内部样式表（Internal CSS）</b></p><ul>    <li><b>定义</b>:在HTML文档的<code>&lt;head&gt;</code>部分使用<code>&lt;style&gt;</code>标签来定义CSS样式。</li>    <li><b>使用方法</b>:在<code>&lt;head&gt;</code>标签内添加<code>&lt;style&gt;</code>标签，在<code>&lt;style&gt;</code>标签内编写CSS选择器和对应的样式规则。例如：</li>    </ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">14px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.highlight</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段蓝色的文本，字体大小为14px。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;highlight&quot;</span>&gt;</span>这是一个黄色背景的div。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul>    <li><b>特点</b>:</li>       </ul><ul type="circle">        <li>优点：样式与HTML结构在同一文件中，方便查看和修改，适用于单个页面的样式定义。可以避免内联样式带来的代码冗余问题。</li>        <li>缺点：样式仍然局限于单个HTML文件，不利于多个页面之间的样式共享和维护。当网站包含多个页面时，每个页面都需要重复编写相同的样式代码。</li></ul><p style="font-size:20px"><b>3. 外部样式表（External CSS）</b></p><ul>    <li><b>定义</b>:将CSS样式写在一个单独的<code>.css</code>文件中，然后在HTML文档中通过<code>&lt;link&gt;</code>标签引入该样式表。</li>    <li><b>使用方法</b>:首先创建一个CSS文件（如<code>styles.css</code>），在其中编写CSS样式规则。然后在HTML文档的<code>&lt;head&gt;</code>部分使用<code>&lt;link&gt;</code>标签引入该CSS文件。例如：</li>    </ul><ul type="circle">    <li><code>styles.css</code>文件内容：</li>    </ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul type="circle">    <li>HTML文件内容：</li>    </ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span>&gt;</span>这是页面头部。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段绿色的文本，字体大小为18px。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul>    <li><b>特点</b>:</li>       </ul><ul type="circle">        <li>优点：实现了CSS与HTML的完全分离，符合Web开发的最佳实践。样式文件可以被多个HTML页面共享，便于维护和更新。当需要修改样式时，只需修改一个CSS文件，所有引用该文件的页面都会自动更新样式。</li>        <li>缺点：需要额外的文件管理，对于非常简单的页面或临时的样式修改，可能会显得有些繁琐。</li></ul><p style="font-size:20px"><b>样式优先级</b></p><div>    当同时使用以上三种方法时，样式的优先级从高到低依次为：内联样式 > 内部样式表 > 外部样式表。此外，还可以通过使用<code>!important</code>规则来提高某个样式规则的优先级，但应谨慎使用，因为它可能会导致样式难以维护。例如：</div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这会使&lt;p&gt;元素的文本颜色无论如何都显示为红色，即使有其他更高优先级的样式规则存在。*/</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red <span class="meta">!important</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识HTML.3学习笔记</title>
      <link href="/2025/01/15/html/%E5%AD%A6%E4%B9%A0html.3/"/>
      <url>/2025/01/15/html/%E5%AD%A6%E4%B9%A0html.3/</url>
      
        <content type="html"><![CDATA[<h1 style="text-align:center;font-size:60px;color:green;font-family:华文楷体">块元素和行内元素</h1><p><dfn>一、定义和用法</dfn></p><blockquote><p>div 标签定义 HTML 文档中的分割或部分（分区或小节，division&#x2F;section）。<br>div 标签可以把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不使用任何格式与其关联。<br>任何类型的内容都可以放在 div 标签内！div 标签可用作 HTML 元素的容器，然后使用 CSS 设置样式或使用 JavaScript 进行操作。<br>如果用 id 或 class 来标记 div，那么该标签的作用会变得更加有效。通过使用 class 或 id 属性，可以轻松地对 div 标签设置样式。<br>注意：默认情况下，浏览器总是在 div 元素前后放置一个换行符。</p></blockquote><p>二、用法</p><blockquote><p>div 是块级元素。这意味着它的内容自动地开始一个新行。实际上，换行是 div 固有的唯一格式表现。可以通过 div 的 class 或 id 应用额外的样式。<br>不必为每一个 div 都加上类或 id，虽然这样做也有一定的好处。<br>可以对同一个 div 元素应用 class 或 id 属性，但是更常见的情况是只应用其中一种。这两者的主要差异是，class 用于元素组（类似的元素，或者可以理解为某一类元素），而 id 用于标识单独的唯一的元素。</p></blockquote><h1 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.cities &#123;</span><br><span class="line">    background-color:black;</span><br><span class="line">    color:white;</span><br><span class="line">    margin:20px;</span><br><span class="line">    padding:20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;cities&quot;&gt;</span><br><span class="line">&lt;h2&gt;London&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Standing on the River Thames, London has been a major settlement for two millennia, its history going back to its founding by the Romans, who named it Londinium.&lt;/p&gt;</span><br><span class="line">&lt;/div&gt; </span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 style="text-align:center;font-size:60px;font-family:华文楷体;color:green">表单</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot;&gt;  &lt;!--输入框--&gt;</span><br><span class="line">&lt;button&gt;SEARCH&lt;button&gt; &lt;!--搜索--&gt;</span><br></pre></td></tr></table></figure><p><b><code>表单常用属性</code></b></p><pre>1.作用于form标签（表单）action:用于指定表单的提交地址（需要与后端沟通后确定）。target:用于控制表单提交后，如何打开页面，常用值如下：        _self:在本窗口打开。        _blank:在新窗口打开。2.作用于input标签（输入框）method:用于控制表单的提交方式。type:设置输入框的类型，目前用到的值是text,表示普通文本。name:用于指定提交数据的名字，（需要与后端人员沟通后确定）。</pre><p><code>示例</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://search.jd.com/Search&quot;</span><span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span><span class="attr">name</span>=<span class="string">&quot;keyword&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>京东搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p style="font-family:华文楷体;color:green;font-size:20px">表单_常用控件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">认识新属性：value(值):可以控制输入框的默认值</span><br><span class="line">           maxlength(最大长度)：可以输入最大的字符长度</span><br></pre></td></tr></table></figure><hr><p style="font-family:华文楷体;color:green;font-size:20px">表单_单选框与多选框</p><ul>    <b><li>单选框</li></b>    </ul>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女</span><br><span class="line">&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男</span><br></pre></td></tr></table></figure><blockquote><p>常用属性性如下：<br>name:数据的名称，注意：想要单选效果，多个radio的name属性值要保持一致。<br>value：提交的数据值<br>checked:让该单选按钮默认选中。</p></blockquote><ul>    <b><li>复选框</li></b>    </ul>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;exercise&quot;</span>&gt;</span>运动</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;reading&quot;</span>&gt;</span>阅读</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;swimming&quot;</span>&gt;</span>游泳</span><br></pre></td></tr></table></figure><blockquote><p>常用属性性如下：<br>checked：让该复选框默认选中。</p></blockquote><hr><p style="font-family:华文楷体;color:green;font-size:20px">表单_隐藏域</p><ul>    <b><li>隐藏域</li></b>    </ul>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;page&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>用户不可见的一个区域，作用是：提交表单的时候，携带一些固定的数据。</p></blockquote><hr><ul>    <b><li>提交按钮</li></b>    </ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hatton</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">hatton</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>1.button标签type属性的默认值是submit。<br>2.button不要指定name属性。<br>3.input标签编写的按钮，使用value属性指定按钮文字。</p></blockquote><ul>    <b><li>重置按钮</li></b>    </ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><ul>    <b><li>普通按钮</li></b>    </ul>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;确定&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>普通按钮的type值为button,若不写type值是submit会引起表单的提交。</p></blockquote><hr><p style="font-family:华文楷体;color:green;font-size:20px">表单_文本域和下拉框</p><ul>    <b><li>文本域</li></b>    </ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">txtarea</span> <span class="attr">name</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;22&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;3&quot;</span>&gt;</span>文本域<span class="tag">&lt;/<span class="name">txtarea</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>常用属性如下：<br>1.rows：指定默认显示的行数，会影响文本域的高度。<br>2.cols:指定默认显示的列数，会影响文本域的宽度。<br>3.不能编写type属性，其他属性，与普通文本输入框一致。</p></blockquote><ul>    <b><li>下拉框</li></b>    </ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;shanghai&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;guangzhou&quot;</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;shenzhen&quot;</span> <span class="attr">selected</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>常用属性及注意事项：<br>1.name:指定数据的名称。<br>2.option标签设置value属性，如果没有value属性，提交的数据是option中间的文字;如果设置了value属性，提交的数据就是value的值（建议设置value属性）<br>3.option标签设置了selected属性，表示默认选中。</p></blockquote><hr><p style="font-family:华文楷体;color:green;font-size:20px">表单_禁用表单控件</p><ul>    <b><li>禁用表单控件</li></b>    </ul><blockquote><p>给表单控件的标签设置disabled即可禁用表单控件。<br>input、textarea、button、select、option都可以设置disabled属性</p></blockquote><p style="font-family:华文楷体;color:green;font-size:20px">表单_label标签</p><ul>    <b><li>表单label标签</li></b>    </ul>    <blockquote><p>label标签可与表单控件相关联，关联之后点击文字，与之对应的表单控件就会获取焦点。两种与label关联方式如下：<br>1.让label标签的form属性的值等于表单控件的id。<br>2.把表单控件套在label标签的里面。</p></blockquote><h1 style="text-align:center;font-size:60px;font-family:华文楷体;color:green">框架标签</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.taobao.com&quot;</span><span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span><span class="attr">width</span>=<span class="string">&quot;300&quot;</span><span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span>taobao<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>与超链接的target属性配合使用</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.taobao.com&quot;</span>  <span class="attr">target</span>=<span class="string">&quot;clj&quot;</span>&gt;</span>淘宝<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;clj&quot;</span>  <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">htight</span>=<span class="string">&quot;300&quot;</span> &gt;</span>taobao<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>与表单的target属性配合使用</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://www.taobao.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;clj&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;keyword&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;clj&quot;</span>  <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">htight</span>=<span class="string">&quot;300&quot;</span> &gt;</span>taobao<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>  </span><br></pre></td></tr></table></figure><table>    <tr>        <th>标签名</th>        <th>功能和语义</th>        <th>属性</th>        <th>单/双标签</th>        </tr>    <tr>        <th>iframe</th>        <th>框架（在页面中嵌入其他文件）</th>        <th>name:框架名字，可以与target属性配合。            width:框架的宽。            height：框架的高。            frameborder:是否显示边框，值：0或者1。</th>        <th>双</th>    </tr>  </table>    <blockquote><p>iframe标签的实际应用：<br>    1.在网页中嵌入广告。<br>    2.与超链接或表单的target配合，展示不同的内容。</p></blockquote><p style="font-family:华文楷体;color:green;font-size:20px">HTML 字符实体</p><p><code><b>字符实体</b>由三部分组成：一个&和一个实体名称（或者一个#和一个实体编号），最后加上一个分号<b>;</b> 。</code></p>]]></content>
      
      
      <categories>
          
          <category> HTML基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio Code </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识HTML.2学习笔记</title>
      <link href="/2025/01/14/html/%E5%AD%A6%E4%B9%A0html.2/"/>
      <url>/2025/01/14/html/%E5%AD%A6%E4%B9%A0html.2/</url>
      
        <content type="html"><![CDATA[<h1 style="text-align:center;font-size:60px;color:green;font-family:华文楷体;">HTML 颜色</h1><p><b><dfn>颜色值</dfn></b></p><p>颜色由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。每种颜色的最小值是 0（十六进制：#00）。最大值是 255（十六进制：#FF）。<p>    <p><b><dfn>在HTML中应用16进制颜色</dfn></b><br><cite>设置文本颜色</cite></p><blockquote><p>可以通过CSS的color属性来设置文本颜色。例如：   </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=&quot;color:#FF5733;&quot;&gt;这是一段红色的文本。&lt;/p&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，段落p中的文本颜色被设置为#FF5733，这是一种橙红色。</p></blockquote><p><cite>设置背景颜色</cite></p><blockquote><p>使用background-color属性可以设置元素的背景颜色。例如：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#333399; width:200px; height:100px;&quot;</span>&gt;</span></span><br><span class="line">  这是一个有背景颜色的div</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里设置了一个div元素的背景颜色为#333399，这是一种深蓝色。同时，通过设置width和height属性，定义了div的大小，以便更好地展示背景颜色效果。</p></blockquote><p><cite>设置边框颜色</cite></p><blockquote><p>如果要给元素添加边框并设置边框颜色，可以使用border属性。例如：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border:2px solid #FFD700; width:200px; height:100px;&quot;</span>&gt;</span></span><br><span class="line">  这是一个有黄色边框的div</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，div元素有一个2像素宽的实线边框，边框颜色为#FFD700，即金色。通过这种方式，可以为网页中的各种元素添加具有特定颜色的边框，增强页面的视觉效果。<br>如何使用样式<br>当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化。有以下三种方式来插入样式表：</p></blockquote><p><cite>外部样式表</cite></p><blockquote><p>当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p><cite>内部样式表</cite></p><blockquote><p>当单个文件需要特别样式时，就可以使用内部样式表。你可以在 head 部分通过 style 标签定义内部样式表。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">body &#123;background-color: red&#125;</span><br><span class="line">p &#123;margin-left: 20px&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p><cite>内联样式</cite></p><blockquote><p>当特殊的样式需要应用到个别元素时，就可以使用内联样式。使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=&quot;color: red; margin-left: 20px&quot;&gt;</span><br><span class="line">This is a paragraph</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><h1 style="text-align:center;font-size:60px;color:green;font-family:华文楷体;">HTML 超链接</h1><p><code>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。</code></p><blockquote><p>当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。<br>我们通过使用 《a》 标签在 HTML 中创建链接。<br>有两种使用 《a》 标签的方式：<br>通过使用 href 属性 - 创建指向另一个文档的链接<br>通过使用 name 属性 - 创建文档内的书签</p></blockquote><p><code>HTML中的链接是通过《a》（anchor）标签来创建的，它允许用户从一个网页跳转到另一个网页、网页的某个部分，或者打开一个文件等。以下是关于HTML链接的详细介绍：</code></p><p>一、基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;链接目标的URL&quot;</span>&gt;</span>链接文字或内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>href属性是关键，它指定了链接的目标地址。可以是网页的URL、文件的路径、网页内部的锚点等。<br>链接文字或内容是显示在网页上的部分，用户点击这部分内容就会触发链接跳转。可以是纯文本，也可以是图片或其他HTML元素。</p></blockquote><p>二、链接类型<br>1.外部链接<br><code>这是指向其他网站的链接。例如，要创建一个链接到百度首页的链接，可以这样写：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>访问百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当用户点击“访问百度”这几个字时，浏览器会打开百度的首页。</p></blockquote><p>2.内部链接<br><code>内部链接是指在同一网站内部不同页面之间的链接。例如，一个网站有首页（index.html）、关于我们（about.html）和联系我们（contact.html）三个页面，可以在首页创建一个链接到关于我们页面的链接：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;about.html&quot;</span>&gt;</span>关于我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里假设这些页面都在同一个目录下。如果页面在不同的目录，需要正确设置相对路径或绝对路径。例如，如果关于我们页面在pages目录下，链接可以写成：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;pages/about.html&quot;</span>&gt;</span>关于我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.锚点链接</p><blockquote><p>锚点链接用于在同一页面内快速跳转到特定位置。首先需要在目标位置设置一个锚点，使用《a》标签的name属性（HTML5中推荐使用id属性）来定义锚点。例如，在页面底部有一个段落：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;section1&quot;</span>&gt;</span>第一部分<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是第一部分的内容……<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>然后在页面顶部可以创建一个链接到这个锚点的链接：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#section1&quot;</span>&gt;</span>跳转到第一部分<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">当用户点击这个链接时，页面会滚动到<span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;section1&quot;</span>&gt;</span>所在的位置。</span><br></pre></td></tr></table></figure><p>三、链接的其他属性<br>1.target属性</p><blockquote><p>这个属性可以控制链接在何处打开。常用的值有：</p></blockquote><p><code>_self：在当前窗口或标签页中打开链接，这是默认值。<br>_blank：在新窗口或新标签页中打开链接。例如：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>在新标签页打开示例网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>点击这个链接会在新标签页中打开<a href="https://www.example.com./">https://www.example.com。</a></p></blockquote><p><code>_parent：在父窗口或标签页中打开链接，主要用于框架（frame）或嵌套的网页场景。<br>_top：在整个浏览器窗口中打开链接，也会清除所有框架。</code><br>2.title属性<br><code>为链接提供额外的信息，当用户将鼠标悬停在链接上时，会显示这个提示信息。例如：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span> <span class="attr">title</span>=<span class="string">&quot;这是一个示例网站&quot;</span>&gt;</span>示例网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>鼠标悬停在“示例网站”链接上时，会显示“这是一个示例网站”的提示。<br>HTML链接是网页之间相互连接的桥梁，合理使用链接可以极大地提升用户体验和网站的导航性。</p></blockquote><h1 style="text-align:center;font-size:60px;color:green;font-family:华文楷体;">HTML 图像</h1><p><code>在HTML中插入图像主要通过《img》标签来实现，这是一种非常简单但功能强大的方式，可以让网页更加生动和富有表现力。以下是关于如何在HTML中插入图像的详细介绍：</code><br>一、基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像的URL或路径&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图像的替代文本&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>src属性：这是必需的属性，用于指定图像的源路径。可以是相对路径（相对于当前HTML文件的位置）或绝对路径（完整的URL）。</p></blockquote><p><code>alt属性：也是很重要的属性，它提供了图像的替代文本。当图像由于某些原因无法显示时（如网络问题、图像路径错误等），浏览器会显示这个替代文本。此外，对于使用屏幕阅读器的用户来说，alt文本可以帮助他们了解图像的内容，从而提高网页的可访问性。</code></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>1.使用相对路径插入图像<br><code>假设你有一个名为image.jpg的图像文件，它和你的HTML文件位于同一个目录下，你可以这样插入图像：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图像&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>如果图像文件位于一个名为images的子目录中，路径应该是：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图像&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.使用绝对路径插入图像<br><code>如果你想插入一个来自互联网的图像，可以使用完整的URL：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://example.com/images/image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;来自外部网站的图像&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>二、其他有用的属性<br>1.width和height属性</p><blockquote><p>这两个属性可以用来指定图像的显示宽度和高度，单位通常是像素。这可以帮助你控制图像在网页中的大小，使其更好地适应布局。例如：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图像&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>注意，如果只设置其中一个属性，图像会按比例自动调整另一个维度的大小，以保持图像的纵横比。</code><br>2.title属性</p><blockquote><p>和链接的title属性类似，title属性为图像提供额外的信息，当用户将鼠标悬停在图像上时，会显示这个提示信息。</p></blockquote><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图像&quot;</span> <span class="attr">title</span>=<span class="string">&quot;这是一个示例图像&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 style="text-align:center;font-size:60px;color:green;font-family:华文楷体;">HTML 表格，列表</h1><p>一、基本语法<br><code>HTML表格是通过table标签来创建的，表格由行（《tr》）、单元格（td或th）组成。其中，th用于定义表头单元格，通常显示为加粗和居中，而td用于定义普通单元格。</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据6<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1.表格的组成部分</p><blockquote><p>1.table标签：定义整个表格。<br>2.tr标签：定义表格的行。<br>3.th标签：定义表头单元格，通常用于第一行来描述列的内容。<br>4.td标签：定义普通单元格，用于包含数据。</p></blockquote><p>2.表格的属性</p><blockquote><p>虽然HTML5中许多表格属性已经被CSS所取代，但仍然有一些属性可以用来控制表格的基本行为：<br>border属性：用于设置表格边框的宽度。例如，table border&#x3D;”1”会创建一个有边框的表格。不过，现在更推荐使用CSS来控制边框样式。<br>cellpadding和cellspacing属性：分别用于设置单元格内内容与边框的距离（内边距）和单元格之间的距离（外边距）。同样，这些现在也推荐使用CSS来控制。</p></blockquote><p><code>在HTML中，列表是一种非常有用的元素，用于组织和显示一系列相关的信息。HTML提供了三种主要的列表类型：无序列表（ul）、有序列表（ol）和描述列表（dl）。每种列表类型都有其特定的用途和格式。</code><br>一、无序列表（ul）</p><blockquote><p>无序列表用于表示没有特定顺序的项目列表。列表项使用li（list item）标签定义。</p></blockquote><p>1.基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>在浏览器中，这将显示一个带有项目符号的列表。</code><br>二、有序列表（ol）<br><dfn>有序列表用于表示有特定顺序的项目列表。列表项同样使用li标签定义。有序列表的列表项会自动编号。</dfn><br>2.基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>在浏览器中，这将显示一个带有数字编号的列表。</code><br>三、描述列表（dl）<br><dfn>描述列表用于表示术语和描述的列表。它由dl标签定义，每个术语使用dt（definition term）标签定义，每个描述使用dd（definition description）标签定义。</dfn><br>1.基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>术语1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>术语2<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>在浏览器中，这将显示一个术语和描述的列表，术语通常会加粗显示。</code><br><dfn>四、列表的嵌套</dfn></p><blockquote><p>列表可以嵌套使用，即在一个列表项内部再创建一个新的列表。这在需要表示层次结构时非常有用。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>水果</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>橙子<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>蔬菜</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>胡萝卜<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>西红柿<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>土豆<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>在浏览器中，这将显示一个嵌套的无序列表，其中每个主要类别（水果和蔬菜）下面有子类别。</code></p>]]></content>
      
      
      <categories>
          
          <category> HTML基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio Code </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html.1学习笔记</title>
      <link href="/2025/01/14/html/%E5%AD%A6%E4%B9%A0html.1/"/>
      <url>/2025/01/14/html/%E5%AD%A6%E4%B9%A0html.1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>HTML 注释</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--（文本）--&gt;</span><br></pre></td></tr></table></figure><h1 style="text-align:center;font-size:60px"> HTML 样式</h1><h2 style="text-align:center;font-size:30px;font-family:华文楷体">HTML 的 style 属性</h2><blockquote><p>style 属性用于改变 HTML 元素的样式。</p></blockquote><p>1.style 属性的作用:</p><blockquote><p>提供了一种改变所有 HTML 元素的样式的通用方法。<br>样式是 HTML 4 引入的，它是一种新的首选的改变 HTML 元素样式的方式。通过 HTML 样式，能够通过使用 style 属性直接将样式添加到 HTML 元素，或者间接地在独立的样式表中（CSS 文件）进行定义。</p></blockquote><h3 style="text-align:center;color:green;font-size:30px;font-family:华文楷体">HTML 样式实例 - 背景颜色</h3><blockquote><p>background-color 属性为元素定义了背景颜色：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body style=&quot;background-color:yellow&quot;&gt;</span><br><span class="line">&lt;h2 style=&quot;background-color:red&quot;&gt;This is a heading&lt;/h2&gt;</span><br><span class="line">&lt;p style=&quot;background-color:green&quot;&gt;This is a paragraph.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 style="text-align:center;color:red;font-size:30px;font-family:华文楷体">HTML 样式实例 - 字体、颜色和尺寸</h4><blockquote><p>font-family、color 以及 font-size 属性分别定义元素中文本的字体系列、颜色和字体尺寸：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 style=&quot;font-family:verdana&quot;&gt;A heading&lt;/h1&gt;</span><br><span class="line">&lt;p style=&quot;font-family:arial;color:red;font-size:20px;&quot;&gt;A paragraph.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h5 style="text-align:center;color:green;font-size:30px;font-family:华文楷体">HTML 样式实例 - 文本对齐</h5>                    <blockquote><p>text-align 属性规定了元素中文本的水平对齐方式：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 style=&quot;text-align:center&quot;&gt;This is a heading&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;The heading above is aligned to the center of this page.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 style="text-align:center;font-size:60px;">HTML 文本格式化</h1><blockquote><p>HTML 可定义很多供格式化输出的元素，比如粗体和斜体字。</p></blockquote><h2 style="text-align:center;font-size:30px;font-family:华文楷体;color:red">文本风格化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;b&gt;This text is bold&lt;/b&gt;</span><br><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;This text is strong&lt;/strong&gt;</span><br><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">&lt;big&gt;This text is big&lt;/big&gt;</span><br><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">&lt;em&gt;This text is emphasized&lt;/em&gt;</span><br><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">&lt;i&gt;This text is italic&lt;/i&gt;</span><br><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">&lt;small&gt;This text is small&lt;/small&gt;</span><br><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">This text contains</span><br><span class="line">&lt;sub&gt;subscript&lt;/sub&gt;</span><br><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br></pre></td></tr></table></figure><h3 style="text-align:center;font-size:30px;color:red;font-family:华文楷体">预格式文本</h3>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    &lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">这是</span><br><span class="line">预格式文本。</span><br><span class="line">它保留了      空格</span><br><span class="line">和换行。</span><br><span class="line">&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;pre 标签很适合显示计算机代码：&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">for i = 1 to 10</span><br><span class="line">     print i</span><br><span class="line">next i</span><br><span class="line">&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 style="text-align:center;font-size:30px;color:red;font-family:华文楷体">“计算机输出”标签</h4>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;code&gt;Computer code&lt;/code&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;kbd&gt;Keyboard input&lt;/kbd&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;tt&gt;Teletype text&lt;/tt&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;samp&gt;Sample text&lt;/samp&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;var&gt;Computer variable&lt;/var&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;b&gt;注释：&lt;/b&gt;这些标签常用于显示计算机/编程代码。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h5 style="text-align:center;font-size:30px;color:red;font-family:华文楷体">地址</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;address&gt;</span><br><span class="line">Written by &lt;a href=&quot;mailto:webmaster@example.com&quot;&gt;Donald Duck&lt;/a&gt;.&lt;br&gt; </span><br><span class="line">Visit us at:&lt;br&gt;</span><br><span class="line">Example.com&lt;br&gt;</span><br><span class="line">Box 564, Disneyland&lt;br&gt;</span><br><span class="line">USA</span><br><span class="line">&lt;/address&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h5 style="text-align:center;font-size:30px;color:red;font-family:华文楷体">缩写和首字母缩写</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTML &lt;abbr&gt; 元素定义缩写或首字母缩略语。</span><br><span class="line"></span><br><span class="line">对缩写进行标记能够为浏览器、翻译系统以及搜索引擎提供有用的信息。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;abbr title=&quot;etcetera&quot;&gt;etc.&lt;/abbr&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;acronym title=&quot;World Wide Web&quot;&gt;WWW&lt;/acronym&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;在某些浏览器中，当您把鼠标移至缩略词语上时，title 可用于展示表达的完整版本。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;仅对于 IE 5 中的 acronym 元素有效。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;对于 Netscape 6.2 中的 abbr 和 acronym 元素都有效。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h6 style="text-align:center;font-size:30px;color:red;font-family:华文楷体">文字方向</h6><blockquote><p>bdo:dir&#x3D;ltr（从左到右输出）,rtl（从右到左输出）必需。规定 <bdo> 元素内文本的文本方向。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">如果您的浏览器支持 bi-directional override (bdo)，下一行会从右向左输出 (rtl)；</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;bdo dir=&quot;rtl&quot;&gt;</span><br><span class="line">Here is some Hebrew text</span><br><span class="line">&lt;/bdo&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h6 style="text-align:center;font-size:30px;color:red;font-family:华文楷体">快引用</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTML &lt;blockquote&gt; 元素定义被引用的节。</span><br><span class="line">浏览器通常会对 &lt;blockquote&gt; 元素进行缩进处理。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">这是长的引用：</span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">这是短的引用：</span><br><span class="line">&lt;q&gt;</span><br><span class="line">这是短的引用。</span><br><span class="line">&lt;/q&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">使用 blockquote 元素的话，浏览器会插入换行和外边距，而 q 元素不会有任何特殊的呈现。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h6 style="text-align:center;font-size:30px;color:red;font-family:华文楷体">删除字效果和插入字效果</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;一打有 &lt;del&gt;二十&lt;/del&gt; &lt;ins&gt;十二&lt;/ins&gt; 件。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;大多数浏览器会改写为删除文本和下划线文本。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;一些老式的浏览器会把删除文本和下划线文本显示为普通文本。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio Code </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识HTML，HTML基本使用</title>
      <link href="/2024/12/23/html/%E8%AE%A4%E8%AF%86html/"/>
      <url>/2024/12/23/html/%E8%AE%A4%E8%AF%86html/</url>
      
        <content type="html"><![CDATA[<h1 id="入门HTML"><a href="#入门HTML" class="headerlink" title="入门HTML"></a>入门HTML</h1><h2 id="在VSCode创建HTML文件"><a href="#在VSCode创建HTML文件" class="headerlink" title="在VSCode创建HTML文件"></a>在VSCode创建HTML文件</h2><h3 id="打开-VSCode："><a href="#打开-VSCode：" class="headerlink" title="打开 VSCode："></a>打开 VSCode：</h3><blockquote><p>如果你还没有打开 VSCode，首先启动它。</p></blockquote><h3 id="创建新文件："><a href="#创建新文件：" class="headerlink" title="创建新文件："></a>创建新文件：</h3><blockquote><p>你可以通过点击界面左上角的“文件”菜单，然后选择“新建文件”来创建一个新文件。<br>或者，你可以使用快捷键 Ctrl + N（在 Windows&#x2F;Linux 上）或 Cmd + N（在 macOS 上）来快速创建一个新文件。</p></blockquote><h3 id="保存文件为-HTML："><a href="#保存文件为-HTML：" class="headerlink" title="保存文件为 HTML："></a>保存文件为 HTML：</h3><blockquote><p>在创建新文件后，你需要保存它。点击界面左上角的“文件”菜单，然后选择“保存”或者使用快捷键 Ctrl + S（在 Windows&#x2F;Linux 上）或 Cmd + S（在 macOS 上）。<br>在弹出的保存对话框中，选择你想要保存文件的位置，然后在文件名输入框中输入文件名，确保文件名以 .html 结尾（例如，example.html）。</p></blockquote><h3 id="开始编写-HTML："><a href="#开始编写-HTML：" class="headerlink" title="开始编写 HTML："></a>开始编写 HTML：</h3><blockquote><p>一旦文件被保存为 HTML 文件，你就可以开始编写 HTML 代码了。例如，一个基本的 HTML 页面结构如下：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用-HTML-模板："><a href="#使用-HTML-模板：" class="headerlink" title="使用 HTML 模板："></a>使用 HTML 模板：</h3><blockquote><p>VSCode 支持通过快捷方式创建文件模板。你可以安装一个名为 “HTML Snippets” 的扩展来快速生成 HTML 文件的基本结构。</p></blockquote><h3 id="保存并预览："><a href="#保存并预览：" class="headerlink" title="保存并预览："></a>保存并预览：</h3><blockquote><p>编写完 HTML 代码后，保存文件。你可以通过右键点击编辑器中的文件并选择“在浏览器中打开”来预览你的 HTML 页面，或者直接使用浏览器打开保存的 HTML 文件。</p></blockquote><h1 id="HTML基础标签"><a href="#HTML基础标签" class="headerlink" title="HTML基础标签"></a>HTML基础标签</h1><p><img src="/img%5Cyouxin%5Chtmljc.png"></p><h1 id="HTML基础属性"><a href="#HTML基础属性" class="headerlink" title="HTML基础属性"></a>HTML基础属性</h1><p><img src="/img%5Cyouxin%5Chtmlsx.png"></p>]]></content>
      
      
      <categories>
          
          <category> HTML基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio Code </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp什么是委托</title>
      <link href="/2024/12/14/csharp%E5%A7%94%E6%89%98/"/>
      <url>/2024/12/14/csharp%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp什么是委托"><a href="#Csharp什么是委托" class="headerlink" title="Csharp什么是委托"></a>Csharp什么是委托</h1><p>1.在C#中，委托（Delegate）是一种特殊的类型，它定义了方法的类型，使得可以将方法作为参数传递，或者将其赋值给变量。委托是实现事件和回调方法的基础。它们使得将方法作为对象进行操作成为可能，这在异步编程、事件处理和回调方法中非常有用。</p><p>2.委托的基本语法</p><blockquote><p>委托的定义类似于接口，但它专门用于方法。下面是一个委托的基本定义：</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Operation</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>这个Operation委托类型可以持有任何接受两个int参数并返回一个int的方法。</p></blockquote><p>3.使用委托</p><blockquote><p>定义委托：首先定义一个委托类型。<br>实例化委托：创建委托的实例，并将其与具体的方法关联。<br>调用委托：通过委托实例调用方法。</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Operation</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现委托的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MathOperations</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Subtract</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MathOperations math = <span class="keyword">new</span> MathOperations();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化委托</span></span><br><span class="line">        Operation op = <span class="keyword">new</span> Operation(math.Add);</span><br><span class="line">        <span class="built_in">int</span> result = op(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用委托，等同于math.Add(5, 3)</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Add: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改变委托关联的方法</span></span><br><span class="line">        op = math.Subtract;</span><br><span class="line">        result = op(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用委托，等同于math.Subtract(5, 3)</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Subtract: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.多播委托</p><blockquote><p>C#中的委托还支持多播，即一个委托可以关联多个方法。当委托被调用时，关联的所有方法都会按顺序被调用。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">HelloDelegate</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Greeting</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hello</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Goodbye</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Goodbye, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        HelloDelegate hello = <span class="keyword">new</span> HelloDelegate(<span class="keyword">new</span> Greeting().Hello);</span><br><span class="line">        hello += <span class="keyword">new</span> Greeting().Goodbye; <span class="comment">// 添加另一个方法</span></span><br><span class="line"></span><br><span class="line">        hello(<span class="string">&quot;World&quot;</span>); <span class="comment">// 输出: Hello, World 和 Goodbye, World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.委托与事件</p><blockquote><p>委托是实现事件的基础。在C#中，事件是一种特殊的多播委托，用于发布订阅模式，允许对象通知其他对象发生了某个事件。</p></blockquote><p>6.总结</p><blockquote><p>委托提供了一种将方法作为参数传递的强大机制，它们是实现回调、事件和异步编程的关键。通过委托，你可以编写更加灵活和动态的代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp枚举类型学习笔记</title>
      <link href="/2024/12/14/csharp%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/12/14/csharp%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp枚举类型"><a href="#Csharp枚举类型" class="headerlink" title="Csharp枚举类型"></a>Csharp枚举类型</h1><p>1.C# 中的枚举（Enum）是一种特殊的值类型，它允许你为一组相关的常量定义一个名称。枚举是一种强类型的常量集合，这意味着每个枚举成员都有一个名称和一个底层的整数值。默认情况下，第一个枚举成员的值是0，每个随后的成员的值比前一个成员的值大1。</p><p>2.下面是枚举的一些基本用法：</p><blockquote><p>定义枚举</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> DaysOfWeek</span><br><span class="line">&#123;</span><br><span class="line">    Sunday,</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用枚举</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DaysOfWeek today = DaysOfWeek.Friday;</span><br><span class="line">Console.WriteLine(today); <span class="comment">// 输出：Friday</span></span><br></pre></td></tr></table></figure><blockquote><p>访问枚举成员的值</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> dayValue = (<span class="built_in">int</span>)today;</span><br><span class="line">Console.WriteLine(dayValue); <span class="comment">// 输出：4</span></span><br></pre></td></tr></table></figure><blockquote><p>枚举的底层类型<br>你可以指定枚举的底层类型，比如 byte、sbyte、short、ushort、int、uint、long 或 ulong。如果不指定，默认是 int。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> DaysOfWeek : <span class="built_in">byte</span></span><br><span class="line">&#123;</span><br><span class="line">    Sunday,</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>枚举成员的显式值<br>你也可以为枚举成员指定显式的值。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> DaysOfWeek</span><br><span class="line">&#123;</span><br><span class="line">    Sunday = <span class="number">1</span>,</span><br><span class="line">    Monday = <span class="number">2</span>,</span><br><span class="line">    Tuesday = <span class="number">3</span>,</span><br><span class="line">    Wednesday = <span class="number">4</span>,</span><br><span class="line">    Thursday = <span class="number">5</span>,</span><br><span class="line">    Friday = <span class="number">6</span>,</span><br><span class="line">    Saturday = <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>枚举与switch语句<br>枚举类型经常与 switch 语句一起使用。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (today)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> DaysOfWeek.Sunday:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sunday is the first day of the week.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DaysOfWeek.Monday:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Monday is the second day of the week.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ... 其他情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>检查枚举成员是否存在<br>你可以使用 Enum.IsDefined 方法来检查一个值是否是枚举中的一个有效成员。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isDefined = Enum.IsDefined(<span class="keyword">typeof</span>(DaysOfWeek), <span class="number">8</span>);</span><br><span class="line">Console.WriteLine(isDefined); <span class="comment">// 输出：False</span></span><br></pre></td></tr></table></figure><blockquote><p>枚举是C#中一个非常有用的功能，它可以让你的代码更加清晰和易于维护。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp结构体介绍及使用学习笔记</title>
      <link href="/2024/12/14/csharp%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2024/12/14/csharp%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp结构体介绍"><a href="#Csharp结构体介绍" class="headerlink" title="Csharp结构体介绍"></a>Csharp结构体介绍</h1><p>1.在C#中，结构体是一种值类型，用于封装少量的数据。结构体使用 struct 关键字定义，并且可以包含数据字段、方法、属性、索引器、运算符重载和构造函数。结构体不能继承其他的结构体或类，也不能被其他结构体或类继承。以下是结构体的一些基本特性：</p><p>2.定义结构体：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.实例化结构体：</p><blockquote><p>结构体可以通过直接声明或使用 new 关键字来实例化。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p1 = <span class="keyword">new</span> Point();</span><br><span class="line">Point p2 = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>4.结构体是值类型：</p><blockquote><p>结构体是值类型，所以当它们被赋值给另一个变量时，它们的值会被复制。</p></blockquote><p>5.方法和属性：</p><blockquote><p>结构体可以包含方法和属性，就像类一样。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Rectangle</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Length;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Area</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> Length * Width; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintArea</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Area: <span class="subst">&#123;Area&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.运算符重载：</p><blockquote><p>结构体可以重载运算符，以提供自定义的操作。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Vector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Vector <span class="keyword">operator</span> +(Vector a, Vector b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector(a.X + b.X, a.Y + b.Y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.结构体与类的区别：</p><blockquote><p>结构体是值类型，而类是引用类型。<br>结构体默认继承自 System.ValueType，而类默认继承自 System.Object。<br>结构体不能有析构函数，而类可以。<br>结构体不能实现接口，而类可以。</p></blockquote><p>8.装箱和拆箱：</p><blockquote><p>当结构体被赋值给一个对象类型（比如 object 或接口类型）时，会发生装箱操作，将值类型转换为引用类型。相反的操作称为拆箱。</p></blockquote><blockquote><p>使用结构体时，通常是为了创建轻量级的、不可变的数据结构，或者当你需要确保数据被复制而不是引用时。</p></blockquote><h1 id="Csharp结构体函数"><a href="#Csharp结构体函数" class="headerlink" title="Csharp结构体函数"></a>Csharp结构体函数</h1><p>1.在C#中，结构体（struct）是一种值类型，它可以用来定义轻量级的数据结构。结构体可以包含数据字段、属性、方法和构造函数等。以下是一些关于C#结构体中函数的基本示例：</p><p>2.结构体定义</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintCoordinates</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;(<span class="subst">&#123;X&#125;</span>, <span class="subst">&#123;Y&#125;</span>)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写ToString方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;Point(<span class="subst">&#123;X&#125;</span>, <span class="subst">&#123;Y&#125;</span>)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.使用结构体</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">p.PrintCoordinates(); <span class="comment">// 输出: (10, 20)</span></span><br><span class="line">Console.WriteLine(p.ToString()); <span class="comment">// 输出: Point(10, 20)</span></span><br></pre></td></tr></table></figure><p>4.结构体与方法</p><blockquote><p>构造函数：用于初始化结构体的字段。<br>方法：可以定义方法来执行特定的操作，比如上面的PrintCoordinates方法。<br>属性：使用get和set块来定义属性，允许外部代码以属性的方式访问结构体的字段。<br>重写方法：可以重写如ToString等方法，以提供结构体的自定义字符串表示。</p></blockquote><p>5.结构体的值类型特性</p><blockquote><p>结构体是值类型，赋值和参数传递时会复制整个结构体。<br>结构体不能被继承，但可以实现接口。<br>结构体默认有Equals、GetHashCode和ToString方法，但通常需要根据需要重写这些方法。</p></blockquote><p>6.结构体与类的区别</p><blockquote><p>类是引用类型，而结构体是值类型。<br>类可以继承其他类，而结构体不能继承其他结构体或类。<br>结构体的字段默认为private，而类的字段默认为private。</p></blockquote><blockquote><p>这些是C#中结构体和函数的基本用法。根据具体需求，你可以在结构体中定义更多复杂的逻辑和方法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp递归的调用、常量学习笔记</title>
      <link href="/2024/12/13/csharp%E9%80%92%E5%BD%92%E3%80%81%E5%B8%B8%E9%87%8F/"/>
      <url>/2024/12/13/csharp%E9%80%92%E5%BD%92%E3%80%81%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp递归函数练习"><a href="#Csharp递归函数练习" class="headerlink" title="Csharp递归函数练习"></a>Csharp递归函数练习</h1><h3 id="1-2！-3！-···-10！"><a href="#1-2！-3！-···-10！" class="headerlink" title="1+2！+3！+···+10！"></a>1+2！+3！+···+10！</h3><p>利用多少个方法计算结果</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">F1</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> result = n * F1(n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">F2</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> result = F2(n - <span class="number">1</span>) + F1(n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(F2(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 输出结果：<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4037913</span></span><br></pre></td></tr></table></figure></p><h1 id="有关系式1-1-2-2-3-3-···-K-K"><a href="#有关系式1-1-2-2-3-3-···-K-K" class="headerlink" title="有关系式1^1+2^2+3^3+···+K^K&lt;2000,编一个程序，求出满足此关系式的最大值"></a>有关系式1^1+2^2+3^3+···+K^K&lt;2000,编一个程序，求出满足此关系式的最大值</h1><blockquote><p>利用递归和循环解决这个问题</p></blockquote><p>1.循环：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result += k * k;</span><br><span class="line">        <span class="keyword">if</span> (result &gt;= <span class="number">2000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p>2.递归：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">F</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> result = F(n - <span class="number">1</span>) + n * n;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(F(i) &gt;= <span class="number">2000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 输出结果：<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure></p><h1 id="什么是常量"><a href="#什么是常量" class="headerlink" title="什么是常量"></a>什么是常量</h1><ol><li>在C#中，常量是一种特殊的变量，其值在初始化后不能被改变。常量用于存储那些在程序运行期间不应该改变的数据。</li><li>以下是C#中常量的几个关键点：</li></ol><blockquote><p>声明：使用const关键字来声明常量。<br>类型：常量必须有明确的类型，通常是基本数据类型，如int、double、string等。<br>初始化：常量在声明时必须被初始化，且之后不能被重新赋值。<br>作用域：常量的作用域取决于其声明的位置，可以是局部的（在方法或代码块中）或全局的（在类或命名空间中）。<br>编译时常数：编译器在编译时会将常量的值内嵌到代码中，这意味着它们在运行时是不可变的。</p></blockquote><h3 id="下面是一个C-中声明和使用常量的例子："><a href="#下面是一个C-中声明和使用常量的例子：" class="headerlink" title="下面是一个C#中声明和使用常量的例子："></a>下面是一个C#中声明和使用常量的例子：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConstantsExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明一个常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> MaxValue = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用常量</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The maximum value is: &quot;</span> + MaxValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ConstantsExample example = <span class="keyword">new</span> ConstantsExample();</span><br><span class="line">        example.Display();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试修改常量值将导致编译错误</span></span><br><span class="line">        <span class="comment">// ConstantsExample.MaxValue = 200; // 错误：无法对只读字段“ConstantsExample.MaxValue”赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，MaxValue是一个常量，它被声明为const，并且初始化为100。在Display方法中，我们使用这个常量来打印信息。尝试修改MaxValue的值将导致编译错误，因为常量在初始化后不能被改变。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp函数的重载学习笔记</title>
      <link href="/2024/12/12/csharp%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
      <url>/2024/12/12/csharp%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp函数的重载-Overload"><a href="#Csharp函数的重载-Overload" class="headerlink" title="Csharp函数的重载-Overload"></a>Csharp函数的重载-Overload</h1><p>1.在C#中，函数重载（Function Overloading）是指在同一个类中可以定义多个同名函数，只要它们的参数列表不同即可。参数列表不同可以是参数的类型不同、参数的数量不同，或者是两者都不同。函数重载使得函数名可以保持一致，同时能够根据传入的参数执行不同的操作。</p><p>2.以下是函数重载的几个要点：</p><blockquote><p>1.函数名相同：重载的函数必须在同一个类中，并且函数名相同。<br>2.参数列表不同：参数列表必须在数量或者类型上有所不同。<br>3.返回类型无关：函数的返回类型不影响重载，即使两个函数返回类型不同，只要参数列表相同，它们就不是重载。<br>4.访问修饰符无关：函数的访问修饰符（如public、private等）不影响重载。</p></blockquote><p>3.下面是一个简单的C#函数重载的例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MathOperations</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 重载函数，无参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数，一个int参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数，两个int参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数，一个double参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，Add 函数被重载了四次，每次的参数列表都不同。这使得调用者可以根据需要传入不同数量或类型的参数，并执行相应的操作。</p></blockquote><blockquote><p>需要注意的是，C#编译器在调用函数时，会根据传入参数的类型和数量来决定调用哪个重载版本。如果存在多个匹配的重载版本，编译器将选择最具体的一个。如果没有匹配的重载版本，或者存在多个同样具体的版本，编译器将报错。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp递归的调用学习笔记</title>
      <link href="/2024/12/12/csharp%E9%80%92%E5%BD%92%E7%9A%84%E8%B0%83%E7%94%A8/"/>
      <url>/2024/12/12/csharp%E9%80%92%E5%BD%92%E7%9A%84%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp方法的递归调用"><a href="#Csharp方法的递归调用" class="headerlink" title="Csharp方法的递归调用"></a>Csharp方法的递归调用</h1><p>1.在C#中，递归调用是一种方法自己调用自己的技术。递归可以用来解决那些可以分解成相似子问题的问题，比如树的遍历、排序算法（如快速排序、归并排序）等。递归方法通常有两个主要部分：递归终止条件和递归工作部分。</p><p>2.下面是一个简单的递归方法的例子，这个方法用来计算一个数的阶乘：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number = <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">int</span> result = Factorial(number);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The factorial of &quot;</span> + number + <span class="string">&quot; is &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Factorial</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归工作部分</span></span><br><span class="line">        <span class="keyword">return</span> n * Factorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在这个例子中，Factorial 方法计算一个整数 n 的阶乘。递归终止条件是当 n 小于或等于1时，因为1的阶乘是1，这是计算的基本情况。递归工作部分是方法调用自己，但是每次都将 n 减少1，直到达到基本情况。</p><p>4.使用递归时需要注意以下几点：</p><blockquote><p>递归终止条件：必须有一个明确的终止条件来防止无限递归。<br>递归工作部分：每次递归调用都应该向终止条件靠近。<br>性能问题：递归可能会导致较大的内存开销，因为每次递归调用都会在调用栈上增加一层。对于深度递归，可能会导致栈溢出错误。<br>尾递归优化：在某些编程语言中，尾递归可以被优化以减少内存使用。但在C#中，编译器并不自动优化尾递归。<br>在实际编程中，递归是一种强大的工具，但需要谨慎使用，以避免性能问题和栈溢出错误。对于可以递归解决的问题，有时候使用迭代方法（循环）可能是一个更好的选择。</p></blockquote><h1 id="递归函数—求阶乘"><a href="#递归函数—求阶乘" class="headerlink" title="递归函数—求阶乘"></a>递归函数—求阶乘</h1><h2 id="1-10的阶乘"><a href="#1-10的阶乘" class="headerlink" title="1.10的阶乘"></a>1.10的阶乘</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">F</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> result=n * F(n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(F(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp方法的参数和返回值学习笔记</title>
      <link href="/2024/12/10/csharp%E5%8F%82%E6%95%B0/"/>
      <url>/2024/12/10/csharp%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp方法的参数和返回值学习笔记"><a href="#Csharp方法的参数和返回值学习笔记" class="headerlink" title="Csharp方法的参数和返回值学习笔记"></a>Csharp方法的参数和返回值学习笔记</h1><p><font size='5'>1.在C#中，方法（Method）是类或结构体中定义的，用来执行特定任务的代码块。方法可以有参数（Parameter），也可以有返回值（Return Value）。下面分别介绍方法的参数和返回值：</font></p><h3 id="方法的参数（Parameter）"><a href="#方法的参数（Parameter）" class="headerlink" title="方法的参数（Parameter）"></a>方法的参数（Parameter）</h3><p>1.参数是传递给方法的值，用于控制方法的行为。参数定义在方法的声明中，位于方法名之后，括号()内部，参数之间用逗号分隔。</p><blockquote><p>位置参数：调用方法时，参数值按照定义的顺序传递。<br>命名参数：在调用方法时，可以指定参数名，使得代码更清晰。<br>可选参数：使用optional关键字定义，调用时可以省略。<br>参数数组：使用params关键字定义，允许传递不定数量的参数。<br>输出参数：使用out关键字定义，方法可以返回多个值。</p></blockquote><h3 id="方法的返回值（Return-Value）"><a href="#方法的返回值（Return-Value）" class="headerlink" title="方法的返回值（Return Value）"></a>方法的返回值（Return Value）</h3><p>1.返回值是方法执行完毕后返回给调用者的值。返回值的类型在方法声明中指定。</p><blockquote><p>返回类型：方法声明时指定的类型，如int、string等。<br>返回语句：使用return关键字，后面跟返回值。<br>无返回值：使用void关键字，表示方法不返回任何值。<br>隐式返回值：对于void方法，不需要return语句，方法执行完毕后自动返回。</p></blockquote><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 带参数和返回值的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b; <span class="comment">// 返回值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带可选参数的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"><span class="built_in">string</span> message = <span class="string">&quot;Hello&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数数组的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] names</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> name <span class="keyword">in</span> names)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带输出参数的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Calculate</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> result</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = <span class="number">42</span>; <span class="comment">// 输出参数赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，Add方法接受两个整数参数并返回它们的和；Display方法有一个可选参数；Print方法接受一个参数数组；Calculate方法有一个输出参数。</p><h1 id="Csharp方法中的参数数组学习笔记"><a href="#Csharp方法中的参数数组学习笔记" class="headerlink" title="Csharp方法中的参数数组学习笔记"></a>Csharp方法中的参数数组学习笔记</h1><p>1.在C#中，参数数组是一种特殊的数组，它允许你传递一个不定数量的参数给方法。参数数组使用params关键字来声明，它只能作为方法的最后一个参数，并且只能声明一次。</p><p>2.以下是使用参数数组的一些基本规则：</p><blockquote><p>使用params关键字：在方法的参数列表中，使用params关键字来声明参数数组。<br>类型限制：参数数组必须是方法的最后一个参数，并且只能有一个。<br>传递参数：你可以像传递普通数组一样传递参数数组，也可以传递单个参数，编译器会自动将它们包装成数组。</p></blockquote><h3 id="下面是一个使用参数数组的简单示例："><a href="#下面是一个使用参数数组的简单示例：" class="headerlink" title="下面是一个使用参数数组的简单示例："></a>下面是一个使用参数数组的简单示例：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PrintSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 传递多个参数</span></span><br><span class="line">        PrintSum(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;); <span class="comment">// 传递数组</span></span><br><span class="line">        PrintSum(<span class="number">1</span>); <span class="comment">// 传递单个参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintSum</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] numbers</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> numbers)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += number;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Sum: <span class="subst">&#123;sum&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，PrintSum方法可以接受任意数量的整数参数。你可以传递单个整数、一个整数数组，或者多个整数作为参数。</p><p>参数数组在内部实际上是一个数组，所以你可以像使用普通数组一样使用它，例如通过索引访问元素、使用Length属性获取元素数量等。</p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp函数定义和调用学习笔记学习笔记</title>
      <link href="/2024/12/08/csharp%E5%87%BD%E6%95%B0%E4%B8%80/"/>
      <url>/2024/12/08/csharp%E5%87%BD%E6%95%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp函数定义和调用学习笔记"><a href="#Csharp函数定义和调用学习笔记" class="headerlink" title="Csharp函数定义和调用学习笔记"></a>Csharp函数定义和调用学习笔记</h1><h3 id="在C-中，函数通常被称为方法（Method）。方法是一种执行特定任务的代码块，可以包含参数（输入值），并可以返回结果。以下是C-中方法的定义和调用的基本步骤："><a href="#在C-中，函数通常被称为方法（Method）。方法是一种执行特定任务的代码块，可以包含参数（输入值），并可以返回结果。以下是C-中方法的定义和调用的基本步骤：" class="headerlink" title="在C#中，函数通常被称为方法（Method）。方法是一种执行特定任务的代码块，可以包含参数（输入值），并可以返回结果。以下是C#中方法的定义和调用的基本步骤："></a>在C#中，函数通常被称为方法（Method）。方法是一种执行特定任务的代码块，可以包含参数（输入值），并可以返回结果。以下是C#中方法的定义和调用的基本步骤：</h3><p>1.方法的定义</p><blockquote><p>访问修饰符：定义方法的可见性（如public, private, protected等）。<br>返回类型：方法执行完毕后返回的数据类型。<br>方法名称：方法的名称，遵循C#的命名规则。<br>参数列表：方法需要的输入值，包括类型和名称，由圆括号包围。<br>方法体：包含方法逻辑的代码块，由大括号 {} 包围。</p></blockquote><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法，没有参数，返回一个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">SayHello</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法，有两个参数，返回一个整数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">AddNumbers</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.方法的调用</p><blockquote><p>要调用一个方法，你需要使用方法的名称，后面跟着一对圆括号，如果方法有参数，则在圆括号内传递相应的参数值。</p></blockquote><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用没有参数的方法</span></span><br><span class="line">        <span class="built_in">string</span> helloMessage = myClass.SayHello();</span><br><span class="line">        Console.WriteLine(helloMessage); <span class="comment">// 输出: Hello, World!</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用有参数的方法</span></span><br><span class="line">        <span class="built_in">int</span> result = myClass.AddNumbers(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        Console.WriteLine(result); <span class="comment">// 输出: 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.静态方法</p><blockquote><p>静态方法不依赖于类的实例，可以直接通过类名来调用。</p></blockquote><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Utility</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetGreeting</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Good morning!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 直接通过类名调用静态方法</span></span><br><span class="line">        <span class="built_in">string</span> greeting = Utility.GetGreeting();</span><br><span class="line">        Console.WriteLine(greeting); <span class="comment">// 输出: Good morning!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.重载方法</p><blockquote><p>你可以在同一个类中定义多个同名方法，只要它们的参数列表不同（参数的类型和&#x2F;或数量不同）。</p></blockquote><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 方法重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Calculate</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Calculate</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Calculator calc = <span class="keyword">new</span> Calculator();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> intResult = calc.Calculate(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Console.WriteLine(intResult); <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">double</span> doubleResult = calc.Calculate(<span class="number">1.5</span>, <span class="number">2.5</span>);</span><br><span class="line">        Console.WriteLine(doubleResult); <span class="comment">// 输出: 4.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上述示例中，Calculate 方法被重载了两次，一次接受两个整数参数，另一次接受两个双精度浮点数参数。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp字符串遍历编程题三学习笔记</title>
      <link href="/2024/12/05/csharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%E7%BC%96%E7%A8%8B%E9%A2%983/"/>
      <url>/2024/12/05/csharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%E7%BC%96%E7%A8%8B%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h1 id="输入是个不相等的正整数，输出这10个正整数中的第二大的数。"><a href="#输入是个不相等的正整数，输出这10个正整数中的第二大的数。" class="headerlink" title="输入是个不相等的正整数，输出这10个正整数中的第二大的数。"></a>输入是个不相等的正整数，输出这10个正整数中的第二大的数。</h1><p>样例输入<br>3 5 7 2 9 5 3 10 3 8<br>样例输出<br>9</p><p>分析：</p><blockquote><p>定义两个变量设置为第一大数，和第二大数</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">string</span>[] strArray = str.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[strArray.Length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; intArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number=Convert.ToInt32(strArray[i]);</span><br><span class="line">        intArray[i] = number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> max1 = <span class="number">0</span>, max2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; intArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (intArray[i] &gt; max1)</span><br><span class="line">        &#123;</span><br><span class="line">            max2 = max1;</span><br><span class="line">            max1=intArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intArray[i] &gt; max2)</span><br><span class="line">            &#123;</span><br><span class="line">                max2 = intArray[i];</span><br><span class="line">            &#125;                        </span><br><span class="line">        &#125;                              </span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;第一大数&quot;</span> + max1 + <span class="string">&quot;第二大数&quot;</span> + max2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">4</span> <span class="number">9</span> <span class="number">7</span> <span class="number">10</span></span><br><span class="line">第一大数<span class="number">10</span>第二大数<span class="number">9</span></span><br></pre></td></tr></table></figure><h1 id="描述给定一个只包含小写字母的字符串，请你找出第一个仅出现一次的字符。如果没有，输出no。"><a href="#描述给定一个只包含小写字母的字符串，请你找出第一个仅出现一次的字符。如果没有，输出no。" class="headerlink" title="描述给定一个只包含小写字母的字符串，请你找出第一个仅出现一次的字符。如果没有，输出no。"></a>描述给定一个只包含小写字母的字符串，请你找出第一个仅出现一次的字符。如果没有，输出no。</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">int</span>[] countArray= <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;str.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        countArray[str[i]-<span class="string">&#x27;a&#x27;</span>]=countArray[str[i]-<span class="string">&#x27;a&#x27;</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bool</span> isFind = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">char</span> c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;str.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (countArray[str[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            isFind = <span class="literal">true</span>;</span><br><span class="line">            c = str[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFind == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果：-1"><a href="#输出结果：-1" class="headerlink" title="输出结果："></a>输出结果：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">levvel</span><br><span class="line">no</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">level</span><br><span class="line">v</span><br></pre></td></tr></table></figure><h1 id="大小写字母转换"><a href="#大小写字母转换" class="headerlink" title="大小写字母转换"></a>大小写字母转换</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">int</span> cha = <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; str.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">char</span> c = (<span class="built_in">char</span>)(str[i] + cha);</span><br><span class="line">            Console.Write(c);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; cha &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">char</span> c = (<span class="built_in">char</span>)(str[i] - cha);</span><br><span class="line">            Console.Write(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果：-2"><a href="#输出结果：-2" class="headerlink" title="输出结果："></a>输出结果：</h3> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fjsdjfFLKSJ</span><br><span class="line">FJSDJFflksj</span><br></pre></td></tr></table></figure><h1 id="在一个数组中查找一个给定的值，输出第一次出现的位置-从一开始）"><a href="#在一个数组中查找一个给定的值，输出第一次出现的位置-从一开始）" class="headerlink" title="在一个数组中查找一个给定的值，输出第一次出现的位置(从一开始）"></a>在一个数组中查找一个给定的值，输出第一次出现的位置(从一开始）</h1><blockquote><p>输入：3 8 23 45 2 5<br> 23<br> 输出：3</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">string</span>[] strArray = str.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[strArray.Length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; intArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n=Convert.ToInt32(strArray[i]);</span><br><span class="line">        intArray[i] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> number=Convert.ToInt32(Console.ReadLine());</span><br><span class="line">    <span class="built_in">int</span> location = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i&lt; intArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (number == intArray[i])</span><br><span class="line">        &#123;</span><br><span class="line">            location = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果：-3"><a href="#输出结果：-3" class="headerlink" title="输出结果："></a>输出结果：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">76</span> <span class="number">3</span> <span class="number">67</span></span><br><span class="line"><span class="number">76</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp字符串遍历编程题二学习笔记</title>
      <link href="/2024/12/03/csharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%E7%BC%96%E7%A8%8B%E9%A2%982/"/>
      <url>/2024/12/03/csharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%E7%BC%96%E7%A8%8B%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp编程题判断合法标识符。"><a href="#Csharp编程题判断合法标识符。" class="headerlink" title="Csharp编程题判断合法标识符。"></a>Csharp编程题判断合法标识符。</h1><p>1.输入一个字符串，判断其是否是c#的合法标识符。<br>2.分析：</p><blockquote><p>判断字符串是否不是是数字、字母（大小写）、下划线。<br>判断是否是数字开头（数字开头不是合法标识符）</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">bool</span> isRight = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; str.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((str[i] &lt; <span class="string">&#x27;0&#x27;</span> || str[i]&gt;<span class="string">&#x27;9&#x27;</span>)&amp;&amp;(str[i] &lt; <span class="string">&#x27;a&#x27;</span> || str[i]&gt;<span class="string">&#x27;z&#x27;</span>)&amp;&amp; (str[i] &lt; <span class="string">&#x27;A&#x27;</span> || str[i] &gt; <span class="string">&#x27;Z&#x27;</span>) &amp;&amp; (str[i] != <span class="string">&#x27;_&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            isRight = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;str[<span class="number">0</span>]&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        isRight=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRight)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;是合法字符&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;不是合法字符&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHFKHFRjgjidgj12</span><br><span class="line">是合法字符</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>JHSJFjlfjsd</span><br><span class="line">不是合法字符</span><br></pre></td></tr></table></figure><h1 id="Csharp编程题-回文串。"><a href="#Csharp编程题-回文串。" class="headerlink" title="Csharp编程题-回文串。"></a>Csharp编程题-回文串。</h1><p>1.“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。请写一个程序判断读入的字符串是否是“回文”。<br>2.分析：</p><blockquote><p>如果字符串是偶数的话，假如8&#x2F;2&#x3D;4，遍历0-3。如果是奇数的话，7&#x2F;2&#x3D;3，遍历0-2<br>假设字符串是8，那么索引对应的是0-7、1-6、2-5···，i对应的倒数length-1-i。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str = Console.ReadLine();</span><br><span class="line">    <span class="built_in">bool</span> ha = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; str.Length / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] != str[str.Length - <span class="number">1</span> - i])</span><br><span class="line">        &#123;</span><br><span class="line">            ha = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ha)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;是回文串&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;不是回文串&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 3.输出结果：<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> level</span><br><span class="line">是回文串</span><br></pre></td></tr></table></figure></p><h1 id="Csharp编程题-查找最长连续次数"><a href="#Csharp编程题-查找最长连续次数" class="headerlink" title="Csharp编程题-查找最长连续次数"></a>Csharp编程题-查找最长连续次数</h1><p>1.收集了连续N（1&lt;N&lt;10000000)天的最高气温数据。现在他想知道气温一直上升的最长连续天数。<br>样例输入：1 3 5 | 2 3 5 7 8 | 6 9<br>样例输出：5<br>2.分析：</p><blockquote><p>判断前面的数字是否比后面小<br>如果后面的连续最高天数比后面的连续天数高则更新一下。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">string</span>[] strArray = str.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">int</span>[] ints= <span class="keyword">new</span> <span class="built_in">int</span>[strArray.Length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ints.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number=Convert.ToInt32(strArray[i]);</span><br><span class="line">        ints[i]=number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> maxDays = <span class="number">0</span>;<span class="comment">//记录最高气温连续升高的天数</span></span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">1</span>;<span class="comment">//记录气温连续升高的天数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; ints.Length<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ints[i] &lt; ints[i + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; maxDays)</span><br><span class="line">            &#123;</span><br><span class="line">                maxDays = count;</span><br><span class="line">            &#125;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxDays)</span><br><span class="line">        &#123;</span><br><span class="line">            maxDays = count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;最高气温连续升高的最长天数&quot;</span> + maxDays);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp字符串遍历编程题学习笔记</title>
      <link href="/2024/12/01/csharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
      <url>/2024/12/01/csharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp字符串遍历编程题学习笔记"><a href="#Csharp字符串遍历编程题学习笔记" class="headerlink" title="Csharp字符串遍历编程题学习笔记"></a>Csharp字符串遍历编程题学习笔记</h1><p>1.输入n(n&lt;100)个数，找出其中最小的数，将它与最前面的数交换后输出这些数。</p><p>2.分析：</p><blockquote><p>1.先获取字符串（string str&#x3D;Console.ReadLine()）<br>2.字符串数组通过空格进行输入，使用string[] strArray&#x3D;str.Split(‘ ‘);<br>3.字符串转换整型,声明int[] intArray&#x3D;new int[strArray.Length];使用for循环转换赋值。<br>4.假设（索引）0最小int min&#x3D;intArray[0];那最小值和后面的索引进行比较，int一个变量进行存储最小值。<br>5.找到最小值和假设的进行位置交换，int一个临时变量进行存储（索引0），在把最小值放在（索引0）里面，然后再将临时变量放在最小值里面。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">string</span>[] strArray = str.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">int</span>[] intArray= <span class="keyword">new</span> <span class="built_in">int</span>[strArray.Length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; strArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number=Convert.ToInt32(strArray[i]);</span><br><span class="line">        intArray[i] = number; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> min = intArray[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; intArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (intArray[i] &lt; min)</span><br><span class="line">        &#123;</span><br><span class="line">            min = intArray[i];</span><br><span class="line">            minIndex = i;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> temp=intArray[<span class="number">0</span>];</span><br><span class="line">    intArray[<span class="number">0</span>] = intArray[minIndex];</span><br><span class="line">    intArray[minIndex] = temp;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="built_in">int</span> t <span class="keyword">in</span> intArray)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(t+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">54</span> <span class="number">56</span> <span class="number">32</span> <span class="number">42</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">54</span> <span class="number">56</span> <span class="number">32</span> <span class="number">42</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="排序-系统方法"><a href="#排序-系统方法" class="headerlink" title="排序-系统方法"></a>排序-系统方法</h2><p>1.编写一个控制台程序，要求用户输入一组数字空格间隔，，对用户输入的数字从小到大输出。</p><p>2.分析：</p><blockquote><p>可以用系统方法做出来（Array.Sort）</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">string</span>[] strArray = str.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">int</span>[] intArray= <span class="keyword">new</span> <span class="built_in">int</span>[strArray.Length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; intArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number=Convert.ToInt32(strArray[i]);</span><br><span class="line">        intArray[i]=number;</span><br><span class="line">    &#125;</span><br><span class="line">    Array.Sort(intArray);</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="built_in">int</span> i <span class="keyword">in</span> intArray)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp编程题学习笔记</title>
      <link href="/2024/11/30/csharp%E7%BC%96%E7%A8%8B%E9%A2%983/"/>
      <url>/2024/11/30/csharp%E7%BC%96%E7%A8%8B%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp编程题学习笔记"><a href="#Csharp编程题学习笔记" class="headerlink" title="Csharp编程题学习笔记"></a>Csharp编程题学习笔记</h1><h2 id="1-c-三个可乐可以换一瓶可乐，现再有364瓶可乐，问一共可以和多少瓶可乐，剩下几个空瓶"><a href="#1-c-三个可乐可以换一瓶可乐，现再有364瓶可乐，问一共可以和多少瓶可乐，剩下几个空瓶" class="headerlink" title="1.c#三个可乐可以换一瓶可乐，现再有364瓶可乐，问一共可以和多少瓶可乐，剩下几个空瓶"></a>1.c#三个可乐可以换一瓶可乐，现再有364瓶可乐，问一共可以和多少瓶可乐，剩下几个空瓶</h2><p>2.分析：</p><blockquote><p>1.这个问题可以通过循环来解决，每次循环计算出可以换到的可乐瓶数和剩下的空瓶数，直到剩下的空瓶数不足以换到一瓶可乐为止。<br>2.首先，我们有364瓶可乐，每3个空瓶可以换1瓶可乐。我们可以通过以下步骤来计算：<br>•以换到的可乐瓶数：364除以3，得到121瓶可乐，余数为1个空瓶。<br>•在我们有121瓶可乐和1个空瓶，总共122个空瓶。<br>•次计算可以换到的可乐瓶数：122除以3，得到40瓶可乐，余数为2个空瓶。<br>•在我们有40瓶可乐和2个空瓶，总共42个空瓶。<br>•再次计算可以换到的可乐瓶数：42除以3，得到14瓶可乐，余数为0个空瓶。<br>•现在我们有14瓶可乐和0个空瓶，总共14个空瓶。<br>•再次计算可以换到的可乐瓶数：14除以3，得到4瓶可乐，余数为2个空瓶。<br>•现在我们有4瓶可乐和2个空瓶，总共6个空瓶。<br>•再次计算可以换到的可乐瓶数：6除以3，得到2瓶可乐，余数为0个空瓶。<br>•现在我们有2瓶可乐和0个空瓶，总共2个空瓶。<br>•再次计算可以换到的可乐瓶数：2除以3，得到0瓶可乐，余数为2个空瓶。<br>•所以，总共可以换到的可乐瓶数为：121 + 40 + 14 + 4 + 2 &#x3D; 181瓶，最后剩下2个空瓶。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> pingNumber = <span class="number">364</span>;</span><br><span class="line">    <span class="built_in">int</span> heNumber = <span class="number">364</span>;</span><br><span class="line">    <span class="keyword">while</span> (pingNumber &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        heNumber += pingNumber / <span class="number">3</span>;</span><br><span class="line">        pingNumber = (pingNumber / <span class="number">3</span>) + (pingNumber % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;一共可以喝&quot;</span>+heNumber+<span class="string">&quot;,剩下&quot;</span>+pingNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一共可以喝<span class="number">545</span>,剩下<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="编写一个应用程序来输入的字符串进行加密，对于字母字符串加密规则如下："><a href="#编写一个应用程序来输入的字符串进行加密，对于字母字符串加密规则如下：" class="headerlink" title="编写一个应用程序来输入的字符串进行加密，对于字母字符串加密规则如下："></a>编写一个应用程序来输入的字符串进行加密，对于字母字符串加密规则如下：</h2><p>‘a’→’d’,’x’→’a’,’A’→’D’,’X’→’A’,<br>1.分析：</p><blockquote><p>字符是循环+3。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">char</span>[] strArray= str.ToCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; strArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((strArray[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; strArray[i] &lt;= <span class="string">&#x27;z&#x27;</span>) || (strArray[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; strArray[i] &lt;= <span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            strArray[i] = (<span class="built_in">char</span>)(strArray[i] + <span class="number">3</span>);<span class="comment">//&#x27;a&#x27;+3 97+3=100=&#x27;d&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (strArray[i] &gt; <span class="string">&#x27;z&#x27;</span> &amp;&amp; strArray[i] &lt;= <span class="string">&#x27;z&#x27;</span> + <span class="number">3</span>)<span class="comment">//zyx</span></span><br><span class="line">            &#123;</span><br><span class="line">                strArray[i] = (<span class="built_in">char</span>)(strArray[i] - <span class="number">26</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (strArray[i] &gt; <span class="string">&#x27;Z&#x27;</span> &amp;&amp; strArray[i] &lt;= <span class="string">&#x27;Z&#x27;</span> + <span class="number">3</span>)<span class="comment">//XYZ</span></span><br><span class="line">            &#123;</span><br><span class="line">                strArray[i]= (<span class="built_in">char</span>)(strArray[i] - <span class="number">26</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">char</span> temp <span class="keyword">in</span> strArray)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(temp+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp什么是数组，数组的遍历笔记</title>
      <link href="/2024/11/29/csharp%E6%95%B0%E7%BB%84/"/>
      <url>/2024/11/29/csharp%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h1><p>1.数组是一种常用的数据结构，用于存储同一类型的多个值。在编程中，数组可以被看作是一个容器，其中包含了固定数量的元素，这些元素通常是相同类型的数据。以下是数组的一些基本特性：</p><blockquote><p>1.元素类型一致：数组中的所有元素都是同一数据类型的，比如整数、浮点数、字符等。<br>2.连续存储：数组的元素在内存中是连续存放的，这意味着它们拥有连续的内存地址。<br>3.索引访问：可以通过索引（通常是从0开始的整数）来访问数组中的元素。例如，如果有一个名为arr的数组，那么可以通过arr[0]来访问第一个元素，arr[1]来访问第二个元素，以此类推。<br>4.固定大小：在某些编程语言中，数组的大小是固定的，一旦声明，其长度就不能改变。而在其他语言中，如Python的列表，数组的大小是动态的，可以根据需要增长和缩小。<br>5.遍历：可以遍历数组中的所有元素，通常使用循环结构（如for循环）来实现。<br>6.操作：数组支持多种操作，如查找、插入、删除、排序等。</p></blockquote><h2 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h2><blockquote><p>类型[] 数组名；<br>数组名遵守变量命名规则</p></blockquote><h2 id="数组的赋值"><a href="#数组的赋值" class="headerlink" title="数组的赋值"></a>数组的赋值</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] ages=&#123;<span class="number">46</span>,<span class="number">45</span>,<span class="number">3</span>,<span class="number">53</span>,<span class="number">5</span>,<span class="number">2</span>&#125;</span><br><span class="line">ages=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>]；</span><br><span class="line">ages=<span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">76</span>,<span class="number">8</span>&#125;</span><br><span class="line">ages=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">6</span>]&#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">42</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的使用（修改和读取）"><a href="#数组的使用（修改和读取）" class="headerlink" title="数组的使用（修改和读取）"></a>数组的使用（修改和读取）</h2><p>通过索引（下标），索引从0开始。<br>可以把数组想象成一个火车，一个车厢里面存储的就是数据元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//声明int类型的数据</span><br><span class="line">       int[] ages=&#123;46,45,3,53,5,2&#125;</span><br><span class="line">//数组的数据有下标   0  1  2 3  4 5</span><br><span class="line">//数组名[索引]</span><br><span class="line">age[index]</span><br></pre></td></tr></table></figure><blockquote><p>注意：不能访问索引不存在的值</p></blockquote><h1 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h1><blockquote><p>1.声明一个int的数组，数组大小为9<br>2.声明一个char的数组，数组长度为20<br>3.声明一个float数组，数组长度为5<br>4.声明一个字符串数组，数组长度为8</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] inta = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">9</span>];</span><br><span class="line"><span class="built_in">char</span>[] chara=<span class="keyword">new</span> <span class="built_in">char</span>[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">float</span>[] floata = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">string</span>[] stringa = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">8</span>];</span><br></pre></td></tr></table></figure><h1 id="这么遍历一个数组？（正序和倒序）"><a href="#这么遍历一个数组？（正序和倒序）" class="headerlink" title="这么遍历一个数组？（正序和倒序）"></a>这么遍历一个数组？（正序和倒序）</h1><blockquote><p>遍历就是取得数组中的每一个值<br> 遍历索引-通过索引访问元素</p></blockquote><p> 1.通过for和while遍历一个数组<br> 2.通过foreach遍历一个数组</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> int[] ages = &#123; 23, 45, 67, 12, 34, 56, 8, 34, 23, 3 &#125;;</span><br><span class="line">for(int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(ages[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] ages = &#123; 23, 45, 67, 12, 34, 56, 8, 34, 23, 3 &#125;;</span><br><span class="line">for(int i = 9; i&gt;=0; i--)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(ages[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在我们不知道数组的长度时可以用ages.Length获取ages的长度。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">int</span>[] ages = &#123; <span class="number">23</span>, <span class="number">45</span>, <span class="number">67</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">8</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;ages.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(ages[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int[] ages = &#123; 23, 45, 67, 12, 34, 56, 8, 34, 23, 3 &#125;;</span><br><span class="line">int i = 0;</span><br><span class="line">while (i &lt; 10)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(ages[i]+&quot; &quot;);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">```CSHARP倒序</span><br><span class="line">int[] ages = &#123; 23, 45, 67, 12, 34, 56, 8, 34, 23, 3 &#125;;</span><br><span class="line">int i = 9;</span><br><span class="line">while (i &gt;= 0)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(ages[i]+&quot; &quot;);</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><blockquote><p>在C#中，foreach 循环是一种简洁且高效的方式来遍历数组、集合或任何实现了 IEnumerable 或 IEnumerable<T>接口的对象。foreach 循环会自动处理迭代过程，你只需要关注每个元素的处理逻辑。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">int</span>[] ages = &#123; <span class="number">23</span>, <span class="number">45</span>, <span class="number">67</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">8</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> age <span class="keyword">in</span> ages)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(age+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp基本数据类型—浮点型，类型转换学习笔记</title>
      <link href="/2024/11/27/csharp%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2/"/>
      <url>/2024/11/27/csharp%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp基本数据类型：浮点型"><a href="#Csharp基本数据类型：浮点型" class="headerlink" title="Csharp基本数据类型：浮点型"></a>Csharp基本数据类型：浮点型</h1><blockquote><p>浮点数值类型表示实数。 所有浮点型数值类型均为值类型。 它们还是简单类型，可以使用文本进行初始化。 所有浮点数值类型都支持算术、比较和相等运算符。</p></blockquote><h2 id="浮点类型的特征"><a href="#浮点类型的特征" class="headerlink" title="浮点类型的特征"></a>浮点类型的特征</h2><p><img src="/img%5Cfudianxing.png"></p><p>1.浮点数在计算机中是以IEEE 754标准来存储的，这意味着它们可以表示非常大或非常小的数，并且可以表示非整数。</p><p>2.以下是一些关于C#浮点型的重要点：</p><blockquote><p>浮点数的精度是有限的，因此在进行浮点数运算时可能会出现精度损失。<br>浮点数可以表示正数、负数和零。<br>浮点数也可以表示特殊值，如正无穷(double.PositiveInfinity)、负无穷(double.NegativeInfinity)和NaN（不是一个数字，double.NaN）。<br>在比较浮点数时，应该使用一定的容差来判断两个数是否“相等”，因为直接比较可能会因为精度问题导致不准确的结果。<br>浮点数的舍入模式可以通过Math.Round方法或者MidpointRounding枚举来控制。<br>使用浮点型时，需要考虑到这些特性和限制，以确保程序的正确性和健壮性。</p></blockquote><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>1.在C#中，转义字符是一种特殊的字符序列，以反斜杠（\）开始，用来表示那些不能直接表示的字符或者具有特殊含义的字符。以下是一些常用的转义字符：</p><blockquote><p>1.换行符（\n）：插入一个新行。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(&quot;Hello,\nWorld!&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>2.回车符（\r）：将光标移动到当前行的开头。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(&quot;Hello,\rWorld!&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>3.制表符（\t）：插入一个水平制表符（Tab）。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(&quot;Hello,\tWorld!&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>4.反斜杠（\）：表示一个实际的反斜杠字符。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string path = &quot;C:\\Program Files\\Example&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>5.单引号（&#39;）：表示一个单引号字符。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string text = &quot;He&#x27;s the one.&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>6.双引号（&quot;）：表示一个双引号字符。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string text = &quot;He said \&quot;Hello\&quot; to me.&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>7.问号（?）：表示一个问号字符。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string text = &quot;What&#x27;s this?&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>8.空字符（\0）：表示一个空字符（null character）。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string text = &quot;Hello\0World&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>9.Unicode转义序列（\uXXXX 或 \UXXXXXXXX）：表示一个Unicode字符，其中XXXX是四位十六进制数，XXXXXXXX是八位十六进制数。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string text = &quot;\u00A9&quot;; // © symbol</span><br><span class="line">string text = &quot;\U0001F600&quot;; // 😀 emoji</span><br></pre></td></tr></table></figure><blockquote><p>10.八进制转义序列（\XXX）：表示一个ASCII字符，其中XXX是三位八进制数。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string text = &quot;\7&quot;; // 表示ASCII码为7的字符，即BEL（响铃）字符</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp基本数据类型—整型学习笔记</title>
      <link href="/2024/11/26/csharp%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/26/csharp%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp基本数据类型：整型"><a href="#Csharp基本数据类型：整型" class="headerlink" title="Csharp基本数据类型：整型"></a>Csharp基本数据类型：整型</h1><blockquote><p>整型数值类型 表示整数。 所有的整型数值类型均为值类型。 它们还是简单类型，可以使用文本进行初始化。 所有整型数值类型都支持算术、位逻辑、比较和相等运算符。</p></blockquote><p>1.C# 支持以下预定义整型类型：<br><img src="/img%5Czhengxing.png"></p><h2 id="在C-中，整数数据类型分为有符号和无符号两种，它们的主要区别在于值的范围和是否包含负数。"><a href="#在C-中，整数数据类型分为有符号和无符号两种，它们的主要区别在于值的范围和是否包含负数。" class="headerlink" title="在C#中，整数数据类型分为有符号和无符号两种，它们的主要区别在于值的范围和是否包含负数。"></a>在C#中，整数数据类型分为有符号和无符号两种，它们的主要区别在于值的范围和是否包含负数。</h2><p>1.有符号整数（Signed Integers）：</p><blockquote><p>可以表示正数、负数和零。<br>常见的有符号整数类型包括：<br>sbyte：8位有符号整数，范围从 -128 到 127。<br>short：16位有符号整数，范围从 -32,768 到 32,767。<br>int：32位有符号整数，范围从 -2,147,483,648 到 2,147,483,647。<br>long：64位有符号整数，范围从 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。</p></blockquote><p>2.无符号整数（Unsigned Integers）：</p><blockquote><p>只能表示正数和零，不能表示负数。<br>常见的无符号整数类型包括：<br>byte：8位无符号整数，范围从 0 到 255。<br>ushort：16位无符号整数，范围从 0 到 65,535。<br>uint：32位无符号整数，范围从 0 到 4,294,967,295。<br>ulong：64位无符号整数，范围从 0 到 18,446,744,073,709,551,615。</p></blockquote><p>3.区别：</p><blockquote><p>值的范围：无符号整数类型的值范围从0开始，而有符号整数类型的值范围则包括负数。<br>内存占用：相同位数的有符号和无符号整数占用的内存大小是相同的，但是无符号整数可以表示更大的正数值。<br>溢出行为：当整数运算结果超出其类型所能表示的范围时，会发生溢出。有符号整数溢出时可能会变成一个负数，而无符号整数溢出时会从0开始循环。<br>默认值：有符号整数类型的默认值是0，而无符号整数类型的默认值也是0。<br>使用场景：有符号整数通常用于需要表示正负值的场景，而无符号整数通常用于计数器、索引、数组长度等只能取非负值的场景。<br>在实际编程中，选择使用有符号还是无符号整数类型，应根据具体的应用场景和需求来决定。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp循环嵌套基本用法学习笔记</title>
      <link href="/2024/11/25/csharp%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/"/>
      <url>/2024/11/25/csharp%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-循环嵌套的基本用法"><a href="#1-循环嵌套的基本用法" class="headerlink" title="1.循环嵌套的基本用法"></a>1.循环嵌套的基本用法</h1><blockquote><p>C# 中的循环嵌套是指在一个循环内部再包含另一个循环。这种结构通常用于处理多维数组或需要多级迭代的情况。以下是一些常见的循环嵌套示例，包括 for 循环和 foreach 循环的嵌套。</p></blockquote><p><font size="5">1.输入两个整数n和m,输出n行m列的*阵</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> n=Convert.ToInt32 (Console.ReadLine());</span><br><span class="line"><span class="built_in">int</span> m=Convert.ToInt32 (Console.ReadLine());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><font size="5">输出结果：</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p><font size="5">2.输入整数n,输出n层的三角形</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> n=Convert.ToInt32 (Console.ReadLine());</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write (<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="5">输出结果：</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br><span class="line">******</span><br></pre></td></tr></table></figure><p><font size="5">3.输入整数n,输出n层的三角形的斜边。</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> n=Convert.ToInt32 (Console.ReadLine());</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i<span class="number">-1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="5">输出结果：</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line">*</span><br><span class="line"> *</span><br><span class="line">  *</span><br><span class="line">   *</span><br><span class="line">    *</span><br><span class="line">     *</span><br></pre></td></tr></table></figure><p><font size="5">4.如果我们要让它反过来呢？.输入整数n。</font></p><blockquote><p>1.前面的题我们都是从小到大开始遍历，而这次是从大到小遍历。<br>2.因为是从大到小第一个for循环初始化i&#x3D;n;i&gt;0;i–;</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> n=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i<span class="number">-1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="5">输出结果：</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line">     *</span><br><span class="line">    *</span><br><span class="line">   *</span><br><span class="line">  *</span><br><span class="line"> *</span><br><span class="line">*</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp循环嵌套九九乘法表、买鸡和最大公约数笔记</title>
      <link href="/2024/11/25/csharp%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
      <url>/2024/11/25/csharp%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp编程题，九九乘法表和百文买鸡问题"><a href="#Csharp编程题，九九乘法表和百文买鸡问题" class="headerlink" title="Csharp编程题，九九乘法表和百文买鸡问题"></a>Csharp编程题，九九乘法表和百文买鸡问题</h1><p>1.使用嵌套循环写出九九乘法表<br>分析：</p><blockquote><p>1.选择for语句进行嵌套循环<br> 2.最外层循环9次，子循环递增到9次</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            console.Write(<span class="string">&quot;&#123;0&#125;*&#123;1&#125;=&#123;2&#125;&quot;</span>,j,i,i*j);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 输出结果：<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> * <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> * <span class="number">2</span> = <span class="number">2</span>   <span class="number">2</span> * <span class="number">2</span> = <span class="number">4</span></span><br><span class="line"><span class="number">1</span> * <span class="number">3</span> = <span class="number">3</span>   <span class="number">2</span> * <span class="number">3</span> = <span class="number">6</span>   <span class="number">3</span> * <span class="number">3</span> = <span class="number">9</span></span><br><span class="line"><span class="number">1</span> * <span class="number">4</span> = <span class="number">4</span>   <span class="number">2</span> * <span class="number">4</span> = <span class="number">8</span>   <span class="number">3</span> * <span class="number">4</span> = <span class="number">12</span>   <span class="number">4</span> * <span class="number">4</span> = <span class="number">16</span></span><br><span class="line"><span class="number">1</span> * <span class="number">5</span> = <span class="number">5</span>   <span class="number">2</span> * <span class="number">5</span> = <span class="number">10</span>   <span class="number">3</span> * <span class="number">5</span> = <span class="number">15</span>   <span class="number">4</span> * <span class="number">5</span> = <span class="number">20</span>   <span class="number">5</span> * <span class="number">5</span> = <span class="number">25</span></span><br><span class="line"><span class="number">1</span> * <span class="number">6</span> = <span class="number">6</span>   <span class="number">2</span> * <span class="number">6</span> = <span class="number">12</span>   <span class="number">3</span> * <span class="number">6</span> = <span class="number">18</span>   <span class="number">4</span> * <span class="number">6</span> = <span class="number">24</span>   <span class="number">5</span> * <span class="number">6</span> = <span class="number">30</span>   <span class="number">6</span> * <span class="number">6</span> = <span class="number">36</span></span><br><span class="line"><span class="number">1</span> * <span class="number">7</span> = <span class="number">7</span>   <span class="number">2</span> * <span class="number">7</span> = <span class="number">14</span>   <span class="number">3</span> * <span class="number">7</span> = <span class="number">21</span>   <span class="number">4</span> * <span class="number">7</span> = <span class="number">28</span>   <span class="number">5</span> * <span class="number">7</span> = <span class="number">35</span>   <span class="number">6</span> * <span class="number">7</span> = <span class="number">42</span>   <span class="number">7</span> * <span class="number">7</span> = <span class="number">49</span></span><br><span class="line"><span class="number">1</span> * <span class="number">8</span> = <span class="number">8</span>   <span class="number">2</span> * <span class="number">8</span> = <span class="number">16</span>   <span class="number">3</span> * <span class="number">8</span> = <span class="number">24</span>   <span class="number">4</span> * <span class="number">8</span> = <span class="number">32</span>   <span class="number">5</span> * <span class="number">8</span> = <span class="number">40</span>   <span class="number">6</span> * <span class="number">8</span> = <span class="number">48</span>   <span class="number">7</span> * <span class="number">8</span> = <span class="number">56</span>   <span class="number">8</span> * <span class="number">8</span> = <span class="number">64</span></span><br><span class="line"><span class="number">1</span> * <span class="number">9</span> = <span class="number">9</span>   <span class="number">2</span> * <span class="number">9</span> = <span class="number">18</span>   <span class="number">3</span> * <span class="number">9</span> = <span class="number">27</span>   <span class="number">4</span> * <span class="number">9</span> = <span class="number">36</span>   <span class="number">5</span> * <span class="number">9</span> = <span class="number">45</span>   <span class="number">6</span> * <span class="number">9</span> = <span class="number">54</span>   <span class="number">7</span> * <span class="number">9</span> = <span class="number">63</span>   <span class="number">8</span> * <span class="number">9</span> = <span class="number">72</span>   <span class="number">9</span> * <span class="number">9</span> = <span class="number">81</span></span><br></pre></td></tr></table></figure><br>2.用100文买一百只鸡，其中公鸡，母鸡，都必须要有，公鸡3文一只，母鸡5文一只，小鸡2文一只，请问公鸡、母鸡、小鸡要买多少只刚好凑齐100文。<br>1.要求：每种鸡都要有且有几种买法。<br>2.分析：</p><blockquote><p>通过三层循环来遍历所有可能的公鸡、母鸡和小鸡的组合，以找到满足条件的解决方案。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> roosters=<span class="number">1</span>;roosters&lt;=<span class="number">100</span>/<span class="number">3</span>;roosters++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> hen = <span class="number">1</span>; hen &lt;= <span class="number">100</span> / <span class="number">5</span>; hen++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> pullet=<span class="number">1</span>; pullet&lt;=<span class="number">100</span> / <span class="number">2</span>; pullet++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((roosters * <span class="number">3</span> + hen * <span class="number">5</span> + pullet * <span class="number">2</span>) == <span class="number">100</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;公鸡：&#123;0&#125;，母鸡：&#123;1&#125;，小鸡：&#123;2&#125;&quot;</span>,roosters,hen,pullet);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>3.输入两个整数num1和num2,输出这两个正整数num1和num2的最大公约数。<br>1.分析：</p><blockquote><p>1.什么是最大公约数:两个或多个 整数 共有 约数 中最大的一个。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> num1=Convert.ToInt32(Console.ReadLine());</span><br><span class="line">    <span class="built_in">int</span> num2=Convert.ToInt32(Console.ReadLine());</span><br><span class="line">    <span class="built_in">int</span> min = num1;</span><br><span class="line">    <span class="keyword">if</span>(num2 &lt; min)</span><br><span class="line">    &#123;</span><br><span class="line">        min = num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = min; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 % i == <span class="number">0</span> &amp;&amp; num2 % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;最大公约数&quot;</span>+i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp认识新的类Random学习笔记</title>
      <link href="/2024/11/25/%E8%AE%A4%E8%AF%86%E6%96%B0%E7%9A%84%E7%B1%BBRandom/"/>
      <url>/2024/11/25/%E8%AE%A4%E8%AF%86%E6%96%B0%E7%9A%84%E7%B1%BBRandom/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp简单认识Random类"><a href="#Csharp简单认识Random类" class="headerlink" title="Csharp简单认识Random类"></a>Csharp简单认识Random类</h1><p>1.定义</p><blockquote><p>表示伪随机数生成器，这是一种能够产生满足某些随机性统计要求的数字序列的算法。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Random</span></span><br></pre></td></tr></table></figure><p>2.示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Random rd = <span class="keyword">new</span> Random();</span><br><span class="line">    Console.WriteLine(rd.Next(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>随机1到10；</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h2><p>1.随机，循环，才对停止循环。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Random rd = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="built_in">int</span> number=rd.Next(<span class="number">1</span>,<span class="number">101</span>);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> numberUser=Convert.ToInt32(Console.ReadLine());</span><br><span class="line">        <span class="keyword">if</span> (numberUser &gt; number)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;你猜大了&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numberUser&lt;number)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;你猜小了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numberUser==number)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;你猜对了&quot;</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p> 输出结果：(随机，结果不唯一)<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">20</span></span><br><span class="line">你猜大了</span><br><span class="line"><span class="number">50</span></span><br><span class="line">你猜大了</span><br><span class="line"><span class="number">10</span></span><br><span class="line">你猜对了</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp笔记各种循环编程题二。</title>
      <link href="/2024/11/24/csharp%E7%BC%96%E7%A8%8B%E9%A2%982/"/>
      <url>/2024/11/24/csharp%E7%BC%96%E7%A8%8B%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h1 id="1-编写一共程序，打印出所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位数字立方等于该数本身。"><a href="#1-编写一共程序，打印出所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位数字立方等于该数本身。" class="headerlink" title="1.编写一共程序，打印出所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位数字立方等于该数本身。"></a>1.编写一共程序，打印出所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位数字立方等于该数本身。</h1><p>1.要求：例如153&#x3D;1<em>1</em>1+5<em>5</em>5+3<em>3</em>3，所以153是“水仙花”。</p><p>2.输入153</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">100</span>; i &lt;= <span class="number">999</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> ge = i % <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">int</span> shi = (i / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">int</span> bai = i / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == ge * ge * ge + shi * shi * shi + bai * bai * bai)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">370</span></span><br><span class="line"><span class="number">371</span></span><br><span class="line"><span class="number">407</span></span><br></pre></td></tr></table></figure><h1 id="随机一个未知的整数，去除这个整数各个位上的0，形成新的数，并输出。"><a href="#随机一个未知的整数，去除这个整数各个位上的0，形成新的数，并输出。" class="headerlink" title="随机一个未知的整数，去除这个整数各个位上的0，形成新的数，并输出。"></a>随机一个未知的整数，去除这个整数各个位上的0，形成新的数，并输出。</h1><p>1.要求：输入的数字n大于0，小于1000000。</p><p>2.输入2020</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a= Convert.ToInt32(Console.ReadLine()); <span class="comment">//2020</span></span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> cheng = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(a != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = a % <span class="number">10</span>;<span class="comment">//0 202 //2 20//0 2 //2</span></span><br><span class="line">    <span class="keyword">if</span>(i != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i *= cheng; <span class="comment">//2 //2</span></span><br><span class="line">        sum+= i;<span class="comment">//2 //2</span></span><br><span class="line">        cheng *= <span class="number">10</span>;<span class="comment">//20 //20</span></span><br><span class="line">    &#125;</span><br><span class="line">    a = a / <span class="number">10</span>; <span class="comment">//2 //2</span></span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(sum); <span class="comment">//22</span></span><br></pre></td></tr></table></figure><p>3.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure><h1 id="随机数入一个整数num-输出一个新的数，新数恰好与原数每一位上的数字相反（如果原数末尾有多个零，输出的新数高位不含0）"><a href="#随机数入一个整数num-输出一个新的数，新数恰好与原数每一位上的数字相反（如果原数末尾有多个零，输出的新数高位不含0）" class="headerlink" title="随机数入一个整数num,输出一个新的数，新数恰好与原数每一位上的数字相反（如果原数末尾有多个零，输出的新数高位不含0）"></a>随机数入一个整数num,输出一个新的数，新数恰好与原数每一位上的数字相反（如果原数末尾有多个零，输出的新数高位不含0）</h1><p>1.样例输入8736 输出6378<br>  样例输入2300 输出32</p><p>  2.输入8736</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> num=Convert.ToInt32(Console.ReadLine());<span class="comment">//8736</span></span><br><span class="line"><span class="built_in">bool</span> yudao = <span class="literal">false</span>; <span class="comment">//默认还没有遇到第一个非0</span></span><br><span class="line"><span class="keyword">while</span> (num!=<span class="number">0</span>) <span class="comment">//从第到高位遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = num % <span class="number">10</span>; <span class="comment">//6 873</span></span><br><span class="line">    <span class="comment">//判断是否遇到了第一个非0数字</span></span><br><span class="line">    <span class="comment">//已经遇到了第一个非0数字</span></span><br><span class="line">    <span class="comment">//不需要去掉0了</span></span><br><span class="line">    <span class="comment">//还没有遇到第一个非0数字</span></span><br><span class="line">    <span class="comment">//去掉</span></span><br><span class="line">    <span class="keyword">if</span> (yudao == <span class="literal">false</span>)<span class="comment">//还没有遇到第一个非0数字</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>)<span class="comment">//i=6</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i);</span><br><span class="line">            <span class="comment">//标志位，标志是否达到了某个条件</span></span><br><span class="line">            yudao= <span class="literal">true</span>;<span class="comment">//确定i!=0时，停止判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">else</span><span class="comment">//i=3</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i);</span><br><span class="line">        &#125;</span><br><span class="line">    num = num / <span class="number">10</span>;<span class="comment">//8736 873</span></span><br></pre></td></tr></table></figure><p>  3.输出结果<br>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6378</span></span><br></pre></td></tr></table></figure></p><h1 id="回文数和倒序读都是一样的整数。输入一个数，判断是否是回文数。输入的整数大于0，小于1000000。"><a href="#回文数和倒序读都是一样的整数。输入一个数，判断是否是回文数。输入的整数大于0，小于1000000。" class="headerlink" title="回文数和倒序读都是一样的整数。输入一个数，判断是否是回文数。输入的整数大于0，小于1000000。"></a>回文数和倒序读都是一样的整数。输入一个数，判断是否是回文数。输入的整数大于0，小于1000000。</h1><p>  1.要求：如果是回文输出yes，不是输出no。<br>  2.输入2397<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">int</span> n=Convert.ToInt32(Console.ReadLine());<span class="comment">//2992</span></span><br><span class="line"><span class="built_in">int</span> tempN = n;</span><br><span class="line"><span class="built_in">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (tempN != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = tempN % <span class="number">10</span>;<span class="comment">//2 299  //9 29 //9 2 //2</span></span><br><span class="line">    number *= <span class="number">10</span>;<span class="comment">//0*10=0 //20 //290 //2990</span></span><br><span class="line">    number += i;<span class="comment">//2 //29 //299 //2992</span></span><br><span class="line">    tempN = tempN / <span class="number">10</span>;<span class="comment">//299 //29 //2 //0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (number == n)</span><br><span class="line">&#123;</span><br><span class="line">   Console.WriteLine(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp笔记各种循环编程题一。</title>
      <link href="/2024/11/22/csharp%E7%BC%96%E7%A8%8B%E9%A2%981/"/>
      <url>/2024/11/22/csharp%E7%BC%96%E7%A8%8B%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h1 id="1-一个球从某一高度落下，每次落地后反跳回原来高度的一半，再落下。"><a href="#1-一个球从某一高度落下，每次落地后反跳回原来高度的一半，再落下。" class="headerlink" title="1.一个球从某一高度落下，每次落地后反跳回原来高度的一半，再落下。"></a>1.一个球从某一高度落下，每次落地后反跳回原来高度的一半，再落下。</h1><p>1.要求：球第十次反弹多高？在第十次落地时，共经过多少米？<br>2.要求：输入球的初始高度，输出反弹多高，和经过了多少米。</p><p>3.分析：</p><blockquote><p>1.我们可以用int n来确定球的从多高往下弹。<br>    2.再利用for循环来求出球体的第十次反弹多高和经过了多少米<br>    3.可以用double来定义high存储第十次的高，因为反弹是原来的一半，for的表达式：high&#x2F;&#x3D;2;。<br>    4.再用double来定义distance存储反弹的和，2*n来确定第一次谈的高，因为反弹是原来的一半<br>    第2个for的表达式：distance&#x2F;&#x3D;2;。</p></blockquote><p>4.输入100。</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> n=Convert.ToInt32 (Console.ReadLine());</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> high = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    high /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine (high);</span><br><span class="line"><span class="built_in">double</span> distance = <span class="number">2</span> * n;</span><br><span class="line"><span class="built_in">double</span> sum = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i= <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    distance /= <span class="number">2</span>;</span><br><span class="line">    sum += distance;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine (sum);</span><br></pre></td></tr></table></figure><p> 5.输出结果：<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0.09765625</span></span><br><span class="line"><span class="number">299.609375</span></span><br></pre></td></tr></table></figure></p><h1 id="2-输入一个整数a，和一个正整数n，计算乘方a的次方"><a href="#2-输入一个整数a，和一个正整数n，计算乘方a的次方" class="headerlink" title="2.输入一个整数a，和一个正整数n，计算乘方a的次方"></a>2.输入一个整数a，和一个正整数n，计算乘方a的次方</h1><p>1.要求：使用循环来计算a的次方。</p><p>2.分析：</p><blockquote><p>1.用int a和n。在double来定义一个变量sum来存储a的次方，再利用for循环来判断次方大小。for循环表达式：sum*&#x3D;n;</p></blockquote><p>3.输入a&#x3D;5,n&#x3D;5</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;           </span><br><span class="line">    <span class="built_in">int</span> a = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">    <span class="built_in">int</span> n = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">    <span class="built_in">double</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum *= n;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(sum);</span><br></pre></td></tr></table></figure><p>4.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3125</span></span><br></pre></td></tr></table></figure><h1 id="3-我国现有x亿人口，按每年0-1-的增长速度，n年后将有多少人？"><a href="#3-我国现有x亿人口，按每年0-1-的增长速度，n年后将有多少人？" class="headerlink" title="3.我国现有x亿人口，按每年0.1%的增长速度，n年后将有多少人？"></a>3.我国现有x亿人口，按每年0.1%的增长速度，n年后将有多少人？</h1><p>1.要求：使用循环求n年后有多少人。</p><p>2.分析：</p><blockquote><p>1.人口是用数字统计，我们可用double定义一个值，在int nian定义过了多少年。<br>2.用for循环，表达式：rankou*&#x3D;1.001;</p></blockquote><p>3.输入rankou&#x3D;120000,nian&#x3D;12</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line"><span class="built_in">double</span> rankou = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"> <span class="built_in">int</span> nian = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nian; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     rankou *= <span class="number">1.001</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> Console.WriteLine(rankou);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 4.输出结果：<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">121447.94645949498</span></span><br></pre></td></tr></table></figure></p><h1 id="投资，已知投资的复合利率为R-0到20之间的整数-。投M钱（100到1000000之间的整数）。投资Y年（范围0到400）。"><a href="#投资，已知投资的复合利率为R-0到20之间的整数-。投M钱（100到1000000之间的整数）。投资Y年（范围0到400）。" class="headerlink" title="投资，已知投资的复合利率为R(0到20之间的整数)。投M钱（100到1000000之间的整数）。投资Y年（范围0到400）。"></a>投资，已知投资的复合利率为R(0到20之间的整数)。投M钱（100到1000000之间的整数）。投资Y年（范围0到400）。</h1><p> 1.要求：投资共赚多少钱？</p><p> 2.分析：</p><blockquote><p>1.复合利率给我们的范围是0到20之间，我就取10好了，复合利率是10除100就是它的复合利率。<br>2.用double来第一变量R、M、Y,和sum来存储答案。</p></blockquote><p>3.输入R&#x3D;10，M&#x3D;50000，Y&#x3D;20</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="built_in">double</span> R=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="built_in">double</span> M=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="built_in">double</span> Y=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="built_in">double</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;Y;i++)</span><br><span class="line">&#123;</span><br><span class="line">    M *= (R / <span class="number">100.0</span>) + <span class="number">1</span>;</span><br><span class="line">    sum += M;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3150124.972129084</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程题：用循环做出挖掘数字并计算和（笔记）</title>
      <link href="/2024/11/20/csharp%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%8F%96/"/>
      <url>/2024/11/20/csharp%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1-挖掘数字，并并计算这些数字的和"><a href="#1-挖掘数字，并并计算这些数字的和" class="headerlink" title="1.挖掘数字，并并计算这些数字的和"></a><font size="8"><b>1.挖掘数字，并并计算这些数字的和</font></b></h1><blockquote><p>知识点：<br>1.如何读取一个字符输入<br>2.输入缓冲区<br>3.break跳出循环</p></blockquote><p><font size="5"><b>1.数字和字符混合在一起了，作为一个优秀的挖掘人员，把输入的数字挖出来并计算这些数字的和，并输出。输入以@作为结束。 样例输入23a34b34@  样例输出19</p><blockquote><p>只学到循环如何做出这道难题</fotn></b></p></blockquote><p><font size="5"><b>2.分析：</fotn></b></p><blockquote><p>1.这题我们可以用ASCII码来做，用char输出字符。<br>2。用if来判断是否是数字。<br>在int定义一个变量来存储和</p></blockquote><p><font size="5">3.输入值：234SKHF23@</fotn></b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> c;</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    c = (<span class="built_in">char</span>)Console.Read();</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        sum += number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (c != <span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">Console.WriteLine(sum);</span><br></pre></td></tr></table></figure><p><font size="5">4.输出结果：</fotn></b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">234</span>SKHF23@</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><h1 id="什么是缓冲区"><a href="#什么是缓冲区" class="headerlink" title="什么是缓冲区"></a><font size="8"><b>什么是缓冲区</font></b></h1><blockquote><p>在C#中，缓冲区通常指的是一块内存区域，用于临时存储数据。缓冲区在处理I&#x2F;O操作（如文件读写、网络通信等）时非常有用，因为它们可以减少实际的I&#x2F;O操作次数，提高性能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量的作用域</title>
      <link href="/2024/11/19/%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2024/11/19/%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="C-变量里的作用域"><a href="#C-变量里的作用域" class="headerlink" title="C#变量里的作用域"></a><font size="8">C#变量里的作用域</font></b></h1><p><font size="6">一.什么是作用域</font></b></p><blockquote><p>作用域（Scope）是编程中的一个基本概念，它定义了代码中变量、函数、类等实体的可见性和生命周期。作用域决定了在程序的哪些部分可以访问或修改这些实体。</p></blockquote><p><font size="6">二.C#变量作用域中一些关键点</font></b></p><p>1.局部作用域是指在编程中，变量或函数仅在定义它们的特定代码块或区域内可见和可访问的作用域。这种作用域通常与局部变量和局部函数相关联，它们只在创建它们的函数、方法或代码块内部有效。以下是局部作用域的一些关键特点：</p><p>定义位置：局部变量或函数通常在函数、方法或代码块内部定义。</p><p>可见性：局部变量或函数只在定义它们的函数、方法或代码块内部可见。一旦代码执行离开了这个区域，局部变量或函数就不再可访问。</p><p>生命周期：局部变量的生命周期通常与定义它们的函数或代码块的执行周期相同。当函数或代码块执行结束时，局部变量会被销毁，占用的内存会被释放。</p><p>初始化：在某些编程语言中，局部变量在使用前必须被初始化，否则可能会引发错误或警告。</p><p>同名变量：在不同的函数或代码块中可以定义同名的局部变量，它们是独立的，互不影响。</p><p>参数传递：当函数或方法被调用时，实参的值会被复制到对应的局部变量（形参）中，局部变量的修改不会影响实参的值，除非使用了引用传递或指针。</p><p>作用域链：在支持闭包的语言中，局部变量可以被嵌套函数访问，形成作用域链。</p><p>重用性：局部变量的名称可以在不同的函数或代码块中重复使用，因为它们的作用域是独立的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Main方法开始执行&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 定义一个局部变量</span></span><br><span class="line">            <span class="built_in">int</span> localVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// localVar仅在这个代码块内部可见</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;局部变量的值: &quot;</span> + localVar);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这个点，localVar不再存在，因为它的作用域已经结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在C#中，全局作用域的概念与传统的全局变量有所不同。C#是一种面向对象的编程语言，它鼓励封装和模块化，因此并不直接支持传统意义上的全局变量。然而，可以通过以下几种方式来实现全局可访问的数据：</p><blockquote><p>静态成员变量和静态属性：<br>在C#中，可以通过静态类和静态成员来模拟全局变量的效果。静态成员属于类本身，而不是类的任何特定实例。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">csharp</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Global</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> GlobalValue = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在程序的任何地方都可以这样访问</span></span><br><span class="line"><span class="built_in">int</span> <span class="keyword">value</span> = Global.GlobalValue;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for语句学习笔记</title>
      <link href="/2024/11/12/for%E8%AF%AD%E5%8F%A5/"/>
      <url>/2024/11/12/for%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="for循环笔记"><a href="#for循环笔记" class="headerlink" title="for循环笔记"></a><font size="8"></b>for循环笔记</font></b></h1><blockquote><p>for循环输出执行循环次数<br>for(初始化；条件表达式；增量表达式)<br>{  &#x2F;&#x2F;循环体<br>}</p></blockquote><p><b><font size="5">1.fot循环的基本结构</font></b></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b><font size="5">2.fot语句的元素</font></b></p><blockquote><p>“初始化表达式”部分仅在进入循环前执行一次。 通常，在该部分中声明并初始化局部循环变量。 不能从 for 语句外部访问声明的变量。</p></blockquote><p>上例中的“初始化表达式”部分声明并初始化整数计数器变量：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>“条件”部分确定是否应执行循环中的下一个迭代。 如果计算结果为 true 或不存在，则执行下一个迭代；否则退出循环。 “条件”部分必须为布尔表达式。</p></blockquote><p>上例中的“条件”条件部分检查计数器值是否小于 10：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i&lt;<span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p>“迭代器”部分定义循环主体的每次执行后将执行的操作。</p></blockquote><p>上例中的“迭代器”部分增加计数器：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i++</span><br></pre></td></tr></table></figure><blockquote><p>循环体，必须是一个语句或一个语句块。</p></blockquote><h2 id="用for循环进行简单的计算"><a href="#用for循环进行简单的计算" class="headerlink" title="用for循环进行简单的计算"></a><font size="7">用for循环进行简单的计算</font></h2><p><font size="5"><b>1.进行计算整数1-100的和<font></b></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>;i&lt;<span class="number">101</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i; </span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(sum);</span><br><span class="line">                          </span><br></pre></td></tr></table></figure><p><font size="5"></b>2.求1-100的偶数</font></b></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>;i&lt;<span class="number">101</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="5"><b>3.输入俩个整数n和m，计算n和m（包括n和m)所有能被17整除的数的和，并输出和。</font></b> </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> n=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="built_in">int</span> m=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="built_in">int</span> i = n; i &lt;= m; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (i % <span class="number">17</span> == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         sum += i;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> Console.WriteLine(sum);</span><br></pre></td></tr></table></figure><p> <font size="5"><b>4.输入俩个整数n和m，利用for循环打印出n和m之间（包含n和m），所用的奇数和所用的偶数。<br> 奇数放一行，用空格分割。偶数放一行，用空格分割。</font></b></p><blockquote><p>应为要同时输出奇数和偶数，我们可以先定义俩个字符串(string)进行存储。<br> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">int</span> n=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="built_in">int</span> m=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="built_in">string</span> oddNumbers = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> numbered = <span class="string">&quot;&quot;</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="built_in">int</span> i = n; i &lt;= m; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         oddNumbers += i+<span class="string">&quot; &quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         numbered += i+<span class="string">&quot; &quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> Console.WriteLine(oddNumbers);</span><br><span class="line"> Console.WriteLine(numbered);</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a><font size="8"><b>break语句</font></b></h2><blockquote><p>break 语句：将终止最接近的封闭迭代语句（即 for、foreach、while 或 do 循环）或 switch 语句。 break 语句将控制权转交给已终止语句后面的语句</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( ; ; )</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine( i );</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>while循环语句</title>
      <link href="/2024/11/10/while%E8%AF%AD%E5%8F%A5/"/>
      <url>/2024/11/10/while%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a><font size="8"></b>while循环语句</font></b></h1><blockquote><p>在指定的布尔表达式的计算结果为 true 时，while 语句会执行一条语句或一个语句块。 由于在每次执行循环之前都会计算此表达式，所以 while 循环会执行零次或多次。</p></blockquote><h2 id="while语句基本结构"><a href="#while语句基本结构" class="headerlink" title="while语句基本结构"></a><font size="5"><b>while语句基本结构</font></b></h2><p><img src="/img%5Cyouxin%5Cwhile1.png"><br><b>1.while语句基本用法</b></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int x = 1;</span><br><span class="line">while (x&lt;10)    //条件判断</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(x);</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(&quot;x&gt;10&quot;);   //条件不满足，执行代码</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="while循环求和"><a href="#while循环求和" class="headerlink" title="while循环求和"></a><font size="5"><b>while循环求和</font></b></h2><p><b>1.控制循环次数？循环1-100。</b></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x=1;</span><br><span class="line">while(x&lt;100)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(x);</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>2.用while就1-100的整数和</b><br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> //第一种方式//局限性、固定的循环次数</span><br><span class="line"> int a = 1;</span><br><span class="line">int sum = 0;    //存放和</span><br><span class="line">while (a &lt; 101)</span><br><span class="line">&#123;</span><br><span class="line">    sum += a;  //sun=sum+a</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(sum);</span><br><span class="line"></span><br><span class="line">//第二种方式//可以设置你像输出的循环次数</span><br><span class="line"> int n=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"> int a = 1;</span><br><span class="line"> int sum = 0;</span><br><span class="line"> while (a &lt; n+1)</span><br><span class="line"> &#123;</span><br><span class="line">     sum += a;</span><br><span class="line">     a++;</span><br><span class="line"> &#125;</span><br><span class="line"> Console.WriteLine(sum);</span><br></pre></td></tr></table></figure><br><b>3.输出1-100的偶数</b></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int n = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">int a = 1;</span><br><span class="line">while (a &lt; n+1)</span><br><span class="line">&#123;</span><br><span class="line">    if (a % 2 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(a);</span><br><span class="line">    &#125;</span><br><span class="line">    a++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><b>4.输入俩个整数n1,n2,输出n1-n2之间所有的偶数</b></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int n1=Convert.ToInt32(Console.ReadLine());</span><br><span class="line">int n2=Convert.ToInt32(Console.ReadLine());</span><br><span class="line">while (n1 &lt; n2 + 1)</span><br><span class="line">&#123;</span><br><span class="line">    if (n1 % 2 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(n1);</span><br><span class="line">    &#125;</span><br><span class="line">    n1++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>5.3n+1:对于任意大于1的自然数n，若n为奇数，将n编程3n+1，否则变成n的一半。经过若干次这样的变化，n一定会最终变成1，比如，7→22→11→34→17→52→26→13→40→20→10→5→16→8→4→2→1<br>输入n，输出变化次数。</b></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int num = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">int a = 0;</span><br><span class="line">while (num != 1)</span><br><span class="line">&#123;</span><br><span class="line">    if (num % 2 == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        num = 3 * num + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        num /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    a++;</span><br><span class="line">    Console.WriteLine(&quot;变换后的值&quot;+num);</span><br><span class="line">&#125; Console.WriteLine(&quot;变换的次数&quot;+a);</span><br></pre></td></tr></table></figure><h1 id="do-while循环学习笔记"><a href="#do-while循环学习笔记" class="headerlink" title="do-while循环学习笔记"></a><font size="8"><b>do-while循环学习笔记</font></b></h1><h2 id="do-while的基本结构"><a href="#do-while的基本结构" class="headerlink" title="do-while的基本结构"></a><font size="6"><b>do-while的基本结构</font></b></h2><blockquote><p>在指定的布尔表达式的计算结果为 true 时，do 语句会执行一条语句或一个语句块。 由于在每次执行循环之后都会计算此表达式，所以 do 循环会执行一次或多次。 do 循环不同于 while 循环（该循环执行零次或多次）。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(n);</span><br><span class="line">    n++;</span><br><span class="line">&#125; <span class="keyword">while</span> (n &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装AE插件</title>
      <link href="/2024/11/06/%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/"/>
      <url>/2024/11/06/%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="AE插件的安装"><a href="#AE插件的安装" class="headerlink" title="AE插件的安装"></a><font size="8">AE插件的安装</font></h1><blockquote><p>学剪辑想要有电影那样的好看特效就少不了插件的帮助，这期教大家下载插件</p></blockquote><h2 id="插件在哪下载呢？"><a href="#插件在哪下载呢？" class="headerlink" title="插件在哪下载呢？"></a><font size="6">插件在哪下载呢？</font></h2><p><font size="4"><b>1.还是有很多人不知道插件在哪下载，有很多人在b站搜AE插件安装，基本都是都是加微信，交钱进群啥的！浪费时间和钱插件还没拿到。</font></b></p><blockquote><p>这里我分享最全的下插件网站：<a href="https://www.lookae.com/">https://www.lookae.com/</a></p></blockquote><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a><font size="6">安装步骤</font></h2><p><font size="4"><b>1.打开looke.ae这个网站，在搜索框中输入你要安装的插件，博主就用<font color="red">Magic Bullet Suite v2023.2.1（红巨人）</font>这个插件来教大家安装：</font></b></p><blockquote><p>这个也是做剪辑常用的调色插件</p></blockquote><p><font size="4"><b>2.第一步，找到要下载的插件并看它是否支持你的AE的版本，选择下载方式。</font></b></p><blockquote><p>下面中文汉化是需要付费的且更新没有英文的快（推荐英文版）</p></blockquote><p><img src="/img%5Cyouxin%5CMan.png"><br><font size="4"><b>3.将我们下载的文件进行解压（推荐Bandizip这个解压软件，电脑自带的微软商店就可以下载到.）</font></b><br><img src="/img%5Cyouxin%5CMan1.png"></p><h2 id="按照步骤即可"><a href="#按照步骤即可" class="headerlink" title="按照步骤即可"></a>按照步骤即可</h2><p><font size="4"><b>4. 1..Maxon_App_2023.2.2_Win.exe，不要登录，安装完成之后关闭即可<br>2.安装Magic Bullet Suite Installer.exe，安装完成之后关闭即可<br>3.安装Unlocker 2023.2.1.exe，即可完成激活。</font></b></p>]]></content>
      
      
      <categories>
          
          <category> AE </category>
          
          <category> 插件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>素材补帧、4k</title>
      <link href="/2024/11/04/%E7%B4%A0%E6%9D%90%E8%A1%A5%E5%B8%A7%EF%BC%8C4k/"/>
      <url>/2024/11/04/%E7%B4%A0%E6%9D%90%E8%A1%A5%E5%B8%A7%EF%BC%8C4k/</url>
      
        <content type="html"><![CDATA[<h1 id="给素材补帧让视频变得丝滑"><a href="#给素材补帧让视频变得丝滑" class="headerlink" title="给素材补帧让视频变得丝滑"></a>给素材补帧让视频变得丝滑</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><blockquote><p>给视频补帧，先给视频进行抽帧在补帧效果更好，下面是操作步骤：</p></blockquote><p>1.将视频导入AE,抽帧就是以你要补帧的人物（主体）为第一要素，第一要素动了就裁剪一次：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;border-radius: 12px">    <iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113429784298208&bvid=BV1uTDhYTEBV&cid=26627605593&p=1" page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 80%; width: 100%;border-radius: 12px"> </iframe></div>2.将视频用Me导出来（也是looked.ae下载），在进行补帧。<blockquote><p>1.我在这里分享两个好用的补帧软件，让你的视频丝滑无比。</p></blockquote><h2 id="第一个：Flowframes"><a href="#第一个：Flowframes" class="headerlink" title="第一个：Flowframes"></a>第一个：<font color="blue">Flowframes</font></h2><p>2.第一步打开flow,如图：↓<br><img src="/img%5Cflow.png"><br>3.点击Browse(Video)，选择要补帧的片段，在选择你要补的帧数按interpolate开始补帧。</p><h2 id="第二个：SVFI"><a href="#第二个：SVFI" class="headerlink" title="第二个：SVFI"></a>第二个：<font color="blue">SVFI</font></h2><p>1.这个补帧软件是我用过最好的，唯一的缺点就是要钱但只补帧的话只需买社区服43元（steam上面购买），这个软件还可以补4K、8k、超分。（但要买专业版328）<br>我这有平替，他就是：<font size="5">VideoAIportable</font></p><h2 id="第二个：SVFI-1"><a href="#第二个：SVFI-1" class="headerlink" title="第二个：SVFI"></a>第二个：<font color="blue">SVFI</font></h2><p>1.这个补帧软件是我用过最好的，唯一的缺点就是要钱但只补帧的话只需买社区服43元（steam上面购买），这个软件还可以补4K、8k、超分。（但要买专业版328）<br>我这有平替，他就是：<font size="5">Topaz VideoAIportable</font></p><p>2.先用SVFI进行补帧。打开SVFI的高级设置先进行调试，可以参考我的来：<br>一.<img src="/img%5Cyouxin%5Csvfi.png"><br>二.<img src="/img%5Cyouxin%5Csvfi1.png"><br>三.<img src="/img%5Cyouxin%5Csvfi2.png"><br>四.<img src="/img%5Cyouxin%5Csvfi3.png"></p><h2 id="视频补4K"><a href="#视频补4K" class="headerlink" title="视频补4K"></a>视频补4K</h2><p>没有 <font size="4">Topaz VideoAIportable</font> 的在looke.ae也可以下载的。</p><p>1.打开<font size="4">Topaz VideoAIportable</font>导入素材可以按照我这样设置：<br><img src="/img%5Cyouxin%5CTopaz.png"><br><font size="4">请看对比</font></p><p><img src="/img%5Cyouxin%5CTopaz1.png"><br>2.导出即可</p>]]></content>
      
      
      <categories>
          
          <category> AE </category>
          
          <category> SVFI </category>
          
          <category> Topaz VideoAIportable </category>
          
          <category> Flowframes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AE素材获取</title>
      <link href="/2024/10/30/AE%E7%B4%A0%E6%9D%90%E6%8F%90%E7%BA%AF/"/>
      <url>/2024/10/30/AE%E7%B4%A0%E6%9D%90%E6%8F%90%E7%BA%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="学习漫剪第一步：获取素材"><a href="#学习漫剪第一步：获取素材" class="headerlink" title="学习漫剪第一步：获取素材"></a><b>学习漫剪第一步：获取素材</b></h1><blockquote><p>我们下好软件之和就是去寻找素材，很多人都不知道或是用录频软件去录制带字幕的视频，这里我分享资源多可以下载生肉的网站。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mikanime.tv/</span><br></pre></td></tr></table></figure><p>1.这个网站只能下载种子到迅雷把视频下载下来。</p><blockquote><p>看到这就有人问博主博主网上不是有很多免费bit下载软件，博主为啥还是推荐迅雷呢？<br>因为迅雷不充钱也比这些免费bit下载速度快。</p></blockquote><p>2.下面是图片描述：<br><img src="/img/mingan.png" alt="图片描述"><br>3.然后搜索你要下载的动漫种子，点击种子自动跳转迅雷下载所选择的盘。<br><img src="/img/mangan1.png" alt="图片描述"><br>4.<b>博主前期出一些操作简单，内容不会很多且好理解的教程。</b></p>]]></content>
      
      
      <categories>
          
          <category> AE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蜜柑计划 </tag>
            
            <tag> 迅雷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常</title>
      <link href="/2024/10/30/YOUXIANDEYU/"/>
      <url>/2024/10/30/YOUXIANDEYU/</url>
      
        <content type="html"><![CDATA[<h1 id="博主的随心日常"><a href="#博主的随心日常" class="headerlink" title="博主的随心日常"></a></b><em>博主的随心日常</em></b></h1><h2 id="2024年"><a href="#2024年" class="headerlink" title="2024年"></a>2024年</h2><h3 id="11月1日"><a href="#11月1日" class="headerlink" title="11月1日"></a>11月1日</h3><!-- <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;border-radius: 12px">    <iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113316101884629&bvid=BV1TRmAYSE94&cid=26314608616&p=1" page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 80%; width: 100%;border-radius: 12px"> </iframe></div> --><blockquote><p>今天明日方舟更新5.5周年了（有没有和博主玩一样的游戏啊），攒了70抽开开心心上线抽卡，出了俩个金，歪了个叔叔潜能+1。给我出个没有的都好啊！<br>说说我对这游戏的评价吧，21年那会儿我是被同学带入坑的那时第一次接触这种类型的游戏感觉很好玩很新颖，后面也玩过很多这种类型的二游但还是明日方舟更好，尽管现在不怎么玩了。<br>可能是新鲜感过了吧。关卡出的没意思，抽卡一直是非酋。如今每天上线就是刷体力完成每日就下了。<br>现在唯一好玩的的就是它出的危机合约了。🥱🥱🥱</p></blockquote><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;border-radius: 12px"><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113407286052207&bvid=BV1NgSRYbEAQ&cid=26564363331&p=1" page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 80%; width: 100%;border-radius: 12px"> </iframe></div><blockquote><p>新出的塑心皮肤还是很好看的。喜欢😍😍😍</p></blockquote><p><img src="/img/youxin/%E5%A1%91%E5%BF%83.jpg"><br><img src="/img/youxin/%E5%A1%91%E5%BF%831.jpg"></p><h3 id="11月3日"><a href="#11月3日" class="headerlink" title="11月3日"></a>11月3日</h3><blockquote><p>看完CS,2024BLAST全球总决赛。<br>恭喜G2夺冠</p></blockquote><p><img src="/img/youxin/G2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C# if、swatch学习笔记</title>
      <link href="/2024/10/30/%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
      <url>/2024/10/30/%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本人是一名初学者，欢迎各位大佬指正。<br>记录自己学习c#过程中的心得体会。</p></blockquote><p><font size="6"> C# if、switch的基本关系与使用 </font><br></p><blockquote><p>1.if语句有两种表达方式，第1种是包含 else 部分的 if 语句根据布尔表达式的值选择两个语句中的一个来执行，如以下示例所示：</p></blockquote><figure class="highlight c#"><figcaption><span>if else...</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">int</span> number=Convert.ToInt32(Console.ReadLine()); <span class="comment">//定义一个整数</span></span><br><span class="line">           <span class="keyword">if</span> (number &gt;= <span class="number">0</span>)  <span class="comment">//条件</span></span><br><span class="line">           &#123;</span><br><span class="line">                  Console.WriteLine(<span class="string">&quot;博主好帅&quot;</span>); <span class="comment">// 满足条件输出</span></span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">else</span>  </span><br><span class="line">             &#123;</span><br><span class="line">                  Console.WriteLine(<span class="string">&quot;博主最帅&quot;</span>); <span class="comment">//不满足条件输出</span></span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.第二种是else嵌套if语句可以判断多个条件：</p></blockquote><figure class="highlight c#"><figcaption><span>else-if...</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> number=Convert.ToInt32(Console.ReadLine());  <span class="comment">//定义一个整数</span></span><br><span class="line">            <span class="keyword">if</span> (number == <span class="number">0</span>)  <span class="comment">//条件1</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;YOU&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (number &gt; <span class="number">0</span>)  <span class="comment">//条件2</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;XIAN&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; <span class="number">0</span>)  <span class="comment">//条件3</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;YU&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (number != <span class="number">0</span>)  <span class="comment">//条件4</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;YOUXIANYU&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;XX&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.switch语句是根据与匹配表达式匹配的模式来选择要执行的语句列表，如以下示例所示：</p></blockquote><figure class="highlight c#"><figcaption><span>输入4个整数，判断最大值和最小值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Schema;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">switch</span>语句2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">int</span> a = Convert.ToInt32(Console.ReadLine());  <span class="comment">//定义一个整数</span></span><br><span class="line">            <span class="built_in">int</span> b = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">            <span class="built_in">int</span> c = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">            <span class="built_in">int</span> d = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> max = a, min = a;  <span class="comment">//赋值</span></span><br><span class="line">            <span class="keyword">if</span> (max &lt; b)  </span><br><span class="line">            &#123;</span><br><span class="line">                max = b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; c)</span><br><span class="line">            &#123;</span><br><span class="line">                max = c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; d)</span><br><span class="line">            &#123;</span><br><span class="line">                max = d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; b)</span><br><span class="line">            &#123;</span><br><span class="line">                min = b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; c)</span><br><span class="line">            &#123;</span><br><span class="line">                min = c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; d)</span><br><span class="line">            &#123;</span><br><span class="line">                min = d;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;最大的值&#123;0&#125;，最小的值&#123;1&#125;.&quot;</span>, max, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何安装Adobe AfterEffects 2022</title>
      <link href="/2024/10/29/%E6%BC%AB%E5%89%AA/"/>
      <url>/2024/10/29/%E6%BC%AB%E5%89%AA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是我第一次写博客,就写一个自己热爱的漫剪。<br>1.所以就从安装Adobe AfterEffects 2022开始，分享一下软件的安装教程吧！<br>后续还会有更多的教程分享！</p></blockquote><h1 id="Adobe-AfterEffects-2022-安装教程"><a href="#Adobe-AfterEffects-2022-安装教程" class="headerlink" title="Adobe AfterEffects 2022 安装教程"></a><em><strong>Adobe AfterEffects 2022 安装教程</strong></em></h1><h2 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1.下载安装包"></a>1.下载安装包</h2><blockquote><p>2.首先，你需要到Adobe官网下载安装包，地址为：</p></blockquote><p> <a href="https://www.adobe.com/products/aftereffects.html">https://www.adobe.com/products/aftereffects.html</a></p><blockquote><p>哈哈，上面是正版Adobe软件，主要是给公司、和团队使用（如果不使用正版懂得懂得😜😜😜）<br>个人使用就用汉化版的就行啦↓<br><a href="https://www.rjctx.com/">https://www.rjctx.com/</a> </p></blockquote><p> 1.第一步进入网站，在搜索框里输入<b>Adobe After Efects</b>, 选择你喜欢的版本下载。</p><blockquote><p><b>温馨提示：版本上的不同软件上会有一定上的区别，还有就是后续的教学会使用到插件如果版本太高或太低就会出现插件上我有的效果你没有和效果不一样。</p></blockquote><p><img src="https://s2.loli.net/2024/10/31/WboNGvH9trF7xnQ.png" alt="AE.png"></p><p>2.随便选一个你喜欢的方式下载：<br>    <img src="https://s2.loli.net/2024/10/31/xFQiIahM61ly2SC.png" alt="AE.png"></p><blockquote><p><b>温馨提示2：下好的安装包可以放在除C盘的任意盘中但安装路径默认C盘就行，了解过AE的都知道经常会崩溃放在C盘会减少这种事情的发生（电脑好就不必理会）</b></p></blockquote><p>3.等它安装好就可以使用啦！！！😊😊😊</p>]]></content>
      
      
      <categories>
          
          <category> AE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Adobe After Effects 2022 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
