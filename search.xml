<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript基础阶段三</title>
      <link href="/2025/03/03/JavaScript/%E5%87%BD%E6%95%B0/"/>
      <url>/2025/03/03/JavaScript/%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数的概念与作用"><a href="#函数的概念与作用" class="headerlink" title="函数的概念与作用"></a>函数的概念与作用</h1><p>函数是程序中的一种基本结构，它允许我们把一组代码封装成一个独立的单位，并通过特定的名称调用这个单元。函数的作用主要有以下几点：</p><p>提高代码复用性: 将重复或相似的操作封装到一个函数中，可以避免代码冗余。<br>增强逻辑清晰度: 通过将具体操作抽象为函数，可以更清楚地表达程序的功能。<br>组织代码结构: 复杂的逻辑可以通过多个函数的调用来实现。</p><p>函数的基本定义</p><p>在JavaScript中，函数可以通过function关键字定义。一个基本的函数定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体内的操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;  <span class="comment">// 定义一个接受参数 `name` 的函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);  <span class="comment">// 执行特定操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的调用</p><p>一旦定义了一个函数，就可以通过调用来执行其中的操作。调用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">greet</span>(<span class="string">&quot;Alice&quot;</span>);  <span class="comment">// 调用 `greet` 函数，并传递参数 `&quot;Alice&quot;`</span></span><br></pre></td></tr></table></figure><p>注意事项:</p><p>必须在函数定义之前调用函数。<br>调用时可以不提供参数（如果函数没有默认参数），但必须遵循函数的定义。<br>函数的作用域与变量</p><p>JavaScript中的函数属于全局作用域，这意味着函数体内使用的变量会被视为全局变量。不过，为了更好地管理代码，我们可以使用以下方法：</p><p>使用括号()强制调用: 这可以避免某些特殊情况下全局作用域的识别。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>)) &#123;  <span class="comment">// 使用括号强制调用函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明确指定作用域: 使用const或let关键字定义变量时，可以指定其作用域。</p><p>函数的参数与返回值<br>参数传递<br>函数可以通过接受参数来接收外部的数据。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">greet</span>(<span class="string">&quot;Alice&quot;</span>);  <span class="comment">// 输出: &quot;Hello, Alice&quot;</span></span><br></pre></td></tr></table></figure><p>如果函数没有定义参数，也可以直接调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">greet</span>();  <span class="comment">// 输出: &quot;Hello, &quot;</span></span><br></pre></td></tr></table></figure><p>返回值<br>JavaScript的默认返回值是undefined。要让函数返回特定值，可以使用return关键字。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;  <span class="comment">// 返回两个数相乘的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="title function_">multiply</span>(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 结果为 `12`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);          <span class="comment">// 输出: &quot;12&quot;</span></span><br></pre></td></tr></table></figure><p>函数的高级特性<br>除了基本功能，JavaScript还支持一些更高级的功能：</p><ol><li>默认参数<br>可以在函数定义中为参数提供默认值。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name = <span class="string">&quot;World&quot;</span></span>) &#123;  <span class="comment">// 如果没有传递参数，则 `name` 的值为 `&quot;World&quot;`</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时：</p><p>调用一次，不传参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">greet</span>();  <span class="comment">// 输出: &quot;Hello, World&quot;</span></span><br></pre></td></tr></table></figure><p>调用两次，传参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">greet</span>(<span class="string">&quot;Alice&quot;</span>);  <span class="comment">// 输出: &quot;Hello, Alice&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>可选参数<br>可以定义函数接受任意数量的参数。</li></ol><p>使用…args接收多余参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">acceptAnyArgs</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args.<span class="property">length</span> + <span class="string">&#x27; arguments passed&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">acceptAnyArgs</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 输出: &quot;3 arguments passed&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>函数的表达式形式<br>可以将函数直接写成一个表达式：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">multiply</span> = (<span class="params">a, b</span>) =&gt; a * b;  <span class="comment">// 定义一个乘法函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiply</span>(<span class="number">2</span>, <span class="number">3</span>));      <span class="comment">// 输出: 6</span></span><br></pre></td></tr></table></figure><ol start="4"><li>闭包<br>闭包是指一个函数在执行过程中能够访问外部变量或内部变量的技术。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params">n</span>) &#123;  <span class="comment">// 内部函数可以访问 `x`</span></span><br><span class="line">        <span class="keyword">return</span> x + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">outer</span>(<span class="number">5</span>)(<span class="number">3</span>);  <span class="comment">// 输出: &quot;8&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);       <span class="comment">// 输出: undefined (因为 result 已被赋值，实际应输出 &quot;8&quot;)</span></span><br></pre></td></tr></table></figure><p>函数的常见使用场景<br>处理重复任务</p><p>如果需要多次执行相同的操作，可以通过函数将代码封装起来。<br>数据转换</p><p>对输入数据进行某种变换或计算，例如排序、统计等。<br>异步操作</p><p>使用 Promises 或 async&#x2F;await关键字时，通常会定义为 async function 并使用await关键字调用。<br>模块化代码</p><p>将逻辑拆分成多个函数，使得代码更易维护。<br>总结<br>函数是 JavaScript 编程中非常重要的基础概念。掌握如何定义和调用函数，能够显著提高代码的可读性和复用性。通过理解函数的基本知识和高级特性，你可以更好地编写高效的代码。</p><p>匿名函数的基本概念<br>匿名函数可以用来解决以下几种情况：</p><p>不需要为函数命名：当一个函数只需要在非常短的时间内使用时，没有必要定义一个命名函数。<br>避免名称冲突：通过不定义名字，可以避免与其他函数或变量产生命名冲突。<br>处理回调函数：匿名函数特别适合用于处理需要传递的回调函数（Callback）。<br>匿名函数的语法<br>匿名函数可以通过以下两种方式定义：</p><ol><li>使用 function 关键字<br>最传统的定义匿名函数的方式是使用 function 关键字：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greeting = <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的 greeting 函数是一个匿名函数，没有名称。</p><ol start="2"><li>使用 ES6 引擎的箭头函数语法<br>现代 JavaScript 提供了一种更简洁的方式来定义匿名函数，这就是 ES6 引入的 箭头函数（arrow function）：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">greeting</span> = (<span class="params">name</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>匿名函数的优势<br>无需声明函数名称：匿名函数不需要为函数起名字，因此可以避免命名冲突。<br>灵活性高：匿名函数可以立即定义并执行，适合处理复杂或动态生成的逻辑。<br>安全：匿名函数不会污染命名空间，避免全局变量的使用问题。<br>匿名函数的常见用途<br>回调函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The sum is <span class="subst">$&#123;a + b&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">func</span>(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 输出：8</span></span><br></pre></td></tr></table></figure><p>处理函数参数的默认值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a, b=<span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>)); <span class="comment">// 输出：2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出：5</span></span><br></pre></td></tr></table></figure><p>匿名函数的命名空间问题<br>因为匿名函数没有显式的名称，所以在 declare 语句中不会被记录到命名空间中。它们会被执行时的当前作用域所隔离。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Outer function: &#x27;</span> + outer2); <span class="comment">// 报错：Cannot read property &#x27;outer2&#x27; of null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inner function: &#x27;</span> + inner.<span class="property">name</span>); <span class="comment">// 报错：Cannot read property &#x27;name&#x27; of null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> anonymous = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Anonymous function: &#x27;</span> + (anonymous.<span class="property">name</span> || <span class="string">&#x27;No name&#x27;</span>)); </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">anonymous = <span class="title function_">outer</span>(); <span class="comment">// 输出：Anonymous function: No name</span></span><br></pre></td></tr></table></figure><p>总结<br>匿名函数 是一种非常灵活且有用的工具，特别适合在处理回调函数或需要临时定义的函数时使用。<br>使用箭头函数可以让匿名函数更简洁、高效。<br>匿名函数不会污染命名空间，因此在复杂的场景中可以更好地控制作用域问题。</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>理解对象的概念：</p><p>对象是将多种数据以键值对的形式封装在一起的数据结构。例如，学生对象包含了学号、姓名和成绩等信息。<br>创建对象的方法：</p><p>使用大括号初始化：const obj &#x3D; { name: “张三”, age: 18 };<br>键必须在值前面，以区分键名和值，并确保语法正确。<br>增删查改操作：</p><p>增：</p><p>使用 obj[newKey] &#x3D; value; 来添加新属性。例如：person.name &#x3D; “小明”;<br>查：</p><p>直接访问属性：obj.keyName<br>引用访问属性：obj[‘keyName’]，后者更灵活，适用于字符串键名的变更。<br>删：</p><p>使用 delete obj[key]; 或者 obj[key] &#x3D; undefined; 来删除属性。删除后需重新赋值以恢复属性。<br>改：</p><p>直接赋值：obj[key] &#x3D; value<br>赋值新对象：obj[key] &#x3D; { … }; 适用于嵌套结构。<br>实例应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">score</span>: [<span class="number">90</span>, <span class="number">85</span>, <span class="number">76</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="property">name</span>); <span class="comment">// 输出：张三</span></span><br><span class="line"><span class="keyword">delete</span> student.<span class="property">score</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="property">score</span>); <span class="comment">// 输出：undefined</span></span><br><span class="line">student.<span class="property">address</span> = &#123; <span class="attr">street</span>: <span class="string">&quot;北京&quot;</span>, <span class="attr">house</span>: <span class="string">&quot;东直门&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础阶段一</title>
      <link href="/2025/03/01/JavaScript/%E7%AE%80%E4%BB%8B/"/>
      <url>/2025/03/01/JavaScript/%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript介绍"><a href="#JavaScript介绍" class="headerlink" title="JavaScript介绍"></a>JavaScript介绍</h1><h2 id="JavaScript（是什么？）"><a href="#JavaScript（是什么？）" class="headerlink" title="JavaScript（是什么？）"></a>JavaScript（是什么？）</h2><p>是一种运行在客户端（浏览器）的编程语言，实现人机交互效果。</p><h2 id="作用（做什么？）"><a href="#作用（做什么？）" class="headerlink" title="作用（做什么？）"></a>作用（做什么？）</h2><p>—— 网页特效（监听用户的一些行为让网页作出对应的发馈）<br>—— 表单验证（针对表单数据的合法性进行判断）<br>—— 数据交互（获取后台的数据，渲染到前端）</p><h2 id="js初体验"><a href="#js初体验" class="headerlink" title="js初体验"></a>js初体验</h2><p><img src="/img%5Cjs%5CSnipaste_2025-02-27_18-47-48.png"></p><p><b>JavaScript的书写位置</b></p><blockquote><p>JavaScript可以放在body部分也可以放在head部分</p></blockquote><p><b>外部 JavaScript 的优势</b></p><blockquote><p>在外部文件中放置脚本有如下优势：<br>分离了 HTML 和代码<br>使 HTML 和 JavaScript 更易于阅读和维护<br>已缓存的 JavaScript 文件可加速页面加载</p></blockquote><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>Window.alert(message（返回值）)方法</p><p><b>参数：message</b><br>显示在对话框中的字符串，传入其他类型值，也会转会成字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;Hello workd!&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>外部引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="comment">//外部引用</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/My.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>示例</p><p><img src="/img%5Cjs%5CSnipaste_2025-02-27_20-47-30.png"></p><h2 id="JavaScript-显示方案"><a href="#JavaScript-显示方案" class="headerlink" title="JavaScript 显示方案"></a>JavaScript 显示方案</h2><p>JavaScript 能够以不同方式“显示”数据：</p><p>使用 window.alert() 写入警告框<br>使用 document.write() 写入 HTML 输出<br>使用 innerHTML 写入 HTML 元素<br>使用 console.log() 写入浏览器控制台</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">```HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;&#x27;</span>).<span class="property">innerHtml</span>=<span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="JavaScript-关键词"><a href="#JavaScript-关键词" class="headerlink" title="JavaScript 关键词"></a>JavaScript 关键词</h1><p>JavaScript 语句常常通过某个关键词来标识需要执行的 JavaScript 动作。</p><p><img src="/img%5Cjs%5CSnipaste_2025-02-28_12-34-10.png"></p><h1 id="JavaScript-变量"><a href="#JavaScript-变量" class="headerlink" title="JavaScript 变量"></a>JavaScript 变量</h1><ol><li>变量声明<br>在 JavaScript 中，您可以使用 let、const 和 var 关键字来声明变量。</li></ol><p>let: 这是最常见的关键字，用于临时声明变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>; <span class="comment">// 变量 name 是一个字符串类型的值 25</span></span><br></pre></td></tr></table></figure><p>const: 该关键字用于最终声明变量。一旦赋值给 const，您就不能再修改该变量的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14159</span>; <span class="comment">// 变量 PI 是一个数字类型的值 3.14159</span></span><br></pre></td></tr></table></figure><p>var: 该关键字用于声明全局变量。不过，由于 var 的使用频率非常高，现在很少使用它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="string">&quot;Hello, World!&quot;</span>; <span class="comment">// 变量 greeting 是一个字符串类型的值 Hello, World!</span></span><br></pre></td></tr></table></figure><ol start="2"><li>变量类型</li></ol><p>JavaScript 不强制指定变量的类型。您可以在声明时直接赋值给变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>; <span class="comment">// num 是数字类型</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// name 是字符串类型</span></span><br></pre></td></tr></table></figure><p>如果在没有明确类型的情况下，JavaScript 会根据赋值的内容推断变量的类型。</p><ol start="3"><li>变量的作用域<br>全局变量: 使用 let 或 var 声明的变量属于全局作用域。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出是 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量: 使用 let 和函数括号 () 声明的变量属于该函数的作用域（局部作用域）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出是 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>块级变量: 使用 const 声明的变量属于该块级元素的作用域（块级作用域）。</p><ol start="4"><li>变量的赋值</li></ol><p>JavaScript 提供多种方式来赋值给变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接赋值</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作数运算符</span></span><br><span class="line"><span class="keyword">let</span> b = a; <span class="comment">// b 和 a 是同一个变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = a + <span class="number">5</span>; <span class="comment">// c = 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="literal">undefined</span>; <span class="comment">// 变量未被赋值，默认为 `undefined`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> e = <span class="literal">null</span>; <span class="comment">// 特殊情况，表示空对象或空值</span></span><br></pre></td></tr></table></figure><ol start="5"><li>注意事项</li></ol><p>JavaScript 的变量是弱引用，这意味着它们存储的是内存地址，而不是直接的值。如果主线程中的脚本退出，这些变量会丢失。</p><p>使用 let 和 const 声明变量时，默认情况下会在全局作用域或当前块级中声明变量。</p><p>示例代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量声明和赋值示例</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14159</span>; <span class="comment">// 最终声明变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">const</span> greeting = <span class="string">&quot;Hello!&quot;</span>; <span class="comment">// 块级常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 输出：25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">PI</span>);   <span class="comment">// 输出：3.14159</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JavaScript 的变量系统非常灵活，允许您在运行时动态地声明和修改变量。使用 let 和 const 是现代 JavaScript 开发中常用的实践，它们分别用于临时变量和最终声明变量。</p><h2 id="JavaScript-数组"><a href="#JavaScript-数组" class="headerlink" title="JavaScript 数组"></a>JavaScript 数组</h2><h3 id="一、数组的创建与初始化"><a href="#一、数组的创建与初始化" class="headerlink" title="一、数组的创建与初始化"></a>一、数组的创建与初始化</h3><p>空数组<br>初始化一个空数组非常简单，可以通过以下方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = []; <span class="comment">// 创建一个空数组</span></span><br></pre></td></tr></table></figure><p>初始化数组</p><p>使用[]构造函数初始化数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [](); <span class="comment">// 初始化一个空数组</span></span><br></pre></td></tr></table></figure><p>将多个元素放入数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;橘子&#x27;</span>]; <span class="comment">// 直接将元素赋值给数组</span></span><br></pre></td></tr></table></figure><p>利用字符串拆分<br>可以通过split()方法将一个字符串按指定分隔符分割成多个元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;one,two,three&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>); <span class="comment">// 结果：[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</span></span><br></pre></td></tr></table></figure><p>推、弹出和删除数组</p><p>使用push()向数组末尾添加元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">push</span>(<span class="string">&#x27;apple&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用pop()移除并返回数组最后一个元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastElement = arr.<span class="title function_">pop</span>(); <span class="comment">// 返回&#x27;apple&#x27;</span></span><br></pre></td></tr></table></figure><p>使用unshift()移除并返回数组第一个元素（只能添加到数组头部）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstElement = arr.<span class="title function_">unshift</span>(<span class="string">&#x27;banana&#x27;</span>); <span class="comment">// 结果：[&#x27;banana&#x27;, &#x27;one&#x27;]</span></span><br></pre></td></tr></table></figure><p>数组长度属性<br>获取或设置数组的长度：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>); <span class="comment">// 输出当前数组长度</span></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">3</span>; <span class="comment">// 将数组长度设为3</span></span><br></pre></td></tr></table></figure><p>处理超出索引范围的情况</p><p>使用arr[undefined]或arr[number outside of bounds]时会返回undefined：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">10</span>]); <span class="comment">// 输出undefined（假设arr有3个元素）</span></span><br></pre></td></tr></table></figure><p>要避免这样的问题，可以使用for…of循环或者检查索引的有效性。</p><h3 id="二、数组的遍历与操作"><a href="#二、数组的遍历与操作" class="headerlink" title="二、数组的遍历与操作"></a>二、数组的遍历与操作</h3><p>使用for…in循环<br>对数组中的每个键进行遍历：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// 输出：0, 1, 2等数字索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用forEach()方法<br>遍历并执行某个函数操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第<span class="subst">$&#123;index&#125;</span>个元素是：<span class="subst">$&#123;element&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>条件遍历与过滤</p><p>使用filter()创建一个新的数组，包含所有符合条件的元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> evenNumbers = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>); <span class="comment">// 筛选出偶数</span></span><br></pre></td></tr></table></figure><p>find()和findIndex()方法用于查找满足条件的第一个元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstEven = arr.<span class="title function_">find</span>(<span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>高阶数组操作</p><p>map()：创建一个新数组，将原数组中的每个元素转换成新的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squaredNumbers = arr.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num * num); <span class="comment">// 筛选出平方后的数</span></span><br></pre></td></tr></table></figure><p>reduce()（或fold）：将数组中的所有元素依次累积，得到一个单一的返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, current</span>) =&gt;</span> acc + current, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>遍历索引与值对</p><p>使用indexOf()和lastIndexOf()方法查找特定值的位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index = arr.<span class="title function_">indexOf</span>(<span class="string">&#x27;apple&#x27;</span>); <span class="comment">// 查找第一个出现的&#x27;apple&#x27;</span></span><br><span class="line"><span class="keyword">let</span> lastIndex = arr.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;banana&#x27;</span>); <span class="comment">// 查找最后一个出现的&#x27;banana&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="三、数组的扩展与裁剪"><a href="#三、数组的扩展与裁剪" class="headerlink" title="三、数组的扩展与裁剪"></a>三、数组的扩展与裁剪</h3><p>数组扩展</p><p>使用unshift()将元素添加到数组头部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">unshift</span>(<span class="string">&#x27;new element&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用push()或直接赋值的方式在数组末尾增加元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">push</span>(<span class="string">&#x27;add element&#x27;</span>); <span class="comment">// 或者 arr = [1,2,3];</span></span><br></pre></td></tr></table></figure><p>数组裁剪<br>通过截取操作符（…）移除数组中的某些元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArr = [...arr, <span class="string">&#x27;a&#x27;</span>, ...arr]; <span class="comment">// 在原数组末尾添加与之相同的元素</span></span><br></pre></td></tr></table></figure><p>删除重复项<br>使用unique()方法去除数组中所有重复的值，保留第一个出现的位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uniqueArray = arr.<span class="title function_">unique</span>(); <span class="comment">// 去除重复项并返回新数组</span></span><br></pre></td></tr></table></figure><h3 id="四、处理特殊情况"><a href="#四、处理特殊情况" class="headerlink" title="四、处理特殊情况"></a>四、处理特殊情况</h3><p>空值和无效索引</p><p>使用hasOwnProperty()检查是否是自己具有的属性，避免访问不存在的元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;index&#x27;</span>)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用for…of循环遍历数组<br>对数组中的每个元素进行处理，较为简洁和高效的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决NaN类型的问题<br>遇到无法被转换为数字的字符串时，使用Number()函数或强制类型转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="title class_">Number</span>(<span class="string">&#x27;apple&#x27;</span>); <span class="comment">// 结果：NaN（表示无效）</span></span><br></pre></td></tr></table></figure><p>避免数组未初始化问题<br>使用|| null强制进行类型转换和赋值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="literal">undefined</span> || arr[<span class="literal">undefined</span>] ? <span class="string">&#x27;默认值&#x27;</span> : <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h3 id="五、优化与性能考虑"><a href="#五、优化与性能考虑" class="headerlink" title="五、优化与性能考虑"></a>五、优化与性能考虑</h3><p>避免重复计算<br>在频繁操作数组时，尽量提前处理数据或缓存结果，减少不必要的计算。</p><p>使用内置方法代替循环<br>对于需要遍历和操作的情况，优先使用forEach(), map(), filter()等内置方法，这些方法经过优化，比自定义循环更高效。</p><p>避免不必要的数组创建<br>多次使用push()或unshift()会导致多个小数组合并成一个大数组，可以考虑一次性完成所有操作。</p><p>处理多维数组时的性能优化<br>如果频繁操作二维或三维数组，可以尝试将它们转换为单维数组处理，并根据具体需求进行分析和优化。</p><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>创建与初始化：灵活使用[], push(), unshift()等方法。<br>遍历：利用for…in, forEach(), indexOf(), lastIndexOf()等方法高效处理数组元素。<br>高阶操作：熟练运用map(), filter(), reduce(), find()和findIndex()进行复杂的数据转换与查询。<br>扩展与裁剪：合理使用数组扩展和裁剪方法，避免不必要的重复计算。</p><h2 id="使用-const-关键字声明变量"><a href="#使用-const-关键字声明变量" class="headerlink" title="使用 const 关键字声明变量"></a>使用 const 关键字声明变量</h2><p>使用 const 关键字声明的变量是不可变的，一旦赋值后不能再被修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">PI</span>); <span class="comment">// 输出: 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">PI</span> = <span class="string">&quot;2&quot;</span>; <span class="comment">// 这条语句会报错，因为 `const` ·· declare immutable variable</span></span><br></pre></td></tr></table></figure><p>使用 !+ 运算符和 let 关键字<br>使用 !+ 运算符可以强制变量为数值类型，但仍然可以通过后续赋值来修改其值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = !+ <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 将字符串转为数字并存储到 `greeting` 变量中。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting); <span class="comment">// 输出: 72（&#x27;H&#x27;的ASCII码）</span></span><br><span class="line"></span><br><span class="line">greeting = !+ <span class="string">&quot;World&quot;</span>; <span class="comment">// 可以修改变量值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting); <span class="comment">// 输出: 87</span></span><br></pre></td></tr></table></figure><p>使用 var 关键字<br>使用 var 关键字声明的变量在现代JavaScript中不被推荐，因为它可能导致代码不可变。建议使用 const 或 let。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span>; <span class="comment">// 这条语句会报错，因为 `var` declare immutable variable</span></span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>在JavaScript中，“常量”通常指的是使用 const 关键字声明的不可变变量。<br>使用 !+ 运算符可以在当前语境下强制变量为数值类型，但并不阻止后续赋值修改该变量的值。</p><h2 id="js数据类型分为两大类"><a href="#js数据类型分为两大类" class="headerlink" title="js数据类型分为两大类"></a>js数据类型分为两大类</h2><p>Primitive 类型：</p><p>这些是不可变的数据类型，包括：<br>number（数字）<br>string（字符串）<br>boolean（布尔值）<br>null<br>undefined<br>symbol（符号值）<br>map（映射）<br>Object 对象：</p><p>这些是可变的，可以包含属性，并且在运行时可以被修改。构造出来的对象属于这一类。<br>详细说明：<br>Primitive 类型：这些是不可变的值，一旦赋值后无法再改变。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">5</span>; <span class="comment">// 原始数值类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num); <span class="comment">// 输出: &quot;number&quot;</span></span><br></pre></td></tr></table></figure><p>Object 对象：这些是可以被修改和扩展的对象。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// 输出: &quot;John&quot;</span></span><br></pre></td></tr></table></figure><p>注意事项：<br>null 和 undefined 是两种不同的值，null 表示没有值，而 undefined 表示变量未被赋值。<br>symbol 类型主要用于性能优化和不可变属性的实现。</p><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串（Template Literals）</p><p>定义：一种语法糖，允许在字符串内直接嵌入表达式或变量，而无需使用拼接符或其他方法手动拼接。<br>语法结构：使用反斜杠\$开始模板字符串，并在其内部插入变量或表达式的计算结果。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用模板字符串拼接输出</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Name is <span class="subst">$&#123;name&#125;</span> and age is <span class="subst">$&#123;age&#125;</span>`</span>); <span class="comment">// 输出: Name是Alice，age是30</span></span><br></pre></td></tr></table></figure><p>优势：简化手动拼接字符串的操作，提高代码的简洁性和可读性。</p><p>注意事项：</p><p>反斜杠前面要加反斜杠（如\$）以表示模板字符串开始。<br>忽略符号问题时，记得检查引号和反斜杠是否匹配。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>JavaScript 可以将不同类型的数据相互转换：</p><p>使用 typeof 操作符可以获取变量的类型。<br>使用布尔值 (true&#x2F;false) 可以强制类型转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str); <span class="comment">// 输出: &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str === <span class="number">42</span>); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="string">&quot;3.14&quot;</span>; <span class="comment">// 字符串到数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num + <span class="string">&quot; + 5 = &quot;</span> + (num + <span class="number">5</span>)); <span class="comment">// 输出: 8.14</span></span><br></pre></td></tr></table></figure><ol start="3"><li>布尔值和 NaN<br>NaN 表示“不是一个数字”，它是一个特殊的数值类型。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span>); <span class="comment">// 输出: NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> === <span class="title class_">NaN</span>); <span class="comment">// 输出: false (因为NaN不能比较)</span></span><br></pre></td></tr></table></figure>布尔值 (true&#x2F;false) 是特殊类型的变量，它们是 boolean 类型。</li></ol><p>隐式转换（Implicit Conversion）和显式转换（Explicit Conversion）是JavaScript中处理数据类型时的两种方式。以下是它们的区别及示例：</p><h3 id="隐式转换："><a href="#隐式转换：" class="headerlink" title="隐式转换："></a>隐式转换：</h3><p>定义： 隐式转换是指在编程过程中，不同数据类型的变量或值会自动地转换为相同的数据类型，以便进行运算或操作。<br>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式转换示例 1: 字符串和数字相加</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;5&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a + <span class="number">3</span>); <span class="comment">// 输出是&quot;8&quot;</span></span><br></pre></td></tr></table></figure><p>这里，“5”被隐式地转换为数字5，然后与3相加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式转换示例 2: 字符串比较</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b &gt; <span class="string">&quot;banana&quot;</span>); <span class="comment">// 输出是false</span></span><br></pre></td></tr></table></figure><p>这里，“apple”被隐式地转换为字符串“apple”，与“banana”进行比较。</p><h3 id="显式转换："><a href="#显式转换：" class="headerlink" title="显式转换："></a>显式转换：</h3><p>定义： 显式转换是指通过特定的函数或运算符将数据从一种类型强制转换到另一种类型。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式转换示例 1: 使用Number()函数将字符串转换为数字</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="string">&quot;7&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(c)); <span class="comment">// 输出是7</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式转换示例 2: 使用强制类型转换运算符++</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+“<span class="number">5</span>”); <span class="comment">// 输出是5</span></span><br><span class="line"><span class="variable constant_">JAVASCRIPT</span></span><br><span class="line"><span class="comment">// 显式转换示例 3: 使用parseInt()将字符串转换为整数</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="string">&quot;10&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(d, <span class="number">10</span>)); <span class="comment">// 输出是10</span></span><br></pre></td></tr></table></figure><p>总结：</p><p>隐式转换在编程过程中自动发生，无需额外的代码。它适用于运算和比较操作。<br>显式转换需要通过特定函数或运算符来完成，可以更精确地控制数据类型，但可能增加代码复杂性。</p><h2 id="逻辑运算符与优先级"><a href="#逻辑运算符与优先级" class="headerlink" title="逻辑运算符与优先级"></a>逻辑运算符与优先级</h2><h3 id="值解释（Value-Interpretation）"><a href="#值解释（Value-Interpretation）" class="headerlink" title="值解释（Value Interpretation）"></a>值解释（Value Interpretation）</h3><p>在 JavaScript 中，许多操作都会涉及对不同类型的值进行“值解释”。这种解释过程确保运算可以在统一的数据类型下执行。</p><p>示例：</p><p>比较运算符：当使用 &#x3D;&#x3D; 或 &#x3D;&#x3D;&#x3D; 进行比较时，JavaScript 会将两个操作数转换为相同的数据类型（通常是数值或字符串）后再进行比较。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;5&quot;</span> == <span class="number">5</span>); <span class="comment">// 输出：true (值解释)</span></span><br></pre></td></tr></table></figure><p>字符串拼接：当使用 + 运算符将一个数值和一个字符串相加时，JavaScript 会将数值转换为字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> + <span class="string">&quot;2&quot;</span>); <span class="comment">// 输出：&quot;5&quot;</span></span><br></pre></td></tr></table></figure><p>布尔运算：在条件运算中（如 &amp;&amp;, ||, 和 !），JavaScript 会将某些值解释为布尔值。例如，数字、空字符串、数组等会被转换为 true 或 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> || <span class="string">&quot;hello&quot;</span>); <span class="comment">// 输出：&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p>总结：</p><p>值解释确保运算可以在一致的数据类型下执行。<br>不同类型的值在运算中会自动转换，但这种转换是隐式的，不是显式的。</p><h3 id="逻辑运算符的优先级"><a href="#逻辑运算符的优先级" class="headerlink" title="逻辑运算符的优先级"></a>逻辑运算符的优先级</h3><p>JavaScript 的逻辑运算符 (&amp;&amp;, ||, 和 !) 的优先级低于算术、比较和字符串操作符。理解这一点可以帮助你准确预测表达式的执行顺序。</p><p>示例：<br>以下表达式中，typeof null 和 typeof undefined 分别会被计算为 “object” 和 “undefined”：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">&#x27;undefined&#x27;</span>; <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure><p>运算符优先级总结（从高到低）：<br>算术运算符 (+, -, *, &#x2F;, %, ** 等)<br>比较运算符 (&gt;, &lt;, &#x3D;&#x3D;, &#x3D;&#x3D;&#x3D;, !&#x3D;, !&#x3D;&#x3D;)<br>运算符 (&amp;, |, ^, ~)<br>字符串操作符 ([], ., () 等)<br>逻辑运算符 (&amp;&amp;, ||, !)<br>括号</p><p>示例：</p><p>以下表达式的执行顺序遵循运算符的优先级：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> + <span class="number">3</span> &gt; <span class="number">5</span> &amp;&amp; <span class="string">&quot;10&quot;</span> &lt; <span class="string">&quot;2&quot;</span>); <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure><p>首先计算 2 + 3（结果为 5）。<br>然后比较 5 &gt; 5，结果为 false。<br>最后执行逻辑与运算 (&amp;&amp;)，因为前一个条件为 false，整个表达式的结果为 false。</p><h3 id="运算符优先级总结"><a href="#运算符优先级总结" class="headerlink" title="运算符优先级总结"></a>运算符优先级总结</h3><p>以下是 JavaScript 中主要运算符的优先级（从高到低）：</p><p>算术运算符：<br>+, -, *, &#x2F;, %, **<br>比较运算符：<br>&lt;, &gt;, &#x3D;&#x3D;, &#x3D;&#x3D;&#x3D;, !&#x3D;, !&#x3D;&#x3D;<br>运算符：<br>&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;,<br>字符串操作符：<br>[], ., ()<br>逻辑运算符：<br>&amp;&amp;, ||  !<br>括号 (())：用于改变执行顺序</p><p>示例：</p><p>以下表达式中，typeof null &#x3D;&#x3D;&#x3D; ‘object’ &amp;&amp; typeof undefined &#x3D;&#x3D;&#x3D; ‘undefined’ 的优先级如下：</p><p>首先计算 typeof null（结果为 “object”）。<br>然后计算 typeof undefined（结果为 “undefined”）。<br>最后执行逻辑与运算 (&amp;&amp;)。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>问题1：为什么 null || undefined 的结果是 undefined？<br>这是因为逻辑或运算符 (||) 在遇到 false（或空值）时会优先返回后面的值。在 JavaScript 中：</p><p>typeof null &#x3D;&#x3D;&#x3D; ‘object’，但在逻辑运算中会被解释为 false。<br>typeof undefined &#x3D;&#x3D;&#x3D; ‘undefined’。</p><p>因此：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> || <span class="literal">undefined</span>; <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure><p>问题2：为什么 “5” + “6” 的结果是 “11”？<br>这是因为字符串拼接的优先级低于算术加法。JavaScript 会将两个字符串相加，而不是尝试将它们转换为数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;5&quot;</span> + <span class="string">&quot;6&quot;</span>); <span class="comment">// 输出：&quot;11&quot;</span></span><br></pre></td></tr></table></figure><p>问题3：为什么 0 || “” 的结果是 “”？<br>这是因为逻辑或运算符 (||) 在遇到 false（或空值）时会优先返回后面的值。在这里：</p><p>0 被视为 false。<br>“ “ 被视为非空字符串，因此会被返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> || <span class="string">&quot;&quot;</span>); <span class="comment">// 输出：&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础阶段二</title>
      <link href="/2025/03/01/JavaScript/%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/"/>
      <url>/2025/03/01/JavaScript/%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="分支语句和循环语句"><a href="#分支语句和循环语句" class="headerlink" title="分支语句和循环语句"></a>分支语句和循环语句</h1><h2 id="逐步解决方案"><a href="#逐步解决方案" class="headerlink" title="逐步解决方案"></a>逐步解决方案</h2><p>步骤 1：理解分支语句</p><p>条件判断：使用 if 和 else if 进行多层条件判断。<br>嵌套结构：可以将分支语句嵌入到其他分支中，实现复杂的逻辑。</p><p>步骤 2：理解循环语句<br>重复执行：使用 for, while 或 do…while 循环控制程序的执行次数。<br>条件判断：根据特定条件决定是否继续执行循环体。</p><p>步骤 3：结合分支与循环<br>嵌套结构：将分支语句嵌入到循环体内，或者反过来使用循环来处理分支中的逻辑。</p><p>步骤 4：应用示例 - 计算最大公约数（GCD）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">gcd</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (b !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示全部 (9)<br>步骤 5：应用示例 - 统计元音字母数量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countVowels</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> vowels = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>]);</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vowels.<span class="title function_">has</span>(char)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示全部 (11)<br>步骤 6：应用示例 - 计算阶乘</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Factorial not defined for negative values.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示全部 (11)<br>最终答案<br>通过掌握分支语句和循环语句的使用，可以有效地解决问题。以下是对问题的逐步解答：</p><p>分支语句：用于在程序运行中根据条件执行不同的代码块。<br>循环语句：用于重复执行同一段代码，直到满足特定条件。<br>嵌套结构：将分支和循环嵌入到其他结构中，实现复杂的逻辑控制。</p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>什么是 Switch 语句？</p><p>Switch 语句是一种控制结构，用于根据一个表达式的结果来执行不同的代码块。它类似于其他编程语言中的多路选择（如 C 语言的 switch-case）。</p><p>基本语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">value1</span>:</span><br><span class="line">        <span class="comment">// 执行的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">value2</span>:</span><br><span class="line">        <span class="comment">// 执行的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="comment">// 默认执行的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能说明<br>expression：一个表达式，其结果决定了执行哪个 case。<br>value1, value2 等：可能是一个具体的值或一个模式匹配的结果。<br>break;：结束当前的 case，并执行下一个代码块。<br>与 if-else 的区别<br>Switch 语句允许多个 case，并且每个 case 可以有复杂的模式匹配（如正则表达式）。此外，switch 语句还能使用 default 标识符来处理所有未匹配的情况。</p><p>示例 1：简单 switch 语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (age) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>-<span class="number">19</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;小于20岁的人&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">20</span>-<span class="number">29</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;20岁到29岁的年轻人&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;其他人&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p>TEXT<br>20岁到29岁的年轻人<br>示例 2：使用正则表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(str) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="regexp">/^H/</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;以H开头的字符串&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;不以H开头的字符串&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p>TEXT<br>以H开头的字符串<br>示例 3：组合 switch 和 if</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> score = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(score) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">90</span>-<span class="number">100</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;满分&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">80</span>-<span class="number">89</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;一般&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 4：使用 switch 处理不同类型的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="string">&quot;integer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(data) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;integer&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;float&#x27;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据类型为 number&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据类型为 string&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;未知的数据类型&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型为 number</span><br></pre></td></tr></table></figure><p>总结</p><p>Switch 语句非常适合处理需要根据多个条件执行不同代码块的场景，尤其是当这些条件可以使用正则表达式或复杂的模式匹配时。它使得代码更加清晰和易于维护。</p><p>在实际项目中，switch 语句通常用于：</p><p>根据数据类型（如 number, string, object 等）进行分类。<br>根据输入的值范围（如年龄、分数等）进行分组处理。<br>处理需要多个分支条件的情况，且这些条件可以复用。</p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>三元运算符是一种在JavaScript中用于在两种情况之间选择一个值的运算符。它是一种简洁的条件表达式，可以将一个 if 语句压缩为一行代码。</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? expression_if_true : expression_if_false</span><br></pre></td></tr></table></figure><p>condition：一个需要进行判断的表达式（通常是布尔值）。<br>expression_if_true：如果 condition 为真时执行的表达式。<br>expression_if_false：如果 condition 为假时执行的表达式。</p><p>功能</p><p>三元运算符可以将一个复杂的 if…else 结构简化为一行代码，同时保持逻辑清晰。</p><p>使用示例<br>简单条件判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a &gt; <span class="number">0</span> ? <span class="string">&quot;a is positive&quot;</span> : <span class="string">&quot;a is not positive&quot;</span>); <span class="comment">// 输出：&quot;a is positive&quot;</span></span><br></pre></td></tr></table></figure><p>注意事项<br>优先级：三元运算符的优先级低于算术运算符（如 +, -, *, &#x2F; 等），但高于比较运算符。因此，在复杂的表达式中，可能需要使用括号来明确运算顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> + <span class="number">5</span> &gt; <span class="number">2</span> ? <span class="string">&quot;真&quot;</span> : <span class="string">&quot;假&quot;</span>); <span class="comment">// 输出：&quot;真&quot;</span></span><br></pre></td></tr></table></figure><p>简洁性：虽然三元运算符可以简化代码，但它并不总是更适合所有情况。在复杂的逻辑中，if…else 结构可能更清晰易读。</p><p>总结</p><p>三元运算符是一种非常有用的工具，可以帮助我们将 if…else 结构压缩为一行代码，并且保持逻辑清晰。它特别适合简单的条件判断场景，但在处理复杂的逻辑时，可能会显得不够直观。因此，在使用三元运算符时，请注意以下几点：</p><p>使用括号明确运算顺序。<br>在复杂的逻辑中，优先选择清晰的 if…else 结构。<br>三元运算符可以与数组或对象进行结合（如练习题中的 map 或 filter 方法）。</p><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><h3 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h3><p>使用循环结构逐个访问数组中的每个元素。</p><p>步骤：</p><p>初始化一个变量作为索引，通常从0开始。<br>确定循环结束条件，通常是索引小于数组长度。<br>在每次迭代中，访问当前索引对应的元素，并执行需要的操作。<br>更新索引值，继续下一个循环。<br>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>通过函数自身调用来逐层处理数组中的每个元素。</p><p>步骤：</p><p>定义一个递归函数，接受数组和当前索引作为参数。<br>在函数中检查是否完成了所有元素的遍历（结束条件）。<br>如果未完成，执行当前操作，并递归调用自己，处理下一个元素。<br>更新递归时使用的索引值。<br>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">recursiveLoop</span>(<span class="params">array, index = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= array.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(array[index]);</span><br><span class="line">    <span class="title function_">recursiveLoop</span>(array, index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="title function_">recursiveLoop</span>(array);</span><br></pre></td></tr></table></figure><p>总结<br>循环遍历适合处理大部分数组操作，因为它简单且效率高。而递归遍历适用于需要逐层处理或分阶段完成任务的情况，但需注意避免栈溢出问题。</p><p>通过理解和实践这两种方法，可以更好地掌握数组遍历的实现与应用。</p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><ol><li>增（Insert）<br>push(): 将元素添加到数组末尾。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">4</span>); <span class="comment">// 现在arr是[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>unshift(): 将元素插入到数组最前面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="number">0</span>); <span class="comment">// 现在arr是[0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>splice(index, [number]): 删除指定索引处的元素，并将新元素插入到该位置之前的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>); <span class="comment">// 现在arr是[1, 4, 2, 3]</span></span><br></pre></td></tr></table></figure><ol start="2"><li>删（Delete）<br>pop(): 删除并返回数组的最后一个元素。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">poppedValue = arr.<span class="title function_">pop</span>(); <span class="comment">// poppedValue是3，现在arr是[1, 2]</span></span><br></pre></td></tr></table></figure><p>indexOf(element): 返回指定元素的第一个索引位置。如果找不到该元素，则返回-1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">index = arr.<span class="title function_">indexOf</span>(<span class="number">2</span>); <span class="comment">// index是1</span></span><br></pre></td></tr></table></figure><p>splice(index, removeItemCount&#x3D;0): 删除指定索引处的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 现在arr是[2, 3]</span></span><br></pre></td></tr></table></figure><ol start="3"><li>改（Update）<br>直接赋值: 访问数组中特定索引的位置并将其值修改。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">4</span>; <span class="comment">// 现在arr是[4, 2, 3]</span></span><br></pre></td></tr></table></figure><p>使用slice()和concat(): 复制数组的一部分，修改后的内容再合并回原数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> updatedPart = arr.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 取前两个元素</span></span><br><span class="line">updatedPart[<span class="number">0</span>] = <span class="number">5</span>; <span class="comment">// 修改第一个元素为5</span></span><br></pre></td></tr></table></figure><p>arr &#x3D; updatedPart.concat(arr.slice(1)); &#x2F;&#x2F; 现在arr是[5, 3]</p><ol start="4"><li>查（Search）</li></ol><p>indexOf(element): 返回指定元素的第一个索引位置，或-1表示不存在。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">index = arr.<span class="title function_">indexOf</span>(<span class="number">2</span>); <span class="comment">// index是1</span></span><br></pre></td></tr></table></figure><p>includes(element): 返回布尔值，判断数组中是否存在该元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">includes</span>(<span class="number">4</span>)); <span class="comment">// 输出false</span></span><br></pre></td></tr></table></figure><p>通过这些方法的学习和实践，可以高效地进行数组的增删改查操作。选择合适的方法根据具体需求，既能提高代码效率，也能让代码更加简洁易懂。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式</title>
      <link href="/2025/02/21/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/Lambda%E6%96%B9%E6%B3%95/"/>
      <url>/2025/02/21/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/Lambda%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="如何给Lambda赋值给委托"><a href="#如何给Lambda赋值给委托" class="headerlink" title="如何给Lambda赋值给委托"></a>如何给Lambda赋值给委托</h1><p>在 C# 中，Lambda表达式（也称为 匿名方法、局部函数 或 函数表达式）是一种简洁的方式来定义和调用小型函数。它允许你在代码中直接嵌入简单的函数逻辑，而无需显式地声明完整的函数。</p><p><img src="/img%5CHello%5CSnipaste_2025-02-21_16-18-05.png"></p><p><img src="/img%5CHello%5CSnipaste_2025-02-21_16-24-23.png"></p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> charp编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型，partial类，枚举，结构</title>
      <link href="/2025/02/21/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/%E6%B3%9B%E5%9E%8B%EF%BC%8Cpartial%E7%B1%BB%EF%BC%8C%E6%9E%9A%E4%B8%BE%EF%BC%8C%E7%BB%93%E6%9E%84/"/>
      <url>/2025/02/21/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/%E6%B3%9B%E5%9E%8B%EF%BC%8Cpartial%E7%B1%BB%EF%BC%8C%E6%9E%9A%E4%B8%BE%EF%BC%8C%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型（generic）无处不在"><a href="#泛型（generic）无处不在" class="headerlink" title="泛型（generic）无处不在"></a>泛型（generic）无处不在</h1><p>为什么需要泛型：避免成员膨胀或者类型膨胀<br>正交性：泛型类型（类&#x2F;接口&#x2F;委托&#x2F;···）、泛型成员（属性&#x2F;方法&#x2F;字段&#x2F;···）<br>类型方法的参数推断<br>泛型与委托、lambda表达式</p><p>泛型基本使用<br><img src="/img%5CHello%5CSnipaste_2025-02-21_13-19-57.png"></p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型有良好的正交性</p><p><img src="/img%5CHello%5CSnipaste_2025-02-21_13-34-30.png"></p><h2 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h2><p><img src="/img%5CHello%5CSnipaste_2025-02-21_13-45-15.png"></p><h2 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h2><p><img src="/img%5CHello%5CSnipaste_2025-02-21_14-50-02.png"></p><h1 id="partial类"><a href="#partial类" class="headerlink" title="partial类"></a>partial类</h1><p>减少类的派生<br>partial类与Entity Framework<br>partial类与Windows Forms,WPF,ASP.NET Core</p><p>步骤一：理解“Partial”在编程中的常见用法</p><p>“Partial”通常用于表示某种部分性、不完整或偏导数的概念。在数学中，偏导数指的是多变量函数对其中一个变量的导数。<br>步骤二：查找C#中的相关类型和命名conventions</p><p>在C#标准库中，没有名为“Partial”的内置类型。<br>第三方库或自定义项目可能会引入名为“Partial”的类或结构。<br>步骤三：推测“Partial”类可能的功能</p><p>假设这是一个自定义的数据结构，用于表示某种部分状态、记录变化或者存储中间结果。<br>可能与多线程、事件处理或其他需要部分执行的结果相关。<br>步骤四：验证假设</p><p>查找项目文档或代码库中的定义，确认“Partial”类的具体用途和实现细节。<br>如果找不到明确的定义，可能需要进一步询问开发者或查看使用场景。<br>总结：</p><p>在C#中，“Partial”作为一个类名通常没有标准的意义。它可能是自定义的、用于特定业务逻辑的数据结构。为了确切理解它的作用，请参考项目文档或相关代码。</p><h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><p>人为限定取值范围的整数<br>整数值的对应<br>比特位式用法</p><p><img src="/img%5CHello%5CSnipaste_2025-02-21_15-32-17.png"></p><h1 id="结构体（struct）"><a href="#结构体（struct）" class="headerlink" title="结构体（struct）"></a>结构体（struct）</h1><p>值类型，可装&#x2F;拆箱<br>可实现接口，不能派生自类&#x2F;结构体<br>不能有显示无参构造器</p><p><img src="/img%5CHello%5CSnipaste_2025-02-21_15-47-39.png"></p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> charp编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射与依赖注入</title>
      <link href="/2025/02/21/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/%E5%8F%8D%E5%B0%84%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2025/02/21/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/%E5%8F%8D%E5%B0%84%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="反射与依赖注入"><a href="#反射与依赖注入" class="headerlink" title="反射与依赖注入"></a>反射与依赖注入</h1><p>反射：以不变应万变（更松的耦合）<br>反射与接口的结合<br>反射与特性的结合<br>依赖注入：此DI非DI，但没有彼DI就没有此DI···</p><h2 id="依赖注入基本用法"><a href="#依赖注入基本用法" class="headerlink" title="依赖注入基本用法"></a>依赖注入基本用法</h2><p>右击项目选择NuGet包，安装Microsoft.Extensions.DependencyInjection。</p><p><img src="/img%5CHello%5CSnipaste_2025-02-21_11-45-56.png"></p><p>依赖 是一个被其他对象所依赖的对象。</p><p>提供者（Provider） 负责创建并返回这些依赖对象。</p><p>接收者（接收依赖的组件或类）会显式地获取这些依赖，并通过它们来实现特定的功能。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ol><li>反射的基本作用</li></ol><p>反射（Reflection）是C#语言中一个非常强大的机制，允许程序在运行时动态地访问类、字段、方法和事件等信息。通过反射，你可以：</p><p>获取或修改对象的属性值。<br>执行或取消执行某个方法。<br>访问与当前对象相关的其他对象，如其父类、子类等。<br>反射的强大之处在于它的灵活性和动态性，使得它在许多编程场景中都能发挥重要作用。</p><ol start="2"><li>“Partial”在C#中的含义</li></ol><p>“Partial”不是一个标准的内置类型或功能。根据上下文，它可能有以下几种解释：</p><p>部分类（Partial Class）：在C#中，System.ComponentModel.IComponent接口的一个子接口，可以用来定义一个可被反射操作访问的部分（partial）。这部分是整个系统的一个独立实体，但不是完整的组件。</p><p>部分属性或方法：可能指某些特定于某个框架或库的“部分”功能，比如在WPF中用于表示一部分视图或行为。</p><p>自定义类或功能模块：也可能是一个自定义的类或功能模块，用来实现某种特定的功能，并通过反射进行动态操作。</p><p>如果“Partial”与其他概念结合使用（如与Reflection结合），可能表示一种特定的反射机制或操作方式。</p><ol start="3"><li>反射在实际开发中的应用</li></ol><p>反射在C#中有广泛的应用场景，以下是几个典型例子：</p><p>依赖注入（Dependency Injection）：通过反射动态地注入对象到其他对象中，避免手动初始化复杂的构造函数。</p><p>事件监听与绑定：使用反射绑定事件以实现组件之间的动态通信和交互。</p><p>游戏开发中的元编程：在游戏开发中，反射可以用来动态绑定游戏对象的属性、方法等，简化开发流程。</p><p>服务注册与解除：通过Reflection API动态注册或解除与框架相关的依赖项，提升系统的灵活性和可扩展性。</p><ol start="4"><li>反射与其他语言的比较</li></ol><p>虽然C#和其他编程语言如Java都支持反射机制，但它们之间的主要区别在于：</p><p>功能和能力：C#的Reflection API比Java更强大，提供了更多关于对象、类和编译信息的操作方法。</p><p>使用场景：C#中的Reflection在类型安全性和动态性方面有更高的要求，需要谨慎使用。</p><p><img src="/img%5CHello%5CSnipaste_2025-02-22_16-16-12.png"></p><p><img src="/img%5CHello%5CSnipaste_2025-02-22_17-33-38.png"></p><h2 id="总结：反射就是操作dll文件的一个类库"><a href="#总结：反射就是操作dll文件的一个类库" class="headerlink" title="总结：反射就是操作dll文件的一个类库"></a>总结：反射就是操作dll文件的一个类库</h2>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> charp编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp入门详解学习笔记</title>
      <link href="/2025/02/08/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/02/08/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/csharp%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="用C-编写的各类应用程序，用Visual-Studio写出Hello-word"><a href="#用C-编写的各类应用程序，用Visual-Studio写出Hello-word" class="headerlink" title="用C#编写的各类应用程序，用Visual Studio写出Hello word!!!."></a>用C#编写的各类应用程序，用Visual Studio写出Hello word!!!.</h1><h1 id="第一个：Console"><a href="#第一个：Console" class="headerlink" title="第一个：Console"></a>第一个：Console</h1><p>打开Visual Studio新建项目选择<b>控制台应用</b><br>会自动帮我们生成最基本的C#的Main方法，在Main中输入Console.WrinteLine(“Hello World!”);按ctrl+F5进行调式。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">namespace</span> <span class="title">Console_Hello_world</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           Console.WrinteLine(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="第二个：Windows-Forms-Old"><a href="#第二个：Windows-Forms-Old" class="headerlink" title="第二个：Windows Forms(Old)"></a>第二个：Windows Forms(Old)</h1><p>打开Visual Studio新建项目选择<b>Windows窗体应用(.NET Framework)</b><br>会自动生成一个Form1的窗口<br>如下：<br><img src="/img%5CHello%5CForm-helloworld.png"></p><p>在工具箱中搜索button和Textbox，将其拖到窗体上。</p><p><img src="/img%5CHello%5CForm-helloworld-2.png"></p><p>左边没有工具箱，在菜单栏中选择视图选选卡，在下拉列表中选着工具箱。</p><p>属性面板中可以看到按钮的各种属性，选择button，在属性面板中将Text改为“Click Me!” </p><p><img src="/img%5CHello%5CForm-helloworld-3.png"></p><p>在属性面板中选择事件按钮</p><p><img src="/img%5CHello%5CForm-helloworld-4.png"></p><p>双击按钮的“Click”事件<br><img src="/img%5CHello%5CForm-helloworld-5.png"></p><p>VS会自动生成一个方法，我们只需要在方法中输入Console.WriteLine(“Hello World!”);即可。</p><p><img src="/img%5CHello%5CForm-helloworld-6.png"></p><p>运行程序，点击按钮，Form1会显示“Hello World!”</p><p><img src="/img%5CHello%5CForm-helloworld-7.png"></p><h1 id="第三个：WPF-Windows-Presentation-Foundation"><a href="#第三个：WPF-Windows-Presentation-Foundation" class="headerlink" title="第三个：WPF(Windows Presentation Foundation)"></a>第三个：WPF(Windows Presentation Foundation)</h1><p>WPF是微软推出的基于.NET Framework的可视化开发框架，可以用来开发桌面应用程序、移动应用程序、Web应用程序、游戏等。</p><p>打开Visual Studio新建项目选择<b>WPF应用程序(.NET Framework)</b><br>会自动生成一个MainWindow的窗口<br>在工具箱中搜索button和Textbox，将其拖到窗体上。<br>步骤和FrameWork Forms类似 </p><p><img src="/img%5CHello%5CWPF-helloworld.png"></p><p><img src="/img%5CHello%5CWPF-helloworld-2.png"></p><p><img src="/img%5CHello%5CWPF-helloworld-3.png"></p><p><img src="/img%5CHello%5CWPF-helloworld-4.png"></p><p><img src="/img%5CHello%5CWPF-helloworld-5.png"></p><h1 id="第四个：ASP-NET-Web-FormS-Old"><a href="#第四个：ASP-NET-Web-FormS-Old" class="headerlink" title="第四个：ASP.NET Web FormS(Old)"></a>第四个：ASP.NET Web FormS(Old)</h1><p>打开Visual Studio新建项目选择<b>ASP.NET Web Forms 应用程序</b></p><p>选择空模板，勾选web窗体，点击确定。</p><p>右击项目，选择添加新项，选择Web窗体，命名为“Default.aspx”，点击添加。<br><img src="/img%5CHello%5CNET-Web-helloworld.png"></p><p>就可以使用HTML、CSS、JavaScript来编写网页了。<br><img src="/img%5CHello%5CFramework-web-helloworld.png"></p><h1 id="第五个：ASP-NET-MVC-Model-View-Controller"><a href="#第五个：ASP-NET-MVC-Model-View-Controller" class="headerlink" title="第五个：ASP.NET MVC(Model-View-Controller)"></a>第五个：ASP.NET MVC(Model-View-Controller)</h1><p>打开Visual Studio新建项目选择<b>ASP.NET MVC 应用(模型-视图-控制器)</b></p><p>选择自带的模板HomeController.cs,在index视图中输入“Hello World!”</p><p>也可以zip下载模板，解压后打开解决方案，找到HomeController.cs，在index视图中输入“Hello World!”<br><img src="/img%5CHello%5CMVC-helloworld.png"></p><p><img src="/img%5CHello%5CMVC-helloworld-2.png"></p><p><img src="/img%5CHello%5CMVC-helloworld-5.png"></p><p><img src="/img%5CHello%5CMVC-helloworld-4.png"></p><h1 id="类库的引用"><a href="#类库的引用" class="headerlink" title="类库的引用"></a>类库的引用</h1><li>类库引用是使用命名空间的物理基础。在C#中，我们可以将代码分成多个文件，每个文件都有自己的命名空间。当我们需要使用某个类库时，我们需要引用它的命名空间。例如，我们需要使用System.IO命名空间，我们可以这样写：using System.IO;。这样，我们就可以在程序中使用System.IO命名空间中的类和方法了。</li><li>不同技术类型的项目会默认引用不同的类库，如Windows Forms项目默认引用System.Windows.Forms命名空间，WPF项目默认引用System.Windows命名空间，ASP.NET Web Forms项目默认引用System.Web命名空间，ASP.NET MVC项目默认引用System.Web.Mvc命名空间。</li><li>DLL引用(黑河引用，无源代码)</li><ol><li>定义与作用<br>DLL 是一个用于存储代码和数据资源的文件，能够在不同应用程序之间动态地共享代码。<br>它类似于 C# 类库（如 System.Collections.Generic），但通常用于外部调用或框架。</li><li>功能特点<br>二进制文件：DLL 是二进制文件，包含类型、静态成员和方法的二进制表示。<br>动态链接：DLL 允许应用程序在运行时动态加载其代码，而不必将其作为可执行文件直接编译。</li><li>类型与结构<br>DLL 文件通常以 .dll 扩展名标识，并由一个或多个 assembly 组成。<br>类型和方法是通过 DLL 中的类型表实现的，允许在 C# 程序中引用外部库。</li><li>常见用途<br>调用外部库：DLL 是大多数 .NET 框架（如 mscorlib、System.Web）的默认形式。例如，mscorlib.dll 包含基础数据类型和方法。<br>框架与组件：许多框架提供 DLL 文件，允许 C# 程序调用其功能。</li><li>管理与使用<br>编译与加载：DLL 是通过编译器在运行时动态加载的。C# 编译器会将类库编译为 DLL。<br>引用方式：在 C# 代码中，可以使用 using 语句或名称空间来引用 DLL 提供的功能。</li><li>常见问题<br>如果项目无法找到 DLL 文件，通常表示路径错误或依赖的 DLL 缺少。检查路径和更新依赖是常见的解决方案。<br>DLL 文件的安全性通常较低，因为它们可以在系统中加载任何代码。因此，在生产环境中应谨慎处理。<br>总结<br>DLL 是 C# 程序中调用外部库或框架的核心工具，通过二进制文件存储代码和数据资源，并在运行时动态加载。理解 DLL 的作用对于编写高效的 .NET 应用程序至关重要。</li></ol><li>NuGet 包管理器</li><p>NuGet 是 Microsoft 提供的 .NET 包管理器，它可以帮助我们轻松地安装、更新和引用第三方类库。</p><ol><li>定义与作用<br>NuGet 是 Microsoft 提供的 .NET 包管理器，它可以帮助我们轻松地安装、更新和引用第三方类库。NuGet 包管理器可以帮助我们管理 .NET 项目的依赖项，包括 NuGet 包。</li><li>功能特点<br>NuGet 包管理器可以帮助我们管理 .NET 项目的依赖项，包括 NuGet 包。<br>NuGet 包可以帮助我们快速、轻松地安装、更新和引用第三方类库。<br>NuGet 包可以帮助我们管理 NuGet 包的版本，包括 NuGet 包依赖项。</li><li>常见用途<br>NuGet 包管理器可以帮助我们管理 .NET 项目的依赖项，包括 NuGet 包。<br>NuGet 包可以帮助我们快速、轻松地安装、更新和引用第三方类库。<br>NuGet 包可以帮助我们管理 NuGet 包的版本，包括 NuGet 包依赖项。</li><li>管理与使用<br>NuGet 包管理器可以帮助我们管理 .NET 项目的依赖项，包括 NuGet 包。<br>NuGet 包可以帮助我们快速、轻松地安装、更新和引用第三方类库。<br>NuGet 包可以帮助我们管理 NuGet 包的版本，包括 NuGet 包依赖项。</li><li>常见问题<br>NuGet 包管理器的安装与使用需要一定的时间，但随着 NuGet 包的增多，它的使用效率会越来越高。<br>NuGet 包管理器的依赖项管理功能可以帮助我们管理 NuGet 包的版本，包括 NuGet 包依赖项。  </li><li>总结<br>NuGet 包管理器是 Microsoft 提供的 .NET 包管理器，它可以帮助我们轻松地安装、更新和引用第三方类库。NuGet 包管理器的安装与使用需要一定的时间，但随着 NuGet 包的增多，它的使用效率会越来越高。NuGet 包管理器的依赖项管理功能可以帮助我们管理 NuGet 包的版本，包括 NuGet 包依赖项。</li></ol><li>项目引用(百盒引用，有源代码)</li><ol><li>定义与作用<br>项目引用是指在一个项目中引用另一个项目的输出文件。</li><li>功能特点<br>项目引用可以帮助我们在一个项目中调用另一个项目的功能。</li><li>常见用途<br>项目引用可以帮助我们在一个项目中调用另一个项目的功能。</li><li>管理与使用<br>项目引用可以帮助我们在一个项目中调用另一个项目的功能。</li><li>常见问题<br>项目引用的管理与使用需要一定的时间，但随着项目的增多，它的使用效率会越来越高。</li><li>总结<br>项目引用是指在一个项目中引用另一个项目的输出文件。项目引用可以帮助我们在一个项目中调用另一个项目的功能。项目引用的管理与使用需要一定的时间，但随着项目的增多，它的使用效率会越来越高。</li></ol><li>依赖关系管理(高内聚低耦合) </li><p>依赖关系管理是指管理项目之间的依赖关系，包括 NuGet 包依赖项、项目依赖项和外部 DLL 依赖项。</p><ol><li>定义与作用<br>依赖关系管理是指管理项目之间的依赖关系，包括 NuGet 包依赖项、项目依赖项和外部 DLL 依赖项。</li><li>功能特点<br>依赖关系管理可以帮助我们管理项目之间的依赖关系。</li><li>常见用途<br>依赖关系管理可以帮助我们管理项目之间的依赖关系。</li><li>管理与使用<br>依赖关系管理可以帮助我们管理项目之间的依赖关系。</li><li>常见问题<br>依赖关系管理的管理与使用需要一定的时间，但随着项目的增多，它的使用效率会越来越高。</li><li>总结</li></ol><h1 id="类的三大成员"><a href="#类的三大成员" class="headerlink" title="类的三大成员"></a>类的三大成员</h1><li>属性(Properties)</li><p>属性是类的成员，它可以获取或设置类的状态。    </p><ol><li>定义与作用<br>属性是类的成员，它可以获取或设置类的状态。</li><li>功能特点<br>属性可以帮助我们在类的外部访问类的状态。</li><li>常见用途<br>属性可以帮助我们在类的外部访问类的状态。</li><li>管理与使用<br>属性的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li><li>常见问题<br>属性的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li><li>总结<br>属性是类的成员，它可以获取或设置类的状态。属性可以帮助我们在类的外部访问类的状态。属性的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li></ol><li>方法(Methods)</li>方法是类的成员，它可以执行一些操作。               <ol><li>定义与作用<br>方法是类的成员，它可以执行一些操作。</li><li>功能特点<br>方法可以帮助我们在类的外部执行一些操作。</li><li>常见用途<br>方法可以帮助我们在类的外部执行一些操作。</li><li>管理与使用<br>方法的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li><li>常见问题<br>方法的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li><li>总结<br>方法是类的成员，它可以执行一些操作。方法可以帮助我们在类的外部执行一些操作。方法的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li></ol><li>事件(Events)</li>事件是类的成员，它可以通知其他对象发生了某些事件。               <ol><li>定义与作用<br>事件是类的成员，它可以通知其他对象发生了某些事件。</li><li>功能特点<br>事件可以帮助我们在类的外部通知其他对象发生了某些事件。</li><li>常见用途<br>事件可以帮助我们在类的外部通知其他对象发生了某些事件。</li><li>管理与使用<br>事件的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li><li>常见问题<br>事件的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li><li>总结<br>事件是类的成员，它可以通知其他对象发生了某些事件。事件可以帮助我们在类的外部通知其他对象发生了某些事件。事件的管理与使用需要一定的时间，但随着类的增多，它的使用效率会越来越高。</li></ol><h1 id="构成C-语言的基本元素"><a href="#构成C-语言的基本元素" class="headerlink" title="构成C#语言的基本元素"></a>构成C#语言的基本元素</h1><li>关键字(Keywords)</li>关键字是C#语言的基本元素，它是C#语言的核心。关键字是C#语言的基本语法单位，它是C#语言的构建块。关键字的作用是用来定义程序的结构、控制流、数据类型、方法、变量、常量、运算符、命名空间、类、接口、结构、枚举、委托等。<b>在MSDN文档有对关键字的详细介绍。</b>             <li>运算符(Operators)</li>运算符是C#语言的基本元素，它是C#语言的核心。运算符是C#语言的基本语法单位，它是C#语言的构建块。运算符的作用是用来执行各种操作，如算术运算、赋值运算、逻辑运算、比较运算、位运算、条件运算等。<b>在MSDN文档有对运算符的详细介绍。</b><li>标识符(Identifiers)</li><ol><li>什么是合法标识符？<br>标识符是不能和关键字重组（关键字已经被赋予了特殊的含义）、不能以数字开头、不能包含特殊字符。<br>标识符可以由字母、下划线或者汉字（但不建议使用汉字）开头。<br>标识符的命名规范：</li></ol><ul><li>标识符的命名必须遵循驼峰命名法。</li><li>标识符的命名必须见名知意。</li><li>标识符的命名必须简短、易于理解。</li></ul><li>标点符号(Punctuation)</li>标点符号是C#语言的基本元素，它是C#语言的核心。标点符号是C#语言的基本语法单位，它是C#语言的构建块。标点符号的作用是用来定义程序的语法结构。<b>在MSDN文档有对标点符号的详细介绍。</b><li>文本(Text)</li><li>注释与空白(Comments and Whitespace)</li>![](img\Hello\tokne.png)<h1 id="初始类型、变量和方法"><a href="#初始类型、变量和方法" class="headerlink" title="初始类型、变量和方法"></a>初始类型、变量和方法</h1><li>初始类型(Primitive Types)</li><p><img src="/img%5CHello%5Ctype.png"></p><li>变量(Variables)</li><p>变量的声明<br>变量的使用</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x;</span><br><span class="line">x = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><li>方法(Methods)</li><p>方法的声明<br>方法的调用</p><p><img src="/img%5CHello%5Cfangfa.png"></p><li>程序=数据+算法</li><p><b>有了变量和方法，我们就可以编写有意义的程序了。</b></p><h1 id="C-语言的类型系统"><a href="#C-语言的类型系统" class="headerlink" title="C#语言的类型系统"></a>C#语言的类型系统</h1><h2 id="C-的五大数据类型"><a href="#C-的五大数据类型" class="headerlink" title="C#的五大数据类型"></a>C#的五大数据类型</h2><li>类（Class）：如Windows、Form、Console、String等</li><li>结构体（Structures）：如Int32、Int64、Single、Double等</li><li>枚举（Enumerations）：如HorizontalAlignment、Visibility等</li><li>接口（Interfaces）：如IEnumerable、IDisposable等</li><li>委托（Delegates）：如EventHandler、Func等</li><h2 id="C-类型的派生谱系"><a href="#C-类型的派生谱系" class="headerlink" title="C#类型的派生谱系"></a>C#类型的派生谱系</h2><p><img src="/img%5CHello%5CObject.png"></p><h1 id="变量、对象与内存"><a href="#变量、对象与内存" class="headerlink" title="变量、对象与内存"></a>变量、对象与内存</h1><h2 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h2><blockquote><p>变量&#x3D;以变量名所对应的内存地址为起点、以其他数据类型所要求的存储空间为长度的一块内存区域</p></blockquote><li>表面上来看，变量的用途是存储数据</li><li>实际上，变量表示了存储位置，并且每个变量都有一个类型，与决定什么样的值能供存入变量</li><li>变量一共有7种</li>静态变量、实例变量(成员变量、字段)、数组元素、值参数、(ref)引用参数、(out)输出参数、局部参数<li>狭义的变量指局部变量、因为其它种类的变量都有自己的约定名称（局部变量就是方法体里的声明的变量）</li><li>变量的声明</li>有效的修饰符组合opt类型变量名初始化器opt<h2 id="值类型的变量"><a href="#值类型的变量" class="headerlink" title="值类型的变量"></a>值类型的变量</h2><li>以byte/sbtye/short/ushort/为例</li><li>值类型没有实例、所谓的“实例”与变量合而为一</li><h2 id="引用类型的变量"><a href="#引用类型的变量" class="headerlink" title="引用类型的变量"></a>引用类型的变量</h2><li>引用类型变量与实例的关系：引用类型变量里存储的数据是对象的内存地址<h1 id="装箱与拆箱（Boxing-Unboxing）"><a href="#装箱与拆箱（Boxing-Unboxing）" class="headerlink" title="装箱与拆箱（Boxing&amp;Unboxing）"></a>装箱与拆箱（Boxing&amp;Unboxing）</h1><li>装箱：将值类型转换为引用类型</li><li>拆箱：将引用类型转换为值类型</li><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>操作符预览：<br><img src="/img%5CHello%5CCAHOZUOFU.png"></p><p>操作符优先级从上往下依次降低，同一行的操作符优先级相同。<br>相同操作符在表达式中运算顺序是从左往右决定。</p><p>但赋值和lanbda表达式的优先级不同。<br>他是从右往左运算的。</p><h1 id="Typeof操作符"><a href="#Typeof操作符" class="headerlink" title="Typeof操作符:"></a>Typeof操作符:</h1><p><img src="/img%5CHello%5CSnipaste_2025-02-11_11-48-57.png"></p><h1 id="var和new的组合"><a href="#var和new的组合" class="headerlink" title="var和new的组合"></a>var和new的组合</h1><p>将 var 和 new 结合使用在 C# 中是一种常见的语法糖，提供了更加简洁和清晰的代码写法。具体来说：</p><p>语义上的优化：</p><p>使用 var new Type obj &#x3D; new Type(); 可以让编译器更清楚地理解变量是在初始化哪个对象或数组中。<br>保持一致性：</p><p>这种组合使得在定义和初始化对象时的代码风格一致，有助于提高可读性和维护性。<br>多态性的支持：</p><p>当目标类型是多态类型时，结合 var 和 new 可以更自然地处理继承或接口实现的情况。<br>扩展性和灵活性：</p><p>这种语法糖允许在初始化复杂的对象、数组或其他结构时保持代码的简洁和可读性。</p><h1 id="checked操作符"><a href="#checked操作符" class="headerlink" title="checked操作符"></a>checked操作符</h1><p><img src="/img%5CHello%5CSnipaste_2025-02-11_13-04-03.png"></p><h1 id="逻辑“与”、“XOR”、“OR”运算符"><a href="#逻辑“与”、“XOR”、“OR”运算符" class="headerlink" title="逻辑“与”、“XOR”、“OR”运算符"></a>逻辑“与”、“XOR”、“OR”运算符</h1><p> <img src="/img%5CHello%5CSnipaste_2025-02-11_15-28-48.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-11_15-34-07.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-11_15-38-04.png"></p><h1 id="null合并运算符"><a href="#null合并运算符" class="headerlink" title="null合并运算符"></a>null合并运算符</h1><p><img src="/img%5CHello%5CSnipaste_2025-02-11_15-58-53.png"></p><h1 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h1><p><img src="/img%5CHello%5CSnipaste_2025-02-11_16-08-30.png"></p><h1 id="操作符的本质"><a href="#操作符的本质" class="headerlink" title="操作符的本质"></a>操作符的本质</h1><li>操作符不能脱离与它关联的数据类型</li>可以说操作符就是与固定数据类型相关联的一套基本算法的简记法为自定义数据类型创造操作符<p><img src="/img%5CHello%5Ccao.png"></p><p><img src="/img%5CHello%5CSnipaste.png"></p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><li>隐式类型转换</li>不丢失精度的转换<p><img src="/img%5CHello%5CSnipaste_2025-02-11_14-11-41.png"></p><p>子类向父类的转换</p><p>装箱</p><li>显式类型转换</li>有可能丢失精度（甚至发生错误）拆箱使用Convert类ToString()方法与各数据类型的Parse/TryParse方法<h1 id="表达式的定义"><a href="#表达式的定义" class="headerlink" title="表达式的定义"></a>表达式的定义</h1><li>算法逻辑的最基本（最小）单元，表达一定的算法意图</li><li>因为操作符有优先级，所以表达式也有优先级</li><h1 id="C-语言中表达式的分类"><a href="#C-语言中表达式的分类" class="headerlink" title="C#语言中表达式的分类"></a>C#语言中表达式的分类</h1><li>A value.Every value has an associated type.任何能得到值的运算（回顾操作符和结果类型）</li><li>A variable.Every variable has an associated type.</li><li>A namespace</li><li>A type.</li><li>A method group. 例如：Console.WriteLine,这是一组方法，重载决策决定具体调用哪个方法</li><li>A null literal.</li><li>An anonymous function.</li><li>A property access.</li><li>An event access.</li><li>An indexer access.</li><li>Nothing.对返回值为void的方法的调用</li><h1 id="符合表达式的求值"><a href="#符合表达式的求值" class="headerlink" title="符合表达式的求值"></a>符合表达式的求值</h1><p>操作符的优先级和同优先级操作符的运算方向</p><h1 id="C-语言对语句的定义"><a href="#C-语言对语句的定义" class="headerlink" title="C#语言对语句的定义"></a>C#语言对语句的定义</h1><li>C#语言的语句除了能够让程序员“顺序地（sequentially）”表达算法思想，还能通过条件判断、跳转和循环等方法控制程序逻辑的走向</li><li>简言之就是：陈述算法思想，控制逻辑走向，完成有意义的动作（action）</li><li>C#语言的语句由分号（;）结尾，但由分号结尾的不一定都是语句</li><li>语句一定是出现在方法体里</li><h1 id="什么是字段"><a href="#什么是字段" class="headerlink" title="什么是字段"></a>什么是字段</h1><p>字段是类型的成员，写在类里面的才是字段，写在函数里面叫局部变量</p><p>字段（field）是一种表示与对象或类型（类与结构体）关联的变量<br>字段是类型的成员，也叫“成员变量”<br>与对象关联的字段亦称“实例字段”<br>与类相关联的字段称为“静态字段”，由static修饰</p><h1 id="字段的初始化"><a href="#字段的初始化" class="headerlink" title="字段的初始化"></a>字段的初始化</h1><p>无显示初始化时，字段获得其类型的默认值，所以字段“永远都不会被初始化”<br>实例字段初始化的时机————对象创建时<br>静态字段初始化的时机————类型被加载（load）时</p><h1 id="readonly-只读字段"><a href="#readonly-只读字段" class="headerlink" title="readonly(只读字段)"></a>readonly(只读字段)</h1><p><b>“readonly”字段在C#编程中有着广泛的应用价值。它不仅有助于提高代码的质量和可维护性，还能有效保障数据的一致性和安全性，适用于多个领域和技术栈中的开发实践。</b></p><p>声明上下文 </p><p>只能在模块级别使用 ReadOnly。 这意味着 ReadOnly 元素的声明上下文必须是类、结构或模块，不能是源文件、命名空间或过程。</p><p>组合修饰符</p><p>不能在同一过程声明中同时指定 ReadOnly 和 Static。</p><p>赋值</p><p>使用 ReadOnly 属性的代码无法设置其值。 但能够访问基础存储的代码可随时赋值或更改值。<br>只能在 ReadOnly 变量的声明中或在定义它的类或结构的构造函数中为其赋值</p><p><img src="/img%5CHello%5CSnipaste_2025-02-15_21-00-06.png"></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p><img src="/img%5CHello%5CSnipaste_2025-02-15_22-54-28.png"></p><p>什么是属性<br><img src="/img%5CHello%5CSnipaste_2025-02-15_22-33-04.png"></p><p><img src="/img%5CHello%5CSnipaste_2025-02-15_22-33-00.png"></p><p>属性的声明</p><p><img src="/img%5CHello%5CSnipaste_2025-02-15_22-32-53.png"></p><p>动态属性</p><p><img src="/img%5CHello%5CSnipaste_2025-02-15_22-53-36.png"></p><h1 id="常量（const）"><a href="#常量（const）" class="headerlink" title="常量（const）"></a>常量（const）</h1><p><img src="/img%5CHello%5CSnipaste_2025-02-15_23-07-18.png"></p><h1 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h1><p> 引用参数是用ref修饰符声明的形参。与值形参不同，引用形参并不创建新的存储位置。相反，引用形参表示的存储位置恰是方法调用中作为实参给出的那个变量所表示的存储位置。</p><p> 当形参为引用形参时，方法调用中的对应实参必须由关键字ref并后接一个与形参类型相同的variable-reference（变量引用）组成。变量在可以作为引用形参传递之前，必须先明确赋值。</p><p> 在方法内部，引用形参始终被认为是明确赋值的。<br> 声明为迭代器的方法不能有引用形参。</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_10-35-37.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_10-52-51.png"></p><p> 不创建新对象只改变对象值</p><h1 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h1><p> 用out修饰符声明的形参是输出形参。类似于引用形参，输出形参不创建新的内存位置。相反，输出形参表的存储位置恰是在该方法调用中作为实参给出的那个变量所表示的存储位置。</p><p> 当形参为输出形参时，方法调用中的相应实参必须由关键字out并后接一个与形参类型相同的varable-reference组成。变量在可以作为输出形参传递之前不一定需要明确赋值，但是在将变量作为输出形参传递的调用之后，该变量被认为是明确赋值的。</p><p> 在方法内部，与局部变量相同，输出形参最初被认为是未赋值的，因而必须在使用它的值之前明确赋值。</p><p> 在方法返回之前，该方法的每个输出形参都必须明确赋值。</p><p> 声明为部分方法或迭代器的方法不能有输出形参。</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_11-34-04.png"></p><p> 如何使用引用类型参数<br> <img src="/img%5CHello%5CSnipaste_2025-02-16_12-05-39.png"></p><h1 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h1><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_13-16-35.png"></p><h1 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h1><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_13-30-20.png"></p><h1 id="扩展方法（this参数）"><a href="#扩展方法（this参数）" class="headerlink" title="扩展方法（this参数）"></a>扩展方法（this参数）</h1><p> 方法必须是公有、静态的、即被public static所修饰<br> 必需是形参列表中的第一个，由this修饰<br> 必需由一个静态类（一般类名为SomeTypeExtension）来统一收纳对SomeType类型的扩展方法</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_15-23-17.png"></p><h1 id="什么是委托"><a href="#什么是委托" class="headerlink" title="什么是委托"></a>什么是委托</h1><p> 委托（delegate）是函数指针的“升级版”</p><p> 一切皆地址<br> 变量（数据）是以某个地址为起点的一段内存中所存储的值<br> 函数（算法）是以某个地址为起点的一段内存中所存储的一组机器语言指令</p><p> 直接调用与间接调用<br> 直接调用：通过函数名来调用函数，CPU通过函数名直接获得函数所在地址并开始执行,返回<br> 间接调用：通过函数指针来调用函数，CPU通过读取函数指针存储的值获得函数所在地址并开始执行，返回</p><p> Action委托</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_16-18-04.png"></p><p> Func委托</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_16-29-37.png"></p><h1 id="委托的声明（自定义委托）"><a href="#委托的声明（自定义委托）" class="headerlink" title="委托的声明（自定义委托）"></a>委托的声明（自定义委托）</h1><p> 委托是一种类（class）,类是数据类型所以委托也是一种数据类型<br> 它的声明方式与一般的类不同，主要是为了照顾可读性和C&#x2F;C++传统<br> 注意声明委托的位置<br> 委托与所封装的方法必需“类型兼容”</p><p><img src="/img%5CHello%5CSnipaste_2025-02-16_19-14-44.png"></p><h1 id="委托的一般使用"><a href="#委托的一般使用" class="headerlink" title="委托的一般使用"></a>委托的一般使用</h1><p> 实例：把方法当作参数传给另一个方法<br> 正确使用1：模板方法，“借用”指定的外部方法来产生结果<br> 相当于“填空题”<br> 常位于代码中部<br> 委托有返回值</p><p> 正确使用2：回调（callback）方法，调用指定的外部方法<br> 相当于“流水线”<br> 常位于代码末尾<br> 委托无返回值</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-18-32.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-18-44.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-18-56.png"></p><h1 id="委托的高级使用"><a href="#委托的高级使用" class="headerlink" title="委托的高级使用"></a>委托的高级使用</h1><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-17-11.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-16-05.png"></p><p> 同步</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-28-48.png"></p><p> 间接同步<br> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-32-52.png"></p><p> 多播的多播</p><p> 一个主委托对象可以容纳多个其他的子委托对象，当调用主委托对象，会将所有子委托全部按序运行</p><p> 异步</p><p> 隐式异步</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-16_22-39-00.png"></p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="事件专用委托定义"><a href="#事件专用委托定义" class="headerlink" title="事件专用委托定义"></a>事件专用委托定义</h2> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params">Object? sender,EventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="为了能够满足两个条件："><a href="#为了能够满足两个条件：" class="headerlink" title="为了能够满足两个条件："></a>为了能够满足两个条件：</h2><p> 事件对应的委托，不应该被类外界调用，只能由某个操作触发<br> 事件对应的委托，不应该被类外界直接赋值，只能够通过+、-增减委托方法<br> <figure class="highlight csharp"><figcaption><span>事件最终写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Player</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">public</span> evnet EventHandler OnAttack = unll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 总结：类内定义、类内触发、只能加减、不可赋值</p><p> 事件是在程序运行过程中触发的特定动作。它可以是用户操作（如点击按钮）引起的，也可以是数据处理、集合遍历等引起的。<br> 每个事件包含一个事件触发器和相应的响应代码。</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-17_10-39-58.png"></p><p>事件的运用</p><p><b>事件对应的委托，不应该被类外界直接赋值，只能够通过+、-增减委托方法</b></p><p> ![]  (img\Hello\Snipaste_20 25-02-17_11-56-33.png)</p><p> 第一种：✨<br> 事件响应者和事件拥有者是完全分开的<br> 由事件处理器订阅事件<br> <img src="/img%5CHello%5CSnipaste_2025-02-17_12-49-52.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-17_12-47-14.png"></p><p> 第二种：✨✨</p><p> 事件的拥有者同时也是事件的响应者<br> <img src="/img%5CHello%5CSnipaste_2025-02-17_12-59-06.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-17_13-16-43.png"></p><p> 第三种：✨✨✨</p><p> <img src="/img%5CHello%5CSnipaste_2025-02-17_13-19-28.png"></p><p> <img src="/img%5CHello%5CSnipaste_2025-02-17_13-37-12.png"></p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> charp编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#&#92;WPF分布类和方法</title>
      <link href="/2025/02/02/csharp%E5%88%86%E5%B8%83%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95/"/>
      <url>/2025/02/02/csharp%E5%88%86%E5%B8%83%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="分布类和方法"><a href="#分布类和方法" class="headerlink" title="分布类和方法"></a>分布类和方法</h1><h2 id="分部类（Partial-Class）"><a href="#分部类（Partial-Class）" class="headerlink" title="分部类（Partial Class）"></a>分部类（Partial Class）</h2><p><b>定义：</b></p><blockquote><p>分部类是一种设计模式，用于将一个大型的、复杂的类拆分成多个较小的部分。这些部分可以是功能模块、数据逻辑或行为集等。</p></blockquote><p><b>特点：</b></p><li>代码可读性：通过将大类分割成小类，代码更加简洁易懂。</li><li>复用性：不同分部类可以被其他地方使用，提高代码的复用性。</li><li>扩展性：如果需要新增功能或修改现有逻辑，只需在相应的分部类中进行改动。</li><p><b>示例：</b></p><p>假设有一个 Person 类，表示一个人的属性和行为。将其分为以下几个分部类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> PartialName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> PartialAge &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params"><span class="built_in">string</span> newName, <span class="built_in">int</span> newAge</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = newName;</span><br><span class="line">        age = newAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>这里，PartialName 和 PartialAge 是分部类，分别对应 name 和 age 属性。</b></p><h2 id="WPF-中的分部类"><a href="#WPF-中的分部类" class="headerlink" title="WPF 中的分部类"></a>WPF 中的分部类</h2><p>在 WPF 中，分部类的概念不直接存在。但可以通过自定义控件或逻辑来实现类似的功能。例如：</p><p>将一个复杂的动画逻辑拆分为多个分部类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AnimationPart1</span> : <span class="title">IAnimationSegment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> StartTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> EndTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">ValueAt</span>(<span class="params"><span class="built_in">double</span> time</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (time &lt; StartTime) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (time &gt; EndTime) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 其他逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-中的分部类"><a href="#C-中的分部类" class="headerlink" title="C# 中的分部类"></a>C# 中的分部类</h2><p><b>在 C# 中，分部类是完全支持的设计模式。通过将一个大的类拆分成多个小的类，可以提高代码的组织性和可维护性。</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分部类 1：PersonName</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">PartialName</span> : <span class="title">INameSegment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">ValueAt</span>(<span class="params"><span class="built_in">double</span> time</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实现特定的行为或属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分部类 2：PersonAge</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">PartialAge</span> : <span class="title">IAgeSegment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">ValueAt</span>(<span class="params"><span class="built_in">double</span> time</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实现特定的行为或属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><b>定义：</b></p><blockquote><p>方法是程序设计中的一种基本结构，用于将一组逻辑操作抽象为一个名称，可以被其他代码调用。</p></blockquote><p><b>特点：</b></p><li>代码复用性：将重复的逻辑提取为方法。</li><li>可读性：通过命名和注释提高代码的可读性。</li><li>参数传递：支持传入零个或多个参数，并返回结果。</li><p><b>示例：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span>(<span class="params"><span class="built_in">int</span> radius</span>) <span class="comment">// 使用方法绘制圆</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 绘制圆的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span>(<span class="params"><span class="built_in">int</span> width, <span class="built_in">int</span> height</span>) <span class="comment">// 使用方法绘制矩形</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 绘制矩形的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WPF-中的方法"><a href="#WPF-中的方法" class="headerlink" title="WPF 中的方法"></a>WPF 中的方法</h2><p>在 WPF 中，方法也是常用的编程工具。例如：</p><p>通过编写自定义动画或逻辑。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PartialKey</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">StartValue</span>&gt;</span>0<span class="tag">&lt;/<span class="name">StartValue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EndValue</span>&gt;</span>1<span class="tag">&lt;/<span class="name">EndValue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TimeSpan</span>&gt;</span>0,1<span class="tag">&lt;/<span class="name">TimeSpan</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">InterpolationModeLinear</span>&gt;</span><span class="tag">&lt;/<span class="name">InterpolationModeLinear</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PartialKey</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="C-中的方法"><a href="#C-中的方法" class="headerlink" title="C# 中的方法"></a>C# 中的方法</h2><p>在 C# 中，方法是实现功能的核心。例如：</p><p>使用重载（Overloading）来支持不同的参数组合。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawCircle</span>(<span class="params"><span class="built_in">int</span> radius</span>) <span class="comment">// 单参版本</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawEllipse</span>(<span class="params"><span class="built_in">int</span> width, <span class="built_in">int</span> height</span>) <span class="comment">// 双参版本</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分部类和方法的关系"><a href="#分部类和方法的关系" class="headerlink" title="分部类和方法的关系"></a>分部类和方法的关系</h2><table>    <tr>        <th>比较项目</th>        <th>分部类</th>        <th>方法</th>    </tr>    <tr>        <td>功能</td>        <td>拆分大型类的功能</td>        <td>实现单个逻辑功能</td>    </tr>    <tr>        <td>应用场景</td>        <td>类型化问题（属性、行为等）</td>        <td>组合式问题（逻辑步骤）</td>    </tr>    <tr>        <td>灵活性</td>        <td>有，可以根据需要设计</td>        <td>有，可以通过重载实现多种逻辑</td>    </tr>    <tr>        <td>复用性</td>        <td>高，其他地方可以使用</td>        <td>高，方法参数可传递信息</td>    </tr>    </table>        <h2 id="WPF-和-C-中的分部类和方法的区别"><a href="#WPF-和-C-中的分部类和方法的区别" class="headerlink" title="WPF 和 C# 中的分部类和方法的区别"></a>WPF 和 C# 中的分部类和方法的区别</h2><li>WPF 是基于XAML和XML配置的语言，主要依赖于自定义属性（&lt;PartialKey&gt;）和动画分段（&lt;key&gt;, &lt;keyPosition&gt;）等特性来实现复杂的动画效果。</li>分部类在WPF 中并不直接存在，而是通过自定义属性或逻辑来实现部分功能。<li>C# 是一种面向对象的语言，支持传统的分部类设计模式和方法开发。在C# 中，分部类和方法是标准的编程工具，适用于多种场景。</li>    <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><li>分部类 和 方法 都是一种将大型或复杂的逻辑拆分成更小、更易管理的方式。</li><li>分部类适合在 C# 等面向对象的语言中使用，而 WPF 则依赖于 XML 和自定义属性来实现类似的功能。</li><li>在WPF 中，部分功能可以通过 PartialKey 或动画分段（如 keyPosition）来实现；而在C# 中，则可以利用分部类和方法来实现更复杂的逻辑。</li>]]></content>
      
      
      <categories>
          
          <category> WPF </category>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> WPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WPF表示模式与框架模式 | MVC&#92;MVVM</title>
      <link href="/2025/02/01/WPF/%E8%A1%A8%E7%A4%BA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/02/01/WPF/%E8%A1%A8%E7%A4%BA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="表象模式-构架模式-设计模式"><a href="#表象模式-构架模式-设计模式" class="headerlink" title="表象模式 | 构架模式 | 设计模式"></a>表象模式 | 构架模式 | 设计模式</h1><h2 id="表象模式（Presentation-Mode）"><a href="#表象模式（Presentation-Mode）" class="headerlink" title="表象模式（Presentation Mode）"></a>表象模式（Presentation Mode）</h2><p><b>定义：</b><br>表现模式的核心思想是将数据的展示逻辑与业务逻辑分离，通过独立的“表现层”来统一显示业务对象的信息。</p><p><b>目标：</b></p><p>将对数据的处理和显示逻辑独立出来。<br>提高代码的复用性。<br>显现数据的一致性和完整性。</p><p><b>主要特点：</b></p><p>数据中立：表现模式不关心数据如何存储或传输，只负责将数据以用户友好的方式展示。<br>事务隔离：业务逻辑与显示逻辑分离，避免事务处理对显示逻辑的干扰。<br>增强可读性：通过统一的数据格式和布局，提高代码的可读性和维护性。</p><p><b>示例：</b></p><p>假设有一个订单列表页面，表现模式会负责如何显示订单信息。它可能包括以下操作：<br>显示订单的基本信息（如编号、客户名称、金额）。<br>格式化订单日期为“年&#x2F;月&#x2F;日”格式。<br>显示订单的图片（如果有的话）。</p><h2 id="构架模式（Framework-Pattern）"><a href="#构架模式（Framework-Pattern）" class="headerlink" title="构架模式（Framework Pattern）"></a>构架模式（Framework Pattern）</h2><p><b>定义：</b><br>构架模式是一种通用的设计模式，用于将系统的组件分解为独立的部分，并通过这些部分来实现系统的功能。其核心思想是模块化开发，每个模块负责特定的功能。</p><p><b>目标：</b></p><p>提高系统的可扩展性。<br>显现系统的各个功能部分之间的依赖关系。<br>便于测试和维护。</p><p><b>特点：</b></p><p>模块化设计：将系统划分为独立的功能模块，每个模块负责特定的功能。<br>组件化开发：各个模块可以灵活地组合和配置，以适应不同的需求。<br>清晰的接口定义：通过明确的接口定义模块之间的交互方式，提高系统的可扩展性和维护性。</p><p><b>示例：</b></p><p>在构建一个复杂的订单管理系统时，构架模式可能会将系统分解为以下几个部分：</p><p>订单管理模块：负责处理订单的增删改查操作。<br>客户管理模块：负责管理客户的 registration 和信息更新。<br>支付 gateway 模块：负责处理订单的支付流程。<br>统计与报告模块：负责生成销售统计报表。</p><h2 id="设计模式（Design-Pattern）"><a href="#设计模式（Design-Pattern）" class="headerlink" title="设计模式（Design Pattern）"></a>设计模式（Design Pattern）</h2><p><b>定义：</b><br>设计模式是一个抽象的概念，指一组为了解决某一类问题的常用结构。它是软件工程中的一个重要概念，广泛应用于面向对象编程中。</p><p><b>特点：</b></p><p>标准化的命名和表达：每个模式都有一个标准名称和抽象的行为描述。<br>解决常见问题：设计模式通常用于解决特定类型的问题（如创建对象、对象获取、事务隔离等）。<br>可扩展性：在遵循模式的前提下，系统可以灵活地添加功能。</p><p><b>常见的设计模式：</b></p><p>工厂模式（Factory Pattern）<br>构造模式（Constructor Pattern）<br>表现模式（Presentation Mode）<br>行为模式（Behavioral Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>适配器模式（Adapter Pattern）</p><p><b>表现模式与构架模式的区别</b></p><table>    <tr>        <th>特性</th>        <th>表现模式</th>        <th>构架模式</th>    </tr>    <tr>        <td>功能分离</td>        <td>数据展示与业务逻辑分离</td>        <td>系统功能模块化，独立开发</td>    </tr>    <tr>        <td>目标</td>        <td>提高代码复用性和数据一致性</td>        <td>提高系统的可扩展性、测试性和维护性</td>    </tr>    <tr>        <td>依赖关系</td>        <td>强调事务隔离和数据的一致性</td>        <td>通过明确的接口定义功能模块之间的关系</td>    </tr>    <tr>        <td>实现方式</td>        <td>使用“表现层”或“数据绑定层”来管理显示逻辑</td>        <td>通过创建功能模块，将系统分解为独立的部分</td>    </tr>    </table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>表现模式主要用于分离数据展示和业务逻辑，提高代码的复用性和可读性。<br>构架模式则用于系统模块化设计，每个模块负责特定的功能。<br>设计模式是软件工程中的一个抽象概念，广泛应用于解决常见问题。</p><p><b>在实际项目中，通常会结合使用这些模式，例如：</b></p><p>使用构架模式来实现系统的模块化设计。<br>在某个模块中使用表现模式来分离显示逻辑和业务逻辑。<br>使用设计模式（如工厂模式或构造模式）来简化对象的创建或管理。<br>通过组合使用这些模式，可以提高系统的复用性、可维护性和扩展性。</p><h1 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h1><p><b>什么是 MVC 模式？</b></p><p>MVC 是一种软件架构设计模式，最初由IBM在数据库应用中提出，后来被扩展到Web和 GUI 开发领域。它将一个应用程序分解为三个主要部分：</p><li><b>模型（Model）</b>：负责处理数据逻辑、业务功能以及与控制器之间的通信。</li><li><b>视图（View）</b>：负责显示数据的呈现方式，通常是HTML页面或使用前端框架构建的组件。</li><li><b>控制器（Controller）</b>：接收用户输入并传递数据到模型和视图。</li><h2 id="MVC-在-GUI-开发中的应用"><a href="#MVC-在-GUI-开发中的应用" class="headerlink" title="MVC 在 GUI 开发中的应用"></a>MVC 在 GUI 开发中的应用</h2><p>MVC 模式在 GUI 应用开发中非常流行，原因如下：</p><li><b>分隔数据逻辑与呈现逻辑</b>：将处理数据的逻辑（模型）与显示数据的部分（视图）分开，使得代码更容易维护和复用。</li><li><b>响应式设计</b>：控制器可以实时更新视图，确保用户界面的动态性。这在前端开发中尤为重要，例如处理用户的点击事件、输入字段更改等。</li><li><b>分离 concerns</b>：每个部分有明确的责任，模型负责业务逻辑，视图负责数据展示，控制器负责用户交互，这样每个部分的功能更集中，易于理解和维护。</li><h2 id="MVC-模式的优点"><a href="#MVC-模式的优点" class="headerlink" title="MVC 模式的优点"></a>MVC 模式的优点</h2><li><b>代码复用性</b>：相同的模型可以被多个视图使用，减少了重复代码。</li><li><b>可扩展性</b>：新增功能时，只需修改模型或控制器，不影响视图。</li><li><b>易测试性</b>：每个部分相对独立，便于单元测试和集成测试。</li><li><b>用户体验一致</b>：通过视图组件化，可以为用户提供标准化的界面元素。</li><h2 id="MVC-模式的挑战"><a href="#MVC-模式的挑战" class="headerlink" title="MVC 模式的挑战"></a>MVC 模式的挑战</h2><li><b>学习曲线</b>：MVC 模式需要开发者理解三个分隔的部分及其交互机制，初期可能会有一定的学习成本。</li><li><b>复杂性</b>：在大型项目中，如果模型和控制器过于复杂，可能会增加维护难度。</li><li><b>性能优化</b>：由于数据传输的多级化（模型-控制器-视图），可能会影响性能，需要进行适当的缓存策略设计。</li><h2 id="MVC-模式的变种"><a href="#MVC-模式的变种" class="headerlink" title="MVC 模式的变种"></a>MVC 模式的变种</h2><p>除了标准的 MVC 模式，还有一些变种被应用在特定领域：</p><li><b>MVIA（Model-View-Interface-Aggregator）</b>：常用于图形界面编程语言如 Smalltalk 中。它将模型、视图、接口和聚合器分开。</li><li><b>V Model</b>：一种适用于前端框架的模式，类似于 MVC，广泛应用于React等框架中。</li><h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><p>在构建一个简单的电商网站时：</p><li><b>模型（Model）</b>：管理订单信息、商品库存、用户数据等。</li><li><b>视图（View）</b>：展示商品列表页面或购物车内容。</li><li><b>控制器（Controller）</b>：处理用户的搜索输入、添加商品点击事件、订单提交等功能。</li><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>MVC 模式在 GUI 开发中确实是一个指导模式，帮助开发者将数据逻辑与用户界面分离，实现高效的代码结构和良好的用户体验。理解并应用 MVC 模式能够显著提高开发效率和代码质量。</p><p>因此，MVC 模式是图形用户界面（GUI）开发中非常重要的设计模式之一。</p><br><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p><b>MVVM（Model-View-ViewModel）模式</b></p><p>MVVM（Model-View-ViewModel）是一种设计模式，通常用于前端开发，特别是在Vue.js等框架中被广泛使用。它是对MVC（Model-View-Controller）模式的一种扩展和优化，主要针对视图层与数据绑定的问题。</p><h2 id="MVVM的核心思想"><a href="#MVVM的核心思想" class="headerlink" title="MVVM的核心思想"></a>MVVM的核心思想</h2><p>在MVC模式中，模型（Model）、视图（View）和控制器（Controller）是分离的三者关系：</p><li><b>模型</b>：负责存储和管理业务逻辑相关的静态或动态数据。</li><li><b>视图</b>：负责将模型的数据呈现给用户。</li><li><b>控制器</b>：负责处理用户的输入事件，并根据业务逻辑更新模型。</li>    <p>然而，MVC模式的一个缺点是，当需要对视图进行动态绑定时，需要通过useEffect等函数手动渲染更新后的视图，这会导致代码冗余、难以维护。</p><p>MVVM模式解决了这个问题，它将模型与视图的绑定关系和数据的双向通信结合起来，提供了更高效的方式来管理数据和视图的动态更新。</p><h2 id="MVVM的主要组件"><a href="#MVVM的主要组件" class="headerlink" title="MVVM的主要组件"></a>MVVM的主要组件</h2><li><b>模型（Model）</b>：<p>负责存储和管理业务逻辑相关的静态或动态数据。<br>模型的数据可以通过命令（Command）的方式被控制器或其他组件访问和修改。</li></p><li><b>命令（Command）</b>：<p>用于将模型中的数据传递给视图层，并在视图层完成操作后，将结果反馈回模型。</li></p><li><b>管理器（Manager）</b>：<p>负责对命令的执行进行监控。<br>管理器确保命令的执行顺序和依赖关系。</li></p><li><b>镜像层（Mirror）</b>：<p>管理器与模型之间的一个中间层，负责将模型的数据传递给视图层，并根据视图层的反馈更新模型。</li></p><li><b>绑定层（Binding）</b>：<p>将数据从模型传递到视图组件中的组件属性上。<br>它可以用来实现单点绑定或多点绑定，并支持动态键值对。</li></p><h2 id="MVVM的工作流程"><a href="#MVVM的工作流程" class="headerlink" title="MVVM的工作流程"></a>MVVM的工作流程</h2><li><b>创建模型、命令和管理器</b>：<p>在组件的生命周期开始时，初始化模型、命令和管理器实例。</li></p><li><b>绑定视图与模型</b>：<p>使用&lt;mx:Binding&gt;标签将模型的数据传递到视图组件中的属性上。<br>确保数据双向绑定，即当视图更新时，模型也会同步更新；反之亦然。</li></p><li><b>绑定命令与管理器</b>：<p>使用useCommand &#x3D; true标记的命令实例绑定到管理器。<br>这些命令会通过useMirror传送到镜像层，并在视图层完成操作后反馈回模型。</li></p><li><b>绑定视图与命令</b>：<p>在视图组件中使用&lt;mx:Command&gt;标签，将数据传递给命令实例。<br>命令完成后，使用管理器来更新模型。</li></p><h2 id="MVVM的优势"><a href="#MVVM的优势" class="headerlink" title="MVVM的优势"></a>MVVM的优势</h2><li><b>数据一致性</b>：通过镜像层和绑定层的双向通信机制，确保模型、视图和命令之间的数据一致性。</li><li><b>组件化开发</b>：每个组件（模型、命令、管理器）都有明确的功能边界，便于理解和维护。</li><li><b>动态绑定</b>：能够实现视图与模型的双向数据绑定，避免手动渲染的问题。</li><h2 id="MVVM与MVC的区别"><a href="#MVVM与MVC的区别" class="headerlink" title="MVVM与MVC的区别"></a>MVVM与MVC的区别</h2><li><b>数据绑定</b>：<p>MVC模式需要通过useEffect等函数手动渲染更新后的视图，导致代码冗余。<br>MVVM模式通过镜像层和绑定层实现自动化的数据绑定和双向通信。</li></p><li><b>命令执行</b>：<p>MVC模式没有内置的命令机制，无法直接将模型的数据传递给视图或组件。<br>MVVM模式引入了命令机制，允许开发者更灵活地处理业务逻辑。</li></p><h2 id="MVVM的使用场景"><a href="#MVVM的使用场景" class="headerlink" title="MVVM的使用场景"></a>MVVM的使用场景</h2><p>MVVM模式非常适合需要对视图和数据进行深度绑定的应用场景，例如：</p><li><b>高级表格（Grid）</b>：实现动态列添加/删除、数据排序等操作。</li><li><b>组件化布局</b>：实现响应式设计中的自动缩放或布局调整。</li><li><b>数据可视化</b>：实现动态图表的数据更新。</li><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>MVVM模式通过将模型、命令和管理器结合在一起，实现了数据的双向绑定和高效的业务逻辑处理。它非常适合需要深度数据绑定和复杂组件化开发的应用场景。</p>]]></content>
      
      
      <categories>
          
          <category> MVVM </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> MVVM </tag>
            
            <tag> MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WPF概述三层架构、高内聚，低耦合、数据交互容器与载体。</title>
      <link href="/2025/02/01/WPF/WPF%E6%A6%82%E8%BF%B0/"/>
      <url>/2025/02/01/WPF/WPF%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="WPF技术概述"><a href="#WPF技术概述" class="headerlink" title="WPF技术概述"></a>WPF技术概述</h1><p><b>WPF全称为Windows Presentation Foundation,是一种基于XAML、.NET和向量绘图技术的表层开发框架，广泛用于软件图形界面的开发，是一种<mark>专门用来编写程序表示层的技术和工具。</mark></b></p><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p><b>在WPF（Windows Presentation Foundation）中，应用程序通常被划分为三层架构：<code>UI Layer、Business Layer 和 Network Layer</code>。每层都有其特定的功能和作用。</b></p><p><b>UI Layer（用户界面层）：</b></p><blockquote><p>负责显示应用程序的图形用户界面（GUI），包括窗体、控件和布局。<br>使用XAML定义界面元素和样式，使用C#或VB.NET编写用户交互逻辑。<br>处理用户的交互操作，如点击按钮、输入文本等。</p></blockquote><p><b>Business Layer（业务逻辑层）：</b></p><blockquote><p>负责应用程序的核心功能和数据管理，与数据库交互执行查询和更新操作。<br>使用Entity Framework进行ORM，提供 fluent API 或 WLINQ实现业务逻辑。<br>处理事务控制、错误处理和状态管理，确保数据的一致性和完整性。</p></blockquote><p><b>Network Layer（网络层）：</b></p><blockquote><p>负责数据的传输和通信，从客户端发送请求到服务器或从服务器返回响应。<br>使用.NET Core或其他网络库如DotNet&#x2F;Transport、Netty或GlassFish实现网络功能。<br>处理HTTP请求的生命周期，包括解析、数据传输、响应生成和错误处理。</p></blockquote><p><b>通过这三层架构的设计，WPF使得应用程序结构清晰、功能分明。UI Layer展示用户界面，Business Layer管理核心业务逻辑，Network Layer负责数据通信。各层之间相互关联，共同支撑整个应用的运行。理解和实现这三层架构是掌握WPF开发的关键。</b></p><h2 id="高内聚，低耦合"><a href="#高内聚，低耦合" class="headerlink" title="高内聚，低耦合"></a>高内聚，低耦合</h2><p><b>“高内聚，低耦合”</b>是一个软件设计模式中的核心概念，尤其是在遵循“开闭原则”时被广泛采用。这种设计理念强调使系统中的各个组件或部分之间的依赖尽可能少（低耦合），同时在每个组件内部实现功能的集中和独立（高内聚）。在WPF（Windows Presentation Foundation）中的三层架构中，“高内聚，低耦合”体现在以下几个方面：</p><p><b>1. 高内聚（High Cohesion）</b></p><blockquote><p>每一层的功能模块都被高度集中，其职责范围明确且相互之间依赖较少。具体来说：</p></blockquote><li><b>UI Layer</b>：负责显示和管理用户界面，包括窗体、控件、布局等。它的核心功能是展示图形内容，与其他层的交互主要通过中间层（如ViewModel）。</li><li><b>Business Layer</b>：负责应用的核心业务逻辑，如数据处理、事务管理、业务流程等。它依赖ORM（Object-Relational Mapping）技术与数据库交互，但对其它层的关系有限。</li><li><b>Network Layer</b>：专注于数据传输和通信，处理HTTP请求、数据发送/接收、认证等操作。这部分通常使用现成的库或框架来实现。</li><p><b>由于每一层的功能都非常集中，彼此之间的依赖关系弱，高内聚特性得以体现。</b></p><br><p><b>2. 低耦合（Low Coupling）</b></p><blockquote><p>各层之间的依赖关系尽可能少，相互之间几乎独立。具体来说：</p></blockquote><li><b>UI Layer</b>：与Business Layer和Network Layer之间的依赖仅限于中间层（如ViewModel或ViewModelBase），这些中间层负责传递数据和控制流。</li><li><b>Business Layer</b>：与UI和Network Layer之间的依赖也主要通过中间层实现，例如通过集合或事件来同步UI的变化。</li><li><b>Network Layer</b>：通常与其他两层的交互非常有限，主要处理本层特定的功能。</li><blockquote><p>低耦合特性使得每一层可以独立地被修改、升级或替换，而不会影响到整个系统的功能。</p></blockquote><br><h2 id="三层架构在“高内聚，低耦合”中的体现"><a href="#三层架构在“高内聚，低耦合”中的体现" class="headerlink" title="三层架构在“高内聚，低耦合”中的体现"></a>三层架构在“高内聚，低耦合”中的体现</h2><p><b>在WPF的三层架构中，“高内聚，低耦合”的特点具体体现在以下几个方面：</b></p><ol><b>UI Layer：</b>    <li>高内聚：仅负责显示和管理用户界面，与其他层的交互通过ViewModel或ViewModelBase实现。</li>    <li>低耦合：与业务逻辑（如数据查询）和网络操作之间的依赖关系非常弱。</li></ol><ol><b>Business Layer：</b>    <li>高内聚：主要负责应用的核心业务逻辑，如数据处理、事务管理等。它依赖ORM技术将数据库表映射到实体类，并通过中间层传递数据。</li>    <li>低耦合：与其他两层的依赖有限，通常通过ViewModel或ViewModelBase与UI Layer交互。</li>    </ol><ol><b>Network Layer：</b></b>P    <li>高内聚：专注于数据传输和通信，处理HTTP请求、数据发送/接收等操作。这部分功能较为独立，与其他层的依赖较少。</li>    <li>低耦合：与UI和业务层之间的交互主要通过中间层实现（如HttpBinding框架），不影响其核心逻辑。</li>    </ol> <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><b>在WPF的三层架构中，“高内聚，低耦合”的设计原则确保了各层功能的独立性和模块化。这种设计方式的优势在于：</b></p><blockquote><p>易于维护：每一层的功能清晰明确，可以独立地进行修改或升级。<br>扩展性强：新增功能时，只需在特定层中实现即可，无需影响其他层。<br>可重用性高：各层的设计较为通用，适合多种应用场景。<br>通过“高内聚，低耦合”的设计思想，WPF的三层架构实现了高效、稳定且易于维护的应用开发。</p></blockquote><h1 id="数据交互容器与载体"><a href="#数据交互容器与载体" class="headerlink" title="数据交互容器与载体"></a>数据交互容器与载体</h1><ol><li>数据容器</li></ol><blockquote><p>数据容器是指提供统一数据访问策略的组件或类，它负责将业务逻辑层、ViewModel（视图模型）和数据源连接起来。在WPF中，数据容器通常是一个自定义的数据访问接口或组件，用于管理与不同数据源（如数据库、云存储等）的交互。</p></blockquote><p><b>数据容器的主要职责包括：</b></p><li>定义与数据源的交互规则（如序列化/反序列化规则、过滤规则等）。</li><li>管理多个数据源之间的切换和协作。</li><li>提供数据访问权限，确保不同组件可以安全地访问数据源。</li><p><b>示例：</b></p><blockquote><p>在WPF中，数据容器可能是一个自定义的类或组件（如 DataContext 或 DataContextComp），它包含了对数据源的操作逻辑，并将这些操作与业务逻辑层和ViewModel结合在一起。</p></blockquote><ol start="2"><li>载体</li></ol><p>载体是指在视图模型（ViewModel）中使用桥梁（Bridge）将业务逻辑层的数据操作映射到数据容器的逻辑。载体负责通过桥梁将业务逻辑的操作结果传递给数据容器，或者从数据容器获取数据并返回给业务逻辑。</p><p>在WPF中，载体通常是一个自定义的组件或类，它包含了对桥梁（如 ILookupBridge、IlooDataAccessBridge）的引用，并负责管理与数据源的交互。载体将业务逻辑和数据源连接起来，确保数据操作的正确性和一致性。</p><p>示例：</p><p>载体可能是一个自定义的组件或类（如 UserDetailBridge），它包含了对桥梁的引用，并通过桥梁将用户的搜索结果传递给数据容器（如 DataContext 或 DataContextComp）。</p><ol start="3"><li>IlooDataAccessBridge</li></ol><p>在WPF中，IlooDataAccessBridge 是一个重要的桥梁接口，用于实现业务逻辑层与数据源之间的交互。它通过以下方式将业务逻辑和数据容器连接起来：</p><li>定义如何从数据源获取数据（如查询、更新等）。</li><li>定义如何将业务逻辑操作的结果映射到数据容器的逻辑中。</li><li>提供数据的序列化和反序列化功能。</li><p><b>示例：</b></p><p>在 UserDetailBridge 中，你可以定义一个方法来查询数据库中的用户信息：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserDetailBridge</span> <span class="title">implements</span> <span class="title">IlooDataAccessBridge</span>&lt;<span class="title">User</span>, <span class="title">IDetailsUser</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IBridgeBridge bridge;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">GetUserInfo</span>(<span class="params"><span class="built_in">int</span> userId</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> bridge.ExecuteScalar(<span class="string">&quot;SELECT * FROM Users WHERE Id = ? &quot;</span>, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>数据容器与载体的关系<blockquote><p>数据容器和载体在WPF中通常结合使用，以实现高效的业务逻辑操作。具体关系如下：</p></blockquote></li></ol><p>数据容器负责管理与数据源的交互策略（如序列化、反序列化规则）。<br>载体（通过桥梁）将业务逻辑的操作结果传递给数据容器，并从数据容器获取数据。</p><p><b>示例：</b></p><p>在WPF中，数据容器和载体可能结合在一起使用如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserDetailBridge</span> <span class="title">implements</span> <span class="title">IlooDataAccessBridge</span>&lt;<span class="title">User</span>, <span class="title">IDetailsUser</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IBridgeBridge bridge;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> DataContext dataContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">GetUserInfo</span>(<span class="params"><span class="built_in">int</span> userId</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> bridge.ExecuteScalar(<span class="string">&quot;SELECT * FROM Users WHERE Id = ? &quot;</span>, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserDetailContainer</span> : <span class="title">IlooDataContextComp</span>&lt;<span class="title">IDetailsUser</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDetailContainer</span>(<span class="params">IBridgeBridge bridge</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bridge != <span class="literal">null</span>)</span><br><span class="line">            bridge.SetBridge(bridge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>总结</li></ol><blockquote><p>数据容器：提供统一的策略和管理逻辑，将业务逻辑与数据源连接起来。<br>载体：通过桥梁将业务逻辑的操作结果传递给数据容器，并从数据容器获取数据。<br>IlooDataAccessBridge：是实现业务逻辑层与数据源交互的核心桥梁。<br>通过合理使用这些组件，可以更好地组织WPF应用的代码结构，提高数据访问的效率和可维护性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> WPF </category>
          
          <category> .NET </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> WPF </tag>
            
            <tag> 三层架构 </tag>
            
            <tag> 高内聚 </tag>
            
            <tag> 低耦合 </tag>
            
            <tag> 数据交互容器与载体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 列表</title>
      <link href="/2025/01/29/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E5%88%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/"/>
      <url>/2025/01/29/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E5%88%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="列表的基本用法"><a href="#列表的基本用法" class="headerlink" title="列表的基本用法"></a>列表的基本用法</h1><p><b>创建列表</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建空列表</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并初始化列表</span></span><br><span class="line">List&lt;<span class="built_in">string</span>&gt; names = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p><b>添加元素</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">numbers.Add(<span class="number">10</span>);       <span class="comment">// 在末尾添加单个元素</span></span><br><span class="line">numbers.AddRange(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">20</span>, <span class="number">30</span> &#125;); <span class="comment">// 添加多个元素</span></span><br></pre></td></tr></table></figure><p><b>访问元素</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> first = numbers[<span class="number">0</span>];  <span class="comment">// 通过索引访问（类似数组）</span></span><br></pre></td></tr></table></figure><p><b>删除元素</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">numbers.Remove(<span class="number">20</span>);      <span class="comment">// 删除第一个匹配的元素</span></span><br><span class="line">numbers.RemoveAt(<span class="number">0</span>);     <span class="comment">// 删除指定索引的元素</span></span><br><span class="line">numbers.Clear();         <span class="comment">// 清空列表</span></span><br></pre></td></tr></table></figure><p><b>遍历列表</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> numbers)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用属性和方法"><a href="#常用属性和方法" class="headerlink" title="常用属性和方法"></a>常用属性和方法</h1><blockquote><p>属性&#x2F;方法说明<br>Count获取列表中的元素数量（实际存储的元素数）<br>Capacity获取或设置列表的内部容量（动态扩容时的预分配大小）<br>Add(T item)在列表末尾添加元素<br>Insert(int index, T item)在指定位置插入元素<br>Contains(T item)检查元素是否存在<br>IndexOf(T item)返回元素的第一个匹配项的索引<br>Sort()对列表元素排序（需元素实现 IComparable 接口或提供自定义比较器）<br>Find(Predicate&lt;T&gt; match)查找第一个符合条件的元素<br>ForEach(Action&lt;T&gt; action)对每个元素执行操作</p></blockquote><p><b> 示例代码</b></p><p><b>动态操作列表</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;<span class="built_in">string</span>&gt; fruits = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span> &#125;;</span><br><span class="line">fruits.Add(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">fruits.Insert(<span class="number">1</span>, <span class="string">&quot;Mango&quot;</span>);</span><br><span class="line">fruits.Remove(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> fruit <span class="keyword">in</span> fruits)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(fruit); <span class="comment">// 输出：Apple, Mango, Cherry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 LINQ 查询列表</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> evenNumbers = numbers.Where(n =&gt; n % <span class="number">2</span> == <span class="number">0</span>).ToList(); <span class="comment">// 筛选偶数</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, evenNumbers)); <span class="comment">// 输出：2, 8</span></span><br></pre></td></tr></table></figure><p>最佳实践<br>预分配容量<br>如果已知元素数量，初始化时指定容量以减少动态扩容的开销：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(<span class="number">100</span>); <span class="comment">// 初始容量为 100</span></span><br><span class="line">避免频繁插入/删除</span><br><span class="line">若需要频繁在中间插入或删除元素，考虑使用 LinkedList&lt;T&gt;。</span><br></pre></td></tr></table></figure><p>使用集合初始化器<br>简化代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">结合 LINQ</span><br><span class="line">使用 LINQ 方法（如 Where, Select, OrderBy）简化复杂查询。</span><br></pre></td></tr></table></figure><p><b> 常见问题<br>如何高效复制列表？</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; copy = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(originalList); <span class="comment">// 通过构造函数复制</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; copy2 = originalList.ToList();      <span class="comment">// 使用 LINQ 的 ToList()</span></span><br></pre></td></tr></table></figure><p>如何将列表转换为数组？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] array = numbers.ToArray();</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>List&lt;T&gt; 是 C# 中最常用的集合类型之一，适用于需要动态调整大小的场景。通过灵活的方法和 LINQ 集成，它可以高效处理大多数集合操作。在使用时需注意容量管理和性能优化，结合具体需求选择合适的数据结构。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 运算符重载</title>
      <link href="/2025/01/28/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2025/01/28/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符重载（Operator-Overloading）"><a href="#运算符重载（Operator-Overloading）" class="headerlink" title="运算符重载（Operator Overloading）"></a>运算符重载（Operator Overloading）</h1><p><b>在 C# 中，运算符重载（Operator Overloading） 是一种允许你为自定义的类或结构体重新定义运算符行为的特性。通过运算符重载，你可以让自定义类型像内置类型（如 int、string）一样，直接使用 +、-、&#x3D;&#x3D; 等运算符进行操作，使代码更简洁、直观。</b></p><p>核心要点<br>目的<br>让自定义类型支持运算符操作，提升代码可读性。例如，用 a + b 代替 a.Add(b)。</p><p>实现方式<br>通过定义 public static 方法，并使用 operator 关键字声明要重载的运算符：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 <span class="keyword">operator</span> 运算符(参数) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="可重载的运算符"><a href="#可重载的运算符" class="headerlink" title="可重载的运算符"></a>可重载的运算符</h2><p><b>算术运算符：+, -, *, &#x2F;, %</p><p>比较运算符：&#x3D;&#x3D;, !&#x3D;, &lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;</p><p>逻辑运算符：!,&amp;, |, ^</p><p>位运算符： &lt; &lt;, &gt;&gt;</p><p>类型转换运算符：implicit（隐式转换）和 explicit（显式转换）</p><p>其他：true, false, ++, –</p><p>不可重载的运算符：<br>&amp; &amp;, ||, &#x3D;, new, is, as, ??, &#x3D;&gt;, . 等。</b></p><br><p><b>简单示例<br>假设有一个表示二维向量的类 Vector，重载 + 运算符实现向量相加：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Vector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 + 运算符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Vector <span class="keyword">operator</span> +(Vector v1, Vector v2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector(v1.X + v2.X, v1.Y + v2.Y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 ToString 方便输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span> =&gt; <span class="string">$&quot;(<span class="subst">&#123;X&#125;</span>, <span class="subst">&#123;Y&#125;</span>)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Vector v1 = <span class="keyword">new</span> Vector(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">Vector v2 = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Vector sum = v1 + v2; <span class="comment">// 直接使用 + 运算符</span></span><br><span class="line">Console.WriteLine(sum); <span class="comment">// 输出 &quot;(4, 6)&quot;</span></span><br></pre></td></tr></table></figure><p><b>关键规则<br>必须为静态方法<br>运算符重载的方法必须是 public static。</p><p>参数和返回类型</p><p>运算符的操作数必须包含当前类型（例如 Vector + Vector）。</p><p>返回类型可以是任意类型，但通常与当前类型一致。</p><p>成对重载</p><p>若重载 &#x3D;&#x3D;，必须同时重载 !&#x3D;。</p><p>若重载 &lt;，通常需要重载 &gt;、 &lt;&#x3D;、&gt;&#x3D;。</p><p>重写 Equals 和 GetHashCode<br>如果重载了比较运算符（如 &#x3D;&#x3D;），必须同时重写 Equals() 和 GetHashCode()，确保逻辑一致。</p><p>典型应用场景<br>数学对象<br>复数、矩阵、多项式等需要算术运算的类型。</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line">Complex c1 = <span class="keyword">new</span> Complex(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Complex c2 = <span class="keyword">new</span> Complex(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">Complex sum = c1 + c2; <span class="comment">// 直接相加</span></span><br></pre></td></tr></table></figure><p><b>物理量<br>距离、速度、温度等需要运算符操作的物理量。</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line">Distance d1 = <span class="keyword">new</span> Distance(<span class="number">10</span>, Unit.Meter);</span><br><span class="line">Distance d2 = <span class="keyword">new</span> Distance(<span class="number">5</span>, Unit.Meter);</span><br><span class="line">Distance total = d1 + d2; <span class="comment">// 自动单位转换并相加</span></span><br></pre></td></tr></table></figure><p><b>自定义逻辑<br>例如重载 + 合并集合，或重载 &#x3D;&#x3D; 比较对象的业务逻辑等价性。</p><p>注意事项<br>避免滥用<br>运算符的行为必须符合直觉。例如，+ 不应被重载为减法操作。</p><p>性能优化<br>避免在运算符重载中执行复杂操作（如数据库查询）。</p><p>隐式&#x2F;显式转换<br>使用 implicit 或 explicit 定义类型转换时需谨慎，确保不会导致歧义。</b></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><b>运算符重载让自定义类型可以像内置类型一样使用运算符，使代码更简洁、直观。但需遵循语义合理性（如 + 表示加法）和一致性原则（如成对重载 &#x3D;&#x3D; 和 !&#x3D;）。正确使用时，能大幅提升代码可读性；滥用则会导致代码难以维护。</b></p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 索引器的使用</title>
      <link href="/2025/01/28/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E7%B4%A2%E5%BC%95%E5%99%A8/"/>
      <url>/2025/01/28/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E7%B4%A2%E5%BC%95%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是索引器？"><a href="#什么是索引器？" class="headerlink" title="什么是索引器？"></a>什么是索引器？</h1><p><b>索引器（Indexer）是 C# 中的一种特殊成员，允许对象像数组或集合一样通过索引（如 []）访问内部元素。</p><p>类似于属性（Property），但通过索引参数访问数据。</p><p>常用于封装集合类（如自定义列表、字典），使其可以通过索引直接操作元素。</b></p><h1 id="如何定义和使用索引器？"><a href="#如何定义和使用索引器？" class="headerlink" title="如何定义和使用索引器？"></a>如何定义和使用索引器？</h1><p>语法结构</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line"><span class="keyword">public</span> 返回类型 <span class="keyword">this</span>[参数类型 index]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="comment">/* 返回 index 对应的值 */</span> &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; <span class="comment">/* 设置 index 对应的值 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">示例代码</span><br><span class="line">csharp</span><br><span class="line">复制</span><br><span class="line"><span class="keyword">class</span> <span class="title">StringCollection</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>[] _data = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义索引器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= _data.Length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException();</span><br><span class="line">            <span class="keyword">return</span> _data[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= _data.Length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException();</span><br><span class="line">            _data[index] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用索引器</span></span><br><span class="line"><span class="keyword">var</span> collection = <span class="keyword">new</span> StringCollection();</span><br><span class="line">collection[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span>;  <span class="comment">// 通过索引赋值</span></span><br><span class="line">Console.WriteLine(collection[<span class="number">0</span>]);  <span class="comment">// 通过索引取值</span></span><br></pre></td></tr></table></figure><br><p><b>关键点</p><p>使用 this 关键字定义。</p><p>支持多个参数（如多维索引）：public int this[int x, int y] { … }。</p><p>可以重载（不同参数类型或数量）。</b></p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p><b>适合使用索引器的场景<br>封装集合类<br>当类内部包含数组、列表或其他集合时，通过索引器提供类似数组的访问方式。</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] _items;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _items[index]; &#125; <span class="keyword">set</span> &#123; _items[index] = <span class="keyword">value</span>; &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line">键值对访问</span><br><span class="line">类似字典的键值访问，例如通过字符串索引：</span><br><span class="line"></span><br><span class="line">csharp</span><br><span class="line">复制</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Config</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; _settings = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">string</span> key]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _settings[key]; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _settings[key] = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><b>数学结构</p><p>表示矩阵、向量等数学结构时，通过多维索引访问元素：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[,] _matrix = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">int</span> row, <span class="built_in">int</span> col]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _matrix[row, col]; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _matrix[row, col] = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><b>简化代码<br>当需要通过索引直接操作对象内部数据时，索引器比方法调用更直观：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line"><span class="comment">// 使用索引器</span></span><br><span class="line">myObject[<span class="number">5</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 对比方法</span></span><br><span class="line">myObject.SetValue(<span class="number">5</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><br><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p><b>索引器参数类型<br>可以是任意类型（如 int、string、enum 等），但需确保逻辑合理。</p><p>异常处理<br>在 get 和 set 中需检查索引有效性，避免越界错误。</p><p>不可静态<br>索引器不能声明为 static。</p><p>与属性的区别</p><p>属性通过名称访问（如 obj.Name），索引器通过参数访问（如 obj[0]）。</p><p>索引器可以有多个参数，属性没有参数。</b></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><b>索引器用于让对象支持类似数组的索引访问，适用于封装集合或需要直接通过索引操作数据的场景。合理使用索引器可以提升代码的可读性和易用性，但需注意边界检查和参数逻辑。</b></p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 虚方法和隐藏方法-抽象类和密封类</title>
      <link href="/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E8%99%9A%E6%96%B9%E6%B3%95%E5%92%8C%E9%9A%90%E8%97%8F%E6%96%B9%E6%B3%95/"/>
      <url>/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E8%99%9A%E6%96%B9%E6%B3%95%E5%92%8C%E9%9A%90%E8%97%8F%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="虚方法和隐藏方法"><a href="#虚方法和隐藏方法" class="headerlink" title="虚方法和隐藏方法"></a>虚方法和隐藏方法</h1><h2 id="虚方法（Virtual-Method）"><a href="#虚方法（Virtual-Method）" class="headerlink" title="虚方法（Virtual Method）"></a>虚方法（Virtual Method）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><b>定义</b></h3><p><b>在 C# 中，虚方法是在基类中使用virtual关键字修饰的方法。它允许派生类重写（override）该方法的实现。虚方法提供了一种多态性的机制，使得在运行时可以根据对象的实际类型来调用相应的方法。</b></p><li><b>示例</b></li><blockquote><p>考虑一个简单的动物类层次结构。首先有一个基类Animal：</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The animal makes a sound.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">然后有一个派生类Dog，它重写了MakeSound方法：</span><br><span class="line">csharp</span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The dog barks.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h2><p>当通过基类引用指向派生类对象时，调用虚方法会根据对象的实际类型（即派生类类型）来执行相应的方法。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">animal.MakeSound(); <span class="comment">// 输出 &quot;The dog barks.&quot;</span></span><br></pre></td></tr></table></figure><p>这展示了多态性，因为即使animal被声明为Animal类型，但实际执行的是Dog类中重写后的MakeSound方法。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>虚方法在基类中定义了一个基本的方法框架，派生类可以根据自己的需求进行定制化的重写。重写方法时，必须使用override关键字，并且方法签名（方法名称、参数列表和返回类型）必须与基类中的虚方法完全一致。</p><br><h1 id="隐藏方法（Method-Hiding）"><a href="#隐藏方法（Method-Hiding）" class="headerlink" title="隐藏方法（Method Hiding）"></a>隐藏方法（Method Hiding）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>当派生类中定义了一个与基类中方法同名的方法，但没有使用override关键字（或者基类方法不是虚方法）时，就发生了方法隐藏。方法隐藏是通过在派生类方法前使用new关键字来显式地表示这种隐藏意图。</p><li><b>示例</b></li><p>假设还是刚才的Animal类，但是这次MakeSound方法不是虚方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The animal makes a sound.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">然后在派生类Cat中隐藏这个方法：</span><br><span class="line">csharp</span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The cat meows.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用方式-1"><a href="#调用方式-1" class="headerlink" title="调用方式"></a>调用方式</h2><p>与虚方法不同，隐藏方法的调用取决于引用变量的类型，而不是对象的实际类型。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br><span class="line">animal.MakeSound(); <span class="comment">// 输出 &quot;The animal makes a sound.&quot;</span></span><br><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.MakeSound(); <span class="comment">// 输出 &quot;The cat meows.&quot;</span></span><br></pre></td></tr></table></figure><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><p><b>方法隐藏可能会导致一些意外的行为，因为它不像虚方法那样遵循多态性原则。一般来说，如果想要实现多态性，应该优先考虑使用虚方法和重写，而方法隐藏主要用于在派生类中提供一个与基类同名但行为不同的方法，并且明确地表明这种行为是独立于基类方法的意图。</b></p><h1 id="抽象类（Abstract-Class）"><a href="#抽象类（Abstract-Class）" class="headerlink" title="抽象类（Abstract Class）"></a>抽象类（Abstract Class）</h1><h2 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h2><p><b>抽象类是使用 abstract 关键字修饰的类，它不能被实例化，主要用于作为其他类的基类，为派生类提供一个通用的模板或框架。</p><p>抽象类可以包含抽象方法、非抽象方法、属性、字段等成员。抽象方法是使用 abstract 关键字修饰的方法，它只有方法声明，没有方法体，派生类必须实现这些抽象方法。</b></p><li>示例代码</li><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义抽象类 Animal</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 抽象方法，派生类必须实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The animal is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Dog 继承自抽象类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实现抽象方法 MakeSound</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The dog barks.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不能实例化抽象类</span></span><br><span class="line">        <span class="comment">// Animal animal = new Animal(); // 这行代码会编译错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以使用派生类实例化</span></span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.MakeSound(); <span class="comment">// 输出: The dog barks.</span></span><br><span class="line">        dog.Eat(); <span class="comment">// 输出: The animal is eating.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p><b>Animal 是一个抽象类，其中包含一个抽象方法 MakeSound 和一个非抽象方法 Eat。<br>Dog 类继承自 Animal 类，必须实现 MakeSound 方法。<br>在 Main 方法中，不能直接实例化抽象类 Animal，但可以实例化派生类 Dog，并调用其方法。</b></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><b>当你需要定义一组相关类的通用行为，但某些行为的具体实现需要由派生类来完成时，可以使用抽象类。例如，图形类可以定义为抽象类，其中包含计算面积的抽象方法，不同的图形（如圆形、矩形）继承自该抽象类并实现具体的计算方法。</b></p><h1 id="密封类（Sealed-Class）"><a href="#密封类（Sealed-Class）" class="headerlink" title="密封类（Sealed Class）"></a>密封类（Sealed Class）</h1><h2 id="定义与特点-1"><a href="#定义与特点-1" class="headerlink" title="定义与特点"></a>定义与特点</h2><p><b>密封类是使用 sealed 关键字修饰的类，它不能被继承，即不能有派生类。<br>密封类通常用于防止其他类继承和修改其行为，从而保证类的安全性和稳定性。密封类可以包含各种成员，与普通类的区别在于它不能作为基类。</b></p><li>示例代码</li><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义密封类 Circle</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="built_in">double</span> radius</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">CalculateArea</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试继承密封类，会导致编译错误</span></span><br><span class="line"><span class="comment">// class DerivedCircle : Circle &#123; &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">double</span> area = circle.CalculateArea();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;The area of the circle is: <span class="subst">&#123;area&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h2><p><b>Circle 是一个密封类，它包含一个私有字段 radius、一个构造函数和一个计算面积的方法 CalculateArea。<br>尝试定义一个继承自 Circle 的类 DerivedCircle 会导致编译错误，因为密封类不能被继承。<br>在 Main 方法中，可以正常实例化密封类 Circle 并调用其方法。</p><h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><p>当你希望某个类的实现细节不被其他类修改，或者某个类的设计已经是最终版本，不需要再进行扩展时，可以使用密封类。例如，一些工具类、单例类等可以设计为密封类。<br>综上所述，抽象类用于提供通用的抽象模板，促进代码的复用和多态性；而密封类用于限制类的继承，保证类的安全性和稳定性。</b></p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 继承</title>
      <link href="/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/"/>
      <url>/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><b>在 C# 中，继承是面向对象编程的一个核心概念，它允许一个类（子类或派生类）继承另一个类（父类或基类）的属性和方法，从而实现代码的复用和扩展。以下从多个方面详细介绍 C# 中的继承：<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>继承建立了类与类之间的一种 “is - a” 关系，即子类是父类的一种特殊类型。通过继承，子类可以拥有父类的成员（字段、属性、方法等），并且可以添加自己特有的成员或重写父类的成员以实现不同的行为。</p><p>语法示例</p><p>以下是一个简单的继承示例，展示了如何定义父类和子类：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个父类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Name&#125;</span> is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个子类 Dog，继承自 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Bark</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Name&#125;</span> is barking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">&quot;Buddy&quot;</span>);</span><br><span class="line">        dog.Eat(); </span><br><span class="line">        dog.Bark(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>在上述代码中：</p><blockquote><p>Animal 是父类，包含一个属性 Name 和一个方法 Eat。<br>Dog 是子类，使用 : 符号表示继承自 Animal 类。子类 Dog 不仅继承了父类的 Name 属性和 Eat 方法，还添加了自己特有的方法 Bark。<br>在 Dog 类的构造函数中，使用 base(name) 调用父类的构造函数来初始化从父类继承的属性。</b></p></blockquote><h2 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h2><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p><b>C# 只支持单继承，即一个类只能直接继承自一个父类。但可以通过接口实现多继承的效果，一个类可以实现多个接口。例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ICanFly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ICanSwim</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Swim</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实现多个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Duck</span> : <span class="title">ICanFly</span>, <span class="title">ICanSwim</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The duck is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Swim</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The duck is swimming.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问修饰符与继承"><a href="#访问修饰符与继承" class="headerlink" title="访问修饰符与继承"></a>访问修饰符与继承</h2><p><b>父类的 public 成员可以在子类中直接访问。<br>父类的 protected 成员只能在父类本身、子类和同一个程序集内的其他类中访问。例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> protectedField = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Child</span> : <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintProtectedField</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(protectedField); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>父类的 private 成员不能被子类直接访问。</p></blockquote><h2 id="方法重写（Override）"><a href="#方法重写（Override）" class="headerlink" title="方法重写（Override）"></a>方法重写（Override）</h2><p><b>子类可以重写父类的虚方法（使用 virtual 关键字修饰的方法），以实现不同的行为。重写时需要使用 override 关键字。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing a shape.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing a circle.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承的优点</p><p>代码复用：避免了重复编写相同的代码，提高了开发效率。例如，多个不同类型的动物类都可以继承自 Animal 类，复用 Eat 方法。</p><p>可维护性：如果需要修改父类的某个通用功能，只需要在父类中修改一次，所有子类都会受到影响，减少了代码的维护成本。</p><p>扩展性：子类可以在继承父类的基础上添加新的功能，实现对现有代码的扩展。</b></p><br><h1 id="base关键字"><a href="#base关键字" class="headerlink" title="base关键字"></a>base关键字</h1><h2 id="调用父类的构造函数"><a href="#调用父类的构造函数" class="headerlink" title="调用父类的构造函数"></a>调用父类的构造函数</h2><p><code>在子类的构造函数中，可以使用 base 关键字来调用父类的构造函数，以完成父类成员的初始化。这在子类需要继承父类的某些初始化逻辑时非常有用。</code></p><p><b>示例代码</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> studentId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类的构造函数，使用 base 调用父类的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age, <span class="built_in">string</span> studentId</span>) : <span class="title">base</span>(<span class="params">name, age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.studentId = studentId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 Student 类的构造函数中，base(name, age) 调用了父类 Person 的构造函数，将 name 和 age 参数传递给父类构造函数进行初始化。这样可以避免在子类中重复编写父类成员的初始化代码。</p></blockquote><h2 id="访问父类的方法和属性"><a href="#访问父类的方法和属性" class="headerlink" title="访问父类的方法和属性"></a>访问父类的方法和属性</h2><p><code>当子类中重写了父类的方法或属性时，可以使用 base 关键字来访问父类的原始实现。</code></p><p><b>示例代码</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing a shape.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 base 调用父类的 Draw 方法</span></span><br><span class="line">        <span class="keyword">base</span>.Draw();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing a circle.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 Circle 类中重写了 Draw 方法。通过 base.Draw()，可以先调用父类 Shape 的 Draw 方法，然后再执行子类特有的绘制逻辑。这使得子类可以在父类的基础上进行功能扩展。</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><b>访问权限：base 只能访问父类中可访问的成员。即父类的 public 和 protected 成员可以通过 base 访问，而 private 成员不能通过 base 访问。<br>调用时机：在子类构造函数中使用 base 调用父类构造函数时，base 语句必须是构造函数中的第一条语句。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>base 关键字为子类提供了一种方便的方式来与父类进行交互。它可以帮助我们在子类中复用父类的构造逻辑，并且在重写方法时能够访问父类的原始实现，从而实现代码的复用和功能的扩展。</b></p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 堆栈和静态类型</title>
      <link href="/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E5%A0%86%E6%A0%88%E5%92%8C%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E5%A0%86%E6%A0%88%E5%92%8C%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="堆栈和静态储区"><a href="#堆栈和静态储区" class="headerlink" title="堆栈和静态储区"></a>堆栈和静态储区</h1><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><b>概念</b></h3><li><b>值类型：</b></li><blockquote><p>值类型变量直接包含它们的数据。当你声明一个值类型变量时，这个变量本身存储了实际的值。例如，C# 中的基本数据类型（如int、double、bool等）都是值类型。如果有一个int变量num &#x3D; 5;，变量num存储的就是数字5这个值。值类型在内存中的存储相对简单，通常存储在栈（Stack）上。</p></blockquote><li><b>引用类型：</b></li><blockquote><p>引用类型变量存储的是一个引用，这个引用指向存储数据的实际内存位置（通常是堆 - Heap）。例如，在 C# 中，类（Class）、接口（Interface）、委托（Delegate）等都是引用类型。当你创建一个类的对象时，例如MyClass myObj &#x3D; new MyClass();，变量myObj存储的是指向MyClass对象在堆内存中实际存储位置的引用。</p></blockquote><h3 id="内存分配和管理"><a href="#内存分配和管理" class="headerlink" title="内存分配和管理"></a><b>内存分配和管理</b></h3><li><b>值类型：</b></li><p><code>如前面提到的，值类型一般存储在栈上。当一个值类型变量进入作用域（例如在一个方法内部声明）时，它会在栈上分配内存，当变量离开作用域时，其占用的栈内存会被自动释放。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">int</span> num2 = num1;</span><br><span class="line">        num2 = <span class="number">20</span>;</span><br><span class="line">        Console.WriteLine(num1); </span><br><span class="line">        <span class="comment">// 输出10，因为num1和num2是两个独立的值类型变量，num2的修改不影响num1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，num1和num2都是int值类型变量，它们在栈上有各自独立的存储空间。当num2被赋值为20时，num1的值不受影响。</p></blockquote><li><b>引用类型：</b></li><p><code>引用类型的对象本身存储在堆中，而引用变量存储在栈上。当你创建一个引用类型的对象时，会在堆中分配内存来存储对象的数据，同时在栈上创建一个引用变量来指向堆中的对象。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass obj1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">        obj1.Value = <span class="number">10</span>;</span><br><span class="line">        MyClass obj2 = obj1;</span><br><span class="line">        obj2.Value = <span class="number">20</span>;</span><br><span class="line">        Console.WriteLine(obj1.Value); </span><br><span class="line">        <span class="comment">// 输出20，因为obj1和obj2指向同一个堆中的对象，修改obj2会影响obj1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里，obj1和obj2是引用变量，它们指向同一个MyClass对象在堆中的存储位置。当通过obj2修改Value属性时，obj1所指向的对象的属性也被修改了，因为它们引用的是同一个对象。</p></blockquote><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><b>参数传递</b></h3><li><b>值类型：</b></li><p><code>当一个值类型变量作为参数传递给一个方法时，实际上是将变量的值复制一份传递给方法。方法内部对参数的修改不会影响原始变量的值。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModifyValue</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> originalNum = <span class="number">10</span>;</span><br><span class="line">        ModifyValue(originalNum);</span><br><span class="line">        Console.WriteLine(originalNum); </span><br><span class="line">        <span class="comment">// 输出10，因为在ModifyValue方法中修改的是复制后的num，而不是originalNum</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><li><b>引用类型：</b></li><p><code>当一个引用类型变量作为参数传递给一个方法时，传递的是引用的副本。这意味着方法内部可以通过这个引用访问和修改原始对象。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModifyObject</span>(<span class="params">MyClass obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.Value = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">        MyClass originalObj = <span class="keyword">new</span> MyClass();</span><br><span class="line">        originalObj.Value = <span class="number">10</span>;</span><br><span class="line">        ModifyObject(originalObj);</span><br><span class="line">        Console.WriteLine(originalObj.Value); </span><br><span class="line">        <span class="comment">// 输出20，因为在ModifyObject方法中通过引用修改了originalObj指向的对象的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a><b>性能差异</b></h3><li><b>值类型：</b></li><blockquote><p>由于值类型数据存储在栈上，访问速度通常比较快。而且值类型的内存管理相对简单，在变量离开作用域时自动释放内存，不需要像引用类型那样进行复杂的垃圾回收（Garbage Collection）操作。</p></blockquote><li><b>引用类型：</b></li><blockquote><p>引用类型的存储和访问涉及到堆和栈的交互。从栈上的引用变量访问堆中的对象可能会稍微慢一些。并且，引用类型对象的生命周期由垃圾回收机制管理，当对象不再被引用时，垃圾回收器会在合适的时间回收对象占用的堆内存，这个过程可能会带来一定的性能开销。不过，引用类型的灵活性使得它们在面向对象编程中非常重要，例如用于实现复杂的数据结构和对象之间的关系。</p></blockquote><br><h1 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h1><h2 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h2><blockquote><p>在 C# 中，栈（Stack）是一种用于存储数据的数据结构，它主要用于存储方法（函数）调用的相关信息，包括局部变量、方法参数、返回地址等。栈的操作遵循 “后进先出”（LIFO - Last In First Out）原则，就像一摞盘子，最后放上去的盘子最先被拿下来。</p></blockquote><blockquote><p>栈在内存中有一个固定的大小（这个大小由操作系统和编译器等因素决定），并且是自动管理内存的。当一个方法被调用时，系统会在栈上为这个方法分配一块内存区域，用于存储该方法所需的信息。当方法执行结束后，这块内存区域会被自动释放，栈顶指针会相应地调整，使得栈恢复到之前的状态。</p></blockquote><h2 id="栈在内存中的存储方式"><a href="#栈在内存中的存储方式" class="headerlink" title="栈在内存中的存储方式"></a>栈在内存中的存储方式</h2><blockquote><p>栈通常存储在内存的较高地址区域。它的内存布局是从高地址向低地址增长的。例如，当一个新的方法被调用时，新的栈帧（Stack Frame）会在栈顶创建。栈帧包含了这个方法的所有局部变量和调用信息。</p></blockquote><blockquote><p>假设一个简单的 C# 程序，在Main方法中调用了另一个方法SomeMethod，当SomeMethod被调用时，一个新的栈帧会在栈顶被创建，用于存储SomeMethod的局部变量和其他相关信息。当SomeMethod执行完毕，这个栈帧会被销毁，栈顶指针会回到Main方法栈帧的位置。</p></blockquote><h2 id="栈在方法调用中的作用"><a href="#栈在方法调用中的作用" class="headerlink" title="栈在方法调用中的作用"></a>栈在方法调用中的作用</h2><h3 id="参数传递："><a href="#参数传递：" class="headerlink" title="参数传递："></a>参数传递：</h3><blockquote><p>当一个方法被调用时，方法的参数会被压入栈中。例如，对于一个方法void MyMethod(int a, int b)，当调用MyMethod(3, 5)时，值3和5会按照从右到左的顺序（在 C# 中一般是这个顺序）被压入栈中。这是因为在方法内部，参数的访问通常是从左到右的，先压入b的值5，再压入a的值3，这样在方法内部就可以按照正确的顺序访问参数。</p></blockquote><h3 id="局部变量存储："><a href="#局部变量存储：" class="headerlink" title="局部变量存储："></a>局部变量存储：</h3><blockquote><p>方法内部的局部变量也存储在栈中。例如，在一个方法void AnotherMethod()中有一个局部变量int localVar &#x3D; 10，这个localVar变量会在AnotherMethod的栈帧中分配一个存储位置，用于存放值10。</p></blockquote><h3 id="返回地址存储："><a href="#返回地址存储：" class="headerlink" title="返回地址存储："></a>返回地址存储：</h3><blockquote><p>当一个方法被调用时，调用该方法的指令的下一条指令的地址（即返回地址）会被存储在栈中。这样，当被调用的方法执行完毕后，系统可以根据这个返回地址回到调用者继续执行后面的指令。例如，在Main方法中调用SomeFunction，当SomeFunction被调用时，Main方法中调用SomeFunction指令的下一条指令的地址会被存储在栈中，当SomeFunction执行结束后，程序会根据这个地址回到Main方法继续执行。</p></blockquote><h3 id="访问速度："><a href="#访问速度：" class="headerlink" title="访问速度："></a>访问速度：</h3><blockquote><p>一般来说，栈的访问速度相对较快。因为栈的内存布局比较规整，而且不需要像堆那样进行复杂的内存管理操作（如垃圾回收）来查找和释放内存。数据在栈上的存储和访问比较直接，而堆中的对象可能因为垃圾回收等操作而导致存储位置发生变化，从而影响访问速度。</p></blockquote><br><h1 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h1><p><code>在 C# 中，堆（Heap）是用于动态内存分配的重要内存区域，主要用于存储引用类型的对象。下面将从堆的基本概念、堆内存分配、垃圾回收机制、堆与栈的对比等方面详细介绍。</code></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>堆是一块较大的内存区域，它与栈不同，栈主要用于存储局部变量和方法调用信息，遵循后进先出（LIFO）原则。而堆用于存储引用类型的对象，其内存分配和释放由垃圾回收器（Garbage Collector，GC）负责管理，不遵循 LIFO 原则。</p></blockquote><h2 id="堆内存分配"><a href="#堆内存分配" class="headerlink" title="堆内存分配"></a>堆内存分配</h2><p><code>当使用 new 关键字创建一个引用类型的对象时，系统会在堆上为该对象分配内存。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在堆上创建一个 Person 对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.Name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        person.Age = <span class="number">25</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上述代码中，new Person() 语句会在堆上分配一块内存，用于存储 Person 对象的 Name 和 Age 字段。同时，栈上的 person 变量存储的是指向堆上该 Person 对象的引用。</p></blockquote><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p><code>垃圾回收器（GC）负责自动回收堆上不再被引用的对象所占用的内存。其主要工作流程如下：<br>标记阶段：GC 会从根对象（如全局变量、静态变量、当前执行栈中的变量等）开始遍历所有可达的对象，并将这些对象标记为 “存活”。<br>清除阶段：未被标记为 “存活” 的对象被视为垃圾对象，GC 会回收这些对象所占用的内存。<br>压缩阶段：为了减少内存碎片，GC 可能会对堆上的存活对象进行移动和整理，使它们在内存中连续存储。</code></p><li><b>例如：</b></li>    <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass obj1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">        obj1.Value = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 现在 obj1 指向一个新的对象，原来的对象不再被引用</span></span><br><span class="line">        obj1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">        obj1.Value = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 之前创建的第一个 MyClass 对象成为了垃圾，等待垃圾回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>垃圾回收器会在合适的时机（如堆空间不足、手动触发等）对这些垃圾对象进行回收。</p></blockquote><h2 id="堆与栈的对比"><a href="#堆与栈的对比" class="headerlink" title="堆与栈的对比"></a>堆与栈的对比</h2><table>    <tr>        <th>对比项</th>        <th>堆</th>        <th>栈</th>    </tr>    <tr>        <td>存储内容</td>        <td>引用类型的对象</td>        <td>值类型的变量、方法调用信息（如局部变量、返回地址等）</td>    </tr>    <tr>        <td>内存管理</td>        <td>由垃圾回收器自动管理</td>        <td>自动分配和释放，方法执行结束后，栈上的内存自动回收</td>    </tr>    <tr>    <td>分配和访问速度</td>    <td>相对较慢，因为涉及复杂的内存管理和对象查找</td>    <td>相对较快，内存分配和释放简单直接</td>    </tr>    <tr>        <td>内存布局</td>        <td>不遵循特定顺序，可能会产生内存碎片</td>        <td>遵循后进先出（LIFO）原则，内存布局较为规整</td>    </tr>    </table>        <h2 id="堆的性能影响因素"><a href="#堆的性能影响因素" class="headerlink" title="堆的性能影响因素"></a>堆的性能影响因素</h2><blockquote><p>象创建频率：频繁创建和销毁对象会增加垃圾回收的负担，影响性能。可以考虑对象池技术来复用对象，减少对象创建和销毁的次数。<br>大对象分配：大对象（如大型数组）会被分配到特殊的大对象堆（LOH）中，大对象堆的垃圾回收机制与普通堆不同，频繁分配大对象可能会导致内存碎片化和性能问题。<br>垃圾回收策略：不同的垃圾回收模式（如工作站模式、服务器模式）适用于不同的应用场景，选择合适的垃圾回收模式可以提高性能。<br>综上所述，了解 C# 中堆的工作原理和特点，有助于编写高效、稳定的代码。</p></blockquote><br><h1 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h1><p><code>C# 中，静态类型是一个重要的概念，它贯穿于语言的多个方面，下面从静态类型的定义、静态成员、静态类以及静态类型检查几个方面详细介绍：</code></p><h2 id="静态类型的定义"><a href="#静态类型的定义" class="headerlink" title="静态类型的定义"></a>静态类型的定义</h2><p><code>静态类型指的是在编译时就确定变量、表达式或参数的类型。在 C# 里，当你声明一个变量时，必须明确指定它的类型，编译器会在编译阶段进行类型检查，确保代码中所有操作都符合该类型的定义。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个 int 类型的变量</span></span><br><span class="line"><span class="built_in">int</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 声明一个 string 类型的变量</span></span><br><span class="line"><span class="built_in">string</span> message = <span class="string">&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在上述代码中，number 被明确指定为 int 类型，message 被指定为 string 类型，编译器在编译时会根据这些类型信息来验证对它们的操作是否合法。例如，不能直接将一个字符串赋值给 int 类型的变量，否则会产生编译错误。</p></blockquote><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><h3 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a><b>静态字段</b></h3><p><code>静态字段属于类本身，而不是类的实例。无论创建多少个类的实例，静态字段在内存中只有一份副本。可以通过类名直接访问静态字段。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 静态字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> StaticField = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过类名访问静态字段</span></span><br><span class="line">        Console.WriteLine(MyClass.StaticField); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a><b>静态方法</b></h3><p><code>静态方法同样属于类本身，不能通过类的实例来调用，只能通过类名调用。静态方法只能直接访问类的静态成员，不能直接访问实例成员。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过类名调用静态方法</span></span><br><span class="line">        <span class="built_in">int</span> result = Calculator.Add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(result); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a><b>静态属性</b></h3><p><code>静态属性和静态字段类似，也是属于类本身。可以通过类名来访问静态属性，并且可以在属性的访问器中添加自定义的逻辑。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Count</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; count = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过类名访问静态属性</span></span><br><span class="line">        Counter.Count = <span class="number">5</span>;</span><br><span class="line">        Console.WriteLine(Counter.Count); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h2><p><code>静态类是一种特殊的类，它只能包含静态成员，不能被实例化。静态类常用于创建工具类，提供一组相关的静态方法和属性。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MathUtils</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Square</span>(<span class="params"><span class="built_in">double</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num * num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> Pi &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="number">3.14159</span>; &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过类名调用静态方法</span></span><br><span class="line">        <span class="built_in">double</span> result = MathUtils.Square(<span class="number">4</span>);</span><br><span class="line">        Console.WriteLine(result); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过类名访问静态属性</span></span><br><span class="line">        Console.WriteLine(MathUtils.Pi); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态类型检查"><a href="#静态类型检查" class="headerlink" title="静态类型检查"></a>静态类型检查</h2><p><code>静态类型检查是 C# 编译器在编译阶段进行的一项重要工作。它会检查代码中变量的使用是否符合其声明的类型，确保类型安全。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 下面这行代码会产生编译错误，因为不能将 int 类型赋值给 string 类型的变量</span></span><br><span class="line"><span class="comment">// string str = num; </span></span><br></pre></td></tr></table></figure><blockquote><p>编译器会在编译时发现上述代码的类型不匹配问题，并给出相应的错误信息，从而避免在运行时出现类型相关的异常。这种静态类型检查机制有助于提高代码的可靠性和可维护性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 匿名类型</title>
      <link href="/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>在 C# 中，匿名类型是一种可以在不定义具体类型（如类）的情况下创建对象的方式。匿名类型提供了一种便捷的方法来封装一组只读属性，通常用于临时的数据存储和传递。</code></p><p><b>匿名类型的实例是由编译器自动生成的类型，其类型名对于开发者是不可见的。例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> &#123; Name = <span class="string">&quot;John&quot;</span>, Age = <span class="number">30</span> &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里创建了一个匿名类型的对象person，它有两个属性Name和Age。var关键字让编译器根据初始化表达式来推断变量<br>的类型。</p></blockquote><p><b>属性访问</b></p><p><b>可以通过对象实例来访问其属性。例如，对于上面的person对象，可以这样访问属性：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(person.Name); </span><br><span class="line">Console.WriteLine(person.Age);</span><br></pre></td></tr></table></figure><p><b>由于匿名类型的属性是只读的，不能对其进行重新赋值。例如，下面的代码是错误的：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.Name = <span class="string">&quot;Jane&quot;</span>; <span class="comment">// 编译错误，因为匿名类型的属性是只读的</span></span><br></pre></td></tr></table></figure><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p><code>LINQ 查询结果的临时存储：在 LINQ（Language - Integrated Query）中，经常会使用匿名类型来存储查询结果。例如，假设有一个List&lt;int&gt;类型的列表numbers，要获取其中每个数字的平方和立方并存储为一个新的对象集合，可以这样做：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> n <span class="keyword">in</span> numbers</span><br><span class="line">             <span class="keyword">select</span> <span class="keyword">new</span> &#123; Square = n * n, Cube = n * n * n &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里result是一个包含匿名类型对象的集合，每个对象都有Square和Cube两个属性，分别存储数字的平方和立方。</p></blockquote><p><code>作为方法返回值的临时类型：当需要从一个方法返回一组简单的数据，但又不想专门为此定义一个类时，可以使用匿名类型。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">object</span> <span class="title">GetData</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> &#123; Message = <span class="string">&quot;Success&quot;</span>, StatusCode = <span class="number">200</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>调用GetData方法时，会返回一个匿名类型的对象，包含Message和StatusCode两个属性。</p></blockquote><h2 id="匿名类型的限制"><a href="#匿名类型的限制" class="headerlink" title="匿名类型的限制"></a>匿名类型的限制</h2><p><code>不能跨方法共享：因为匿名类型是由编译器在编译时生成的临时类型，其类型定义只在定义它的方法内部有效。如果要在多个方法之间传递数据，最好使用自定义的类或结构。</code></p><p><code>缺少类型名称：由于没有明确的类型名称，不能将匿名类型用作方法参数的类型声明（除非使用object等更通用的类型来接收），也不能用于继承等面向对象的高级特性。例如，不能这样定义一个方法：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessData</span>(<span class="params"><span class="keyword">new</span> &#123; Name = <span class="string">&quot;&quot;</span>, Age = <span class="number">0</span> &#125;</span>) <span class="comment">// 编译错误，不能使用匿名类型作为参数类型</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp 构造函数的使用，this关键字</title>
      <link href="/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2025/01/27/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="什么是构造函数？"><a href="#什么是构造函数？" class="headerlink" title="什么是构造函数？"></a>什么是构造函数？</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><b>定义</b></h3><p><code>在 C# 中，构造函数是一种特殊的方法，它与类同名，并且没有返回类型（甚至不能是 void）。构造函数主要用于在创建类的对象时初始化对象的状态。例如，当你创建一个Person类的对象时，可以使用构造函数来初始化Person对象的姓名、年龄等属性。</code></p><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a><b>默认构造函数</b></h3><p><code>如果一个类中没有定义任何构造函数，C# 编译器会自动提供一个默认构造函数。这个默认构造函数没有参数，并且它的作用是初始化对象的成员变量为它们的默认值（例如，数值类型为 0，引用类型为null）。</code></p><p><b>例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> myVariable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">        <span class="comment">// 此时obj.myVariable的值为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="带参数的构造函数"><a href="#带参数的构造函数" class="headerlink" title="带参数的构造函数"></a><b>带参数的构造函数</b></h3><p><code>可以定义带参数的构造函数来根据传入的参数初始化对象的属性。</code></p><p><b>例如，定义一个Rectangle类来表示矩形，有width和height两个属性：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Width &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Height &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"><span class="built_in">int</span> width, <span class="built_in">int</span> height</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Width = width;</span><br><span class="line">        Height = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Rectangle rect = <span class="keyword">new</span> Rectangle(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 此时rect.Width的值为5，rect.Height的值为3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="构造函数的重载"><a href="#构造函数的重载" class="headerlink" title="构造函数的重载"></a><b>构造函数的重载</b></h3><p><code>C# 允许在一个类中定义多个构造函数，只要它们的参数列表不同（参数个数、参数类型或者参数顺序不同）。这被称为构造函数的重载。</code></p><p><b>例如，对于上面的Rectangle类，可以添加一个默认构造函数：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Width &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Height &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Width = <span class="number">0</span>;</span><br><span class="line">        Height = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"><span class="built_in">int</span> width, <span class="built_in">int</span> height</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Width = width;</span><br><span class="line">        Height = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Rectangle rect1 = <span class="keyword">new</span> Rectangle();</span><br><span class="line">        <span class="comment">// rect1.Width和rect1.Height的值都为0</span></span><br><span class="line">        Rectangle rect2 = <span class="keyword">new</span> Rectangle(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// rect2.Width的值为5，rect2.Height的值为3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a><b>构造函数的继承</b></h3><p><code>在派生类中，如果没有显式地调用基类的构造函数，编译器会默认调用基类的无参数构造函数。</code></p><p><b>例如，有一个基类Shape和一个派生类Circle：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = <span class="string">&quot;Shape&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Radius &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="built_in">double</span> radius</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle(<span class="number">2.0</span>);</span><br><span class="line">        <span class="comment">// circle.Name的值为&quot;Shape&quot;，这是因为默认调用了基类Shape的无参数构造函数</span></span><br><span class="line">        <span class="comment">// circle.Radius的值为2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><blockquote><p>如果基类没有无参数构造函数，并且派生类需要调用基类的有参数构造函数，可以使用base关键字在派生类的构造函数中显式地调用基类构造函数。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Radius &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="built_in">double</span> radius</span>) : <span class="title">base</span>(<span class="params"><span class="string">&quot;Circle&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle(<span class="number">2.0</span>);</span><br><span class="line">        <span class="comment">// circle.Name的值为&quot;Circle&quot;，通过base关键字调用了基类Shape的有参数构造函数</span></span><br><span class="line">        <span class="comment">// circle.Radius的值为2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><hr><h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><h2 id="含义和用途"><a href="#含义和用途" class="headerlink" title="含义和用途"></a><b>含义和用途</b></h2><p><code>在 C# 中，this是一个引用当前类的实例的关键字。它主要用于在类的内部区分成员变量和局部变量，尤其是当它们名称相同时。例如，当一个类的方法参数与类的成员变量同名时，使用this可以明确地引用成员变量。</code></p><p><b>例如，有一个Person类，包含name属性和一个方法来设置name属性：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetName</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><blockquote><p>在SetName方法中，参数name是局部变量，this.name引用的是类中的成员变量name。当调用SetName方法并传入一个字符串时，这个字符串会被赋值给成员变量name。</p></blockquote><h3 id="在构造函数中的使用"><a href="#在构造函数中的使用" class="headerlink" title="在构造函数中的使用"></a><b>在构造函数中的使用</b></h3><p><code>this也常用于在一个类的构造函数中调用其他构造函数。这在构造函数重载的情况下很有用，可以避免代码重复。</code></p><p><b>例如，对于一个Rectangle类，有两个构造函数，一个接收长和宽，另一个只接收边长（用于创建正方形）：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"><span class="built_in">int</span> width, <span class="built_in">int</span> height</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"><span class="built_in">int</span> sideLength</span>) : <span class="title">this</span>(<span class="params">sideLength, sideLength</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><blockquote><p>在第二个构造函数中，通过this(sideLength, sideLength)调用了第一个构造函数，这样就可以复用设置width和height的代码。</p></blockquote><h3 id="在链式调用中的应用"><a href="#在链式调用中的应用" class="headerlink" title="在链式调用中的应用"></a><b>在链式调用中的应用</b></h3><p><b>可以在方法返回当前类的实例时使用this来实现链式调用。例如，在一个Calculator类中：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Calculator <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        result += num;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetResult</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以这样使用：Calculator calc &#x3D; new Calculator().Add(5).Add(3).GetResult();，这里Add方法返回this，使得可以连续调用Add方法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp public与private说明 set-get方法</title>
      <link href="/2025/01/26/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%AC%E6%9C%89%E8%AF%B4%E6%98%8E/"/>
      <url>/2025/01/26/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%AC%E6%9C%89%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="set-get方法的使用"><a href="#set-get方法的使用" class="headerlink" title="set-get方法的使用"></a>set-get方法的使用</h1><p><code>在 C# 中，get 和 set 主要用于定义属性（Property），属性是一种用于封装字段（Field）的成员，它提供了对字段的访问控制，使得可以更安全、更方便地读取和修改字段的值。以下是关于 get 和 set 的详细介绍：</code></p><p><b>1. 属性的基本概念</b></p><blockquote><p>属性结合了字段和方法的优点，从外部看它就像一个字段，可以像访问字段一样访问属性；但在内部，它通过 get 和 set 访问器来控制对字段的读写操作。</p></blockquote><p><b>2. 完整属性定义（包含 get 和 set）</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 私有字段，用于存储数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共属性，用于封装 _name 字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get 访问器用于获取属性的值</span></span><br><span class="line">            <span class="keyword">return</span> _name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// set 访问器用于设置属性的值</span></span><br><span class="line">            <span class="comment">// value 是一个隐式参数，代表要设置的值</span></span><br><span class="line">            _name = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 设置属性值，调用 set 访问器</span></span><br><span class="line">        person.Name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取属性值，调用 get 访问器</span></span><br><span class="line">        Console.WriteLine(person.Name); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>在上述代码中：</b></p><blockquote><p>_name 是一个私有字段，用于实际存储数据。<br>Name 是一个公共属性，它封装了 _name 字段。<br>get 访问器用于返回 _name 字段的值，当从外部读取 Name 属性时，会执行 get 访问器中的代码。<br>set 访问器用于设置 _name 字段的值，当从外部给 Name 属性赋值时，会执行 set 访问器中的代码，value 是一个隐式参数，它代表要设置的新值。</p></blockquote><p><b>3. 只读属性（只包含 get 访问器）</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> _radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="built_in">double</span> radius</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只读属性，只有 get 访问器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Area</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.PI * _radius * _radius;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 可以读取 Area 属性的值</span></span><br><span class="line">        Console.WriteLine(circle.Area); </span><br><span class="line">        <span class="comment">// 下面这行代码会报错，因为 Area 是只读属性</span></span><br><span class="line">        <span class="comment">// circle.Area = 100; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，Area 属性只有 get 访问器，没有 set 访问器，所以它是只读的。外部代码只能读取该属性的值，不能对其进行赋值操作。</p></blockquote><p><b>4. 自动实现属性（简化属性定义）</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Book</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自动实现属性，编译器会自动生成一个隐藏的私有字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Author &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.Title = <span class="string">&quot;C# Programming&quot;</span>;</span><br><span class="line">        book.Author = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Title: <span class="subst">&#123;book.Title&#125;</span>, Author: <span class="subst">&#123;book.Author&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在自动实现属性中，不需要显式定义私有字段，编译器会自动生成一个隐藏的私有字段。可以直接使用 get 和 set 访问器，代码更加简洁。</p></blockquote><p><b>5. 访问修饰符与 get、set</b></p><blockquote><p>可以为 get 和 set 访问器分别指定不同的访问修饰符，以实现更细粒度的访问控制。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _age = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 类内部可以调用私有 set 访问器</span></span><br><span class="line">        Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 可以读取 Age 属性的值</span></span><br><span class="line">        Console.WriteLine(student.Age); </span><br><span class="line">        <span class="comment">// 下面这行代码会报错，因为 set 访问器是私有的</span></span><br><span class="line">        <span class="comment">// student.Age = 21; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，Age 属性的 set 访问器被声明为 private，这意味着只有在 Student 类内部才能修改 Age 属性的值，外部代码只能读取该属性的值。</p></blockquote><br><hr><h1 id="Csharp-public与private的权限控制"><a href="#Csharp-public与private的权限控制" class="headerlink" title="Csharp public与private的权限控制"></a>Csharp public与private的权限控制</h1><p><b>访问修饰符的概念</b></p><p><code>在 C# 中，访问修饰符用于控制类、成员（如字段、方法、属性等）的可访问性。<mark>public</mark>和<mark>private</mark>是两种最常用的访问修饰符。它们定义了代码中的哪些部分可以访问特定的类成员。</code></p><p><b>private访问修饰符</b></p><blockquote><p>含义：private是最严格的访问级别。被标记为private的成员只能在其所属的类内部访问。</p></blockquote><p><b>示例代码：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> myPrivateVariable;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MyPrivateMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这个方法可以访问myPrivateVariable</span></span><br><span class="line">        myPrivateVariable = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">AnotherClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myObj = <span class="keyword">new</span> MyClass();</span><br><span class="line">        <span class="comment">// 下面这行代码会导致编译错误，因为myPrivateVariable是私有的，不能在MyClass外部访问</span></span><br><span class="line">        <span class="comment">// myObj.myPrivateVariable = 5;</span></span><br><span class="line">        <span class="comment">// 下面这行代码会导致编译错误，因为MyPrivateMethod是私有的，不能在MyClass外部访问</span></span><br><span class="line">        <span class="comment">// myObj.MyPrivateMethod();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>用途：</b></p><blockquote><p>用于隐藏类的内部实现细节。例如，一个类可能有一些内部的计数器或者状态变量，这些变量不应该被外部代码随意修改，就可以将它们声明为private。这样可以确保类的完整性和一致性，防止外部代码对内部数据进行不恰当的操作。<br>限制对方法的访问。有些方法可能只是为了辅助类内部的其他方法而存在，不应该被外部调用，将这些方法声明为private可以避免它们被误用。</p></blockquote><p><b>public访问修饰符</b></p><blockquote><p>含义：public提供了最广泛的访问级别。被标记为public的成员可以从任何其他类访问，无论是在同一个程序集中还是在引用了该程序集的其他程序集中。</p></blockquote><p><b>示例代码：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> myPublicVariable;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyPublicMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这个方法可以被其他类访问</span></span><br><span class="line">        myPublicVariable = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">AnotherClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myObj = <span class="keyword">new</span> MyClass();</span><br><span class="line">        myObj.myPublicVariable = <span class="number">5</span>;</span><br><span class="line">        myObj.MyPublicMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>用途：</b></p><blockquote><p>当需要向外部提供类的功能或者数据时使用。例如，一个表示图形的类可能有一个public方法用于绘制图形，或者一个表示数据库连接的类可能有public属性用于获取连接字符串。这些public成员构成了类与外部世界交互的接口，其他类可以通过这些接口来使用该类的功能。</p></blockquote><p>protected（受保护的）</p><p>含义：被 protected 修饰的成员可以在其所属的类内部以及该类的派生类中访问。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> myProtectedVariable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyDerivedClass</span> : <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyDerivedMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可以访问myProtectedVariable，因为MyDerivedClass继承自MyBaseClass</span></span><br><span class="line">        myProtectedVariable = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>internal（内部的）</p><p>含义：被 internal 修饰的成员可以在同一程序集（一个.dll 或.exe 文件）内的任何类中访问。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyInternalClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">MyInternalMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有另一个类在相同的程序集中，就可以访问MyInternalClass和MyInternalMethod，但如果在其他程序集中则无法访问。</p><p>protected internal（受保护的内部）</p><p>含义：这是一种组合修饰符。被 protected internal 修饰的成员可以在其所属的类内部、该类的派生类中或者同一程序集内的任何类中访问。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyBaseClass2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">internal</span> <span class="built_in">int</span> myProtectedInternalVariable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyDerivedClass2</span> : <span class="title">MyBaseClass2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyDerivedMethod2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可以访问myProtectedInternalVariable，因为是派生类</span></span><br><span class="line">        myProtectedInternalVariable = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，在同一程序集中的其他类也可以访问myProtectedInternalVariable。</p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp类的定义和使用</title>
      <link href="/2025/01/26/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/01/26/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><p><code>在 C# 中，类是一种用户定义的数据类型，它是面向对象编程的基本构建块。类用于封装数据（通过字段）和行为（通过方法）。定义一个类的基本语法如下：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类的成员（字段、方法、属性等）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>例如，定义一个简单的Person类：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 字段，用于存储人的姓名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="comment">// 方法，用于打印问候语</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Hello, my name is <span class="subst">&#123;Name&#125;</span>.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h1><p><b>字段</b></p><p><code>字段是类中的变量，用于存储数据。它们可以有不同的访问修饰符，如public、private、protected等。public字段可以从类的外部访问，而private字段只能在类的内部访问。例如，在上面的Person类中，Name是一个public字段。</code></p><p><b>方法</b></p><p><code>方法是类中的函数，用于定义类的行为。方法可以接受参数并返回一个值。例如，Person类中的SayHello方法没有参数，并且返回类型为void（即不返回任何值）。如果一个方法要返回一个值，需要在方法声明中指定返回类型。</code></p><p><b>例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>属性</b><br>属性提供了一种灵活的方式来访问和修改类中的数据。属性在形式上类似于字段，但实际上它们包含了get（用于获取值）和set（用于设置值）访问器。例如，我们可以为Person类的Name字段添加属性：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样，我们可以通过属性来访问和修改_name字段，并且可以在get和set访问器中添加额外的逻辑，如数据验证。</p></blockquote><p><b>构造函数</b></p><p><code>构造函数是一种特殊的方法，用于在创建类的对象时初始化对象的状态。构造函数的名称与类名相同，并且没有返回类型（甚至不能是void）。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>现在，当我们创建一个Person对象时，必须提供姓名和年龄：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><b>访问修饰符</b></p><blockquote><p>public：公开的，类的外部可以访问。例如，public方法和字段可以在其他类中通过对象实例来访问。<br>private：私有的，只能在类的内部访问。通常用于封装类的内部实现细节，防止外部代码的非法访问。<br>protected：受保护的，只能在类的内部以及该类的派生类中访问。用于在继承关系中控制成员的访问权限。<br>internal：内部的，在同一个程序集（Assembly）内可以访问。这对于组织代码和限制访问范围很有用。</p></blockquote><p><b>继承</b></p><p><code>C# 支持类的继承，它允许一个类（派生类或子类）继承另一个类（基类或父类）的成员。继承的语法如下：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 派生类的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>例如，定义一个Student类继承自Person类：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> School;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age, <span class="built_in">string</span> school</span>) : <span class="title">base</span>(<span class="params">name, age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        School = school;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里，Student类继承了Person类的Name和Age字段以及相关方法。并且Student类有自己的字段School。构造函数中的base(name, age)用于调用基类Person的构造函数来初始化继承的成员。</p></blockquote><p><b>多态性</b></p><p><code>多态性是面向对象编程的重要概念，C# 通过方法重写（Override）来实现多态。在基类中定义一个虚方法（使用virtual关键字），然后在派生类中重写该方法（使用override关键字）。例如：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">double</span> <span class="title">Area</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="built_in">double</span> r</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Area</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当我们有一个Shape类型的数组，其中包含不同的形状（如Circle）对象时，通过调用Area方法，会根据对象的实际类型（多态）来执行正确的Area计算方法。</p></blockquote><br><hr><h1 id="车辆类与向量类的定义和使用"><a href="#车辆类与向量类的定义和使用" class="headerlink" title="车辆类与向量类的定义和使用"></a>车辆类与向量类的定义和使用</h1><p><b>车辆类（Vehicle Class）</b></p><p><b>定义和基本属性</b></p><p><code>首先，车辆类可以包含车辆的基本属性，如品牌（brand）、型号（model）、颜色（color）、速度（speed）等。在 C# 中，可以这样定义车辆类：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Brand &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Model &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> speed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Speed</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> speed; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里，Brand、Model和Color是公共属性，可以直接读写。Speed属性是通过一个私有字段speed来实现的，并且在设置速度时进行了简单的验证，确保速度不小于 0。</p></blockquote><p><b>方法</b></p><p><code>车辆类可以有一些方法，比如加速（Accelerate）和减速（Decelerate）方法。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//... 前面定义的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>(<span class="params"><span class="built_in">double</span> increment</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Speed += increment;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Decelerate</span>(<span class="params"><span class="built_in">double</span> decrement</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Speed -= decrement;</span><br><span class="line">        <span class="keyword">if</span> (Speed &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Speed = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这些方法可以改变车辆的速度属性。Accelerate方法将速度增加指定的增量，Decelerate方法将速度减少指定的减量，并确保速度不会小于 0。</p></blockquote><br><p><b>向量类（Vector Class）</b></p><p><b>定义和基本操作</b></p><p><code>在数学和编程中，向量是一个很重要的概念。在 C# 中，可以定义一个二维向量类，包含 x 和 y 两个分量。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Vector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这是一个简单的向量类定义，有两个公共属性X和Y来表示向量的两个分量，并且通过构造函数来初始化这两个分量。</p></blockquote><p><b>向量运算方法</b></p><p><b>向量类可以有一些方法来进行向量运算，比如向量加法和减法。</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Vector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//... 前面定义的属性和构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector <span class="title">Add</span>(<span class="params">Vector other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector(X + other.X, Y + other.Y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector <span class="title">Subtract</span>(<span class="params">Vector other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector(X - other.X, Y - other.Y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Add方法用于将当前向量和另一个向量相加，返回一个新的向量。Subtract方法用于将当前向量减去另一个向量，也返回一个新的向量。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp面向对象概念引入</title>
      <link href="/2025/01/26/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5%E5%BC%95%E5%85%A5/"/>
      <url>/2025/01/26/cshrap%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/csharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5%E5%BC%95%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象编程（Object-Oriented-Programming）"><a href="#面向对象编程（Object-Oriented-Programming）" class="headerlink" title="面向对象编程（Object - Oriented Programming）"></a>面向对象编程（Object - Oriented Programming）</h1><h2 id="面向对象概念引入："><a href="#面向对象概念引入：" class="headerlink" title="面向对象概念引入："></a>面向对象概念引入：</h2><p> <b>从实际生活场景类比引入</b></p><p><code>想象我们要开发一个汽车管理系统。在现实生活中，汽车是一个具有多种属性和行为的实体。汽车有颜色（如红色、蓝色）、品牌（如丰田、宝马）、速度（如 0 - 200km/h）等属性，还有启动、加速、刹车等行为。</code></p><p><b>在 C# 中，我们可以把汽车抽象成一个<mark>类（class）</mark>，就像创建一个汽车的蓝图。这个类可以定义汽车的各种属性和行为。例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 汽车的属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Brand;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Speed;</span><br><span class="line">    <span class="comment">// 汽车的行为（方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The car has started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Speed += <span class="number">10</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;The <span class="subst">&#123;Brand&#125;</span> car&#x27;s speed is now <span class="subst">&#123;Speed&#125;</span> km/h.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Brake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Speed -= <span class="number">5</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;The <span class="subst">&#123;Brand&#125;</span> car&#x27;s speed is now <span class="subst">&#123;Speed&#125;</span> km/h.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里，Color、Brand和Speed是汽车类的属性，用来描述汽车的状态。Start、Accelerate和Brake是方法，代表汽车可以执行的行为。这就是面向对象编程中类的概念，它是对象的模板，定义了对象具有什么和能做什么。<br>通过简单程序结构引入对象和类的关系</p></blockquote><br><p><b>当我们有了汽车类这个蓝图后，就可以创建汽车对象。在 C# 中，使用<mark>new</mark>关键字来创建对象。例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Car myCar = <span class="keyword">new</span> Car();</span><br><span class="line">        myCar.Color = <span class="string">&quot;Red&quot;</span>;</span><br><span class="line">        myCar.Brand = <span class="string">&quot;Toyota&quot;</span>;</span><br><span class="line">        myCar.Speed = <span class="number">0</span>;</span><br><span class="line">        myCar.Start();</span><br><span class="line">        myCar.Accelerate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个Main方法中，Car myCar &#x3D; new Car();这一行创建了一个Car类的对象myCar。然后我们可以像设置变量一样设置对象的属性，如myCar.Color &#x3D; “Red”;。并且可以调用对象的方法，如myCar.Start();和myCar.Accelerate();。这就像根据汽车蓝图制造出了一辆具体的汽车，然后可以对这辆汽车进行各种操作，比如改变它的颜色、启动它、让它加速等。这体现了对象是类的实例的概念，每个对象都有自己独立的属性值，可以执行类中定义的方法。</p></blockquote><br><p><b>引入封装概念以增强数据安全性和程序可维护性</b></p><p><code>在上面的例子中，汽车的属性是直接可访问的，这在某些情况下可能会导致问题。例如，外部代码可能会不小心设置不合理的速度值。为了更好地控制对数据的访问，C# 提供了封装机制。</code></p><p><b>我们可以把属性设为<mark>private（私有）</mark>，然后通过公共<mark>（public）</mark>的方法来访问和修改这些属性。例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> color;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> brand;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> speed;</span><br><span class="line">    <span class="comment">// 公共属性（用于访问私有属性）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> color; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; color = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Brand</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> brand; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; brand = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Speed</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> speed; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 汽车的行为（方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The car has started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Speed += <span class="number">10</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;The <span class="subst">&#123;Brand&#125;</span> car&#x27;s speed is now <span class="subst">&#123;Speed&#125;</span> km/h.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Brake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Speed -= <span class="number">5</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;The <span class="subst">&#123;Board&#125;</span> car&#x27;s speed is now <span class="subst">&#123;Speed&#125;</span> km/h.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里，color、brand和speed是私有属性，外部代码不能直接访问它们。通过定义公共属性Color、Brand和Speed，外部代码可以安全地获取和设置这些属性的值。而且在Speed属性的set方法中，我们可以添加逻辑来确保速度值不会被设置为负数，这增强了数据的安全性和程序的可维护性，体现了封装的概念。</p></blockquote><br><p><b>引入继承来展示代码复用和层次结构</b></p><p><code>假设我们要创建一个跑车（Sports Car）类，跑车也是汽车，它具有汽车的基本属性和行为，但还有一些特殊的功能，比如涡轮增压（Turbo Boost）。</code></p><p><b>在 C# 中，我们可以使用继承来创建跑车类。跑车类（SportsCar）可以继承汽车类（Car）的属性和方法，并添加自己的新方法。例如：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SportsCar</span> : <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurboBoost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Speed += <span class="number">50</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;The <span class="subst">&#123;Brand&#125;</span> sports car&#x27;s speed after turbo boost is <span class="subst">&#123;Speed&#125;</span> km/h.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里，SportsCar类继承了Car类，它自动拥有了Car类的Color、Brand、Speed属性和Start、Accelerate、Brake方法。同时，它还添加了自己的TurboBoost方法。这体现了继承的概念，通过继承可以复用代码，并且可以构建层次化的类结构，使得程序更加清晰和易于维护。</p></blockquote><br><p><b>引入多态来展示方法的灵活性和动态性</b></p><p><code>假设我们有一个方法，它的功能是让汽车显示自己的信息。在汽车类（Car）中，我们可以定义一个方法：</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DisplayInfo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;This is a <span class="subst">&#123;Brand&#125;</span> car with color <span class="subst">&#123;Color&#125;</span> and speed <span class="subst">&#123;Speed&#125;</span> km/h.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>对于跑车类（SportsCar），我们可以重写（override）这个方法来显示更详细的信息：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SportsCar</span> : <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">DisplayInfo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;This is a sports <span class="subst">&#123;Brand&#125;</span> car with color <span class="subst">&#123;Color&#125;</span>, speed <span class="subst">&#123;Speed&#125;</span> km/h and turbo boost function.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>现在，如果我们有一个方法，它接受一个Car类型的对象，并调用这个对象的DisplayInfo方法：</b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Car myCar = <span class="keyword">new</span> Car();</span><br><span class="line">        myCar.Color = <span class="string">&quot;Red&quot;</span>;</span><br><span class="line">        myCar.Brand = <span class="string">&quot;Toyota&quot;</span>;</span><br><span class="line">        myCar.Speed = <span class="number">0</span>;</span><br><span class="line">        SportsCar mySportsCar = <span class="keyword">new</span> SportsCar();</span><br><span class="line">        mySportsCar.Color = <span class="string">&quot;Blue&quot;</span>;</span><br><span class="line">        mySportsCar.Brand = <span class="string">&quot;Ferrari&quot;</span>;</span><br><span class="line">        mySportsCar.Speed = <span class="number">0</span>;</span><br><span class="line">        DisplayCarInfo(myCar);</span><br><span class="line">        DisplayCarInfo(mySportsCar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisplayCarInfo</span>(<span class="params">Car car</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        car.DisplayInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在DisplayCarInfo方法中，它并不知道传入的是普通汽车对象还是跑车对象，但是会根据对象的实际类型来调用相应的DisplayInfo方法。如果是普通汽车对象，就调用Car类的DisplayInfo方法；如果是跑车对象，就调用SportsCar类的DisplayInfo方法。这体现了多态的概念，同一个方法在不同的对象中有不同的行为，增加了程序的灵活性和可扩展性。</p></blockquote><br><hr><h1 id="使用面向对象有什么好处？"><a href="#使用面向对象有什么好处？" class="headerlink" title="使用面向对象有什么好处？"></a>使用面向对象有什么好处？</h1><h2 id="提高代码的可维护性"><a href="#提高代码的可维护性" class="headerlink" title="提高代码的可维护性"></a>提高代码的可维护性</h2><p><b>封装性的优势：</b></p><blockquote><p>通过封装，将数据和操作数据的方法组合在一个类中，并隐藏内部细节。例如，在一个复杂的企业资源规划（ERP）系统中，有一个 “员工” 类，其中包含员工的工资、绩效等敏感数据。这些数据可以被封装为私有属性，只能通过特定的公共方法（如获取工资、更新绩效）来访问和修改。这样，当系统的业务逻辑发生变化，比如工资计算方式改变时，只需要修改 “员工” 类内部的相关方法，而不会影响到系统中其他依赖这个类的部分。</p></blockquote><p><b>层次结构便于管理：</b></p><blockquote><p>面向对象的继承和多态特性使得代码具有清晰的层次结构。以图形绘制系统为例，有一个基类 “图形”，它定义了基本的绘制方法和通用属性（如颜色）。从这个基类派生出来的 “圆形”“方形” 等类可以继承这些基本的功能，并添加自己特有的属性和方法（如圆形的半径、方形的边长）。当需要对系统进行维护，比如优化绘制算法时，开发人员可以很容易地定位到相关的类层次结构部分进行修改，而不会干扰到其他不相关的图形类。</p></blockquote><h2 id="增强代码的复用性"><a href="#增强代码的复用性" class="headerlink" title="增强代码的复用性"></a>增强代码的复用性</h2><p><b>继承实现代码复用：</b></p><blockquote><p>继承允许一个类（派生类）继承另一个类（基类）的属性和方法。例如，在开发一个游戏时，有一个 “角色” 基类，它包含了角色的基本属性（如生命值、攻击力）和通用方法（如移动、攻击）。当创建 “战士”“法师” 等不同类型的角色类时，它们可以继承 “角色” 基类的这些属性和方法，而不需要重新编写相同的代码。这大大减少了代码的冗余，提高了开发效率。</p></blockquote><p> <b>组件化开发便于复用：</b></p><blockquote><p>面向对象编程鼓励将功能划分为独立的类，这些类可以像组件一样在不同的项目中被复用。比如，一个开发好的 “文件读取” 类，可以在多个需要读取文件的应用程序中使用。只要这个类的接口（公共方法和属性）设计合理，就可以方便地集成到新的项目中，而不需要重新编写文件读取相关的代码。</p></blockquote><h2 id="更好地模拟现实世界"><a href="#更好地模拟现实世界" class="headerlink" title="更好地模拟现实世界"></a>更好地模拟现实世界</h2><p><b>自然地抽象现实事物：</b></p><blockquote><p>面向对象编程能够将现实世界中的事物抽象为类和对象。例如，在一个交通模拟系统中，可以将汽车、行人、交通信号灯等都看作对象。汽车对象有品牌、速度、位置等属性，以及启动、加速、刹车等方法；行人对象有姓名、行走速度、目的地等属性和行走、等待等方法；交通信号灯对象有颜色、切换时间等属性和变色方法。通过这些对象之间的交互，可以很自然地模拟出交通场景，使得程序的设计和理解更加贴近现实。</p></blockquote><p><b>方便处理复杂关系：</b></p><blockquote><p>面向对象可以很好地处理现实世界中事物之间的复杂关系。以生态系统模拟为例，动物类和植物类之间存在捕食、共生等关系。可以通过对象之间的方法调用和消息传递来模拟这种关系。比如，动物对象的 “进食” 方法可能会涉及到对植物对象的 “被吃” 方法的调用，这种方式能够更直观地表示和处理复杂的生态关系。</p></blockquote><h2 id="利于团队协作开发"><a href="#利于团队协作开发" class="headerlink" title="利于团队协作开发"></a>利于团队协作开发</h2><p><b>分工明确：</b></p><blockquote><p>在团队开发中，面向对象的编程方式使得不同的开发人员可以负责不同的类或类层次结构。例如，在一个大型的电子商务系统开发中，一个开发人员可以负责 “用户” 类相关的功能，包括用户注册、登录、信息修改等；另一个开发人员可以专注于 “商品” 类相关的部分，如商品添加、删除、展示等。每个开发人员只需要关注自己负责的类的内部实现和对外接口，降低了开发过程中的沟通成本。</p></blockquote><p><b>易于集成与测试：</b></p><blockquote><p>由于类是相对独立的单元，它们之间的接口清晰，这使得在集成各个部分的代码时更加容易。而且，在测试阶段，可以对每个类进行单元测试，检查其功能是否符合预期。例如，在开发一个软件系统时，对于 “订单处理” 类，可以独立地编写测试用例来验证订单的创建、修改、删除等功能是否正确，然后再将这个类集成到整个系统中进行系统测试。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio 2022 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp  try-catch-finally语句处理异常</title>
      <link href="/2025/01/25/csharp%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/"/>
      <url>/2025/01/25/csharp%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1>Csharp 使用try-catch-finally语句处理异常</h1><p>在 C# 编程中，<code>try - catch - finally</code>语句是一种强大的机制，用于处理程序运行时可能出现的异常情况。异常是在程序执行过程中出现的错误或意外情况，例如试图访问不存在的文件、数组越界、除数为零等操作。使用<code>try - catch - finally</code>可以让程序在遇到这些异常时采取适当的措施，而不是直接崩溃。</p><p><b>try 块</b><br>功能：try块是包含可能会抛出异常的代码部分。这是异常处理的起点，当程序执行到try块中的代码时，会监控其中的操作是否会引发异常。</p><li>示例：</li><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    Console.WriteLine(numbers[<span class="number">3</span>]);<span class="comment">// 这里会抛出IndexOutOfRangeException异常，因为数组最大索引是2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，代码试图访问数组numbers中不存在的索引（索引为 3，而数组长度为 3，有效索引范围是 0 - 2），这会导致一个<code>IndexOutOfRangeException</code>异常。</p><li>catch 块</li><p>功能：catch块用于捕获try块中抛出的特定类型的异常。当try块中的代码抛出异常后，程序会查找匹配的catch块来处理该异常。可以有多个catch块，每个catch块可以处理不同类型的异常。</p><li>示例：</li><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    Console.WriteLine(numbers[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IndexOutOfRangeException ex)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;数组索引超出范围，异常信息： &quot;</span> + ex.Message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，catch块捕获了<code>IndexOutOfRangeException</code>类型的异常。ex是异常对象，通过它可以访问异常的详细信息，如Message属性包含了异常的文本描述。当异常被捕获后，catch块中的代码会被执行，这里是打印出异常信息。</p><p><b>finally 块，</b></p><p>功能：finally块中的代码无论try块中是否抛出异常都会被执行。它通常用于清理资源，例如关闭文件、释放数据库连接、释放内存等操作，以确保程序的资源得到正确的管理。</p><li>示例：</li><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    FileStream fileStream = <span class="keyword">new</span> FileStream(<span class="string">&quot;test.txt&quot;</span>, FileMode.Open);</span><br><span class="line">    <span class="comment">// 这里可能会有读取文件等操作，如果出现异常，文件流应该被正确关闭</span></span><br><span class="line">    <span class="comment">// 假设这里有一些可能导致异常的代码，比如读取文件内容时文件格式错误</span></span><br><span class="line">    <span class="comment">// 具体的读取文件操作代码省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileNotFoundException ex)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;文件未找到，异常信息： &quot;</span> + ex.Message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 关闭文件流，无论是否出现异常</span></span><br><span class="line">    <span class="keyword">if</span> (fileStream!= <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fileStream.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，try块尝试打开一个文件流。如果文件不存在，会抛出<code>FileNotFoundException</code>异常并被catch块捕获处理。无论是否出现异常，finally块中的代码都会尝试关闭文件流（这里需要注意的是，在实际代码中，更推荐使用using语句来自动管理文件流等资源，using语句在内部也使用了try - finally机制）。</p><p><b>异常类型的层次结构和匹配规则</b></p><p>在 C# 中，所有异常类型都派生自<code>System.Exception</code>类。当抛出一个异常时，catch块会按照从上到下的顺序查找匹配的异常类型来处理。</p><blockquote><p>例如，System.ArithmeticException是一个抽象类，DivideByZeroException派生自它。如果有一个try块抛出了DivideByZeroException异常，并且有一个catch块捕获System.ArithmeticException，另一个catch块捕获DivideByZeroException，那么会优先匹配DivideByZeroException的catch块，因为它是最具体的匹配。</p></blockquote><li>示例：</li><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> result = a / b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (DivideByZeroException ex)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;除数不能为零，异常信息： &quot;</span> + ex.Message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArithmeticException ex)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;算术异常，异常信息： &quot;</span> + ex.Message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，try块中除法运算除数为零会抛出DivideByZeroException，它会被第一个catch块捕获，而不会匹配第二个catch块，因为DivideByZeroException更具体地匹配了抛出的异常类型。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数clac(),css 媒体查询</title>
      <link href="/2025/01/24/css/clac(),css%20%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"/>
      <url>/2025/01/24/css/clac(),css%20%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:59px;color:#0DE6FE;font-family:华文行楷">calc</h1><p>在 CSS 中，calc() 是一个非常有用的函数，它允许你在 CSS 属性值中进行数学计算。这使得你可以根据不同的长度单位（如像素、百分比等）动态地计算属性值，为网页布局提供了更大的灵活性。以下是关于 calc() 的详细介绍：</p><p><b>基本语法</b></p><li>calc() 函数的基本语法如下：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calc(expression)</span><br></pre></td></tr></table></figure><blockquote><p>其中 expression 是一个数学表达式，该表达式可以包含加（+）、减（-）、乘（*）、除（&#x2F;）四种基本运算符，同时可以使用不同的长度单位，如 px、%、em、rem 等。需要注意的是，运算符前后必须有空格。<br>示例代码及解释</p></blockquote><ol><li>使用 calc() 进行宽度计算<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">800px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: lightgray;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 子元素宽度为父元素宽度减去40px */</span></span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">40px</span>);</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: lightblue;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>在上述代码中，.child 元素的宽度通过 calc(100% - 40px) 计算得出，即父元素宽度减去 40px。这样可以确保子元素在父元素内部有一定的左右边距。</p></blockquote><ol start="2"><li>使用 calc() 进行高度计算<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">html</span>,</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 元素高度为视口高度的50%加上20px */</span></span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">50vh</span> + <span class="number">20px</span>);</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: lightgreen;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>在这个例子中，.box 元素的高度通过 calc(50vh + 20px) 计算，即视口高度的 50% 再加上 20px。</p></blockquote><br><p><b>注意事项</b></p><li>运算符前后的空格：在 calc() 函数中，运算符（+、-、*、/）前后必须有空格，否则表达式将无效。例如，calc(100% - 40px) 是正确的，而 calc(100%-40px) 是错误的。</li><li>计算规则：乘法和除法运算符的优先级高于加法和减法运算符。例如，calc(10px + 5 * 2px) 会先计算 5 * 2px，再加上 10px，结果为 20px。</li><li>兼容性：calc() 函数在现代浏览器中得到了广泛支持，但在一些旧版本的浏览器中可能存在兼容性问题。在使用时，建议进行兼容性测试。</li><br><h1 style="font-size:30px;color:#220DFE;font-family:华文行楷">媒体查询</h1><p>CSS 媒体查询是实现网页响应式设计的关键技术，它能让网页在不同设备和屏幕尺寸下都有良好的显示效果。以下从基础概念、语法、常见应用场景和注意事项等方面详细介绍 CSS 媒体查询的学习要点。</p><p><b>基础概念</b></p><blockquote><p>媒体查询允许你根据设备的各种特性（如屏幕宽度、高度、分辨率、设备方向等）来应用不同的 CSS 样式。通过媒体查询，可以为不同的设备环境定制特定的样式规则，从而实现网页在多种设备上的自适应布局。</p></blockquote><p><b>基本语法</b></p><li>媒体查询使用 @media 规则，其基本语法如下：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> media_type <span class="keyword">and</span> (media_feature) &#123;</span><br><span class="line">    <span class="comment">/* 当条件满足时应用的 CSS 规则 */</span></span><br><span class="line">    selector &#123;</span><br><span class="line">        property: value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>media_type（媒体类型）：指定适用的设备类型，常见值有：<br>all：适用于所有设备，是默认值。<br>screen：用于计算机屏幕、平板电脑、智能手机等。<br>print：用于打印机和打印预览。<br>speech：用于屏幕阅读器等语音合成设备。<br>media_feature（媒体特性）：描述设备的具体特性，通常以括号包裹。常见的媒体特性有：<br>width、min-width 和 max-width：分别表示屏幕宽度、最小屏幕宽度和最大屏幕宽度。例如 (min-width: 768px) 表示屏幕宽度大于等于 768 像素。<br>height、min-height 和 max-height：分别表示屏幕高度、最小屏幕高度和最大屏幕高度。<br>orientation：表示设备的方向，值为 portrait（竖屏）或 landscape（横屏）。</p></blockquote><p><b>逻辑运算符</b></p><p>可以使用逻辑运算符组合多个媒体特性或媒体类型，使查询条件更灵活：</p><p><code>and：</code>用于连接多个媒体特性，表示所有条件都必须满足。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1023px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码表示在屏幕设备且宽度在 768px 到 1023px 之间时，将 body 元素的字体大小设置为 16px。<br>,（逗号）：表示或的关系，只要其中一个条件满足即可。例如：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">767px</span>), print &#123;</span><br><span class="line">    <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段代码表示在屏幕设备宽度小于等于 767px 或者在打印时，隐藏 sidebar 元素。<br>not：用于取反查询结果。例如：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">    <span class="comment">/* 样式规则 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>表示除了屏幕设备且宽度大于等于 768px 的情况外，应用这些样式。<br>常见应用场景</p></blockquote><ol><li>响应式布局</li></ol><p>根据不同屏幕宽度调整页面布局。例如，在小屏幕设备上采用单列布局，大屏幕设备上采用多列布局：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 小屏幕设备（宽度小于 768px） */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">767px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.column</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 中等屏幕设备（宽度在 768px 到 1023px 之间） */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1023px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.column</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 大屏幕设备（宽度大于等于 1024px） */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">1024px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.column</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">33.33%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>字体大小调整</li></ol><p>在不同屏幕尺寸下调整字体大小以提高可读性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 小屏幕设备 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">767px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 大屏幕设备 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">1024px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>图片显示优化</li></ol><p>根据设备分辨率和屏幕大小显示不同尺寸的图片，节省带宽：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 小屏幕设备 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">767px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.image</span> &#123;</span><br><span class="line">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;small-image.jpg&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 大屏幕设备 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">1024px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.image</span> &#123;</span><br><span class="line">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;large-image.jpg&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意事项</b></p><li>媒体查询顺序：媒体查询的顺序很重要，因为后面的规则可能会覆盖前面的规则。一般建议按照从小到大（或从大到小）的屏幕尺寸顺序编写媒体查询。</li><li>浏览器兼容性：现代浏览器对媒体查询的支持很好，但在一些旧版本浏览器中可能存在兼容性问题。可以使用 CSS 前缀或借助 CSS 预处理器（如 Sass、Less）来处理兼容性。</li><li>性能考虑：过多复杂的媒体查询可能会影响页面性能，尤其是在移动设备上。尽量保持媒体查询简洁，避免不必要的嵌套和复杂逻辑。</li>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.14学习笔记</title>
      <link href="/2025/01/24/css/%E5%AD%A6%E4%B9%A0css.14/"/>
      <url>/2025/01/24/css/%E5%AD%A6%E4%B9%A0css.14/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:30px;color:#F30000;font-family:华文行楷">伸缩容器，伸缩项目</h1><li><b>伸缩容器</b>：开启了<code>flex</code>的元素，就是：伸缩容器。</li><blockquote><p>1.给元素设置：<mark>dispay:flex</mark>或<mark>display:inline-flex</mark>，该元素就变为了伸缩容器。<br>2.<mark>display:inline-flex</mark>很少使用，因为可以给多个伸缩容器的父容器，也设置为伸缩容器。<br>3.一个元素可以同时是：伸缩容器、伸缩项目。</p></blockquote><li><b>伸缩项目</b>:伸缩容器所有<mark>子元素</mark>自动成为了：伸缩项目。</li><blockquote><p>1.仅伸缩容器的<mark>子元素</mark>成为了伸缩项目，孙子元素、重孙子元素等后代，不是伸缩项目。<br>2.无论原来是哪种元素（快、行内块、行内），一旦成为了伸缩项目，全都会“块状化”。</p></blockquote><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">主轴与侧轴</h1><li><b>主轴</b>：伸缩项目沿着主轴排列，主轴默认是水平的，默认方向是：从左到右（左边是起点，右边是终点）。</li><li><b>侧轴</b>：与主轴垂直的就是侧轴，侧轴默认是垂直的，默认方向是：从上到下（上边是起点，下边是终点）。</li><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">主轴方向</h1><li>属性名：<code>flex-direction</code></li><li>常用值如下:</li><ol>    <li><code>row</code>：主轴方向水平从左到右--默认值</li>    <li><code>row-reverse</code>：主轴方向水平从右到左。</li>    <li><code>column</code>：主轴方向垂直从上到下。</li>    <li><code>column-reverse</code>：主轴方向垂直从下到上。</li>    </ol> <blockquote><p>注意：改变了主轴的方向，侧轴方向也会随之改变。</p></blockquote><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">主轴换行方式</h1><li>属性名：<mark>flex-wrap</mark></li><li>常用值如下：</li><ol>    <li><code>nowrap</code>：默认值，不换行。</li>    <li><code>wrap</code>：自动换行，伸缩容器不够自动换行。</li>    <li><code>wrap-reverse</code>：反向换行。</li>    </ol>        <h1 style="font-size:30px;color:#F30000;font-family:华文行楷">主轴对齐方式</h1><li>属性名</li>：<mark>justify-content</mark></li><li>常用值如下：</li><ol>    <li><code>flex-start</code>：主轴起点对齐。--默认值</li>    <li><code>flex-end</code>：主轴终点对齐。</li>    <li><code>center</code>：居中对齐</li>    <li><code>space-between</code>：均匀分布，两端对齐（最常用）。</li>    <li><code>space-around</code>：均匀分布，两端距离是中间距离的一半。</li>    <li><code>space-evenly</code>：均匀分布，两端距离与中间距离一致。</li>    </ol><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">侧轴对齐方式</h1>        <p><b>只有一行的情况</b></p><li>所需属性：<mark>align-items</mark></li><li>常用值如下：</li><ol>    <li><code>flex-start</code>：侧轴的起点对齐。</li>    <li><code>flex-end</code>：侧轴的终点对齐。</li>    <li><code>center</code>：侧轴的中点对齐。</li>    <li><code>baseline</code>：伸缩项目的第一行文字的基线对齐。</li>    <li><code>stretch</code>：如果伸缩项目未设置高度，将占满整个容器的高度。--默认值</li>    </ol><p><b>多行的情况</b></p><li>所需属性：<mark>align-content</mark></li><li>常用值如下：</li><ol>    <li><code>flex-start</code>：与侧轴的起点对齐。</li>    <li><code>flex-end</code>：与侧轴的终点对齐。</li>    <li><code>center</code>：与侧轴的中点对齐。</li>    <li><code>space-between</code>：与侧轴两端对齐，中间平均分布。</li>    <li><code>space-around</code>：伸缩项目间的距离相等，比距边缘大一倍。</li>    <li><code>space-evenly</code>：在侧轴上完全平分</li>    <li><code>stretch</code>：占满整个侧轴。--默认值</li>    </ol><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">伸缩盒模型_伸</h1> <p><b><mark>flex-grow</mark></b></p><li>概念：<code>flex-grow</code>定义伸缩项目的放大比例，默认为0，即：纵使主轴存在剩余空间，也不拉伸（放大）。</li><li>规则：</li><ol>    <li>若所有伸缩项目的<code>flex-grow</code>值为1，则：它们将等分剩余空间（如果有空间的话）。</li>    <li>若三个伸缩项目的<code>flex-grow</code>值分别为：1、2、3，则：分别瓜分到：1/6、2/6、3/6的空间。</li>    </ol><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">伸缩盒模型_缩</h1> <p><b><mark>flex-shrink</mark></b></p><li>概念：<code>flex-shrink</code>定义了项目的压缩比例，默认为1，即：如果空间不足，该项目将会缩小。</li><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">flex符合属性</h1><p><mark>flex</mark>是复合属性，复合了：<code>flex-grow、flex-shrink、flex-bassis</code>三个属性，默认值为0、0、auto。</p><li>如果写<code>flex:1 1 auto</code>，则可简写为：<code>flex:auto</code></li><li>如果写<code>flex:1 1 0</code>，则可简写为：<code>flex:auto</code></li><li>如果写<code>flex:0 0 auto</code>，则可简写为：<code>flex:1</code></li><li>如果写<code>flex:0 1 auto</code>，则可简写为：<code>flex:0 auto -- 即flex初始值</code></li><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">项目排序</h1><li><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认值为0。</li><h1 style="font-size:30px;color:#F30000;font-family:华文行楷">单独对齐</h1><li>通过<code>align-self</code>属性，可以单独调整某个伸缩项目的对齐方式。</li><li>默认值为auto,表示继承父元素的align-items属性。</li>    ]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.13学习笔记</title>
      <link href="/2025/01/23/css/%E5%AD%A6%E4%B9%A0css.13/"/>
      <url>/2025/01/23/css/%E5%AD%A6%E4%B9%A0css.13/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:30px;color:#B72795;font-family:华文行楷">CSS 动画</h1><p><b>相较于传统的脚本实现动画技术，使用 CSS 动画有三个主要优点：</b></p><p>1.能够非常容易地创建简单动画，你甚至不需要了解 JavaScript 就能创建动画。</p><p>2.动画运行效果良好，甚至在低性能的系统上。渲染引擎会使用跳帧或者其他技术以保证动画表现尽可能的流畅。而使  用 JavaScript 实现的动画通常表现不佳（除非经过很好的设计）。</p><p>3.让浏览器控制动画序列，允许浏览器优化性能和效果，如降低位于隐藏选项卡中的动画更新频率。</p><br><p>CSS 动画是网页设计中用于创建动态和交互效果的强大工具，以下是关于 CSS 动画的学习内容：</p><p style="font-size:20px"><b>基本概念</b></p><li><b>关键帧</b>：CSS 动画通过定义关键帧来描述动画的不同状态。关键帧使用@keyframes规则来创建，它允许你指定动画在不同时间点的属性值。</li><li><b>动画属性</b>：通过一系列 CSS 动画属性来控制动画的行为，包括动画名称、持续时间、播放次数、播放方向、延迟时间等。</li><br><p style="font-size:20px"><b>主要属性</b></p><p><b>@keyframes</b></p><li><b>语法</b>：<code>@keyframes animationName &#123; keyframe-selector &#123; property: value; &#125; &#125;</code></li><br><li><b>描述</b>：用于定义动画的关键帧。animationName是动画的名称，keyframe-selector可以是百分比（如0%、50%、100%）或from、to关键字，用于指定动画在不同时间点的状态。</li><br><p><b>animation-name</b></p><li><b>语法</b>：<code>animation-name: none | &lt;single-animation-name&gt;#</code></li><br><li><b>描述</b>：指定要应用的动画名称，对应@keyframes中定义的名称。</li><br><p><b>animation-duration</b></p><li><b>语法</b>：<code>animation-duration: &lt;time&gt;#</code></li><br><li><b>描述</b>：指定动画完成一个周期所需的时间，以秒（s）或毫秒（ms）为单位。</li><br>    <p><b>animation-timing-function</b></p><li><b>语法</b>：<code>animation-timing-function: ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(n,n,n,n)</code></li><br><li><b>描述</b>：控制动画的速度曲线，与过渡的时间函数类似。</li><br>    <p><b>animation-delay</b></p><li><b>语法</b>：<code>animation-delay: &lt;time&gt;</code></li><br><li><b>描述</b>：指定动画开始前的延迟时间。</li><br>    <p><b>animation-iteration-count</b></p><li><b>语法</b>：<code>animation-iteration-count: infinite | &lt;number&gt;</code></li><br><li><b>描述</b>：指定动画的播放次数，infinite表示无限循环播放。</li><br>    <p><b>animation-direction</b></p><li><b>语法</b>：<code>animation-direction: normal | reverse | alternate | alternate-reverse</code></li><br><li><b>描述</b>：控制动画的播放方向，normal为正向播放，reverse为反向播放，alternate表示在奇数次迭代时正向播放，偶数次迭代时反向播放，alternate-reverse则相反。</li><br>    <li><b>示例</b></li>    <p>以下是一个简单的 CSS 动画示例，让一个方块在页面上从左到右移动并旋转：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义关键帧 */</span></span><br><span class="line"><span class="keyword">@keyframes</span> moveAndRotate &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0</span>) <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">200px</span>) <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 应用动画 */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="comment">/* 应用动画属性 */</span></span><br><span class="line">  <span class="attribute">animation-name</span>: moveAndRotate;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">3s</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease-in-out;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">0s</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="attribute">animation-direction</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意事项</b></p><li>性能考虑：与过渡类似，复杂的动画可能会对性能产生影响，尤其是在移动设备上。尽量避免过度使用动画，或者对大量元素同时应用复杂动画。</li><li>兼容性处理：不同浏览器对 CSS 动画的支持可能存在差异，需要使用浏览器前缀来确保在各种浏览器中都能正常显示。例如，-webkit-animation用于 WebKit 内核的浏览器。</li><li>可访问性：确保动画不会影响网站的可访问性，例如，对于有视觉障碍的用户，动画可能会造成困扰。可以提供关闭动画的选项，或者确保动画不会干扰用户对内容的理解和操作。</li>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.12学习笔记</title>
      <link href="/2025/01/23/css/%E5%AD%A6%E4%B9%A0css.12/"/>
      <url>/2025/01/23/css/%E5%AD%A6%E4%B9%A0css.12/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:30px;color:#00633D;font-family:华文行楷">CSS 过渡</h1><p>CSS 过渡是 CSS 中一项非常实用的特性，它可以在元素的属性值发生变化时创建平滑的过渡效果，提升用户体验。以下是关于 CSS 过渡的学习内容：</p><p style="font-size:24px"><b>基本概念</b></p><li><b>过渡属性</b>：CSS 过渡主要通过transition属性来实现，它是一个复合属性，用于设置过渡效果的各个方面，包括过渡的属性、持续时间、过渡函数和延迟时间。</li><br><li><b>过渡效果触发</b>：通常在元素的状态发生改变时触发过渡效果，比如鼠标悬停（:hover）、获取焦点（:focus）、激活（:active）等伪类状态变化，或者通过 JavaScript 动态修改元素的属性值。</li><br><p style="font-size:24px"><b>transition属性</b></p><li><b>语法</b>：<code>transition: property duration timing-function delay</code>;</li><li><b>property</b>：指定要应用过渡效果的 CSS 属性名称。可以是具体的属性，如width、height、color等，也可以使用all表示所有可过渡的属性。</li><li><b>duration</b>：指定过渡效果持续的时间，以秒（s）或毫秒（ms）为单位。</li><li><b>timing-function</b>：指定过渡的时间函数，用于控制过渡的速度曲线。常见的值有ease（默认值，慢 - 快 - 慢）、linear（匀速）、ease-in（慢 - 快）、ease-out（快 - 慢）、ease-in-out（慢 - 快 - 慢）等，还可以使用cubic-bezier()函数自定义曲线。</li><li><b>delay</b>：指定过渡效果开始前的延迟时间，以秒（s）或毫秒（ms）为单位。</li><br><li><b>示例</b></li><li>以下是一个简单的 CSS 过渡示例，当鼠标悬停在一个按钮上时，按钮的背景颜色和宽度会在 1 秒内平滑过渡：</li>    <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: background-color <span class="number">1s</span>, width <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><li>可以给过渡效果添加延迟，让过渡在鼠标悬停一段时间后才开始：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: background-color <span class="number">1s</span> <span class="number">0.5s</span>, width <span class="number">1s</span> <span class="number">0.5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><li>使用ease-in时间函数让宽度变化的过渡效果以慢 - 快的方式进行：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">1s</span> ease-in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p style="font-size:24px"><b>注意事项</b></p><li><b>兼容性</b>：CSS 过渡在大多数现代浏览器中都得到了很好的支持，但在一些旧版本的浏览器中可能存在兼容性问题。可以使用浏览器前缀（如-webkit-、-moz-等）来提高兼容性。</li><li><b>可过渡属性</b>：并非所有的 CSS 属性都可以进行过渡，只有具有中间值的属性才能实现过渡效果。例如，display属性就不能直接过渡，因为它的值没有中间状态。</li><li><b>性能优化</b>：过度使用复杂的过渡效果可能会影响页面性能，特别是在移动设备上。尽量避免对大量元素同时应用过渡效果，或者使用过于复杂的过渡函数。</li>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.11学习笔记</title>
      <link href="/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.11/"/>
      <url>/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.11/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:30px;color:#F56262;font-family:华文行楷">CSS 3D</h1><p>CSS 3D 是 CSS（层叠样式表）的一个重要特性，它允许开发人员在网页上创建具有三维空间效果的元素，为用户带来更加丰富和沉浸式的视觉体验。以下是对 CSS 3D 几个关键方面的详细解释：</p><p style="font-size:20px"><b>一、核心概念</b></p><p><b>1.三维空间坐标系</b>：</p><li>在 CSS 3D 中，使用三维空间坐标系，由 x、y 和 z 轴组成。</li><li>x 轴是水平轴，从左到右为正方向。</li><li>y 轴是垂直轴，从上到下为正方向。</li><li>z 轴是深度轴，从屏幕外向屏幕内为正方向。</li><br><p><b>2.视角与透视</b>：</p><li>Perspective（透视）：该属性定义了观察 3D 场景的距离，它影响元素在 3D 空间中的呈现效果。</li><li>可以通过设置父元素的 perspective 属性来实现透视效果，例如 perspective: 500px;。较小的值会使元素的 3D 效果更强烈，而较大的值会使元素看起来更扁平。</li><li>还可以使用 perspective-origin 属性来改变透视的原点，默认是元素的中心（50% 50%），可以调整为其他位置，如 perspective-origin: top left;。</li><p><b>3.变换（Transforms）：</b></p><li>translate3d(x, y, z)：将元素在 3D 空间中沿 x、y 和 z 轴进行平移。例如，transform: translate3d(50px, 100px, 20px); 会将元素在 x 轴上移动 50 像素，y 轴上移动 100 像素，z 轴上移动 20 像素。</li><li>rotateX(angle)、rotateY(angle)、rotateZ(angle)：分别将元素绕 x、y、z 轴旋转指定的角度。例如，transform: rotateX(45deg); 会使元素绕 x 轴旋转 45 度。</li><li>scale3d(sx, sy, sz)：按比例缩放元素在 x、y 和 z 轴上的尺寸。例如，transform: scale3d(1.5, 1.2, 0.8); 会将元素在 x 轴上放大 1.5 倍，y 轴上放大 1.2 倍，z 轴上缩小到 0.8 倍。</li><li>可以组合使用这些变换，例如 transform: translate3d(50px, 100px, 20px) rotateY(45deg); 会先平移元素，再绕 y 轴旋转。</li><br><p><b>4.变换风格（Transform Style）：</b></p><li>transform-style: preserve-3d：该属性用于指定子元素是否在 3D 空间中呈现。设置为 preserve-3d 时，子元素会保留 3D 特性，可以创建更复杂的 3D 结构，例如 3D 立方体。</li><li>transform-style: flat：这是默认值，子元素会被平面化，不具有 3D 效果。</li><br><p style="font-size:20px"><b>二、元素的 3D 定位与布局</b></p><p><b>绝对定位（Absolute Positioning）：</b></p><li>通常将元素的位置设置为 absolute 或 fixed 以方便在 3D 空间中对其进行精确的定位和变换。</li><br><p><b>层叠顺序（Stacking Order）：</b></p><li>使用 z-index 属性可以控制元素在 3D 空间中的层叠顺序。较高的 z-index 值的元素会显示在较低 z-index 值的元素前面。</li><br><p style="font-size:20px"><b>三、背面可见性（Backface Visibility）</b></p><li>backface-visibility：该属性决定元素的背面是否可见。</li><li>backface-visibility: visible; 表示元素的背面可见，当元素旋转时可以看到其背面。</li><li>backface-visibility: hidden; 表示元素的背面不可见，常用于创建具有双面效果的元素，当旋转时只显示正面。</li>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.10学习笔记</title>
      <link href="/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.10/"/>
      <url>/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.10/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:30px;color:#3A4973;font-family:华文行楷">CSS 2D</h1><p>CSS 2D 是指使用 CSS 实现的二维变换，它允许开发者对 HTML 元素进行平面内的各种变换操作，从而实现丰富的页面效果。以下是更详细的解释：</p><p style="font-weight:bold;font-size:20px">一、基本变换函数</p><p><b>translate(x, y)：</b></p><li>功能：将元素在二维平面上进行平移。</li><li>参数：</li><br><p>1.x：元素在水平方向（X 轴）上的移动距离。可以是像素值（如 50px）、百分比（如 50%）或其他长度单位。正值表示向右移动，负值表示向左移动。</p><p>2.y：元素在垂直方向（Y 轴）上的移动距离。可以是像素值、百分比或其他长度单位。正值表示向下移动，负值表示向上移动。</p><li>示例：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">100px</span>, <span class="number">50px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：上述代码会将 .element 类的元素在水平方向向右移动 100 像素，在垂直方向向下移动 50 像素。</p></blockquote><p><b>rotate(angle)：</b></p><li>功能：将元素绕其中心点旋转一定角度。</li><li>参数：</li><br><p>angle：旋转的角度，单位是度（deg）。正值表示顺时针旋转，负值表示逆时针旋转。</p><li>示例：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：该代码将 .element 类的元素顺时针旋转 45 度。</p></blockquote><p><b>scale(x, y)：</b></p><li>功能：对元素进行缩放操作。</li><li>参数：</li><br><p>x：元素在水平方向（X 轴）上的缩放比例。可以是小数（如 0.5 表示缩小到原来的 50%）或大于 1 的数（如 2 表示放大到原来的 2 倍）。<br>y：元素在垂直方向（Y 轴）上的缩放比例。如果不指定 y 值，元素将在 X 和 Y 轴上按照 x 的比例进行缩放。</p><li>示例：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：此代码将 .element 类的元素在水平方向放大到原来的 1.5 倍，在垂直方向放大到原来的 2 倍。</p></blockquote><p><b>skew(x-angle, y-angle)：</b></p><li>功能：使元素在二维平面上产生倾斜效果。</li><li>参数：</li><br><p>x-angle：元素在水平方向（X 轴）上的倾斜角度，单位是度（deg）。正值表示向右侧倾斜，负值表示向左侧倾斜。<br>y-angle：元素在垂直方向（Y 轴）上的倾斜角度，单位是度（deg）。正值表示向下方倾斜，负值表示向上方倾斜。</p><li>示例：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>, <span class="number">10deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：.element 类的元素将在水平方向倾斜 30 度，在垂直方向倾斜 10 度。</p></blockquote><p style="font-weight:bold;font-size:20px">二、transform-origin 属性</p><li>功能：设置元素变换的原点位置，默认是元素的中心（50% 50%）。</li><li>参数：</li><br><p>可以使用长度单位（如 px）、百分比或关键字（如 top、bottom、left、right、center）来指定位置。</p><li>示例：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">transform-origin</span>: top left;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：对于 .element 类的元素，首先将变换原点设置为左上角，然后进行 45 度的旋转操作。由于变换原点改变，元素将以左上角为中心进行旋转。</p></blockquote><p style="font-weight:bold;font-size:20px">三、组合使用变换函数</p><li>可以将多个变换函数组合使用，它们会按照顺序依次对元素进行操作。</li><li>示例：</li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">100px</span>, <span class="number">50px</span>) <span class="built_in">rotate</span>(<span class="number">45deg</span>) <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：对于 .element 类的元素，先将其向右平移 100 像素、向下平移 50 像素，然后顺时针旋转 45 度，最后将其放大到原来的 1.5 倍。</p></blockquote><h1 style="font-size:30px;color:#3A4973;font-family:华文行楷">应用场景</h1><p><b>动态效果增强</b></p><li>动画效果：通过 CSS 2D 变换可以创建各种吸引人的动画效果，如元素在页面上的平滑移动、旋转、缩放等，使页面更具吸引力。</li><li>交互效果：为按钮、链接、图标等添加点击、悬停等交互效果，当用户与页面元素交互时，通过 2D 变换来改变元素的外观，使页面更加生动有趣。</li><p><b>布局调整</b></p><li>响应式设计：在响应式布局中，利用 CSS 2D 变换调整元素的位置和大小，以适应不同屏幕尺寸和分辨率的设备，确保页面在各种设备上都能保持良好的显示效果。</li><li>创意布局：实现一些非传统的布局方式，如倾斜的文本、旋转的图片等，为页面带来独特的视觉风格，突破传统矩形布局的限制。</li><b>UI 元素设计</b><li>按钮和图标：为按钮和图标添加阴影、立体效果等，使用 CSS 2D 变换可以让它们看起来更加立体和吸引人，增强用户对可交互元素的感知。</li><li>导航菜单：创建具有动态效果的导航菜单，如悬停时弹出的下拉菜单、旋转的选项卡等，提升导航的易用性和视觉效果。</li><b>兼容性</b><li>虽然大多数现代浏览器都支持 CSS 2D 变换，但在一些较旧的浏览器或特定版本中可能存在兼容性问题。为了确保兼容性，可能需要使用浏览器前缀（如 -webkit-、-moz- 等），也可以使用工具如 Autoprefixer 来自动添加这些前缀。</li>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.9学习笔记</title>
      <link href="/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.9/"/>
      <url>/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.9/</url>
      
        <content type="html"><![CDATA[<div style="font-size:50px;font-family:华文楷体;color:#B4A8FC">CSS 渐变</div><br></br><p style="font-size:25px"><b>1.线性渐变</b></p><li>多个颜色之间的渐变，默认<b>从上到下</b>渐变。</li><blockquote><p>background-image:linear-gradient( , , );</p></blockquote><li>使用关键词设置线性<b>渐变的方向</b>。</li><blockquote><p>background-image:linear-gradient(to top, , , );<br>background-image:linear-gradient(to  right top, , , ); </p></blockquote><li>使用角度设置线性<b>2.渐变的方向</b>。</li><blockquote><p>background-imge:linear-gradient(30deg, , , );</p></blockquote><li>调整开始<b>渐变的位置</b>。</li><blockquote><p>background-imge:linear-gradient(red 50px, , , );</p></blockquote><p style="font-size:25px"><b>3.径向渐变</b></p><li>使用像素值值调整渐变圆的圆心位置。</li><blockquote><p>background-image:radial-gradient(at 100px 50px, , , );</p></blockquote><li>调整渐变形状为正圆。</li><blockquote><p>background-image:radial-gradient(circle, , , );</p></blockquote><li>调整形状的半径</li>。<blockquote><p>background-image:radial-gradient(100px, , , );<br>background-image:radial-gradient(50px,100px, , , );</p></blockquote><p style="font-size:25px"><b>4.重复渐变</b></p><blockquote><p>在渐变类型前面加上 repeating</p></blockquote><div style="font-size:50px;font-family:华文楷体;color:#B4A8FC">web 字体</div><p><b>基本用法</b></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@font-face&#123;</span><br><span class="line">     font-family:&quot;&quot;;</span><br><span class="line">     font-display:swap;</span><br><span class="line">     src:url(./  );</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.8学习笔记</title>
      <link href="/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.8/"/>
      <url>/2025/01/22/css/%E5%AD%A6%E4%B9%A0css.8/</url>
      
        <content type="html"><![CDATA[<p style="font-size:30px;color:#43E2FE;font-family:华文楷体">CSS3长度单位</p><p><mark>vm</mark>视口宽度的百分之多少<mark>10vw</mark>就是视口宽度的<mark>10%</mark><br><mark>vh</mark>视口宽度的百分之多少<mark>10vw</mark>就是视口高度的<mark>10%</mark></p><p style="font-size:30px;color:#43E2FE;font-family:华文楷体"><mark>box-sizing</mark>怪异盒模型</p><p>使用<mark>box-sizing</mark>属性可以设置和模型的俩种类型</p><details><mark>width</mark>和<mark>height</mark>设置的是盒子内容区的大小。（默认值） <summary><b>content-box</b></summary></details><details><mark>width</mark>和<mark>height</mark>设置的是盒子总大小（怪异盒模型） <summary><b>border-box</b></summary></details>   <p style="font-size:30px;color:#43E2FE;font-family:华文楷体"><mark>resize</mark>调整盒子大小</p><p>使用<mark>resize</mark>属性可以可以控制是否允许用户调节元素尺寸。</p><p><b>none:</b>不允许用户调整元素大小。（默认）<br><b>both:</b>用户可以调节元素的宽度和高度。<br><b>horizontal:</b>用户可以调节元素的宽度。<br><b>vertical:</b>用户可以调节元素的高度。</p><p style="font-size:30px;color:#43E2FE;font-family:华文楷体"><mark>box-shadow</mark>盒子阴影</p><div>使用<mark>box-shadow</mark>属性为盒子添加阴影。</div><br><details><code>box-shadow: h-shadow v-shadow blur spread color inset;</code><summary><b>语法</b></summary></details><li>各个值的含义：</li><b>h-shadow</b>:水平阴影的位置，必须填写，可以为负值<b>v-shadow</b>:垂直阴影的位置，必须填写，可以为负值<b>blur</b>:可选，模糊距离<b>spread</b>:可选，隐隐的外延值<b>color</b>:可选，阴影的颜色<b>inset</b>:可选，将外部阴影该为内部阴影<blockquote><p>默认值：box-shadow:none表示没有阴影</p></blockquote><p style="font-size:30px;color:#43E2FE;font-family:华文楷体"><mark>opacity</mark>盒子阴影</p><p><b>opacity</b>属性能为整个元素添加透明度效果，值是0到1之间的小数，0是完全透明，1表示完全不透明。</p><p style="font-size:30px;color:#43E2FE;font-family:华文楷体"><mark>background-origin</mark>设置背景图的原点。</p><li>语法</li><p>1.<b>padding-box:</b>从<b>padding</b>区域开始显示背景图像。–默认值<br>2.<b>border-box:</b>从<b>border</b>区域开始显示背景图像。<br>3.<b>content-box:</b>从<b>content</b>区域开始显示背景图像。</p><hr><p style="font-size:30px;color:#43E2FE;font-family:华文楷体"><mark>background-clip</mark>设置背景图的向外裁剪的区域。</p><li>语法</li><p>1.<b>padding-box:</b>从<b>padding</b>区域开始向外裁剪背景。–默认值<br>2.<b>border-box:</b>从<b>border</b>区域开始向外裁剪背景。<br>3.<b>content-box:</b>从<b>content</b>区域开始向外裁剪背景。<br>4.<b>text:</b>背景图只呈现在文字上。</p><p style="font-size:30px;color:#43E2FE;font-family:华文楷体"><mark>background-size</mark>设置背景图的尺寸。</p><li>语法</li><p>1.用长度指定背景图片大小，不允许负值。</p><blockquote><p>background-size:300px 200px;</p></blockquote><p>2.用百分比指定背景图片大小，不允许负责。</p><blockquote><p>background-size:100% 100%;</p></blockquote><p>3.<b>auto</b>：背景图片的真实大小，–默认值<br>4.<b>contain</b>：将背景图片等比缩放，是北京图片的宽高，与容器的款或高相等，再将完整背景图片包含在容器内，但要注意：可能会造成容器里部分区域没有背景图片。</p><blockquote><p>background-size:contain:</p></blockquote><p>5.<b>cover</b>：将背景图片等比例缩放，直到完全覆盖容器，图片会尽可能全的显示在元素上，但要注意：背景图片有可能显示不完整。–相对比较好的选择</p><blockquote><p>background-size:cover;</p></blockquote><hr><p style="font-size:30px;color:#43E2FE;font-family:华文楷体">边框圆角</p><li>同时设置四个角的圆角：</li><blockquote><p>border-radius:10px;</p></blockquote><hr><p style="font-size:30px;color:#43E2FE;font-family:华文楷体">文本阴影</p><details>text-shadow:h-shahow v-shadow blur color;<summary>语法</summary></details><p style="font-size:30px;color:#43E2FE;font-family:华文楷体">文本换行</p></li>常用值如下</li>:<b>normal</b>:文本超出边界自动换行，文本中的换行被浏览器识别为一个空格。（默认值）<b>pre</b>:原样输出，与pre标签的效果相同。<b>pre-wrap</b>:在pre效果的基础上，超出元素边界自动换行。<b>pre-line</b>:在pre效果的基础上，超出元素边界自动换行，且识别文本中的换行，空格会忽略。<b>nowrap</b>:强制不换行。<p style="font-size:30px;color:#43E2FE;font-family:华文楷体">文本溢出</p><li>常用值如下</li>:<b>clip</b>:党内联内容溢出时，将溢出部分裁切掉。（默认值）<b>ellipsis</b>:当内联内容溢出快容器时，将溢出部分替换为···。<blockquote><p>要使得text-overflow属性生效，快容器必须显式定义overflow为非visible值，white-space为nowrap值。</p></blockquote><hr><p style="font-size:30px;color:#43E2FE;font-family:华文行楷">CSS3 多列布局</p><p>CSS 多列布局是一种用于将网页内容排列成多列显示的技术，能够在有限的空间内更高效地展示信息，以下是关于 CSS 多列布局的学习内容：</p><li><b>基本概念</b></li><li>多列布局属性：CSS 通过一系列属性来实现多列布局，主要用于控制列的数量、宽度、间距以及列之间的分隔线等。</li><li>应用场景：多列布局常用于新闻列表、文章排版、产品展示等场景，使内容呈现更加清晰、有条理，提高可读性和视觉效果。</li><br><li><b>主要属性</b></li><p><b>column-count</b></p><li>语法：<code>column-count: auto | &lt;integer&gt;</code></li><li>描述：指定元素要划分的列数，auto为默认值，表示根据其他属性自动计算列数，&lt;integer&gt;为具体的列数。</li><br><p><b>column-width</b></p><li>语法：column-width: auto | &lt;length&gt;</li><li>描述：指定每列的宽度，auto表示由浏览器根据容器大小和其他属性自动确定列宽，&lt;length&gt;为具体的宽度值，如100px、20em等。</li><br><p><b>column-gap</b></p><li>语法：column-gap: normal | &lt;length&gt;</li><li>语法：column-gap: normal | &lt;length&gt;</li><li>描述：设置列与列之间的间隙宽度，normal的默认值通常为1em，也可以指定具体的长度值。</li><br><p><b>column-rule</b></p><li>语法：column-rule: &lt;column-rule-width&gt; || &lt;column-rule-style&gt; || &lt;column-rule-color&gt;</li><li>语法：column-rule: &lt;column-rule-width&gt; || &lt;column-rule-style&gt; || &lt;column-rule-color&gt;</li><li>描述：是一个复合属性，用于设置列之间的分隔线，分别对应分隔线的宽度、样式和颜色。例如column-rule: 1px solid black表示 1 像素宽、实线、黑色的分隔线。</li><br><p><b>column-span</b></p><li>语法：column-span: none | all</li><li>描述：指定元素是否跨越所有列，none表示元素不跨越列，在所在列显示，all表示元素跨越所有列。</li><br><li>示例</li><p>以下是一个简单的 CSS 多列布局示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.multicol</span> &#123;</span><br><span class="line">  <span class="comment">/* 设置3列布局 */</span></span><br><span class="line">  <span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="comment">/* 列之间的间隙为20px */</span></span><br><span class="line">  <span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="comment">/* 列之间的分隔线为1px实线灰色 */</span></span><br><span class="line">  <span class="attribute">column-rule</span>: <span class="number">1px</span> solid gray;</span><br><span class="line">&#125;</span><br><span class="line">让一个标题跨越所有列：</span><br><span class="line">css</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">column-span</span>: all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意事项</b></p><li>内容适配：多列布局中的内容应根据列宽自动换行和调整，确保内容在不同列中完整显示，避免出现截断或显示不完整的情况。对于图像等元素，可能需要设置max-width: 100%等属性来使其适应列宽。</li><li>兼容性问题：多列布局在不同浏览器中的支持存在一定差异，特别是在一些旧版本浏览器中。在实际应用中，需要进行充分的测试，并根据需要使用浏览器前缀来提高兼容性，如-webkit-column-count、-moz-column-count等。</li><li>复杂布局处理：对于复杂的多列布局需求，可能需要结合其他 CSS 布局技术，如 Flexbox 或 Grid 布局来实现更精细的排版效果。同时，要注意多列布局与其他布局方式之间的相互影响，避免出现布局混乱的问题。</li>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识HTML.4学习笔记</title>
      <link href="/2025/01/21/html/%E5%AD%A6%E4%B9%A0html.4/"/>
      <url>/2025/01/21/html/%E5%AD%A6%E4%B9%A0html.4/</url>
      
        <content type="html"><![CDATA[<p style="font-size:30px;color:#8DFEF6">列表标签</p><br><p>datalist:用于搜索框的关键字提示</p><p>details:用于展示问题和答案，或对专有名词进行解释</p><p>summary:写在detaisls的里面，用于指定问题或专用名词</p><p style="font-size:30px;color:#8DFEF6">文本标签</p><br>ruby:包裹需要注音的文字rt:写注音，rt标签写在ruby的里面<p style="font-size:30px;color:#8DFEF6">文本标记</p><br>mark:标记<p style="font-size:30px;color:#8DFEF6">表单功能</p><br><p>placeholder:提示文字（注意：不是默认值，value是默认值），适用于<mark>文字输入类</mark>的表单控件。</p><p>required:表示输入项必填，适用于<mark>除按钮外</mark>其他表单控件。</p><p>autofocus:自动获取焦点，适用于所有表单控件。</p><p>autocomplete:自动完成，可以设置为<mark>on</mark>或<mark>off</mark>，适用于<make>文字输入类</make>的表单控件。</p><p>pattern:填写正则表达式，是用于输入类表单控件。        注意：多行输入不可用，且空的输入框不会验证，往往与<mark>required</mark>配合。</p>          <p style="font-size:30px;color:#8DFEF6">input属性值</p><p><br></br><br>email:邮箱类型的输入框，表单提交时会验证格式，输入为空则不验证格式。<br>url:url类型的输入框，表单提交时会验证格式，输入为空则不验证格式。<br>number:数字类型的输入框，表单提交时会验证格式，输入为空则不验证格式。<br>search:搜索类型的输入框，表单提交时不会验证格式。<br>tel:电话类型的输入框，表单提交时不会验证格式，在移动端使用时，会唤起数字键盘。<br>range:范围选择框，默认值为<make>50</make>，表单提交时不会验证格式。<br>color:颜色选择框，默认值为黑色，表单提交时不会验证格式。<br>date:日期选择框，默认值为空，表单提交时不会验证格式。<br>month:月份选择框，默认值为空，表单提交时不会验证格式。<br>week:周选择框，默认值为空，表单提交时不会验证格式。<br>time:时间选则框，默认值为空，表单提交时不会验证格式。<br>datetime-local:日期➕时间选择框，默认值为空，表单提交时不会验证格式。</p><p style="font-size:30px;color:#8DFEF6">form属性</p><blockquote><p>novalidate:如果给form标签设置了该属性值，表单提交的时候不再进行验证。</p></blockquote><p style="font-size:30px;color:#8DFEF6">视频标签</p><p>&lt;video&gt;标签用来定义视频，他是双标签。</p><p><br></br></p><p>src:URL地址  视频地址<br>width:像素值  设置视频播放器的宽高<br>height:像素值  设置视频播放器的高度<br>controls:向用户显示视频控件（比如播放&#x2F;暂停按钮）<br>muted:视频静音<br>autoplay:视频自动播放<br>loop:循环播放<br>poster:URL地址   视频封面<br>preload:  auto&#x2F;metadta&#x2F;none  如果使用autoplay,则忽略该属性。</p>]]></content>
      
      
      <categories>
          
          <category> HTML基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio Code </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.7学习笔记</title>
      <link href="/2025/01/19/css/%E5%AD%A6%E4%B9%A0css.7/"/>
      <url>/2025/01/19/css/%E5%AD%A6%E4%B9%A0css.7/</url>
      
        <content type="html"><![CDATA[<p style="font-size:40px;color:#0F7369;font-family:华文楷体">CSS 相对定位</p><p><b>1.如何设置相对定位？</b></p><ul>    <li>给元素设置<code>position:relative</code>即可实现相对定位。</li>    <li>可以使用<code>left、right、top、bottom</code>四个属性调整位置。</li>    </ul>  <p><b>2.相对定位的参考点在哪里？</b></p><ul>    <li>相对自己原来的位置</li>    </ul><p><b>3.相对定位的特点</b></p><ol>    <li>不会脱离文档流，元素位置的变化，只是视觉效果上的变化，不会对其他元素产生任何影响。</li>    <li>定位元素的显示<b>层级</b>比普通元素高，无论什么定位，显示层级都是一样的。</li>    <p>默认规则是：<p>    <ul>        <li>定位的元素会盖在普通元素之上。</li>        <li>都发生定位的俩个元素，后写的元素会盖在先写的元素之水上。</li>        </ul>    <li><code>left</code>不能和<code>right</code>一起设置，<code>top</code>和<code>bottom</code>不能一起设置。</li>    <li>相对定位的元素，也能继续浮动，但不推荐这样做。</li>    <li>想对行为的元素，也能通过<code>margin</code>调整位置，但不推荐这样做。</li>    </ol>    <blockquote><p>绝大多数情况下，相对定位，会与绝对定位配合使用。</p></blockquote><p style="font-size:40px;color:#0F7369;font-family:华文楷体">CSS 绝对定位</p><p>如何设置绝对定位？</p><ul>    <li>给元素设置<code>position:absolute</code>即可实现绝对定位。</li>    <li>可以使用<code>left、right、top、bottom</code>四个属性调整位置。</li>    </ul>    <p>绝对定位的参考点在哪里？</p>    <li>参考它的包含块。</li>    </ul><blockquote><p>什么是包含块？</p><p> 1.对于没有脱离文档流的元素：包含块就是父元素；<br>    2.对于脱离文档流的元素：包含块是第一个拥有定位属性的祖先元素（如果所有祖先都没定位，那包含快就是整个页面）。</p></blockquote><p>绝对定位元素的特点：</p><ol>    <li>脱离文档流，会对后面的兄弟元素、父元素有影响。</li>    <li><code>left</code>不能和<code>right</code>一起设置，<code>top</code>和<code>bottom</code>不能一起设置。</li>    <li>绝对定位、浮动不能同时设置，如果同时设置，浮动失效，以绝对定位为主。</li>    <li>绝对定位的元素，也能用过<code>margin</code>调整位置，但不推荐这样做。</li>    <li>无论是什么元素（行内、行内块、块级）设置为绝对定位之后，都变成了绝对定位元素。</li>    </ol> <blockquote><p>何为定位元素？–默认宽、高都被内容所撑开，且能自用设置宽高。</p></blockquote><p style="font-size:40px;color:#0F7369;font-family:华文楷体">CSS 固定定位</p>    <p><b>如何设置为固定定位？</b></p><ul>    <li>给元素设置<code>position:fixed</code>即可实现固定定位。</li>    <li>可以使用<code>left、right、top、bottom</code>四个属性调整位置。</li>    <p>固定定位的参考点在哪里？</p>    <li>参考它的<b>视口</b>        </ul> <blockquote><p>什么是视口？–对于PC浏览器来说，视口就是我们看网页的那扇“窗户”。</p></blockquote><p><b>固定定位元素的特点</b></p><ol>    <li>脱离文档流，会对后面的兄弟元素、父元素有影响。</li>    <li><code>left</code>不能和<code>right</code>一起设置，<code>top</code>和<code>bottom</code>不能一起设置。</li>    <li>固定定位、浮动不能同时设置，如果同时设置，浮动失效，以固定定位为主。</li>    <li>固定定位的元素，也能用过<code>margin</code>调整位置，但不推荐这样做。</li>    <li>无论是什么元素（行内、行内块、块级）设置为绝对定位之后，都变成了固定定位元素。</li>    </ol>    <p style="font-size:40px;color:#0F7369;font-family:华文楷体">CSS 粘性定位</p><p><b>如何设置为粘性定位？</b></p><ul>    <li>给元素设置<code>position:sticky</code>即可实现粘性定位。</li>    <li>可以使用<code>left、right、top、bottom</code>四个属性调整位置，不过最常用的是<code>top</code>值。</li>    </ul><p><b>粘性定位的参考点在哪里？</b></p><ul>    <li>离他最近的一个拥有“滚动机制”的祖先元素，即使这个祖先不是最近的真实可滚动祖先。</li>    </ul>    <p> <b>粘性定位元素的特点</b></p> <ul> <li>不会脱离文档流，它是一种专门用于窗口滚动是的新的定位方式。</li> <li>最常用的值是<code>top</code>值。</li> <li>粘性定位和浮动可以同时设置，但不推荐这样做。</li> <li>粘性定位的元素，也能通过<code>margin</code>调整位置，但不推荐这样做。</li> </ul><p style="font-size:40px;color:#0F7369;font-family:华文楷体">CSS 定位的特殊应用</p><blockquote><p>1.发生固定定位、绝对定位后，元素都变成了定位元素，默认宽高被内容撑开，且依然可以设置宽高。<br>2.发生相对定位后，元素依然是之前的显示模式。<br>3.以下所说的特殊应用，只针对<code>绝对定位</code>和<code>固定定位</code>的元素，不包括相对定位的元素。</p></blockquote><p><b>让定位元素的款充满包含块</b><br>1.快宽想与包含块一致，可以给定位元素同时设置<code>left</code>和<code>right</code>为0。<br>2.高度想与包含块一致，<code>top</code>和<code>bottom</code>设置为0。</p><p><b>让定位元素在包含块中居中</b><br>方案一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">left:0;</span><br><span class="line">right:0;</span><br><span class="line">top:0;</span><br><span class="line">bottom:0;</span><br><span class="line">margin:0;</span><br></pre></td></tr></table></figure><p>方案二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left:50%;</span><br><span class="line">top:50;</span><br><span class="line">margin-left:负的宽度一半;</span><br><span class="line">margin-top:负的高度一半;</span><br></pre></td></tr></table></figure><blockquote><p>该定位的元素必须设置宽高！！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.6学习笔记</title>
      <link href="/2025/01/19/css/%E5%AD%A6%E4%B9%A0css.6/"/>
      <url>/2025/01/19/css/%E5%AD%A6%E4%B9%A0css.6/</url>
      
        <content type="html"><![CDATA[<h6 style="font-size:50px;color:#54E4E9;font-family:华文楷体">CSS 浮动（float）</h6><blockquote><p>现在浮动是主流的页面布局方式之一。</p></blockquote><p><b>1.元素浮动后的特点</b></p><lo>    <li>脱离文档流</li>    <li>不管浮动前是什么元素，浮动后：默认宽与高都是被内容撑开（尽可能小），而且可以设置宽高。</li>    <li>不会独占一行，可以与其他元素共用一行。</li>    <li>不会<code>margin</code>合并，也不会<code>margin</code>塌陷，能够完美地设置四个方向的<code>margin</code><code>padding</code>。</li>    <li>不会像行内块一样被当作文本处理（没有行内块的空白问题）。</li>    </lo>    <br><p><b>2.浮动后会有哪些影响</b><br><b>对兄弟元素的影响</b>:后面的兄弟元素，会占据浮动元素之前的位置，在浮动元素的下面；对前面的兄弟无影响。<br><b>对父元素的影响</b>:不能撑起父元素的高度，导致父元素高度塌陷；但父元素的宽高依然束缚浮动的元素。</p><p><b>3.解决浮动产生的影响（清除浮动）</b></p><p>解决方案：<br>        1.方案一：给父元素指定高度。<br>        2.方案二：给父元素也设置浮动，带来其他影响。<br>        3.方案三：给父元素设置<code>overflow:hidden</code>。<br>        4.方案四：在所有浮动元素的最后面，添加一个块级元素，并给该块级元素设置<code>clear:both</code>。<br>        5.方案五：给浮动元素的父元素，设置伪元素，通过伪元素清除浮动，原理与方案四相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.parent::after&#123;</span><br><span class="line">     contert:&#x27;&#x27;;</span><br><span class="line">     display:block;</span><br><span class="line">     clear:both;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>布局中的一个原则：设置浮动的时候，兄弟元素要么全都浮动，要么全都不浮动。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.5学习笔记</title>
      <link href="/2025/01/18/css/%E5%AD%A6%E4%B9%A0css.5/"/>
      <url>/2025/01/18/css/%E5%AD%A6%E4%B9%A0css.5/</url>
      
        <content type="html"><![CDATA[<h6 style="font-size:50px;color:#7C5E17;font-family:华文楷体">CSS盒子模型</h6><ol>    <li style="font-size:25px;"><b>CSS长度单位</b></li>    </ol>    <ol>    <li><code>px</code>:像素。</li>    <li><code>em</code>:相对元素<code>font-size</code>的倍数。</li>    <li><code>rem</code>:相对根字体大小，html标签就是根.</li>    <li><code>%</code>:相对父元素计算。</li>    </ol><blockquote><p>CSS中设置长度，必须加单位，否则样式无效！</p></blockquote><br><br><p style="font-size:30px;color:#26F0E6;font-family:华文楷体">盒子模型的组成</p><p><code>CSS</code>会把所有的<code>HTML</code>元素都看成一个<b>盒子</b>，所有的样式也都是基于这个盒子。</p><ol>    <li><b>margin（外边距）</b>：盒子与外界的距离。（不会影响盒子大小，但会影响盒子的位置）</li>    <li><b>border（边框）</b>:盒子的边框。</li>    <li><b>padding（内边距）</b>:紧贴内容的补白区域。</li>    <li><b>contert（内容）</b>:元素中的文本或后代元素都是它的内容。</li>    </ol><blockquote><p>盒子的大小&#x3D;content+左右padding+左右border。</p></blockquote><br><p style="font-size:30px;color:#26F0E6;font-family:华文楷体">margin注意事项</p><blockquote><p>1.子元素的<code>margin</code>,是参考父元素的<code>content</code>计算的。（因为是父亲的content中承装着子元素）<br>2.上<code>margin</code>、左<code>margin</code>:影响自己的位置；下<code>margin</code>、右<code>margin</code>:影响后面兄弟元素的位置。<br>3.块级元素、行内块级元素，均可完美地设置四个方向的<code>margin</code>；但行内元素，左右<code>margin</code>可以完美设置，上下<code>margin</code>设置无效。<br>4.<code>margin</code>的值也可以是<code>auto</code>,如果给一个<b>块级元素</b>设置左右<code>margin</code>都为<code>auto</code>,该块级元素会在父元素中水平居中。<br>5.<code>margin</code>的值可以是负值。</p></blockquote><p style="font-size:25px;color:#26F0E6;font-family:华文楷体">margin塌陷问题</p><p>什么是<code>margin</code>塌陷？</p><p>&nbsp;&nbsp;第一个元素的<b>上</b><code>margin</code>会作用在父元素上，最后一个子元素的<b>下</b><code>margin</code>会作用在父元素上。<br><br><br>如何解决<code>margin</code>塌陷？</p><ul>    <li>方案一：给父元素设置不为0的<code>padding</code>。</li>    <li>方案二：给父元素设置宽度不为0的<code>border</code>。</li>    <li>方案三：给父元素设置css样式<code>overflow:hidden</code></li>    </ul>    <blockquote><p>处理内容溢出：也是加上voerflow:hidden.</p></blockquote><blockquote><p>隐藏元素的方式<br>vidibility:hidden<br>display:none</p></blockquote><p style="font-size:30px;color:#26F0E6;font-family:华文楷体">布局小技巧</p><p>1.行内元素、行内块元素，可以被父元素当做文本处理。</p><blockquote><p>即：可以像处理文本对齐一样，去处理：行内、行内块在父元素中的对齐。<br>例如：text-align、line-height、text-indent等。</p></blockquote><p>2.如何让子元素，在父亲中<b>水平居中：</p><ul>    <li>若子元素为块元素，给父元素加上：<code>margin:0 auto;</code>。</li>    <li>若子元素为行内元素、行内块元素，给父元素加上：<code>text-align:center</code></li>    </ul><p> 3.如何让子元素，在父亲中<b>垂直居中</b>:<br>    <ul><br>        <li>若子元素为块元素，给子元素加上：<code>margin-top</code>，值为：（父元素<code>content</code>-子元素盒子总高）&#x2F;2。</li><br>        <li>若子元素为行内元素、行内块元素：<br>            让父元素的<code>height=line-height</code>，每个子元素都加上：<code>vertical-align:middle;</code>。<br>            补充：若想绝对垂直居中，父元素<code>font-size</code>设置为<code>0</code>。</li><br>    </ul></p>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.4学习笔记</title>
      <link href="/2025/01/18/css/%E5%AD%A6%E4%B9%A0css.4/"/>
      <url>/2025/01/18/css/%E5%AD%A6%E4%B9%A0css.4/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:30px;color:#7DFFB5;font-family:华文楷体">CSS列表属性</h1><p><b>列表相关的属性，可以作用在<code>ul</code>、<code>ol</code>、<code>li</code>元素上。</b></p><table border="1">    <tr>        <th>CSS属性名</th>        <th>功能</th>        <th>属性值</th>    </tr>        <tr>            <th><code>tlst-style-type</code></th>            <th>设置列表符号</th>            <th>常用属性如下：                <code>none</code>：不显示前面的标识（很常用！）                <code>square</code>:实心方块                <code>disc</code>：圆形                <code>decimal</code>:数字                <code>lower-roman</code>:小写罗马字                <code>upper-roman</code>:大写罗马字                <code>lower-alpha</code>:小写字母                <code>upper-alpha</code>:大写字母</th>     </tr>         <tr>        <th><code>list-style-position</code></th>        <th>设置列表符号的位置</th>        <th><code>inside</code>:在<code>li</code>的里面            <code>outside</code>:在<code>li</code>的外边</th>    </tr>    <tr>        <th><code>list-style-image</code></th>        <th>自定义列表符号</th>        <th><code>url（图片地址）</code></th>    </tr>    <tr>        <th><code>list-style</code></th>        <th>符合属性</th>        <th>没有数量、顺序的要求</th>    </tr>        </table><h1 style="font-size:30px;color:#7DFFB5;font-family:华文楷体">CSS表格属性</h1><p><b>1.边框相关属性（其他元素也能用）：</b></p><table>    <tr>        <th>CSS属性名</th>        <th>功能</th>        <th>属性值</th>    </tr>    <tr>        <td><code>border-width</code></td>        <td>边框宽度</td>        <td><code>CSS</code>中可用的长度值</td>    </tr>    <tr>        <td><code>bordet-color</code></td>        <td>边框颜色</td>        <td><code>CSS</code>中可用的颜色值</td>    </tr>    <tr>        <td><code>border-style</code></td>        <td>边框风格</td>        <td><code>none</code>默认值            <code>solid</code>实线            <code>dashed</code>虚线            <code>dotted</code>点线            <code>double</code>双实线        </td>    </tr>    <tr>        <td><code>border</code></td>        <td>边框复合属性</td>        <td>没有书量、顺序的要求</td>    </tr>    </table><h1 style="font-size:30px;color:#7DFFB5;font-family:华文楷体">表格独有属性（只有<code>table</code>表情才能使用）：</h1><table>    <tr>        <th>CSS属性名</th>        <th>功能</th>        <th>属性值</th>    </tr>    <tr>        <td><code>table-layout</code></td>        <td>设置了列宽度</td>        <td><code>auto</code>:自动，类款根据内容计算（默认值）            <code>fixed</code>:固定列宽，平均分。</td>    </tr>    <tr>        <td><code>borber-spacing</code></td>        <td>单元格间距</td>        <td><code>CSS</code>中可用的长度值。        生效的前提：单元格边框不能合并</td>    </tr>    <tr>        <td><code>borer-collapse</code></td>        <td>合并单元格边框</td>        <td><code>collapse</code>:合并            <code>separate</code>:不合并</td>    </tr>    <tr>        <td><code>empty-cells</code></td>        <td>隐藏没有内容的单元格</td>        <td><code>show</code>:显示，默认            <code>hide</code>:隐藏</td>    </tr>    <tr>        <td><code>caption-side</code></td>        <td>设置表格标题位置</td>        <td><code>top</code>:上面（默认值）            <code>bottom</code>在表格下面</td></table>    <h1 style="font-size:30px;color:#7DFFB5;font-family:华文楷体">CSS背景属性</h1><table>    <tr>        <th>CSS属性名</th>        <th>功能</th>        <th>属性值</th>    </tr>    <tr>        <td><code>background-color</code></td>        <td>设置背景颜色</td>        <td>符合<code>CSS</code>中的颜色规范的值。默认背景颜色是<code>transparent</code>。</td>    </tr>    <tr>        <td><code>background-image</code></td>        <td>设置背景图片</td>        <td><code>url（图片地址）</code></td>    </tr>    <tr>        <td><code>background-repeat</code></td>        <td>设置背景重复方式</td>        <td><code>repeat</code>:重复，铺满整个元素，默认值<code>repeat-x</code>只在水平方向重复。<code>repeat-y</code>只在垂直方向重复<code>no-repeat</code>:不重复。</td>    </tr>    <tr>        <td><code>background-position</code></td>        <td>设置背景图位置</td>        <td><b>通过关键字设置位置</b>：写两个值，用空格隔开。 水平：<code>left、center、right、</code>垂直：<code>top、center、bottom</code>如果只取一个值，另一个方向的值取center            <b>通过长度指定坐标位置</b>:以元素左上角，为坐标原点，设置图标左上角位置。俩个值，分别是<code>x,y坐标。</code>只写一个值，会被当做x坐标，y坐标取center</td>    </tr>    <tr>        <td><code>background</code></td>        <td>符合属性</td>        <td>没有数量和顺序要求</td>    </tr>    </table> <h1 style="font-size:30px;color:#7DFFB5;font-family:华文楷体">CSS鼠标属性</h1><table>    <tr>        <th>CSS属性名</th>        <th>功能</th>        <th>属性值</th>    </tr>    <tr>        <td><code>cursor</code></td>        <td>设置鼠标光标的样式</td>        <td><code>pointer</code>:小手        <code>move</code>:移动图标        <code>text</code>:文字选择器        <code>crosshair</code>:十字架        <code>wait</code>:等待        <code>hrlp</code>:帮助</td>    </tr>    </table>        ]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.3学习笔记</title>
      <link href="/2025/01/17/css/%E5%AD%A6%E4%B9%A0css.3/"/>
      <url>/2025/01/17/css/%E5%AD%A6%E4%B9%A0css.3/</url>
      
        <content type="html"><![CDATA[<h2 style="font-size:45px;color:#5274E3;font-family:华文楷体">CSS 常用文本样式</h2><p style="font-size:20px;font-family:华文楷体"><b>以下是一些常用的 CSS 文本样式：</b></p>   <ul>        <li style="font-size:25px"><b>字体样式</b></li><br>    <li><b>字体类型：</b></li>    <li><b><code>font-family: 'Arial', sans-serif;</code></b>：设置字体为 Arial，如果没有 Arial 字体，则使用系统默认的无衬线字体。</li>    <li><b><code>font-family: 'Times New Roman', serif;</code></b>：设置字体为 Times New Roman，如果没有该字体，则使用系统默认的有衬线字体。</li><br>    <li><b>字体大小：</b></li>    <li><b><code>font-size: 16px;</code></b>：将字体大小设置为 16 像素。</li>    <li><b><code>font-size: 1.2em;</code></b>：字体大小相对于其父元素字体大小的 1.2 倍，这是一种相对单位，常用于保持文本在不同屏幕和设备上的可读性。</li><br>    <li><b>字体粗细：</b></li>    <li><b><code>font-weight: normal;</code></b>：正常粗细，等同于 <b><code>font-weight: 400;</code></b>。</li>    <li><b><code>font-weight: bold;</code></b>：加粗，等同于 <b><code>font-weight: 700;</code></b>，常用于突出显示标题或重要信息。</li>    <li><b><code>font-weight: 100;</code></b>：最细的字体粗细，数值越大，字体越粗，一般有 100、200、300、400、500、600、700、800、900 等等级别。</li><br><hr>    <li style="font-size:25px"><b>文本排版</b></li><br>    <li><b>文本对齐：</b></li>    <li><b><code>text-align: left;</code></b>：文本左对齐，常用于段落文本的默认对齐方式。</li>    <li><b><code>text-align: center;</code></b>：文本居中对齐，适用于标题、重要提示等需要突出显示的文本。</li>    <li><b><code>text-align: right;</code></b>：文本右对齐，可用于一些特定的布局需求，如表格中的数据对齐。</li>    <li><b><code>text-align: justify;</code></b>：两端对齐，常用于报纸、书籍等排版，使文本的左右两端都对齐，但可能会导致单词间距不均匀。</li><br>    <li><b>文本缩进：</b></li>    <li><b><code>text-indent: 2em;</code></b>：首行缩进 2 个字符宽度，符合中文排版习惯，常用于段落首行缩进，增强文本的层次感。</li><br>    <li><b>行高：</b></li>    <li><b><code>line-height: 1.5;</code></b>：行高是字体大小的 1.5 倍，合适的行高可以使文本更易读，避免行与行之间过于拥挤或过于疏远。</li>    <li><b><code>line-height: 24px;</code></b>：将行高固定为 24 像素，适用于需要精确控制行间距的场景。</li><br><hr>    <li style="font-size:25px"><b>文本修饰</b></li><br>    <li><b>文本颜色：</b></li>    <li><b><code>color: #ff0000;</code></b>：设置文本颜色为红色，使用十六进制颜色代码。</li>    <li><b><code>color: rgb(0, 0, 255);</code></b>：设置文本颜色为蓝色，使用 RGB 颜色模式。</li>    <li><b><code>color: rgba(0, 128, 0, 0.5);</code></b>：设置文本颜色为半透明的绿色，其中 0.5 表示透明度。</li><br>    <li><b>文本装饰：</b></li>    <li><b><code>text-decoration: none;</code></b>：去除文本装饰，常用于链接，使其看起来像普通文本。</li>    <li><b><code>text-decoration: underline;</code></b>：给文本添加下划线，可用于强调或表示链接。</li>    <li><b><code>text-decoration: overline;</code></b>：给文本添加上划线，较少使用，可用于一些特殊效果。</li>    <li><b><code>text-decoration: line-through;</code></b>：给文本添加删除线，表示文本被删除或不再有效。</li><br><hr>    <li style="font-size:25px"><b>其他</b></li><br>    <li><b>字母间距：</b></li>    <li><b><code>letter-spacing: 1px;</code></b>：字母间距增加 1 像素，可以使文本看起来更宽敞，常用于标题或需要强调的文本。</li><br>    <li><b>单词间距：</b></li>    <li><b><code>word-spacing: 2px;</code></b>：单词间距增加 2 像素，对英文等以空格分隔单词的语言有效，可改善文本的视觉效果。</li>    <li><b>文本转换：</b></li>    <li><b><code>text-transform: uppercase;</code></b>：将文本转换为大写，常用于标题或缩写词。</li>    <li><b><code>text-transform: lowercase;</code></b>：将文本转换为小写。</li>    <li><b><code>text-transform: capitalize;</code></b>：将每个单词的首字母大写，适用于标题或需要突出显示的文本。。</li>    </ul><p style="font-size:30px;font-weight: bold;font-family:华文楷体">vertical-align</p><ul>    <li>属性名：<code>vertical-align</code>。</li>    <li>作用:用于指定<code>同一行元素之间</code>，或<code>表格单元格</code>内文字的<code>垂直对齐方式</code>。</li>    <li>常用值：</li>    </ul>    <ol>    <li><code>baseline</code>(默认值)：使元素的基线与父元素的基线对齐。</li>    <li><code>top</code>:使元素的<code>顶部</code>与其<code>所在行的顶部</code>对齐。</li>    <li><code>middle</code>:使元素的<code>中部</code>与<code>父元素的基线</code>加上父元素字母<code>x</code>的一半。</li>    <li><code>bottom</code>:使元素的<code>底部</code>与其<code>所在行的底部</code>对齐。</li>    </ol><blockquote><p>注意：<code>vertical-align</code>不能控制块元素。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.2学习笔记</title>
      <link href="/2025/01/17/css/%E5%AD%A6%E4%B9%A0css.2/"/>
      <url>/2025/01/17/css/%E5%AD%A6%E4%B9%A0css.2/</url>
      
        <content type="html"><![CDATA[<h1 style="font-size:45pxpx;color:#47F1EF;font-family:华文楷体">伪类选择器</h1><ul>    <li>概念</li>    </ul><blockquote><p>作用：选中特殊状态的元素。<br>如何理解“伪”？-虚假的，不是真的。<br>如何理解“伪类”？-像类（class），但不是类，是元素的特殊状态。</p></blockquote><ul>    <li>常用伪类选择器</li>    </ul>    <p><b>一、动态伪类：</b></p><ol>    <li><code>:link</code>超链接<code>未被访问</code>的状态。</li>    <li><code>:visted</code>超链接<code>访问过</code>的状态。</li>    <li><code>:hover</code>鼠标<code>悬停</code>在元素上的状态。</li>    <li><code>:active</code>元素激活的状态。</li>    <li><code>:focus</code>获取焦点的元素。</li>    </ol>    <blockquote><p>表达类元素才能使用<code>:focus</code>伪类。<br>当用户：点击元素、触摸元素、或通过键盘的“tab”建等方式，选择元素时，就是获得焦点。</p></blockquote><p><b>二、常用结构伪类：</b></p><ul type="circle">    <li>常用的</li>    </ul>     <ol>    <li><code>:first-child</code>所用兄弟元素中的<code>第一个。</code></li>    <li><code>:last-child</code>所有元素中的<code>最后一个。</code></li>    <li><code>:nth-child(n)</code>所有兄弟元素中的<code>第n个。</code></li>    <li><code>:first-of-type</code>所有同类型兄弟元素的<code>第一个。</code></li>    <li><code>:last-of-type</code>所有同类型兄弟中的最后一个。</li>    <li><code>:nth-of-type(n)</code>所有同类型兄弟元素中的<code>第n个。</code>    </ol>  <p><b>三、否定伪类：</b></p> <blockquote><p><code>:not(选择器)</code>派纯满足括号中条件的元素。</p></blockquote><p><b>四、UI伪类</b></p><ol>    <li><code>:checked</code>被选中的复选框或单选框按钮。</li>    <li><code>:enable</code>可用的表单元素（没有<code>didabled</code>属性）。</li>    <li><code>:disabled</code>不可用的表单元素（有<code>didabled</code>属性）。</li>    </ol><p style="font-size:25px"><b>伪元素选择器</b></p><ul>    <li>作用：<code>选中元素</code>中的一些特殊位置。</li>    <li>常用伪元素：<li>    <ol>        <li><code>::first-letter</code>选中元素中的<code>第一个文字</code>。</li>        <li><code>::first-line</code>选中元素中的<code>第一行文字</code>。</li>        <li><code>::selection</code> 选中<code>被鼠标选中的</code>内容。</li>        <li><code>::placeholder</code>选中输入框的<code>提示文字</code>。</li>        <li><code>::before</code>在元素<code>最开始</code>的位置，创建一个子元素（必须用<code>content</code>属性指定内容）。</li>        <li><code>::after</code>在元素<code>最后</code>的位置，创建一个子元素（必须用<code>content</code>属性指定内容）。</li>              </ol></ul><p><b>选择器优先级</b></p><p><b>CSS选择器优先级是指当多个CSS规则应用于同一个元素时，用来决定哪个规则生效的顺序。优先级从高到低依次为：</b></p><p><b>一、内联样式（Inline styles）</b></p><li>内联样式是直接在HTML元素的<code>style</code>属性中定义的样式。例如<code>&lt;div  style="color: red;"&gt;内容&lt;/div"&gt;</code>，这种样式具有最高的优先级，因为它直接作用于元素本身，能够覆盖外部样式表和内部样式表中的其他选择器定义的样式。</li><p><b>二、ID选择器（ID selectors）</b></p><li>ID选择器使用<code>#</code>加元素的ID值来选择元素，如<code>#header&#123;background-color: blue;&#125;</code>。在页面中，ID应该是唯一的，所以ID选择器的优先级很高。它仅次于内联样式，能够覆盖类选择器、属性选择器等定义的样式。</li><p><b>三、类选择器、属性选择器和伪类选择器（Class selectors, Attribute selectors, and Pseudo-classes）</b></p><ol>       <li><b>类选择器</b>：使用<code>.</code>加类名来选择元素，如<code>.container&#123;width: 100px;&#125;</code>。它可以为具有相同类名的多个元素设置统一的样式。</li>    <li><b>属性选择器</b>：通过元素的属性来选择元素，例如<code>input[type="text"]&#123;border: 1px solid black;&#125;</code>，它选择所有<code>type</code>属性为<code>text</code>的<code>input</code>元素。</li><li><b>伪类选择器</b>：用于定义元素的特殊状态，如<code>:hover</code>（鼠标悬停时）、<code>:active</code>（元素被激活时）等，例如<code>a:hover&#123;color: green;&#125;</code>。这三者优先级相同，都高于标签选择器和通配符选择器。</li>    <p><b>四、标签选择器和伪元素选择器（Type selectors and Pseudo-elements）</b></p><ol>    <li><b>标签选择器</b>：直接使用元素的标签名来选择元素，如<code>div&#123;margin: 10px;&#125;</code>，它会选择页面上所有的<code>div</code>元素。</li><li><b>伪元素选择器</b>：用于选择元素的特定部分，如<code>::before</code>和<code>::after</code>。例如<code>div::before&#123;content: "前缀";&#125;</code>，会在<code>div</code>元素内容前插入“前缀”文本。它们的优先级相同，低于类选择器等。</li>    <p><b>五、通配符选择器、继承样式和浏览器默认样式<code>（Universal selectors, Inherited styles, and Default browser styles</code>）</b></p><ol>        <li><b>通配符选择器</b>：使用<code>*</code>来选择页面上所有的元素，如<code>*&#123;box-sizing: border-box;&#125;</code>，它的优先级很低。</li>    <li><b>继承样式</b>：某些CSS属性（如<code>color、font-size</code>等）会从父元素继承到子元素，这种继承而来的样式优先级也很低。</li>    <li><b>浏览器默认样式</b>：浏览器自身为元素定义的一些初始样式，如果没有其他样式覆盖，这些默认样式会生效，它的优先级是最低的。</li>    <blockquote><p>当优先级相同时，CSS规则的定义顺序也会影响最终生效的样式。在同一个CSS文件中，后定义的规则会覆盖先定义的规则；如果多个CSS文件同时作用于页面，后加载的CSS文件中的规则会覆盖先加载的CSS文件中的规则（前提是选择器优先级相同）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习CSS.1学习笔记</title>
      <link href="/2025/01/16/css/%E5%AD%A6%E4%B9%A0css.1/"/>
      <url>/2025/01/16/css/%E5%AD%A6%E4%B9%A0css.1/</url>
      
        <content type="html"><![CDATA[<p style="text-align:center;color:#DB7A0B;font-family:华文楷体;font-size:60px">入门CSS</p><div>S<h1 style="color:#47F1EF;font-size:39px;font-family:华文楷体">CSS简介</h1></div><p style="font-size:30px;font-family:华文楷体"><b>1.什么是 CSS？</b></p><ul>    <li>CSS 指的是层叠样式表* (Cascading Style Sheets)</li>    <li>CSS 描述了<b>如何在屏幕、纸张或其他媒体上显示 HTML 元素</b></li>    <li>CSS <b>节省了大量工作</b>。它可以同时控制多张网页的布局</li>    <li>外部样式表存储在<b> CSS 文件中</b></li></ul><h1 style="color:#47F1EF;font-size:39px;font-family:华文楷体">CSS 语法</h1><p style="font-size:19px">CSS（层叠样式表）用于设置HTML页面中元素的样式，其语法主要包括以下几个部分：</p><p style="font-size:20px"><b>1.选择器</b></p><div>    <p>选择器用于选择页面中的元素，以便为其应用样式。常见的选择器类型有：</p>    <ul>        <li><b>元素选择器</b>：直接使用元素名称，如p选择页面中所有的&lt;p&gt;元素。</li>        <li><b>类选择器</b>：以<code>.</code>开头，如<code>.my-class</code>选择页面中所有<code>class="my-class"</code>的元素。</li>        <li><b>ID选择器</b>:以<code>#</code>开头，如<code>#my-id</code>选择页面中<code>id="my-id"</code>的元素。</li>        <li><b>属性选择器</b>:以<code>[attribute]</code>形式，如<code>[type="text"]</code>选择所有<code>type</code>属性值为<code>text</code>的元素。</li>        <li><b>伪类选择器</b>:以<code>:</code>开头，如<code>:hover</code>选择鼠标悬停的元素，<code>:nth-child(n)</code>选择其父元素的第<code>n</code>个子元素等。</li>        <li><b>伪元素选择器</b>:以<code>:before</code>在元素内容前插入内容，<code>::after</code>在元素内容后插入内容等。</li>        <li><b>组合选择器</b>:可以将多个选择器组合使用，如<code>div p</code>选择<code>&lt;div&gt;</code>元素内的所有<code>&lt;p&gt;</code>元素，<code>.class1.class2</code>选择同时具有<code>class1</code>和<code>class2</code>类的元素等。</li>        </ul>        </div><p style="font-size:20px"><b>2.声明器</b></p><p>选择器后面跟着一个花括号<code>&#123;&#125;</code>，里面包含一个或多个声明，用于定义元素的样式。每个声明由属性和值组成，属性和值之间用英文冒号<code>:</code>分隔，每个声明之间用英文分号<code>;</code>分隔。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="font-size:25px"><b>示例:</b></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选择所有段落元素，设置字体颜色为红色，字体大小为16px */</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择id为&quot;header&quot;的元素，设置背景颜色为蓝色，文字颜色为白色 */</span></span><br><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择类名为&quot;highlight&quot;的元素，鼠标悬停时设置背景颜色为黄色 */</span></span><br><span class="line"><span class="selector-class">.highlight</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择所有input元素，且type属性值为&quot;text&quot;，设置边框为1px实线黑色 */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;text&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CSS的语法简洁而强大，通过合理使用选择器和声明块，可以灵活地为HTML页面中的元素设置各种样式。</p></blockquote><h1 style="color:#47F1EF;font-size:39px;font-family:华文楷体">CSS 样式</h1><p>有三种主要的插入CSS样式表的方法，分别是内联样式、内部样式表和外部样式表。以下是详细介绍：</p><p style="font-size:20px"><b>1. 内联样式（Inline CSS）</b></p><ul>    <li><b>定义</b>:直接在HTML元素的标签中使用<code>style</code>属性来添加CSS样式。</li>    <li><b>使用方法</b>:在元素标签中添加<code>style="样式规则"</code>，样式规则中包含属性和值，属性和值之间用英文冒号分隔，多个样式规则之间用英文分号分隔。例如：</li>    </ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red; font-size: 16px;&quot;</span>&gt;</span>这是一段红色的文本，字体大小为16px。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul>    <li><b>特点</b>:</li>   <ul type="circle">    </ul>        <li>优点：可以直接在元素上应用样式，对于单个元素的样式修改非常方便，可以快速看到效果。</li>        <li>缺点：样式与结构混合，违反了CSS与HTML分离的原则，不利于维护和重用。当需要对多个元素应用相同的样式时，代码会变得冗余。</li></ul>        <p style="font-size:20px"><b>2. 内部样式表（Internal CSS）</b></p><ul>    <li><b>定义</b>:在HTML文档的<code>&lt;head&gt;</code>部分使用<code>&lt;style&gt;</code>标签来定义CSS样式。</li>    <li><b>使用方法</b>:在<code>&lt;head&gt;</code>标签内添加<code>&lt;style&gt;</code>标签，在<code>&lt;style&gt;</code>标签内编写CSS选择器和对应的样式规则。例如：</li>    </ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">14px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.highlight</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段蓝色的文本，字体大小为14px。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;highlight&quot;</span>&gt;</span>这是一个黄色背景的div。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul>    <li><b>特点</b>:</li>       </ul><ul type="circle">        <li>优点：样式与HTML结构在同一文件中，方便查看和修改，适用于单个页面的样式定义。可以避免内联样式带来的代码冗余问题。</li>        <li>缺点：样式仍然局限于单个HTML文件，不利于多个页面之间的样式共享和维护。当网站包含多个页面时，每个页面都需要重复编写相同的样式代码。</li></ul><p style="font-size:20px"><b>3. 外部样式表（External CSS）</b></p><ul>    <li><b>定义</b>:将CSS样式写在一个单独的<code>.css</code>文件中，然后在HTML文档中通过<code>&lt;link&gt;</code>标签引入该样式表。</li>    <li><b>使用方法</b>:首先创建一个CSS文件（如<code>styles.css</code>），在其中编写CSS样式规则。然后在HTML文档的<code>&lt;head&gt;</code>部分使用<code>&lt;link&gt;</code>标签引入该CSS文件。例如：</li>    </ul><ul type="circle">    <li><code>styles.css</code>文件内容：</li>    </ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul type="circle">    <li>HTML文件内容：</li>    </ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span>&gt;</span>这是页面头部。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段绿色的文本，字体大小为18px。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul>    <li><b>特点</b>:</li>       </ul><ul type="circle">        <li>优点：实现了CSS与HTML的完全分离，符合Web开发的最佳实践。样式文件可以被多个HTML页面共享，便于维护和更新。当需要修改样式时，只需修改一个CSS文件，所有引用该文件的页面都会自动更新样式。</li>        <li>缺点：需要额外的文件管理，对于非常简单的页面或临时的样式修改，可能会显得有些繁琐。</li></ul><p style="font-size:20px"><b>样式优先级</b></p><div>    当同时使用以上三种方法时，样式的优先级从高到低依次为：内联样式 > 内部样式表 > 外部样式表。此外，还可以通过使用<code>!important</code>规则来提高某个样式规则的优先级，但应谨慎使用，因为它可能会导致样式难以维护。例如：</div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这会使&lt;p&gt;元素的文本颜色无论如何都显示为红色，即使有其他更高优先级的样式规则存在。*/</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red <span class="meta">!important</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识HTML.3学习笔记</title>
      <link href="/2025/01/15/html/%E5%AD%A6%E4%B9%A0html.3/"/>
      <url>/2025/01/15/html/%E5%AD%A6%E4%B9%A0html.3/</url>
      
        <content type="html"><![CDATA[<h1 style="text-align:center;font-size:60px;color:green;font-family:华文楷体">块元素和行内元素</h1><p><dfn>一、定义和用法</dfn></p><blockquote><p>div 标签定义 HTML 文档中的分割或部分（分区或小节，division&#x2F;section）。<br>div 标签可以把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不使用任何格式与其关联。<br>任何类型的内容都可以放在 div 标签内！div 标签可用作 HTML 元素的容器，然后使用 CSS 设置样式或使用 JavaScript 进行操作。<br>如果用 id 或 class 来标记 div，那么该标签的作用会变得更加有效。通过使用 class 或 id 属性，可以轻松地对 div 标签设置样式。<br>注意：默认情况下，浏览器总是在 div 元素前后放置一个换行符。</p></blockquote><p>二、用法</p><blockquote><p>div 是块级元素。这意味着它的内容自动地开始一个新行。实际上，换行是 div 固有的唯一格式表现。可以通过 div 的 class 或 id 应用额外的样式。<br>不必为每一个 div 都加上类或 id，虽然这样做也有一定的好处。<br>可以对同一个 div 元素应用 class 或 id 属性，但是更常见的情况是只应用其中一种。这两者的主要差异是，class 用于元素组（类似的元素，或者可以理解为某一类元素），而 id 用于标识单独的唯一的元素。</p></blockquote><h1 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.cities &#123;</span><br><span class="line">    background-color:black;</span><br><span class="line">    color:white;</span><br><span class="line">    margin:20px;</span><br><span class="line">    padding:20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;cities&quot;&gt;</span><br><span class="line">&lt;h2&gt;London&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Standing on the River Thames, London has been a major settlement for two millennia, its history going back to its founding by the Romans, who named it Londinium.&lt;/p&gt;</span><br><span class="line">&lt;/div&gt; </span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 style="text-align:center;font-size:60px;font-family:华文楷体;color:green">表单</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot;&gt;  &lt;!--输入框--&gt;</span><br><span class="line">&lt;button&gt;SEARCH&lt;button&gt; &lt;!--搜索--&gt;</span><br></pre></td></tr></table></figure><p><b><code>表单常用属性</code></b></p><pre>1.作用于form标签（表单）action:用于指定表单的提交地址（需要与后端沟通后确定）。target:用于控制表单提交后，如何打开页面，常用值如下：        _self:在本窗口打开。        _blank:在新窗口打开。2.作用于input标签（输入框）method:用于控制表单的提交方式。type:设置输入框的类型，目前用到的值是text,表示普通文本。name:用于指定提交数据的名字，（需要与后端人员沟通后确定）。</pre><p><code>示例</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://search.jd.com/Search&quot;</span><span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span><span class="attr">name</span>=<span class="string">&quot;keyword&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>京东搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p style="font-family:华文楷体;color:green;font-size:20px">表单_常用控件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">认识新属性：value(值):可以控制输入框的默认值</span><br><span class="line">           maxlength(最大长度)：可以输入最大的字符长度</span><br></pre></td></tr></table></figure><hr><p style="font-family:华文楷体;color:green;font-size:20px">表单_单选框与多选框</p><ul>    <b><li>单选框</li></b>    </ul>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女</span><br><span class="line">&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男</span><br></pre></td></tr></table></figure><blockquote><p>常用属性性如下：<br>name:数据的名称，注意：想要单选效果，多个radio的name属性值要保持一致。<br>value：提交的数据值<br>checked:让该单选按钮默认选中。</p></blockquote><ul>    <b><li>复选框</li></b>    </ul>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;exercise&quot;</span>&gt;</span>运动</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;reading&quot;</span>&gt;</span>阅读</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;swimming&quot;</span>&gt;</span>游泳</span><br></pre></td></tr></table></figure><blockquote><p>常用属性性如下：<br>checked：让该复选框默认选中。</p></blockquote><hr><p style="font-family:华文楷体;color:green;font-size:20px">表单_隐藏域</p><ul>    <b><li>隐藏域</li></b>    </ul>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;page&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>用户不可见的一个区域，作用是：提交表单的时候，携带一些固定的数据。</p></blockquote><hr><ul>    <b><li>提交按钮</li></b>    </ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hatton</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">hatton</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>1.button标签type属性的默认值是submit。<br>2.button不要指定name属性。<br>3.input标签编写的按钮，使用value属性指定按钮文字。</p></blockquote><ul>    <b><li>重置按钮</li></b>    </ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><ul>    <b><li>普通按钮</li></b>    </ul>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;确定&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>普通按钮的type值为button,若不写type值是submit会引起表单的提交。</p></blockquote><hr><p style="font-family:华文楷体;color:green;font-size:20px">表单_文本域和下拉框</p><ul>    <b><li>文本域</li></b>    </ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">txtarea</span> <span class="attr">name</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;22&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;3&quot;</span>&gt;</span>文本域<span class="tag">&lt;/<span class="name">txtarea</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>常用属性如下：<br>1.rows：指定默认显示的行数，会影响文本域的高度。<br>2.cols:指定默认显示的列数，会影响文本域的宽度。<br>3.不能编写type属性，其他属性，与普通文本输入框一致。</p></blockquote><ul>    <b><li>下拉框</li></b>    </ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;shanghai&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;guangzhou&quot;</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;shenzhen&quot;</span> <span class="attr">selected</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>常用属性及注意事项：<br>1.name:指定数据的名称。<br>2.option标签设置value属性，如果没有value属性，提交的数据是option中间的文字;如果设置了value属性，提交的数据就是value的值（建议设置value属性）<br>3.option标签设置了selected属性，表示默认选中。</p></blockquote><hr><p style="font-family:华文楷体;color:green;font-size:20px">表单_禁用表单控件</p><ul>    <b><li>禁用表单控件</li></b>    </ul><blockquote><p>给表单控件的标签设置disabled即可禁用表单控件。<br>input、textarea、button、select、option都可以设置disabled属性</p></blockquote><p style="font-family:华文楷体;color:green;font-size:20px">表单_label标签</p><ul>    <b><li>表单label标签</li></b>    </ul>    <blockquote><p>label标签可与表单控件相关联，关联之后点击文字，与之对应的表单控件就会获取焦点。两种与label关联方式如下：<br>1.让label标签的form属性的值等于表单控件的id。<br>2.把表单控件套在label标签的里面。</p></blockquote><h1 style="text-align:center;font-size:60px;font-family:华文楷体;color:green">框架标签</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.taobao.com&quot;</span><span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span><span class="attr">width</span>=<span class="string">&quot;300&quot;</span><span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span>taobao<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>与超链接的target属性配合使用</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.taobao.com&quot;</span>  <span class="attr">target</span>=<span class="string">&quot;clj&quot;</span>&gt;</span>淘宝<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;clj&quot;</span>  <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">htight</span>=<span class="string">&quot;300&quot;</span> &gt;</span>taobao<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>与表单的target属性配合使用</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://www.taobao.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;clj&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;keyword&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;clj&quot;</span>  <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">htight</span>=<span class="string">&quot;300&quot;</span> &gt;</span>taobao<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>  </span><br></pre></td></tr></table></figure><table>    <tr>        <th>标签名</th>        <th>功能和语义</th>        <th>属性</th>        <th>单/双标签</th>        </tr>    <tr>        <th>iframe</th>        <th>框架（在页面中嵌入其他文件）</th>        <th>name:框架名字，可以与target属性配合。            width:框架的宽。            height：框架的高。            frameborder:是否显示边框，值：0或者1。</th>        <th>双</th>    </tr>  </table>    <blockquote><p>iframe标签的实际应用：<br>    1.在网页中嵌入广告。<br>    2.与超链接或表单的target配合，展示不同的内容。</p></blockquote><p style="font-family:华文楷体;color:green;font-size:20px">HTML 字符实体</p><p><code><b>字符实体</b>由三部分组成：一个&和一个实体名称（或者一个#和一个实体编号），最后加上一个分号<b>;</b> 。</code></p>]]></content>
      
      
      <categories>
          
          <category> HTML基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio Code </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识HTML.2学习笔记</title>
      <link href="/2025/01/14/html/%E5%AD%A6%E4%B9%A0html.2/"/>
      <url>/2025/01/14/html/%E5%AD%A6%E4%B9%A0html.2/</url>
      
        <content type="html"><![CDATA[<h1 style="text-align:center;font-size:60px;color:green;font-family:华文楷体;">HTML 颜色</h1><p><b><dfn>颜色值</dfn></b></p><p>颜色由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。每种颜色的最小值是 0（十六进制：#00）。最大值是 255（十六进制：#FF）。<p>    <p><b><dfn>在HTML中应用16进制颜色</dfn></b><br><cite>设置文本颜色</cite></p><blockquote><p>可以通过CSS的color属性来设置文本颜色。例如：   </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=&quot;color:#FF5733;&quot;&gt;这是一段红色的文本。&lt;/p&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，段落p中的文本颜色被设置为#FF5733，这是一种橙红色。</p></blockquote><p><cite>设置背景颜色</cite></p><blockquote><p>使用background-color属性可以设置元素的背景颜色。例如：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#333399; width:200px; height:100px;&quot;</span>&gt;</span></span><br><span class="line">  这是一个有背景颜色的div</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里设置了一个div元素的背景颜色为#333399，这是一种深蓝色。同时，通过设置width和height属性，定义了div的大小，以便更好地展示背景颜色效果。</p></blockquote><p><cite>设置边框颜色</cite></p><blockquote><p>如果要给元素添加边框并设置边框颜色，可以使用border属性。例如：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border:2px solid #FFD700; width:200px; height:100px;&quot;</span>&gt;</span></span><br><span class="line">  这是一个有黄色边框的div</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，div元素有一个2像素宽的实线边框，边框颜色为#FFD700，即金色。通过这种方式，可以为网页中的各种元素添加具有特定颜色的边框，增强页面的视觉效果。<br>如何使用样式<br>当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化。有以下三种方式来插入样式表：</p></blockquote><p><cite>外部样式表</cite></p><blockquote><p>当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p><cite>内部样式表</cite></p><blockquote><p>当单个文件需要特别样式时，就可以使用内部样式表。你可以在 head 部分通过 style 标签定义内部样式表。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">body &#123;background-color: red&#125;</span><br><span class="line">p &#123;margin-left: 20px&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p><cite>内联样式</cite></p><blockquote><p>当特殊的样式需要应用到个别元素时，就可以使用内联样式。使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=&quot;color: red; margin-left: 20px&quot;&gt;</span><br><span class="line">This is a paragraph</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><h1 style="text-align:center;font-size:60px;color:green;font-family:华文楷体;">HTML 超链接</h1><p><code>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。</code></p><blockquote><p>当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。<br>我们通过使用 《a》 标签在 HTML 中创建链接。<br>有两种使用 《a》 标签的方式：<br>通过使用 href 属性 - 创建指向另一个文档的链接<br>通过使用 name 属性 - 创建文档内的书签</p></blockquote><p><code>HTML中的链接是通过《a》（anchor）标签来创建的，它允许用户从一个网页跳转到另一个网页、网页的某个部分，或者打开一个文件等。以下是关于HTML链接的详细介绍：</code></p><p>一、基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;链接目标的URL&quot;</span>&gt;</span>链接文字或内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>href属性是关键，它指定了链接的目标地址。可以是网页的URL、文件的路径、网页内部的锚点等。<br>链接文字或内容是显示在网页上的部分，用户点击这部分内容就会触发链接跳转。可以是纯文本，也可以是图片或其他HTML元素。</p></blockquote><p>二、链接类型<br>1.外部链接<br><code>这是指向其他网站的链接。例如，要创建一个链接到百度首页的链接，可以这样写：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>访问百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当用户点击“访问百度”这几个字时，浏览器会打开百度的首页。</p></blockquote><p>2.内部链接<br><code>内部链接是指在同一网站内部不同页面之间的链接。例如，一个网站有首页（index.html）、关于我们（about.html）和联系我们（contact.html）三个页面，可以在首页创建一个链接到关于我们页面的链接：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;about.html&quot;</span>&gt;</span>关于我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里假设这些页面都在同一个目录下。如果页面在不同的目录，需要正确设置相对路径或绝对路径。例如，如果关于我们页面在pages目录下，链接可以写成：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;pages/about.html&quot;</span>&gt;</span>关于我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.锚点链接</p><blockquote><p>锚点链接用于在同一页面内快速跳转到特定位置。首先需要在目标位置设置一个锚点，使用《a》标签的name属性（HTML5中推荐使用id属性）来定义锚点。例如，在页面底部有一个段落：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;section1&quot;</span>&gt;</span>第一部分<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是第一部分的内容……<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>然后在页面顶部可以创建一个链接到这个锚点的链接：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#section1&quot;</span>&gt;</span>跳转到第一部分<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">当用户点击这个链接时，页面会滚动到<span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;section1&quot;</span>&gt;</span>所在的位置。</span><br></pre></td></tr></table></figure><p>三、链接的其他属性<br>1.target属性</p><blockquote><p>这个属性可以控制链接在何处打开。常用的值有：</p></blockquote><p><code>_self：在当前窗口或标签页中打开链接，这是默认值。<br>_blank：在新窗口或新标签页中打开链接。例如：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>在新标签页打开示例网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>点击这个链接会在新标签页中打开<a href="https://www.example.com./">https://www.example.com。</a></p></blockquote><p><code>_parent：在父窗口或标签页中打开链接，主要用于框架（frame）或嵌套的网页场景。<br>_top：在整个浏览器窗口中打开链接，也会清除所有框架。</code><br>2.title属性<br><code>为链接提供额外的信息，当用户将鼠标悬停在链接上时，会显示这个提示信息。例如：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span> <span class="attr">title</span>=<span class="string">&quot;这是一个示例网站&quot;</span>&gt;</span>示例网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>鼠标悬停在“示例网站”链接上时，会显示“这是一个示例网站”的提示。<br>HTML链接是网页之间相互连接的桥梁，合理使用链接可以极大地提升用户体验和网站的导航性。</p></blockquote><h1 style="text-align:center;font-size:60px;color:green;font-family:华文楷体;">HTML 图像</h1><p><code>在HTML中插入图像主要通过《img》标签来实现，这是一种非常简单但功能强大的方式，可以让网页更加生动和富有表现力。以下是关于如何在HTML中插入图像的详细介绍：</code><br>一、基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像的URL或路径&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图像的替代文本&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>src属性：这是必需的属性，用于指定图像的源路径。可以是相对路径（相对于当前HTML文件的位置）或绝对路径（完整的URL）。</p></blockquote><p><code>alt属性：也是很重要的属性，它提供了图像的替代文本。当图像由于某些原因无法显示时（如网络问题、图像路径错误等），浏览器会显示这个替代文本。此外，对于使用屏幕阅读器的用户来说，alt文本可以帮助他们了解图像的内容，从而提高网页的可访问性。</code></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>1.使用相对路径插入图像<br><code>假设你有一个名为image.jpg的图像文件，它和你的HTML文件位于同一个目录下，你可以这样插入图像：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图像&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>如果图像文件位于一个名为images的子目录中，路径应该是：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图像&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.使用绝对路径插入图像<br><code>如果你想插入一个来自互联网的图像，可以使用完整的URL：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://example.com/images/image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;来自外部网站的图像&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>二、其他有用的属性<br>1.width和height属性</p><blockquote><p>这两个属性可以用来指定图像的显示宽度和高度，单位通常是像素。这可以帮助你控制图像在网页中的大小，使其更好地适应布局。例如：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图像&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>注意，如果只设置其中一个属性，图像会按比例自动调整另一个维度的大小，以保持图像的纵横比。</code><br>2.title属性</p><blockquote><p>和链接的title属性类似，title属性为图像提供额外的信息，当用户将鼠标悬停在图像上时，会显示这个提示信息。</p></blockquote><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图像&quot;</span> <span class="attr">title</span>=<span class="string">&quot;这是一个示例图像&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 style="text-align:center;font-size:60px;color:green;font-family:华文楷体;">HTML 表格，列表</h1><p>一、基本语法<br><code>HTML表格是通过table标签来创建的，表格由行（《tr》）、单元格（td或th）组成。其中，th用于定义表头单元格，通常显示为加粗和居中，而td用于定义普通单元格。</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据6<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1.表格的组成部分</p><blockquote><p>1.table标签：定义整个表格。<br>2.tr标签：定义表格的行。<br>3.th标签：定义表头单元格，通常用于第一行来描述列的内容。<br>4.td标签：定义普通单元格，用于包含数据。</p></blockquote><p>2.表格的属性</p><blockquote><p>虽然HTML5中许多表格属性已经被CSS所取代，但仍然有一些属性可以用来控制表格的基本行为：<br>border属性：用于设置表格边框的宽度。例如，table border&#x3D;”1”会创建一个有边框的表格。不过，现在更推荐使用CSS来控制边框样式。<br>cellpadding和cellspacing属性：分别用于设置单元格内内容与边框的距离（内边距）和单元格之间的距离（外边距）。同样，这些现在也推荐使用CSS来控制。</p></blockquote><p><code>在HTML中，列表是一种非常有用的元素，用于组织和显示一系列相关的信息。HTML提供了三种主要的列表类型：无序列表（ul）、有序列表（ol）和描述列表（dl）。每种列表类型都有其特定的用途和格式。</code><br>一、无序列表（ul）</p><blockquote><p>无序列表用于表示没有特定顺序的项目列表。列表项使用li（list item）标签定义。</p></blockquote><p>1.基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>在浏览器中，这将显示一个带有项目符号的列表。</code><br>二、有序列表（ol）<br><dfn>有序列表用于表示有特定顺序的项目列表。列表项同样使用li标签定义。有序列表的列表项会自动编号。</dfn><br>2.基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>在浏览器中，这将显示一个带有数字编号的列表。</code><br>三、描述列表（dl）<br><dfn>描述列表用于表示术语和描述的列表。它由dl标签定义，每个术语使用dt（definition term）标签定义，每个描述使用dd（definition description）标签定义。</dfn><br>1.基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>术语1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>术语2<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>在浏览器中，这将显示一个术语和描述的列表，术语通常会加粗显示。</code><br><dfn>四、列表的嵌套</dfn></p><blockquote><p>列表可以嵌套使用，即在一个列表项内部再创建一个新的列表。这在需要表示层次结构时非常有用。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">复制</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>水果</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>橙子<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>蔬菜</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>胡萝卜<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>西红柿<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>土豆<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>在浏览器中，这将显示一个嵌套的无序列表，其中每个主要类别（水果和蔬菜）下面有子类别。</code></p>]]></content>
      
      
      <categories>
          
          <category> HTML基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio Code </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html.1学习笔记</title>
      <link href="/2025/01/14/html/%E5%AD%A6%E4%B9%A0html.1/"/>
      <url>/2025/01/14/html/%E5%AD%A6%E4%B9%A0html.1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>HTML 注释</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--（文本）--&gt;</span><br></pre></td></tr></table></figure><h1 style="text-align:center;font-size:60px"> HTML 样式</h1><h2 style="text-align:center;font-size:30px;font-family:华文楷体">HTML 的 style 属性</h2><blockquote><p>style 属性用于改变 HTML 元素的样式。</p></blockquote><p>1.style 属性的作用:</p><blockquote><p>提供了一种改变所有 HTML 元素的样式的通用方法。<br>样式是 HTML 4 引入的，它是一种新的首选的改变 HTML 元素样式的方式。通过 HTML 样式，能够通过使用 style 属性直接将样式添加到 HTML 元素，或者间接地在独立的样式表中（CSS 文件）进行定义。</p></blockquote><h3 style="text-align:center;color:green;font-size:30px;font-family:华文楷体">HTML 样式实例 - 背景颜色</h3><blockquote><p>background-color 属性为元素定义了背景颜色：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body style=&quot;background-color:yellow&quot;&gt;</span><br><span class="line">&lt;h2 style=&quot;background-color:red&quot;&gt;This is a heading&lt;/h2&gt;</span><br><span class="line">&lt;p style=&quot;background-color:green&quot;&gt;This is a paragraph.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 style="text-align:center;color:red;font-size:30px;font-family:华文楷体">HTML 样式实例 - 字体、颜色和尺寸</h4><blockquote><p>font-family、color 以及 font-size 属性分别定义元素中文本的字体系列、颜色和字体尺寸：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 style=&quot;font-family:verdana&quot;&gt;A heading&lt;/h1&gt;</span><br><span class="line">&lt;p style=&quot;font-family:arial;color:red;font-size:20px;&quot;&gt;A paragraph.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h5 style="text-align:center;color:green;font-size:30px;font-family:华文楷体">HTML 样式实例 - 文本对齐</h5>                    <blockquote><p>text-align 属性规定了元素中文本的水平对齐方式：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 style=&quot;text-align:center&quot;&gt;This is a heading&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;The heading above is aligned to the center of this page.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 style="text-align:center;font-size:60px;">HTML 文本格式化</h1><blockquote><p>HTML 可定义很多供格式化输出的元素，比如粗体和斜体字。</p></blockquote><h2 style="text-align:center;font-size:30px;font-family:华文楷体;color:red">文本风格化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;b&gt;This text is bold&lt;/b&gt;</span><br><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;This text is strong&lt;/strong&gt;</span><br><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">&lt;big&gt;This text is big&lt;/big&gt;</span><br><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">&lt;em&gt;This text is emphasized&lt;/em&gt;</span><br><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">&lt;i&gt;This text is italic&lt;/i&gt;</span><br><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">&lt;small&gt;This text is small&lt;/small&gt;</span><br><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">This text contains</span><br><span class="line">&lt;sub&gt;subscript&lt;/sub&gt;</span><br><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br></pre></td></tr></table></figure><h3 style="text-align:center;font-size:30px;color:red;font-family:华文楷体">预格式文本</h3>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    &lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">这是</span><br><span class="line">预格式文本。</span><br><span class="line">它保留了      空格</span><br><span class="line">和换行。</span><br><span class="line">&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;pre 标签很适合显示计算机代码：&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">for i = 1 to 10</span><br><span class="line">     print i</span><br><span class="line">next i</span><br><span class="line">&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 style="text-align:center;font-size:30px;color:red;font-family:华文楷体">“计算机输出”标签</h4>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;code&gt;Computer code&lt;/code&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;kbd&gt;Keyboard input&lt;/kbd&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;tt&gt;Teletype text&lt;/tt&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;samp&gt;Sample text&lt;/samp&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;var&gt;Computer variable&lt;/var&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;b&gt;注释：&lt;/b&gt;这些标签常用于显示计算机/编程代码。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h5 style="text-align:center;font-size:30px;color:red;font-family:华文楷体">地址</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;address&gt;</span><br><span class="line">Written by &lt;a href=&quot;mailto:webmaster@example.com&quot;&gt;Donald Duck&lt;/a&gt;.&lt;br&gt; </span><br><span class="line">Visit us at:&lt;br&gt;</span><br><span class="line">Example.com&lt;br&gt;</span><br><span class="line">Box 564, Disneyland&lt;br&gt;</span><br><span class="line">USA</span><br><span class="line">&lt;/address&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h5 style="text-align:center;font-size:30px;color:red;font-family:华文楷体">缩写和首字母缩写</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTML &lt;abbr&gt; 元素定义缩写或首字母缩略语。</span><br><span class="line"></span><br><span class="line">对缩写进行标记能够为浏览器、翻译系统以及搜索引擎提供有用的信息。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;abbr title=&quot;etcetera&quot;&gt;etc.&lt;/abbr&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;acronym title=&quot;World Wide Web&quot;&gt;WWW&lt;/acronym&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;在某些浏览器中，当您把鼠标移至缩略词语上时，title 可用于展示表达的完整版本。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;仅对于 IE 5 中的 acronym 元素有效。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;对于 Netscape 6.2 中的 abbr 和 acronym 元素都有效。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h6 style="text-align:center;font-size:30px;color:red;font-family:华文楷体">文字方向</h6><blockquote><p>bdo:dir&#x3D;ltr（从左到右输出）,rtl（从右到左输出）必需。规定 <bdo> 元素内文本的文本方向。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">如果您的浏览器支持 bi-directional override (bdo)，下一行会从右向左输出 (rtl)；</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;bdo dir=&quot;rtl&quot;&gt;</span><br><span class="line">Here is some Hebrew text</span><br><span class="line">&lt;/bdo&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h6 style="text-align:center;font-size:30px;color:red;font-family:华文楷体">快引用</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTML &lt;blockquote&gt; 元素定义被引用的节。</span><br><span class="line">浏览器通常会对 &lt;blockquote&gt; 元素进行缩进处理。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">这是长的引用：</span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">这是短的引用：</span><br><span class="line">&lt;q&gt;</span><br><span class="line">这是短的引用。</span><br><span class="line">&lt;/q&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">使用 blockquote 元素的话，浏览器会插入换行和外边距，而 q 元素不会有任何特殊的呈现。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h6 style="text-align:center;font-size:30px;color:red;font-family:华文楷体">删除字效果和插入字效果</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;一打有 &lt;del&gt;二十&lt;/del&gt; &lt;ins&gt;十二&lt;/ins&gt; 件。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;大多数浏览器会改写为删除文本和下划线文本。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;一些老式的浏览器会把删除文本和下划线文本显示为普通文本。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio Code </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识HTML，HTML基本使用</title>
      <link href="/2024/12/23/html/%E8%AE%A4%E8%AF%86html/"/>
      <url>/2024/12/23/html/%E8%AE%A4%E8%AF%86html/</url>
      
        <content type="html"><![CDATA[<h1 id="入门HTML"><a href="#入门HTML" class="headerlink" title="入门HTML"></a>入门HTML</h1><h2 id="在VSCode创建HTML文件"><a href="#在VSCode创建HTML文件" class="headerlink" title="在VSCode创建HTML文件"></a>在VSCode创建HTML文件</h2><h3 id="打开-VSCode："><a href="#打开-VSCode：" class="headerlink" title="打开 VSCode："></a>打开 VSCode：</h3><blockquote><p>如果你还没有打开 VSCode，首先启动它。</p></blockquote><h3 id="创建新文件："><a href="#创建新文件：" class="headerlink" title="创建新文件："></a>创建新文件：</h3><blockquote><p>你可以通过点击界面左上角的“文件”菜单，然后选择“新建文件”来创建一个新文件。<br>或者，你可以使用快捷键 Ctrl + N（在 Windows&#x2F;Linux 上）或 Cmd + N（在 macOS 上）来快速创建一个新文件。</p></blockquote><h3 id="保存文件为-HTML："><a href="#保存文件为-HTML：" class="headerlink" title="保存文件为 HTML："></a>保存文件为 HTML：</h3><blockquote><p>在创建新文件后，你需要保存它。点击界面左上角的“文件”菜单，然后选择“保存”或者使用快捷键 Ctrl + S（在 Windows&#x2F;Linux 上）或 Cmd + S（在 macOS 上）。<br>在弹出的保存对话框中，选择你想要保存文件的位置，然后在文件名输入框中输入文件名，确保文件名以 .html 结尾（例如，example.html）。</p></blockquote><h3 id="开始编写-HTML："><a href="#开始编写-HTML：" class="headerlink" title="开始编写 HTML："></a>开始编写 HTML：</h3><blockquote><p>一旦文件被保存为 HTML 文件，你就可以开始编写 HTML 代码了。例如，一个基本的 HTML 页面结构如下：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用-HTML-模板："><a href="#使用-HTML-模板：" class="headerlink" title="使用 HTML 模板："></a>使用 HTML 模板：</h3><blockquote><p>VSCode 支持通过快捷方式创建文件模板。你可以安装一个名为 “HTML Snippets” 的扩展来快速生成 HTML 文件的基本结构。</p></blockquote><h3 id="保存并预览："><a href="#保存并预览：" class="headerlink" title="保存并预览："></a>保存并预览：</h3><blockquote><p>编写完 HTML 代码后，保存文件。你可以通过右键点击编辑器中的文件并选择“在浏览器中打开”来预览你的 HTML 页面，或者直接使用浏览器打开保存的 HTML 文件。</p></blockquote><h1 id="HTML基础标签"><a href="#HTML基础标签" class="headerlink" title="HTML基础标签"></a>HTML基础标签</h1><p><img src="/img%5Cyouxin%5Chtmljc.png"></p><h1 id="HTML基础属性"><a href="#HTML基础属性" class="headerlink" title="HTML基础属性"></a>HTML基础属性</h1><p><img src="/img%5Cyouxin%5Chtmlsx.png"></p>]]></content>
      
      
      <categories>
          
          <category> HTML基础 </category>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio Code </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp什么是委托</title>
      <link href="/2024/12/14/csharp%E5%A7%94%E6%89%98/"/>
      <url>/2024/12/14/csharp%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp什么是委托"><a href="#Csharp什么是委托" class="headerlink" title="Csharp什么是委托"></a>Csharp什么是委托</h1><p>1.在C#中，委托（Delegate）是一种特殊的类型，它定义了方法的类型，使得可以将方法作为参数传递，或者将其赋值给变量。委托是实现事件和回调方法的基础。它们使得将方法作为对象进行操作成为可能，这在异步编程、事件处理和回调方法中非常有用。</p><p>2.委托的基本语法</p><blockquote><p>委托的定义类似于接口，但它专门用于方法。下面是一个委托的基本定义：</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Operation</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>这个Operation委托类型可以持有任何接受两个int参数并返回一个int的方法。</p></blockquote><p>3.使用委托</p><blockquote><p>定义委托：首先定义一个委托类型。<br>实例化委托：创建委托的实例，并将其与具体的方法关联。<br>调用委托：通过委托实例调用方法。</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Operation</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现委托的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MathOperations</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Subtract</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MathOperations math = <span class="keyword">new</span> MathOperations();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化委托</span></span><br><span class="line">        Operation op = <span class="keyword">new</span> Operation(math.Add);</span><br><span class="line">        <span class="built_in">int</span> result = op(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用委托，等同于math.Add(5, 3)</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Add: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改变委托关联的方法</span></span><br><span class="line">        op = math.Subtract;</span><br><span class="line">        result = op(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用委托，等同于math.Subtract(5, 3)</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Subtract: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.多播委托</p><blockquote><p>C#中的委托还支持多播，即一个委托可以关联多个方法。当委托被调用时，关联的所有方法都会按顺序被调用。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">HelloDelegate</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Greeting</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hello</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Goodbye</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Goodbye, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        HelloDelegate hello = <span class="keyword">new</span> HelloDelegate(<span class="keyword">new</span> Greeting().Hello);</span><br><span class="line">        hello += <span class="keyword">new</span> Greeting().Goodbye; <span class="comment">// 添加另一个方法</span></span><br><span class="line"></span><br><span class="line">        hello(<span class="string">&quot;World&quot;</span>); <span class="comment">// 输出: Hello, World 和 Goodbye, World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.委托与事件</p><blockquote><p>委托是实现事件的基础。在C#中，事件是一种特殊的多播委托，用于发布订阅模式，允许对象通知其他对象发生了某个事件。</p></blockquote><p>6.总结</p><blockquote><p>委托提供了一种将方法作为参数传递的强大机制，它们是实现回调、事件和异步编程的关键。通过委托，你可以编写更加灵活和动态的代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp结构体介绍及使用学习笔记</title>
      <link href="/2024/12/14/csharp%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2024/12/14/csharp%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp结构体介绍"><a href="#Csharp结构体介绍" class="headerlink" title="Csharp结构体介绍"></a>Csharp结构体介绍</h1><p>1.在C#中，结构体是一种值类型，用于封装少量的数据。结构体使用 struct 关键字定义，并且可以包含数据字段、方法、属性、索引器、运算符重载和构造函数。结构体不能继承其他的结构体或类，也不能被其他结构体或类继承。以下是结构体的一些基本特性：</p><p>2.定义结构体：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.实例化结构体：</p><blockquote><p>结构体可以通过直接声明或使用 new 关键字来实例化。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p1 = <span class="keyword">new</span> Point();</span><br><span class="line">Point p2 = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>4.结构体是值类型：</p><blockquote><p>结构体是值类型，所以当它们被赋值给另一个变量时，它们的值会被复制。</p></blockquote><p>5.方法和属性：</p><blockquote><p>结构体可以包含方法和属性，就像类一样。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Rectangle</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Length;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Area</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> Length * Width; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintArea</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Area: <span class="subst">&#123;Area&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.运算符重载：</p><blockquote><p>结构体可以重载运算符，以提供自定义的操作。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Vector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Vector <span class="keyword">operator</span> +(Vector a, Vector b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector(a.X + b.X, a.Y + b.Y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.结构体与类的区别：</p><blockquote><p>结构体是值类型，而类是引用类型。<br>结构体默认继承自 System.ValueType，而类默认继承自 System.Object。<br>结构体不能有析构函数，而类可以。<br>结构体不能实现接口，而类可以。</p></blockquote><p>8.装箱和拆箱：</p><blockquote><p>当结构体被赋值给一个对象类型（比如 object 或接口类型）时，会发生装箱操作，将值类型转换为引用类型。相反的操作称为拆箱。</p></blockquote><blockquote><p>使用结构体时，通常是为了创建轻量级的、不可变的数据结构，或者当你需要确保数据被复制而不是引用时。</p></blockquote><h1 id="Csharp结构体函数"><a href="#Csharp结构体函数" class="headerlink" title="Csharp结构体函数"></a>Csharp结构体函数</h1><p>1.在C#中，结构体（struct）是一种值类型，它可以用来定义轻量级的数据结构。结构体可以包含数据字段、属性、方法和构造函数等。以下是一些关于C#结构体中函数的基本示例：</p><p>2.结构体定义</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintCoordinates</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;(<span class="subst">&#123;X&#125;</span>, <span class="subst">&#123;Y&#125;</span>)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写ToString方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;Point(<span class="subst">&#123;X&#125;</span>, <span class="subst">&#123;Y&#125;</span>)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.使用结构体</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">p.PrintCoordinates(); <span class="comment">// 输出: (10, 20)</span></span><br><span class="line">Console.WriteLine(p.ToString()); <span class="comment">// 输出: Point(10, 20)</span></span><br></pre></td></tr></table></figure><p>4.结构体与方法</p><blockquote><p>构造函数：用于初始化结构体的字段。<br>方法：可以定义方法来执行特定的操作，比如上面的PrintCoordinates方法。<br>属性：使用get和set块来定义属性，允许外部代码以属性的方式访问结构体的字段。<br>重写方法：可以重写如ToString等方法，以提供结构体的自定义字符串表示。</p></blockquote><p>5.结构体的值类型特性</p><blockquote><p>结构体是值类型，赋值和参数传递时会复制整个结构体。<br>结构体不能被继承，但可以实现接口。<br>结构体默认有Equals、GetHashCode和ToString方法，但通常需要根据需要重写这些方法。</p></blockquote><p>6.结构体与类的区别</p><blockquote><p>类是引用类型，而结构体是值类型。<br>类可以继承其他类，而结构体不能继承其他结构体或类。<br>结构体的字段默认为private，而类的字段默认为private。</p></blockquote><blockquote><p>这些是C#中结构体和函数的基本用法。根据具体需求，你可以在结构体中定义更多复杂的逻辑和方法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp枚举类型学习笔记</title>
      <link href="/2024/12/14/csharp%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/12/14/csharp%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp枚举类型"><a href="#Csharp枚举类型" class="headerlink" title="Csharp枚举类型"></a>Csharp枚举类型</h1><p>1.C# 中的枚举（Enum）是一种特殊的值类型，它允许你为一组相关的常量定义一个名称。枚举是一种强类型的常量集合，这意味着每个枚举成员都有一个名称和一个底层的整数值。默认情况下，第一个枚举成员的值是0，每个随后的成员的值比前一个成员的值大1。</p><p>2.下面是枚举的一些基本用法：</p><blockquote><p>定义枚举</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> DaysOfWeek</span><br><span class="line">&#123;</span><br><span class="line">    Sunday,</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用枚举</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DaysOfWeek today = DaysOfWeek.Friday;</span><br><span class="line">Console.WriteLine(today); <span class="comment">// 输出：Friday</span></span><br></pre></td></tr></table></figure><blockquote><p>访问枚举成员的值</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> dayValue = (<span class="built_in">int</span>)today;</span><br><span class="line">Console.WriteLine(dayValue); <span class="comment">// 输出：4</span></span><br></pre></td></tr></table></figure><blockquote><p>枚举的底层类型<br>你可以指定枚举的底层类型，比如 byte、sbyte、short、ushort、int、uint、long 或 ulong。如果不指定，默认是 int。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> DaysOfWeek : <span class="built_in">byte</span></span><br><span class="line">&#123;</span><br><span class="line">    Sunday,</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>枚举成员的显式值<br>你也可以为枚举成员指定显式的值。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> DaysOfWeek</span><br><span class="line">&#123;</span><br><span class="line">    Sunday = <span class="number">1</span>,</span><br><span class="line">    Monday = <span class="number">2</span>,</span><br><span class="line">    Tuesday = <span class="number">3</span>,</span><br><span class="line">    Wednesday = <span class="number">4</span>,</span><br><span class="line">    Thursday = <span class="number">5</span>,</span><br><span class="line">    Friday = <span class="number">6</span>,</span><br><span class="line">    Saturday = <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>枚举与switch语句<br>枚举类型经常与 switch 语句一起使用。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (today)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> DaysOfWeek.Sunday:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sunday is the first day of the week.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DaysOfWeek.Monday:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Monday is the second day of the week.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ... 其他情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>检查枚举成员是否存在<br>你可以使用 Enum.IsDefined 方法来检查一个值是否是枚举中的一个有效成员。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isDefined = Enum.IsDefined(<span class="keyword">typeof</span>(DaysOfWeek), <span class="number">8</span>);</span><br><span class="line">Console.WriteLine(isDefined); <span class="comment">// 输出：False</span></span><br></pre></td></tr></table></figure><blockquote><p>枚举是C#中一个非常有用的功能，它可以让你的代码更加清晰和易于维护。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp递归的调用、常量学习笔记</title>
      <link href="/2024/12/13/csharp%E9%80%92%E5%BD%92%E3%80%81%E5%B8%B8%E9%87%8F/"/>
      <url>/2024/12/13/csharp%E9%80%92%E5%BD%92%E3%80%81%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp递归函数练习"><a href="#Csharp递归函数练习" class="headerlink" title="Csharp递归函数练习"></a>Csharp递归函数练习</h1><h3 id="1-2！-3！-···-10！"><a href="#1-2！-3！-···-10！" class="headerlink" title="1+2！+3！+···+10！"></a>1+2！+3！+···+10！</h3><p>利用多少个方法计算结果</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">F1</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> result = n * F1(n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">F2</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> result = F2(n - <span class="number">1</span>) + F1(n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(F2(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 输出结果：<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4037913</span></span><br></pre></td></tr></table></figure></p><h1 id="有关系式1-1-2-2-3-3-···-K-K"><a href="#有关系式1-1-2-2-3-3-···-K-K" class="headerlink" title="有关系式1^1+2^2+3^3+···+K^K&lt;2000,编一个程序，求出满足此关系式的最大值"></a>有关系式1^1+2^2+3^3+···+K^K&lt;2000,编一个程序，求出满足此关系式的最大值</h1><blockquote><p>利用递归和循环解决这个问题</p></blockquote><p>1.循环：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result += k * k;</span><br><span class="line">        <span class="keyword">if</span> (result &gt;= <span class="number">2000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p>2.递归：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">F</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> result = F(n - <span class="number">1</span>) + n * n;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(F(i) &gt;= <span class="number">2000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 输出结果：<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure></p><h1 id="什么是常量"><a href="#什么是常量" class="headerlink" title="什么是常量"></a>什么是常量</h1><ol><li>在C#中，常量是一种特殊的变量，其值在初始化后不能被改变。常量用于存储那些在程序运行期间不应该改变的数据。</li><li>以下是C#中常量的几个关键点：</li></ol><blockquote><p>声明：使用const关键字来声明常量。<br>类型：常量必须有明确的类型，通常是基本数据类型，如int、double、string等。<br>初始化：常量在声明时必须被初始化，且之后不能被重新赋值。<br>作用域：常量的作用域取决于其声明的位置，可以是局部的（在方法或代码块中）或全局的（在类或命名空间中）。<br>编译时常数：编译器在编译时会将常量的值内嵌到代码中，这意味着它们在运行时是不可变的。</p></blockquote><h3 id="下面是一个C-中声明和使用常量的例子："><a href="#下面是一个C-中声明和使用常量的例子：" class="headerlink" title="下面是一个C#中声明和使用常量的例子："></a>下面是一个C#中声明和使用常量的例子：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConstantsExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明一个常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> MaxValue = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用常量</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The maximum value is: &quot;</span> + MaxValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ConstantsExample example = <span class="keyword">new</span> ConstantsExample();</span><br><span class="line">        example.Display();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试修改常量值将导致编译错误</span></span><br><span class="line">        <span class="comment">// ConstantsExample.MaxValue = 200; // 错误：无法对只读字段“ConstantsExample.MaxValue”赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，MaxValue是一个常量，它被声明为const，并且初始化为100。在Display方法中，我们使用这个常量来打印信息。尝试修改MaxValue的值将导致编译错误，因为常量在初始化后不能被改变。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp函数的重载学习笔记</title>
      <link href="/2024/12/12/csharp%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
      <url>/2024/12/12/csharp%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp函数的重载-Overload"><a href="#Csharp函数的重载-Overload" class="headerlink" title="Csharp函数的重载-Overload"></a>Csharp函数的重载-Overload</h1><p>1.在C#中，函数重载（Function Overloading）是指在同一个类中可以定义多个同名函数，只要它们的参数列表不同即可。参数列表不同可以是参数的类型不同、参数的数量不同，或者是两者都不同。函数重载使得函数名可以保持一致，同时能够根据传入的参数执行不同的操作。</p><p>2.以下是函数重载的几个要点：</p><blockquote><p>1.函数名相同：重载的函数必须在同一个类中，并且函数名相同。<br>2.参数列表不同：参数列表必须在数量或者类型上有所不同。<br>3.返回类型无关：函数的返回类型不影响重载，即使两个函数返回类型不同，只要参数列表相同，它们就不是重载。<br>4.访问修饰符无关：函数的访问修饰符（如public、private等）不影响重载。</p></blockquote><p>3.下面是一个简单的C#函数重载的例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MathOperations</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 重载函数，无参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数，一个int参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数，两个int参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数，一个double参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，Add 函数被重载了四次，每次的参数列表都不同。这使得调用者可以根据需要传入不同数量或类型的参数，并执行相应的操作。</p></blockquote><blockquote><p>需要注意的是，C#编译器在调用函数时，会根据传入参数的类型和数量来决定调用哪个重载版本。如果存在多个匹配的重载版本，编译器将选择最具体的一个。如果没有匹配的重载版本，或者存在多个同样具体的版本，编译器将报错。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp递归的调用学习笔记</title>
      <link href="/2024/12/12/csharp%E9%80%92%E5%BD%92%E7%9A%84%E8%B0%83%E7%94%A8/"/>
      <url>/2024/12/12/csharp%E9%80%92%E5%BD%92%E7%9A%84%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp方法的递归调用"><a href="#Csharp方法的递归调用" class="headerlink" title="Csharp方法的递归调用"></a>Csharp方法的递归调用</h1><p>1.在C#中，递归调用是一种方法自己调用自己的技术。递归可以用来解决那些可以分解成相似子问题的问题，比如树的遍历、排序算法（如快速排序、归并排序）等。递归方法通常有两个主要部分：递归终止条件和递归工作部分。</p><p>2.下面是一个简单的递归方法的例子，这个方法用来计算一个数的阶乘：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number = <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">int</span> result = Factorial(number);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The factorial of &quot;</span> + number + <span class="string">&quot; is &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Factorial</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归工作部分</span></span><br><span class="line">        <span class="keyword">return</span> n * Factorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在这个例子中，Factorial 方法计算一个整数 n 的阶乘。递归终止条件是当 n 小于或等于1时，因为1的阶乘是1，这是计算的基本情况。递归工作部分是方法调用自己，但是每次都将 n 减少1，直到达到基本情况。</p><p>4.使用递归时需要注意以下几点：</p><blockquote><p>递归终止条件：必须有一个明确的终止条件来防止无限递归。<br>递归工作部分：每次递归调用都应该向终止条件靠近。<br>性能问题：递归可能会导致较大的内存开销，因为每次递归调用都会在调用栈上增加一层。对于深度递归，可能会导致栈溢出错误。<br>尾递归优化：在某些编程语言中，尾递归可以被优化以减少内存使用。但在C#中，编译器并不自动优化尾递归。<br>在实际编程中，递归是一种强大的工具，但需要谨慎使用，以避免性能问题和栈溢出错误。对于可以递归解决的问题，有时候使用迭代方法（循环）可能是一个更好的选择。</p></blockquote><h1 id="递归函数—求阶乘"><a href="#递归函数—求阶乘" class="headerlink" title="递归函数—求阶乘"></a>递归函数—求阶乘</h1><h2 id="1-10的阶乘"><a href="#1-10的阶乘" class="headerlink" title="1.10的阶乘"></a>1.10的阶乘</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">F</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> result=n * F(n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(F(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp方法的参数和返回值学习笔记</title>
      <link href="/2024/12/10/csharp%E5%8F%82%E6%95%B0/"/>
      <url>/2024/12/10/csharp%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp方法的参数和返回值学习笔记"><a href="#Csharp方法的参数和返回值学习笔记" class="headerlink" title="Csharp方法的参数和返回值学习笔记"></a>Csharp方法的参数和返回值学习笔记</h1><p><font size='5'>1.在C#中，方法（Method）是类或结构体中定义的，用来执行特定任务的代码块。方法可以有参数（Parameter），也可以有返回值（Return Value）。下面分别介绍方法的参数和返回值：</font></p><h3 id="方法的参数（Parameter）"><a href="#方法的参数（Parameter）" class="headerlink" title="方法的参数（Parameter）"></a>方法的参数（Parameter）</h3><p>1.参数是传递给方法的值，用于控制方法的行为。参数定义在方法的声明中，位于方法名之后，括号()内部，参数之间用逗号分隔。</p><blockquote><p>位置参数：调用方法时，参数值按照定义的顺序传递。<br>命名参数：在调用方法时，可以指定参数名，使得代码更清晰。<br>可选参数：使用optional关键字定义，调用时可以省略。<br>参数数组：使用params关键字定义，允许传递不定数量的参数。<br>输出参数：使用out关键字定义，方法可以返回多个值。</p></blockquote><h3 id="方法的返回值（Return-Value）"><a href="#方法的返回值（Return-Value）" class="headerlink" title="方法的返回值（Return Value）"></a>方法的返回值（Return Value）</h3><p>1.返回值是方法执行完毕后返回给调用者的值。返回值的类型在方法声明中指定。</p><blockquote><p>返回类型：方法声明时指定的类型，如int、string等。<br>返回语句：使用return关键字，后面跟返回值。<br>无返回值：使用void关键字，表示方法不返回任何值。<br>隐式返回值：对于void方法，不需要return语句，方法执行完毕后自动返回。</p></blockquote><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 带参数和返回值的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b; <span class="comment">// 返回值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带可选参数的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"><span class="built_in">string</span> message = <span class="string">&quot;Hello&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数数组的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] names</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> name <span class="keyword">in</span> names)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带输出参数的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Calculate</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> result</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = <span class="number">42</span>; <span class="comment">// 输出参数赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，Add方法接受两个整数参数并返回它们的和；Display方法有一个可选参数；Print方法接受一个参数数组；Calculate方法有一个输出参数。</p><h1 id="Csharp方法中的参数数组学习笔记"><a href="#Csharp方法中的参数数组学习笔记" class="headerlink" title="Csharp方法中的参数数组学习笔记"></a>Csharp方法中的参数数组学习笔记</h1><p>1.在C#中，参数数组是一种特殊的数组，它允许你传递一个不定数量的参数给方法。参数数组使用params关键字来声明，它只能作为方法的最后一个参数，并且只能声明一次。</p><p>2.以下是使用参数数组的一些基本规则：</p><blockquote><p>使用params关键字：在方法的参数列表中，使用params关键字来声明参数数组。<br>类型限制：参数数组必须是方法的最后一个参数，并且只能有一个。<br>传递参数：你可以像传递普通数组一样传递参数数组，也可以传递单个参数，编译器会自动将它们包装成数组。</p></blockquote><h3 id="下面是一个使用参数数组的简单示例："><a href="#下面是一个使用参数数组的简单示例：" class="headerlink" title="下面是一个使用参数数组的简单示例："></a>下面是一个使用参数数组的简单示例：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PrintSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 传递多个参数</span></span><br><span class="line">        PrintSum(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;); <span class="comment">// 传递数组</span></span><br><span class="line">        PrintSum(<span class="number">1</span>); <span class="comment">// 传递单个参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintSum</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] numbers</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> numbers)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += number;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Sum: <span class="subst">&#123;sum&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，PrintSum方法可以接受任意数量的整数参数。你可以传递单个整数、一个整数数组，或者多个整数作为参数。</p><p>参数数组在内部实际上是一个数组，所以你可以像使用普通数组一样使用它，例如通过索引访问元素、使用Length属性获取元素数量等。</p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp函数定义和调用学习笔记学习笔记</title>
      <link href="/2024/12/08/csharp%E5%87%BD%E6%95%B0%E4%B8%80/"/>
      <url>/2024/12/08/csharp%E5%87%BD%E6%95%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp函数定义和调用学习笔记"><a href="#Csharp函数定义和调用学习笔记" class="headerlink" title="Csharp函数定义和调用学习笔记"></a>Csharp函数定义和调用学习笔记</h1><h3 id="在C-中，函数通常被称为方法（Method）。方法是一种执行特定任务的代码块，可以包含参数（输入值），并可以返回结果。以下是C-中方法的定义和调用的基本步骤："><a href="#在C-中，函数通常被称为方法（Method）。方法是一种执行特定任务的代码块，可以包含参数（输入值），并可以返回结果。以下是C-中方法的定义和调用的基本步骤：" class="headerlink" title="在C#中，函数通常被称为方法（Method）。方法是一种执行特定任务的代码块，可以包含参数（输入值），并可以返回结果。以下是C#中方法的定义和调用的基本步骤："></a>在C#中，函数通常被称为方法（Method）。方法是一种执行特定任务的代码块，可以包含参数（输入值），并可以返回结果。以下是C#中方法的定义和调用的基本步骤：</h3><p>1.方法的定义</p><blockquote><p>访问修饰符：定义方法的可见性（如public, private, protected等）。<br>返回类型：方法执行完毕后返回的数据类型。<br>方法名称：方法的名称，遵循C#的命名规则。<br>参数列表：方法需要的输入值，包括类型和名称，由圆括号包围。<br>方法体：包含方法逻辑的代码块，由大括号 {} 包围。</p></blockquote><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法，没有参数，返回一个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">SayHello</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法，有两个参数，返回一个整数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">AddNumbers</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.方法的调用</p><blockquote><p>要调用一个方法，你需要使用方法的名称，后面跟着一对圆括号，如果方法有参数，则在圆括号内传递相应的参数值。</p></blockquote><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用没有参数的方法</span></span><br><span class="line">        <span class="built_in">string</span> helloMessage = myClass.SayHello();</span><br><span class="line">        Console.WriteLine(helloMessage); <span class="comment">// 输出: Hello, World!</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用有参数的方法</span></span><br><span class="line">        <span class="built_in">int</span> result = myClass.AddNumbers(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        Console.WriteLine(result); <span class="comment">// 输出: 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.静态方法</p><blockquote><p>静态方法不依赖于类的实例，可以直接通过类名来调用。</p></blockquote><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Utility</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetGreeting</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Good morning!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 直接通过类名调用静态方法</span></span><br><span class="line">        <span class="built_in">string</span> greeting = Utility.GetGreeting();</span><br><span class="line">        Console.WriteLine(greeting); <span class="comment">// 输出: Good morning!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.重载方法</p><blockquote><p>你可以在同一个类中定义多个同名方法，只要它们的参数列表不同（参数的类型和&#x2F;或数量不同）。</p></blockquote><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 方法重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Calculate</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Calculate</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Calculator calc = <span class="keyword">new</span> Calculator();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> intResult = calc.Calculate(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Console.WriteLine(intResult); <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">double</span> doubleResult = calc.Calculate(<span class="number">1.5</span>, <span class="number">2.5</span>);</span><br><span class="line">        Console.WriteLine(doubleResult); <span class="comment">// 输出: 4.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上述示例中，Calculate 方法被重载了两次，一次接受两个整数参数，另一次接受两个双精度浮点数参数。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp字符串遍历编程题三学习笔记</title>
      <link href="/2024/12/05/csharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%E7%BC%96%E7%A8%8B%E9%A2%983/"/>
      <url>/2024/12/05/csharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%E7%BC%96%E7%A8%8B%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h1 id="输入是个不相等的正整数，输出这10个正整数中的第二大的数。"><a href="#输入是个不相等的正整数，输出这10个正整数中的第二大的数。" class="headerlink" title="输入是个不相等的正整数，输出这10个正整数中的第二大的数。"></a>输入是个不相等的正整数，输出这10个正整数中的第二大的数。</h1><p>样例输入<br>3 5 7 2 9 5 3 10 3 8<br>样例输出<br>9</p><p>分析：</p><blockquote><p>定义两个变量设置为第一大数，和第二大数</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">string</span>[] strArray = str.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[strArray.Length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; intArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number=Convert.ToInt32(strArray[i]);</span><br><span class="line">        intArray[i] = number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> max1 = <span class="number">0</span>, max2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; intArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (intArray[i] &gt; max1)</span><br><span class="line">        &#123;</span><br><span class="line">            max2 = max1;</span><br><span class="line">            max1=intArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intArray[i] &gt; max2)</span><br><span class="line">            &#123;</span><br><span class="line">                max2 = intArray[i];</span><br><span class="line">            &#125;                        </span><br><span class="line">        &#125;                              </span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;第一大数&quot;</span> + max1 + <span class="string">&quot;第二大数&quot;</span> + max2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">4</span> <span class="number">9</span> <span class="number">7</span> <span class="number">10</span></span><br><span class="line">第一大数<span class="number">10</span>第二大数<span class="number">9</span></span><br></pre></td></tr></table></figure><h1 id="描述给定一个只包含小写字母的字符串，请你找出第一个仅出现一次的字符。如果没有，输出no。"><a href="#描述给定一个只包含小写字母的字符串，请你找出第一个仅出现一次的字符。如果没有，输出no。" class="headerlink" title="描述给定一个只包含小写字母的字符串，请你找出第一个仅出现一次的字符。如果没有，输出no。"></a>描述给定一个只包含小写字母的字符串，请你找出第一个仅出现一次的字符。如果没有，输出no。</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">int</span>[] countArray= <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;str.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        countArray[str[i]-<span class="string">&#x27;a&#x27;</span>]=countArray[str[i]-<span class="string">&#x27;a&#x27;</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bool</span> isFind = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">char</span> c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;str.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (countArray[str[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            isFind = <span class="literal">true</span>;</span><br><span class="line">            c = str[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFind == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果：-1"><a href="#输出结果：-1" class="headerlink" title="输出结果："></a>输出结果：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">levvel</span><br><span class="line">no</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">level</span><br><span class="line">v</span><br></pre></td></tr></table></figure><h1 id="大小写字母转换"><a href="#大小写字母转换" class="headerlink" title="大小写字母转换"></a>大小写字母转换</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">int</span> cha = <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; str.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">char</span> c = (<span class="built_in">char</span>)(str[i] + cha);</span><br><span class="line">            Console.Write(c);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; cha &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">char</span> c = (<span class="built_in">char</span>)(str[i] - cha);</span><br><span class="line">            Console.Write(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果：-2"><a href="#输出结果：-2" class="headerlink" title="输出结果："></a>输出结果：</h3> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fjsdjfFLKSJ</span><br><span class="line">FJSDJFflksj</span><br></pre></td></tr></table></figure><h1 id="在一个数组中查找一个给定的值，输出第一次出现的位置-从一开始）"><a href="#在一个数组中查找一个给定的值，输出第一次出现的位置-从一开始）" class="headerlink" title="在一个数组中查找一个给定的值，输出第一次出现的位置(从一开始）"></a>在一个数组中查找一个给定的值，输出第一次出现的位置(从一开始）</h1><blockquote><p>输入：3 8 23 45 2 5<br> 23<br> 输出：3</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">string</span>[] strArray = str.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[strArray.Length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; intArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n=Convert.ToInt32(strArray[i]);</span><br><span class="line">        intArray[i] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> number=Convert.ToInt32(Console.ReadLine());</span><br><span class="line">    <span class="built_in">int</span> location = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i&lt; intArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (number == intArray[i])</span><br><span class="line">        &#123;</span><br><span class="line">            location = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果：-3"><a href="#输出结果：-3" class="headerlink" title="输出结果："></a>输出结果：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">76</span> <span class="number">3</span> <span class="number">67</span></span><br><span class="line"><span class="number">76</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp字符串遍历编程题二学习笔记</title>
      <link href="/2024/12/03/csharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%E7%BC%96%E7%A8%8B%E9%A2%982/"/>
      <url>/2024/12/03/csharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%E7%BC%96%E7%A8%8B%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp编程题判断合法标识符。"><a href="#Csharp编程题判断合法标识符。" class="headerlink" title="Csharp编程题判断合法标识符。"></a>Csharp编程题判断合法标识符。</h1><p>1.输入一个字符串，判断其是否是c#的合法标识符。<br>2.分析：</p><blockquote><p>判断字符串是否不是是数字、字母（大小写）、下划线。<br>判断是否是数字开头（数字开头不是合法标识符）</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">bool</span> isRight = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; str.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((str[i] &lt; <span class="string">&#x27;0&#x27;</span> || str[i]&gt;<span class="string">&#x27;9&#x27;</span>)&amp;&amp;(str[i] &lt; <span class="string">&#x27;a&#x27;</span> || str[i]&gt;<span class="string">&#x27;z&#x27;</span>)&amp;&amp; (str[i] &lt; <span class="string">&#x27;A&#x27;</span> || str[i] &gt; <span class="string">&#x27;Z&#x27;</span>) &amp;&amp; (str[i] != <span class="string">&#x27;_&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            isRight = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;str[<span class="number">0</span>]&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        isRight=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRight)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;是合法字符&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;不是合法字符&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHFKHFRjgjidgj12</span><br><span class="line">是合法字符</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>JHSJFjlfjsd</span><br><span class="line">不是合法字符</span><br></pre></td></tr></table></figure><h1 id="Csharp编程题-回文串。"><a href="#Csharp编程题-回文串。" class="headerlink" title="Csharp编程题-回文串。"></a>Csharp编程题-回文串。</h1><p>1.“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。请写一个程序判断读入的字符串是否是“回文”。<br>2.分析：</p><blockquote><p>如果字符串是偶数的话，假如8&#x2F;2&#x3D;4，遍历0-3。如果是奇数的话，7&#x2F;2&#x3D;3，遍历0-2<br>假设字符串是8，那么索引对应的是0-7、1-6、2-5···，i对应的倒数length-1-i。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str = Console.ReadLine();</span><br><span class="line">    <span class="built_in">bool</span> ha = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; str.Length / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] != str[str.Length - <span class="number">1</span> - i])</span><br><span class="line">        &#123;</span><br><span class="line">            ha = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ha)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;是回文串&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;不是回文串&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 3.输出结果：<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> level</span><br><span class="line">是回文串</span><br></pre></td></tr></table></figure></p><h1 id="Csharp编程题-查找最长连续次数"><a href="#Csharp编程题-查找最长连续次数" class="headerlink" title="Csharp编程题-查找最长连续次数"></a>Csharp编程题-查找最长连续次数</h1><p>1.收集了连续N（1&lt;N&lt;10000000)天的最高气温数据。现在他想知道气温一直上升的最长连续天数。<br>样例输入：1 3 5 | 2 3 5 7 8 | 6 9<br>样例输出：5<br>2.分析：</p><blockquote><p>判断前面的数字是否比后面小<br>如果后面的连续最高天数比后面的连续天数高则更新一下。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">string</span>[] strArray = str.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">int</span>[] ints= <span class="keyword">new</span> <span class="built_in">int</span>[strArray.Length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ints.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number=Convert.ToInt32(strArray[i]);</span><br><span class="line">        ints[i]=number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> maxDays = <span class="number">0</span>;<span class="comment">//记录最高气温连续升高的天数</span></span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">1</span>;<span class="comment">//记录气温连续升高的天数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; ints.Length<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ints[i] &lt; ints[i + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; maxDays)</span><br><span class="line">            &#123;</span><br><span class="line">                maxDays = count;</span><br><span class="line">            &#125;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxDays)</span><br><span class="line">        &#123;</span><br><span class="line">            maxDays = count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;最高气温连续升高的最长天数&quot;</span> + maxDays);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp字符串遍历编程题学习笔记</title>
      <link href="/2024/12/01/csharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
      <url>/2024/12/01/csharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp字符串遍历编程题学习笔记"><a href="#Csharp字符串遍历编程题学习笔记" class="headerlink" title="Csharp字符串遍历编程题学习笔记"></a>Csharp字符串遍历编程题学习笔记</h1><p>1.输入n(n&lt;100)个数，找出其中最小的数，将它与最前面的数交换后输出这些数。</p><p>2.分析：</p><blockquote><p>1.先获取字符串（string str&#x3D;Console.ReadLine()）<br>2.字符串数组通过空格进行输入，使用string[] strArray&#x3D;str.Split(‘ ‘);<br>3.字符串转换整型,声明int[] intArray&#x3D;new int[strArray.Length];使用for循环转换赋值。<br>4.假设（索引）0最小int min&#x3D;intArray[0];那最小值和后面的索引进行比较，int一个变量进行存储最小值。<br>5.找到最小值和假设的进行位置交换，int一个临时变量进行存储（索引0），在把最小值放在（索引0）里面，然后再将临时变量放在最小值里面。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">string</span>[] strArray = str.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">int</span>[] intArray= <span class="keyword">new</span> <span class="built_in">int</span>[strArray.Length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; strArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number=Convert.ToInt32(strArray[i]);</span><br><span class="line">        intArray[i] = number; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> min = intArray[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; intArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (intArray[i] &lt; min)</span><br><span class="line">        &#123;</span><br><span class="line">            min = intArray[i];</span><br><span class="line">            minIndex = i;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> temp=intArray[<span class="number">0</span>];</span><br><span class="line">    intArray[<span class="number">0</span>] = intArray[minIndex];</span><br><span class="line">    intArray[minIndex] = temp;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="built_in">int</span> t <span class="keyword">in</span> intArray)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(t+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">54</span> <span class="number">56</span> <span class="number">32</span> <span class="number">42</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">54</span> <span class="number">56</span> <span class="number">32</span> <span class="number">42</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="排序-系统方法"><a href="#排序-系统方法" class="headerlink" title="排序-系统方法"></a>排序-系统方法</h2><p>1.编写一个控制台程序，要求用户输入一组数字空格间隔，，对用户输入的数字从小到大输出。</p><p>2.分析：</p><blockquote><p>可以用系统方法做出来（Array.Sort）</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">string</span>[] strArray = str.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">int</span>[] intArray= <span class="keyword">new</span> <span class="built_in">int</span>[strArray.Length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; intArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number=Convert.ToInt32(strArray[i]);</span><br><span class="line">        intArray[i]=number;</span><br><span class="line">    &#125;</span><br><span class="line">    Array.Sort(intArray);</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="built_in">int</span> i <span class="keyword">in</span> intArray)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp编程题学习笔记</title>
      <link href="/2024/11/30/csharp%E7%BC%96%E7%A8%8B%E9%A2%983/"/>
      <url>/2024/11/30/csharp%E7%BC%96%E7%A8%8B%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp编程题学习笔记"><a href="#Csharp编程题学习笔记" class="headerlink" title="Csharp编程题学习笔记"></a>Csharp编程题学习笔记</h1><h2 id="1-c-三个可乐可以换一瓶可乐，现再有364瓶可乐，问一共可以和多少瓶可乐，剩下几个空瓶"><a href="#1-c-三个可乐可以换一瓶可乐，现再有364瓶可乐，问一共可以和多少瓶可乐，剩下几个空瓶" class="headerlink" title="1.c#三个可乐可以换一瓶可乐，现再有364瓶可乐，问一共可以和多少瓶可乐，剩下几个空瓶"></a>1.c#三个可乐可以换一瓶可乐，现再有364瓶可乐，问一共可以和多少瓶可乐，剩下几个空瓶</h2><p>2.分析：</p><blockquote><p>1.这个问题可以通过循环来解决，每次循环计算出可以换到的可乐瓶数和剩下的空瓶数，直到剩下的空瓶数不足以换到一瓶可乐为止。<br>2.首先，我们有364瓶可乐，每3个空瓶可以换1瓶可乐。我们可以通过以下步骤来计算：<br>•以换到的可乐瓶数：364除以3，得到121瓶可乐，余数为1个空瓶。<br>•在我们有121瓶可乐和1个空瓶，总共122个空瓶。<br>•次计算可以换到的可乐瓶数：122除以3，得到40瓶可乐，余数为2个空瓶。<br>•在我们有40瓶可乐和2个空瓶，总共42个空瓶。<br>•再次计算可以换到的可乐瓶数：42除以3，得到14瓶可乐，余数为0个空瓶。<br>•现在我们有14瓶可乐和0个空瓶，总共14个空瓶。<br>•再次计算可以换到的可乐瓶数：14除以3，得到4瓶可乐，余数为2个空瓶。<br>•现在我们有4瓶可乐和2个空瓶，总共6个空瓶。<br>•再次计算可以换到的可乐瓶数：6除以3，得到2瓶可乐，余数为0个空瓶。<br>•现在我们有2瓶可乐和0个空瓶，总共2个空瓶。<br>•再次计算可以换到的可乐瓶数：2除以3，得到0瓶可乐，余数为2个空瓶。<br>•所以，总共可以换到的可乐瓶数为：121 + 40 + 14 + 4 + 2 &#x3D; 181瓶，最后剩下2个空瓶。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> pingNumber = <span class="number">364</span>;</span><br><span class="line">    <span class="built_in">int</span> heNumber = <span class="number">364</span>;</span><br><span class="line">    <span class="keyword">while</span> (pingNumber &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        heNumber += pingNumber / <span class="number">3</span>;</span><br><span class="line">        pingNumber = (pingNumber / <span class="number">3</span>) + (pingNumber % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;一共可以喝&quot;</span>+heNumber+<span class="string">&quot;,剩下&quot;</span>+pingNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一共可以喝<span class="number">545</span>,剩下<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="编写一个应用程序来输入的字符串进行加密，对于字母字符串加密规则如下："><a href="#编写一个应用程序来输入的字符串进行加密，对于字母字符串加密规则如下：" class="headerlink" title="编写一个应用程序来输入的字符串进行加密，对于字母字符串加密规则如下："></a>编写一个应用程序来输入的字符串进行加密，对于字母字符串加密规则如下：</h2><p>‘a’→’d’,’x’→’a’,’A’→’D’,’X’→’A’,<br>1.分析：</p><blockquote><p>字符是循环+3。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str=Console.ReadLine();</span><br><span class="line">    <span class="built_in">char</span>[] strArray= str.ToCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; strArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((strArray[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; strArray[i] &lt;= <span class="string">&#x27;z&#x27;</span>) || (strArray[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; strArray[i] &lt;= <span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            strArray[i] = (<span class="built_in">char</span>)(strArray[i] + <span class="number">3</span>);<span class="comment">//&#x27;a&#x27;+3 97+3=100=&#x27;d&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (strArray[i] &gt; <span class="string">&#x27;z&#x27;</span> &amp;&amp; strArray[i] &lt;= <span class="string">&#x27;z&#x27;</span> + <span class="number">3</span>)<span class="comment">//zyx</span></span><br><span class="line">            &#123;</span><br><span class="line">                strArray[i] = (<span class="built_in">char</span>)(strArray[i] - <span class="number">26</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (strArray[i] &gt; <span class="string">&#x27;Z&#x27;</span> &amp;&amp; strArray[i] &lt;= <span class="string">&#x27;Z&#x27;</span> + <span class="number">3</span>)<span class="comment">//XYZ</span></span><br><span class="line">            &#123;</span><br><span class="line">                strArray[i]= (<span class="built_in">char</span>)(strArray[i] - <span class="number">26</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">char</span> temp <span class="keyword">in</span> strArray)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(temp+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp什么是数组，数组的遍历笔记</title>
      <link href="/2024/11/29/csharp%E6%95%B0%E7%BB%84/"/>
      <url>/2024/11/29/csharp%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h1><p>1.数组是一种常用的数据结构，用于存储同一类型的多个值。在编程中，数组可以被看作是一个容器，其中包含了固定数量的元素，这些元素通常是相同类型的数据。以下是数组的一些基本特性：</p><blockquote><p>1.元素类型一致：数组中的所有元素都是同一数据类型的，比如整数、浮点数、字符等。<br>2.连续存储：数组的元素在内存中是连续存放的，这意味着它们拥有连续的内存地址。<br>3.索引访问：可以通过索引（通常是从0开始的整数）来访问数组中的元素。例如，如果有一个名为arr的数组，那么可以通过arr[0]来访问第一个元素，arr[1]来访问第二个元素，以此类推。<br>4.固定大小：在某些编程语言中，数组的大小是固定的，一旦声明，其长度就不能改变。而在其他语言中，如Python的列表，数组的大小是动态的，可以根据需要增长和缩小。<br>5.遍历：可以遍历数组中的所有元素，通常使用循环结构（如for循环）来实现。<br>6.操作：数组支持多种操作，如查找、插入、删除、排序等。</p></blockquote><h2 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h2><blockquote><p>类型[] 数组名；<br>数组名遵守变量命名规则</p></blockquote><h2 id="数组的赋值"><a href="#数组的赋值" class="headerlink" title="数组的赋值"></a>数组的赋值</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] ages=&#123;<span class="number">46</span>,<span class="number">45</span>,<span class="number">3</span>,<span class="number">53</span>,<span class="number">5</span>,<span class="number">2</span>&#125;</span><br><span class="line">ages=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>]；</span><br><span class="line">ages=<span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">76</span>,<span class="number">8</span>&#125;</span><br><span class="line">ages=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">6</span>]&#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">42</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的使用（修改和读取）"><a href="#数组的使用（修改和读取）" class="headerlink" title="数组的使用（修改和读取）"></a>数组的使用（修改和读取）</h2><p>通过索引（下标），索引从0开始。<br>可以把数组想象成一个火车，一个车厢里面存储的就是数据元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//声明int类型的数据</span><br><span class="line">       int[] ages=&#123;46,45,3,53,5,2&#125;</span><br><span class="line">//数组的数据有下标   0  1  2 3  4 5</span><br><span class="line">//数组名[索引]</span><br><span class="line">age[index]</span><br></pre></td></tr></table></figure><blockquote><p>注意：不能访问索引不存在的值</p></blockquote><h1 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h1><blockquote><p>1.声明一个int的数组，数组大小为9<br>2.声明一个char的数组，数组长度为20<br>3.声明一个float数组，数组长度为5<br>4.声明一个字符串数组，数组长度为8</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] inta = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">9</span>];</span><br><span class="line"><span class="built_in">char</span>[] chara=<span class="keyword">new</span> <span class="built_in">char</span>[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">float</span>[] floata = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">string</span>[] stringa = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">8</span>];</span><br></pre></td></tr></table></figure><h1 id="这么遍历一个数组？（正序和倒序）"><a href="#这么遍历一个数组？（正序和倒序）" class="headerlink" title="这么遍历一个数组？（正序和倒序）"></a>这么遍历一个数组？（正序和倒序）</h1><blockquote><p>遍历就是取得数组中的每一个值<br> 遍历索引-通过索引访问元素</p></blockquote><p> 1.通过for和while遍历一个数组<br> 2.通过foreach遍历一个数组</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> int[] ages = &#123; 23, 45, 67, 12, 34, 56, 8, 34, 23, 3 &#125;;</span><br><span class="line">for(int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(ages[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] ages = &#123; 23, 45, 67, 12, 34, 56, 8, 34, 23, 3 &#125;;</span><br><span class="line">for(int i = 9; i&gt;=0; i--)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(ages[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在我们不知道数组的长度时可以用ages.Length获取ages的长度。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">int</span>[] ages = &#123; <span class="number">23</span>, <span class="number">45</span>, <span class="number">67</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">8</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;ages.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(ages[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int[] ages = &#123; 23, 45, 67, 12, 34, 56, 8, 34, 23, 3 &#125;;</span><br><span class="line">int i = 0;</span><br><span class="line">while (i &lt; 10)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(ages[i]+&quot; &quot;);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">```CSHARP倒序</span><br><span class="line">int[] ages = &#123; 23, 45, 67, 12, 34, 56, 8, 34, 23, 3 &#125;;</span><br><span class="line">int i = 9;</span><br><span class="line">while (i &gt;= 0)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(ages[i]+&quot; &quot;);</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><blockquote><p>在C#中，foreach 循环是一种简洁且高效的方式来遍历数组、集合或任何实现了 IEnumerable 或 IEnumerable<T>接口的对象。foreach 循环会自动处理迭代过程，你只需要关注每个元素的处理逻辑。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">int</span>[] ages = &#123; <span class="number">23</span>, <span class="number">45</span>, <span class="number">67</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">8</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> age <span class="keyword">in</span> ages)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(age+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp基本数据类型—浮点型，类型转换学习笔记</title>
      <link href="/2024/11/27/csharp%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2/"/>
      <url>/2024/11/27/csharp%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp基本数据类型：浮点型"><a href="#Csharp基本数据类型：浮点型" class="headerlink" title="Csharp基本数据类型：浮点型"></a>Csharp基本数据类型：浮点型</h1><blockquote><p>浮点数值类型表示实数。 所有浮点型数值类型均为值类型。 它们还是简单类型，可以使用文本进行初始化。 所有浮点数值类型都支持算术、比较和相等运算符。</p></blockquote><h2 id="浮点类型的特征"><a href="#浮点类型的特征" class="headerlink" title="浮点类型的特征"></a>浮点类型的特征</h2><p><img src="/img%5Cfudianxing.png"></p><p>1.浮点数在计算机中是以IEEE 754标准来存储的，这意味着它们可以表示非常大或非常小的数，并且可以表示非整数。</p><p>2.以下是一些关于C#浮点型的重要点：</p><blockquote><p>浮点数的精度是有限的，因此在进行浮点数运算时可能会出现精度损失。<br>浮点数可以表示正数、负数和零。<br>浮点数也可以表示特殊值，如正无穷(double.PositiveInfinity)、负无穷(double.NegativeInfinity)和NaN（不是一个数字，double.NaN）。<br>在比较浮点数时，应该使用一定的容差来判断两个数是否“相等”，因为直接比较可能会因为精度问题导致不准确的结果。<br>浮点数的舍入模式可以通过Math.Round方法或者MidpointRounding枚举来控制。<br>使用浮点型时，需要考虑到这些特性和限制，以确保程序的正确性和健壮性。</p></blockquote><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>1.在C#中，转义字符是一种特殊的字符序列，以反斜杠（\）开始，用来表示那些不能直接表示的字符或者具有特殊含义的字符。以下是一些常用的转义字符：</p><blockquote><p>1.换行符（\n）：插入一个新行。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(&quot;Hello,\nWorld!&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>2.回车符（\r）：将光标移动到当前行的开头。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(&quot;Hello,\rWorld!&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>3.制表符（\t）：插入一个水平制表符（Tab）。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(&quot;Hello,\tWorld!&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>4.反斜杠（\）：表示一个实际的反斜杠字符。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string path = &quot;C:\\Program Files\\Example&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>5.单引号（&#39;）：表示一个单引号字符。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string text = &quot;He&#x27;s the one.&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>6.双引号（&quot;）：表示一个双引号字符。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string text = &quot;He said \&quot;Hello\&quot; to me.&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>7.问号（?）：表示一个问号字符。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string text = &quot;What&#x27;s this?&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>8.空字符（\0）：表示一个空字符（null character）。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string text = &quot;Hello\0World&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>9.Unicode转义序列（\uXXXX 或 \UXXXXXXXX）：表示一个Unicode字符，其中XXXX是四位十六进制数，XXXXXXXX是八位十六进制数。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string text = &quot;\u00A9&quot;; // © symbol</span><br><span class="line">string text = &quot;\U0001F600&quot;; // 😀 emoji</span><br></pre></td></tr></table></figure><blockquote><p>10.八进制转义序列（\XXX）：表示一个ASCII字符，其中XXX是三位八进制数。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string text = &quot;\7&quot;; // 表示ASCII码为7的字符，即BEL（响铃）字符</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp基本数据类型—整型学习笔记</title>
      <link href="/2024/11/26/csharp%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/26/csharp%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp基本数据类型：整型"><a href="#Csharp基本数据类型：整型" class="headerlink" title="Csharp基本数据类型：整型"></a>Csharp基本数据类型：整型</h1><blockquote><p>整型数值类型 表示整数。 所有的整型数值类型均为值类型。 它们还是简单类型，可以使用文本进行初始化。 所有整型数值类型都支持算术、位逻辑、比较和相等运算符。</p></blockquote><p>1.C# 支持以下预定义整型类型：<br><img src="/img%5Czhengxing.png"></p><h2 id="在C-中，整数数据类型分为有符号和无符号两种，它们的主要区别在于值的范围和是否包含负数。"><a href="#在C-中，整数数据类型分为有符号和无符号两种，它们的主要区别在于值的范围和是否包含负数。" class="headerlink" title="在C#中，整数数据类型分为有符号和无符号两种，它们的主要区别在于值的范围和是否包含负数。"></a>在C#中，整数数据类型分为有符号和无符号两种，它们的主要区别在于值的范围和是否包含负数。</h2><p>1.有符号整数（Signed Integers）：</p><blockquote><p>可以表示正数、负数和零。<br>常见的有符号整数类型包括：<br>sbyte：8位有符号整数，范围从 -128 到 127。<br>short：16位有符号整数，范围从 -32,768 到 32,767。<br>int：32位有符号整数，范围从 -2,147,483,648 到 2,147,483,647。<br>long：64位有符号整数，范围从 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。</p></blockquote><p>2.无符号整数（Unsigned Integers）：</p><blockquote><p>只能表示正数和零，不能表示负数。<br>常见的无符号整数类型包括：<br>byte：8位无符号整数，范围从 0 到 255。<br>ushort：16位无符号整数，范围从 0 到 65,535。<br>uint：32位无符号整数，范围从 0 到 4,294,967,295。<br>ulong：64位无符号整数，范围从 0 到 18,446,744,073,709,551,615。</p></blockquote><p>3.区别：</p><blockquote><p>值的范围：无符号整数类型的值范围从0开始，而有符号整数类型的值范围则包括负数。<br>内存占用：相同位数的有符号和无符号整数占用的内存大小是相同的，但是无符号整数可以表示更大的正数值。<br>溢出行为：当整数运算结果超出其类型所能表示的范围时，会发生溢出。有符号整数溢出时可能会变成一个负数，而无符号整数溢出时会从0开始循环。<br>默认值：有符号整数类型的默认值是0，而无符号整数类型的默认值也是0。<br>使用场景：有符号整数通常用于需要表示正负值的场景，而无符号整数通常用于计数器、索引、数组长度等只能取非负值的场景。<br>在实际编程中，选择使用有符号还是无符号整数类型，应根据具体的应用场景和需求来决定。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp循环嵌套基本用法学习笔记</title>
      <link href="/2024/11/25/csharp%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/"/>
      <url>/2024/11/25/csharp%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-循环嵌套的基本用法"><a href="#1-循环嵌套的基本用法" class="headerlink" title="1.循环嵌套的基本用法"></a>1.循环嵌套的基本用法</h1><blockquote><p>C# 中的循环嵌套是指在一个循环内部再包含另一个循环。这种结构通常用于处理多维数组或需要多级迭代的情况。以下是一些常见的循环嵌套示例，包括 for 循环和 foreach 循环的嵌套。</p></blockquote><p><font size="5">1.输入两个整数n和m,输出n行m列的*阵</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> n=Convert.ToInt32 (Console.ReadLine());</span><br><span class="line"><span class="built_in">int</span> m=Convert.ToInt32 (Console.ReadLine());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><font size="5">输出结果：</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p><font size="5">2.输入整数n,输出n层的三角形</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> n=Convert.ToInt32 (Console.ReadLine());</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write (<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="5">输出结果：</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br><span class="line">******</span><br></pre></td></tr></table></figure><p><font size="5">3.输入整数n,输出n层的三角形的斜边。</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> n=Convert.ToInt32 (Console.ReadLine());</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i<span class="number">-1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="5">输出结果：</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line">*</span><br><span class="line"> *</span><br><span class="line">  *</span><br><span class="line">   *</span><br><span class="line">    *</span><br><span class="line">     *</span><br></pre></td></tr></table></figure><p><font size="5">4.如果我们要让它反过来呢？.输入整数n。</font></p><blockquote><p>1.前面的题我们都是从小到大开始遍历，而这次是从大到小遍历。<br>2.因为是从大到小第一个for循环初始化i&#x3D;n;i&gt;0;i–;</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> n=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i<span class="number">-1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="5">输出结果：</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line">     *</span><br><span class="line">    *</span><br><span class="line">   *</span><br><span class="line">  *</span><br><span class="line"> *</span><br><span class="line">*</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp循环嵌套九九乘法表、买鸡和最大公约数笔记</title>
      <link href="/2024/11/25/csharp%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
      <url>/2024/11/25/csharp%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp编程题，九九乘法表和百文买鸡问题"><a href="#Csharp编程题，九九乘法表和百文买鸡问题" class="headerlink" title="Csharp编程题，九九乘法表和百文买鸡问题"></a>Csharp编程题，九九乘法表和百文买鸡问题</h1><p>1.使用嵌套循环写出九九乘法表<br>分析：</p><blockquote><p>1.选择for语句进行嵌套循环<br> 2.最外层循环9次，子循环递增到9次</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            console.Write(<span class="string">&quot;&#123;0&#125;*&#123;1&#125;=&#123;2&#125;&quot;</span>,j,i,i*j);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 输出结果：<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> * <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> * <span class="number">2</span> = <span class="number">2</span>   <span class="number">2</span> * <span class="number">2</span> = <span class="number">4</span></span><br><span class="line"><span class="number">1</span> * <span class="number">3</span> = <span class="number">3</span>   <span class="number">2</span> * <span class="number">3</span> = <span class="number">6</span>   <span class="number">3</span> * <span class="number">3</span> = <span class="number">9</span></span><br><span class="line"><span class="number">1</span> * <span class="number">4</span> = <span class="number">4</span>   <span class="number">2</span> * <span class="number">4</span> = <span class="number">8</span>   <span class="number">3</span> * <span class="number">4</span> = <span class="number">12</span>   <span class="number">4</span> * <span class="number">4</span> = <span class="number">16</span></span><br><span class="line"><span class="number">1</span> * <span class="number">5</span> = <span class="number">5</span>   <span class="number">2</span> * <span class="number">5</span> = <span class="number">10</span>   <span class="number">3</span> * <span class="number">5</span> = <span class="number">15</span>   <span class="number">4</span> * <span class="number">5</span> = <span class="number">20</span>   <span class="number">5</span> * <span class="number">5</span> = <span class="number">25</span></span><br><span class="line"><span class="number">1</span> * <span class="number">6</span> = <span class="number">6</span>   <span class="number">2</span> * <span class="number">6</span> = <span class="number">12</span>   <span class="number">3</span> * <span class="number">6</span> = <span class="number">18</span>   <span class="number">4</span> * <span class="number">6</span> = <span class="number">24</span>   <span class="number">5</span> * <span class="number">6</span> = <span class="number">30</span>   <span class="number">6</span> * <span class="number">6</span> = <span class="number">36</span></span><br><span class="line"><span class="number">1</span> * <span class="number">7</span> = <span class="number">7</span>   <span class="number">2</span> * <span class="number">7</span> = <span class="number">14</span>   <span class="number">3</span> * <span class="number">7</span> = <span class="number">21</span>   <span class="number">4</span> * <span class="number">7</span> = <span class="number">28</span>   <span class="number">5</span> * <span class="number">7</span> = <span class="number">35</span>   <span class="number">6</span> * <span class="number">7</span> = <span class="number">42</span>   <span class="number">7</span> * <span class="number">7</span> = <span class="number">49</span></span><br><span class="line"><span class="number">1</span> * <span class="number">8</span> = <span class="number">8</span>   <span class="number">2</span> * <span class="number">8</span> = <span class="number">16</span>   <span class="number">3</span> * <span class="number">8</span> = <span class="number">24</span>   <span class="number">4</span> * <span class="number">8</span> = <span class="number">32</span>   <span class="number">5</span> * <span class="number">8</span> = <span class="number">40</span>   <span class="number">6</span> * <span class="number">8</span> = <span class="number">48</span>   <span class="number">7</span> * <span class="number">8</span> = <span class="number">56</span>   <span class="number">8</span> * <span class="number">8</span> = <span class="number">64</span></span><br><span class="line"><span class="number">1</span> * <span class="number">9</span> = <span class="number">9</span>   <span class="number">2</span> * <span class="number">9</span> = <span class="number">18</span>   <span class="number">3</span> * <span class="number">9</span> = <span class="number">27</span>   <span class="number">4</span> * <span class="number">9</span> = <span class="number">36</span>   <span class="number">5</span> * <span class="number">9</span> = <span class="number">45</span>   <span class="number">6</span> * <span class="number">9</span> = <span class="number">54</span>   <span class="number">7</span> * <span class="number">9</span> = <span class="number">63</span>   <span class="number">8</span> * <span class="number">9</span> = <span class="number">72</span>   <span class="number">9</span> * <span class="number">9</span> = <span class="number">81</span></span><br></pre></td></tr></table></figure><br>2.用100文买一百只鸡，其中公鸡，母鸡，都必须要有，公鸡3文一只，母鸡5文一只，小鸡2文一只，请问公鸡、母鸡、小鸡要买多少只刚好凑齐100文。<br>1.要求：每种鸡都要有且有几种买法。<br>2.分析：</p><blockquote><p>通过三层循环来遍历所有可能的公鸡、母鸡和小鸡的组合，以找到满足条件的解决方案。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> roosters=<span class="number">1</span>;roosters&lt;=<span class="number">100</span>/<span class="number">3</span>;roosters++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> hen = <span class="number">1</span>; hen &lt;= <span class="number">100</span> / <span class="number">5</span>; hen++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> pullet=<span class="number">1</span>; pullet&lt;=<span class="number">100</span> / <span class="number">2</span>; pullet++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((roosters * <span class="number">3</span> + hen * <span class="number">5</span> + pullet * <span class="number">2</span>) == <span class="number">100</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;公鸡：&#123;0&#125;，母鸡：&#123;1&#125;，小鸡：&#123;2&#125;&quot;</span>,roosters,hen,pullet);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>3.输入两个整数num1和num2,输出这两个正整数num1和num2的最大公约数。<br>1.分析：</p><blockquote><p>1.什么是最大公约数:两个或多个 整数 共有 约数 中最大的一个。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> num1=Convert.ToInt32(Console.ReadLine());</span><br><span class="line">    <span class="built_in">int</span> num2=Convert.ToInt32(Console.ReadLine());</span><br><span class="line">    <span class="built_in">int</span> min = num1;</span><br><span class="line">    <span class="keyword">if</span>(num2 &lt; min)</span><br><span class="line">    &#123;</span><br><span class="line">        min = num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = min; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 % i == <span class="number">0</span> &amp;&amp; num2 % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;最大公约数&quot;</span>+i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp认识新的类Random学习笔记</title>
      <link href="/2024/11/25/%E8%AE%A4%E8%AF%86%E6%96%B0%E7%9A%84%E7%B1%BBRandom/"/>
      <url>/2024/11/25/%E8%AE%A4%E8%AF%86%E6%96%B0%E7%9A%84%E7%B1%BBRandom/</url>
      
        <content type="html"><![CDATA[<h1 id="Csharp简单认识Random类"><a href="#Csharp简单认识Random类" class="headerlink" title="Csharp简单认识Random类"></a>Csharp简单认识Random类</h1><p>1.定义</p><blockquote><p>表示伪随机数生成器，这是一种能够产生满足某些随机性统计要求的数字序列的算法。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Random</span></span><br></pre></td></tr></table></figure><p>2.示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Random rd = <span class="keyword">new</span> Random();</span><br><span class="line">    Console.WriteLine(rd.Next(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>随机1到10；</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h2><p>1.随机，循环，才对停止循环。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Random rd = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="built_in">int</span> number=rd.Next(<span class="number">1</span>,<span class="number">101</span>);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> numberUser=Convert.ToInt32(Console.ReadLine());</span><br><span class="line">        <span class="keyword">if</span> (numberUser &gt; number)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;你猜大了&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numberUser&lt;number)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;你猜小了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numberUser==number)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;你猜对了&quot;</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p> 输出结果：(随机，结果不唯一)<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">20</span></span><br><span class="line">你猜大了</span><br><span class="line"><span class="number">50</span></span><br><span class="line">你猜大了</span><br><span class="line"><span class="number">10</span></span><br><span class="line">你猜对了</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp笔记各种循环编程题二。</title>
      <link href="/2024/11/24/csharp%E7%BC%96%E7%A8%8B%E9%A2%982/"/>
      <url>/2024/11/24/csharp%E7%BC%96%E7%A8%8B%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h1 id="1-编写一共程序，打印出所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位数字立方等于该数本身。"><a href="#1-编写一共程序，打印出所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位数字立方等于该数本身。" class="headerlink" title="1.编写一共程序，打印出所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位数字立方等于该数本身。"></a>1.编写一共程序，打印出所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位数字立方等于该数本身。</h1><p>1.要求：例如153&#x3D;1<em>1</em>1+5<em>5</em>5+3<em>3</em>3，所以153是“水仙花”。</p><p>2.输入153</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">100</span>; i &lt;= <span class="number">999</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> ge = i % <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">int</span> shi = (i / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">int</span> bai = i / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == ge * ge * ge + shi * shi * shi + bai * bai * bai)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">370</span></span><br><span class="line"><span class="number">371</span></span><br><span class="line"><span class="number">407</span></span><br></pre></td></tr></table></figure><h1 id="随机一个未知的整数，去除这个整数各个位上的0，形成新的数，并输出。"><a href="#随机一个未知的整数，去除这个整数各个位上的0，形成新的数，并输出。" class="headerlink" title="随机一个未知的整数，去除这个整数各个位上的0，形成新的数，并输出。"></a>随机一个未知的整数，去除这个整数各个位上的0，形成新的数，并输出。</h1><p>1.要求：输入的数字n大于0，小于1000000。</p><p>2.输入2020</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a= Convert.ToInt32(Console.ReadLine()); <span class="comment">//2020</span></span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> cheng = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(a != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = a % <span class="number">10</span>;<span class="comment">//0 202 //2 20//0 2 //2</span></span><br><span class="line">    <span class="keyword">if</span>(i != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i *= cheng; <span class="comment">//2 //2</span></span><br><span class="line">        sum+= i;<span class="comment">//2 //2</span></span><br><span class="line">        cheng *= <span class="number">10</span>;<span class="comment">//20 //20</span></span><br><span class="line">    &#125;</span><br><span class="line">    a = a / <span class="number">10</span>; <span class="comment">//2 //2</span></span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(sum); <span class="comment">//22</span></span><br></pre></td></tr></table></figure><p>3.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure><h1 id="随机数入一个整数num-输出一个新的数，新数恰好与原数每一位上的数字相反（如果原数末尾有多个零，输出的新数高位不含0）"><a href="#随机数入一个整数num-输出一个新的数，新数恰好与原数每一位上的数字相反（如果原数末尾有多个零，输出的新数高位不含0）" class="headerlink" title="随机数入一个整数num,输出一个新的数，新数恰好与原数每一位上的数字相反（如果原数末尾有多个零，输出的新数高位不含0）"></a>随机数入一个整数num,输出一个新的数，新数恰好与原数每一位上的数字相反（如果原数末尾有多个零，输出的新数高位不含0）</h1><p>1.样例输入8736 输出6378<br>  样例输入2300 输出32</p><p>  2.输入8736</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> num=Convert.ToInt32(Console.ReadLine());<span class="comment">//8736</span></span><br><span class="line"><span class="built_in">bool</span> yudao = <span class="literal">false</span>; <span class="comment">//默认还没有遇到第一个非0</span></span><br><span class="line"><span class="keyword">while</span> (num!=<span class="number">0</span>) <span class="comment">//从第到高位遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = num % <span class="number">10</span>; <span class="comment">//6 873</span></span><br><span class="line">    <span class="comment">//判断是否遇到了第一个非0数字</span></span><br><span class="line">    <span class="comment">//已经遇到了第一个非0数字</span></span><br><span class="line">    <span class="comment">//不需要去掉0了</span></span><br><span class="line">    <span class="comment">//还没有遇到第一个非0数字</span></span><br><span class="line">    <span class="comment">//去掉</span></span><br><span class="line">    <span class="keyword">if</span> (yudao == <span class="literal">false</span>)<span class="comment">//还没有遇到第一个非0数字</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>)<span class="comment">//i=6</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i);</span><br><span class="line">            <span class="comment">//标志位，标志是否达到了某个条件</span></span><br><span class="line">            yudao= <span class="literal">true</span>;<span class="comment">//确定i!=0时，停止判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">else</span><span class="comment">//i=3</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i);</span><br><span class="line">        &#125;</span><br><span class="line">    num = num / <span class="number">10</span>;<span class="comment">//8736 873</span></span><br></pre></td></tr></table></figure><p>  3.输出结果<br>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6378</span></span><br></pre></td></tr></table></figure></p><h1 id="回文数和倒序读都是一样的整数。输入一个数，判断是否是回文数。输入的整数大于0，小于1000000。"><a href="#回文数和倒序读都是一样的整数。输入一个数，判断是否是回文数。输入的整数大于0，小于1000000。" class="headerlink" title="回文数和倒序读都是一样的整数。输入一个数，判断是否是回文数。输入的整数大于0，小于1000000。"></a>回文数和倒序读都是一样的整数。输入一个数，判断是否是回文数。输入的整数大于0，小于1000000。</h1><p>  1.要求：如果是回文输出yes，不是输出no。<br>  2.输入2397<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">int</span> n=Convert.ToInt32(Console.ReadLine());<span class="comment">//2992</span></span><br><span class="line"><span class="built_in">int</span> tempN = n;</span><br><span class="line"><span class="built_in">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (tempN != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = tempN % <span class="number">10</span>;<span class="comment">//2 299  //9 29 //9 2 //2</span></span><br><span class="line">    number *= <span class="number">10</span>;<span class="comment">//0*10=0 //20 //290 //2990</span></span><br><span class="line">    number += i;<span class="comment">//2 //29 //299 //2992</span></span><br><span class="line">    tempN = tempN / <span class="number">10</span>;<span class="comment">//299 //29 //2 //0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (number == n)</span><br><span class="line">&#123;</span><br><span class="line">   Console.WriteLine(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp笔记各种循环编程题一。</title>
      <link href="/2024/11/22/csharp%E7%BC%96%E7%A8%8B%E9%A2%981/"/>
      <url>/2024/11/22/csharp%E7%BC%96%E7%A8%8B%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h1 id="1-一个球从某一高度落下，每次落地后反跳回原来高度的一半，再落下。"><a href="#1-一个球从某一高度落下，每次落地后反跳回原来高度的一半，再落下。" class="headerlink" title="1.一个球从某一高度落下，每次落地后反跳回原来高度的一半，再落下。"></a>1.一个球从某一高度落下，每次落地后反跳回原来高度的一半，再落下。</h1><p>1.要求：球第十次反弹多高？在第十次落地时，共经过多少米？<br>2.要求：输入球的初始高度，输出反弹多高，和经过了多少米。</p><p>3.分析：</p><blockquote><p>1.我们可以用int n来确定球的从多高往下弹。<br>    2.再利用for循环来求出球体的第十次反弹多高和经过了多少米<br>    3.可以用double来定义high存储第十次的高，因为反弹是原来的一半，for的表达式：high&#x2F;&#x3D;2;。<br>    4.再用double来定义distance存储反弹的和，2*n来确定第一次谈的高，因为反弹是原来的一半<br>    第2个for的表达式：distance&#x2F;&#x3D;2;。</p></blockquote><p>4.输入100。</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> n=Convert.ToInt32 (Console.ReadLine());</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> high = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    high /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine (high);</span><br><span class="line"><span class="built_in">double</span> distance = <span class="number">2</span> * n;</span><br><span class="line"><span class="built_in">double</span> sum = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i= <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    distance /= <span class="number">2</span>;</span><br><span class="line">    sum += distance;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine (sum);</span><br></pre></td></tr></table></figure><p> 5.输出结果：<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0.09765625</span></span><br><span class="line"><span class="number">299.609375</span></span><br></pre></td></tr></table></figure></p><h1 id="2-输入一个整数a，和一个正整数n，计算乘方a的次方"><a href="#2-输入一个整数a，和一个正整数n，计算乘方a的次方" class="headerlink" title="2.输入一个整数a，和一个正整数n，计算乘方a的次方"></a>2.输入一个整数a，和一个正整数n，计算乘方a的次方</h1><p>1.要求：使用循环来计算a的次方。</p><p>2.分析：</p><blockquote><p>1.用int a和n。在double来定义一个变量sum来存储a的次方，再利用for循环来判断次方大小。for循环表达式：sum*&#x3D;n;</p></blockquote><p>3.输入a&#x3D;5,n&#x3D;5</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;           </span><br><span class="line">    <span class="built_in">int</span> a = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">    <span class="built_in">int</span> n = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">    <span class="built_in">double</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum *= n;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(sum);</span><br></pre></td></tr></table></figure><p>4.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3125</span></span><br></pre></td></tr></table></figure><h1 id="3-我国现有x亿人口，按每年0-1-的增长速度，n年后将有多少人？"><a href="#3-我国现有x亿人口，按每年0-1-的增长速度，n年后将有多少人？" class="headerlink" title="3.我国现有x亿人口，按每年0.1%的增长速度，n年后将有多少人？"></a>3.我国现有x亿人口，按每年0.1%的增长速度，n年后将有多少人？</h1><p>1.要求：使用循环求n年后有多少人。</p><p>2.分析：</p><blockquote><p>1.人口是用数字统计，我们可用double定义一个值，在int nian定义过了多少年。<br>2.用for循环，表达式：rankou*&#x3D;1.001;</p></blockquote><p>3.输入rankou&#x3D;120000,nian&#x3D;12</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line"><span class="built_in">double</span> rankou = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"> <span class="built_in">int</span> nian = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nian; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     rankou *= <span class="number">1.001</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> Console.WriteLine(rankou);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 4.输出结果：<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">121447.94645949498</span></span><br></pre></td></tr></table></figure></p><h1 id="投资，已知投资的复合利率为R-0到20之间的整数-。投M钱（100到1000000之间的整数）。投资Y年（范围0到400）。"><a href="#投资，已知投资的复合利率为R-0到20之间的整数-。投M钱（100到1000000之间的整数）。投资Y年（范围0到400）。" class="headerlink" title="投资，已知投资的复合利率为R(0到20之间的整数)。投M钱（100到1000000之间的整数）。投资Y年（范围0到400）。"></a>投资，已知投资的复合利率为R(0到20之间的整数)。投M钱（100到1000000之间的整数）。投资Y年（范围0到400）。</h1><p> 1.要求：投资共赚多少钱？</p><p> 2.分析：</p><blockquote><p>1.复合利率给我们的范围是0到20之间，我就取10好了，复合利率是10除100就是它的复合利率。<br>2.用double来第一变量R、M、Y,和sum来存储答案。</p></blockquote><p>3.输入R&#x3D;10，M&#x3D;50000，Y&#x3D;20</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="built_in">double</span> R=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="built_in">double</span> M=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="built_in">double</span> Y=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="built_in">double</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;Y;i++)</span><br><span class="line">&#123;</span><br><span class="line">    M *= (R / <span class="number">100.0</span>) + <span class="number">1</span>;</span><br><span class="line">    sum += M;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3150124.972129084</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程题：用循环做出挖掘数字并计算和（笔记）</title>
      <link href="/2024/11/20/csharp%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%8F%96/"/>
      <url>/2024/11/20/csharp%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1-挖掘数字，并并计算这些数字的和"><a href="#1-挖掘数字，并并计算这些数字的和" class="headerlink" title="1.挖掘数字，并并计算这些数字的和"></a><font size="8"><b>1.挖掘数字，并并计算这些数字的和</font></b></h1><blockquote><p>知识点：<br>1.如何读取一个字符输入<br>2.输入缓冲区<br>3.break跳出循环</p></blockquote><p><font size="5"><b>1.数字和字符混合在一起了，作为一个优秀的挖掘人员，把输入的数字挖出来并计算这些数字的和，并输出。输入以@作为结束。 样例输入23a34b34@  样例输出19</p><blockquote><p>只学到循环如何做出这道难题</fotn></b></p></blockquote><p><font size="5"><b>2.分析：</fotn></b></p><blockquote><p>1.这题我们可以用ASCII码来做，用char输出字符。<br>2。用if来判断是否是数字。<br>在int定义一个变量来存储和</p></blockquote><p><font size="5">3.输入值：234SKHF23@</fotn></b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> c;</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    c = (<span class="built_in">char</span>)Console.Read();</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        sum += number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (c != <span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">Console.WriteLine(sum);</span><br></pre></td></tr></table></figure><p><font size="5">4.输出结果：</fotn></b></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">234</span>SKHF23@</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><h1 id="什么是缓冲区"><a href="#什么是缓冲区" class="headerlink" title="什么是缓冲区"></a><font size="8"><b>什么是缓冲区</font></b></h1><blockquote><p>在C#中，缓冲区通常指的是一块内存区域，用于临时存储数据。缓冲区在处理I&#x2F;O操作（如文件读写、网络通信等）时非常有用，因为它们可以减少实际的I&#x2F;O操作次数，提高性能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量的作用域</title>
      <link href="/2024/11/19/%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2024/11/19/%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="C-变量里的作用域"><a href="#C-变量里的作用域" class="headerlink" title="C#变量里的作用域"></a><font size="8">C#变量里的作用域</font></b></h1><p><font size="6">一.什么是作用域</font></b></p><blockquote><p>作用域（Scope）是编程中的一个基本概念，它定义了代码中变量、函数、类等实体的可见性和生命周期。作用域决定了在程序的哪些部分可以访问或修改这些实体。</p></blockquote><p><font size="6">二.C#变量作用域中一些关键点</font></b></p><p>1.局部作用域是指在编程中，变量或函数仅在定义它们的特定代码块或区域内可见和可访问的作用域。这种作用域通常与局部变量和局部函数相关联，它们只在创建它们的函数、方法或代码块内部有效。以下是局部作用域的一些关键特点：</p><p>定义位置：局部变量或函数通常在函数、方法或代码块内部定义。</p><p>可见性：局部变量或函数只在定义它们的函数、方法或代码块内部可见。一旦代码执行离开了这个区域，局部变量或函数就不再可访问。</p><p>生命周期：局部变量的生命周期通常与定义它们的函数或代码块的执行周期相同。当函数或代码块执行结束时，局部变量会被销毁，占用的内存会被释放。</p><p>初始化：在某些编程语言中，局部变量在使用前必须被初始化，否则可能会引发错误或警告。</p><p>同名变量：在不同的函数或代码块中可以定义同名的局部变量，它们是独立的，互不影响。</p><p>参数传递：当函数或方法被调用时，实参的值会被复制到对应的局部变量（形参）中，局部变量的修改不会影响实参的值，除非使用了引用传递或指针。</p><p>作用域链：在支持闭包的语言中，局部变量可以被嵌套函数访问，形成作用域链。</p><p>重用性：局部变量的名称可以在不同的函数或代码块中重复使用，因为它们的作用域是独立的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Main方法开始执行&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 定义一个局部变量</span></span><br><span class="line">            <span class="built_in">int</span> localVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// localVar仅在这个代码块内部可见</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;局部变量的值: &quot;</span> + localVar);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这个点，localVar不再存在，因为它的作用域已经结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在C#中，全局作用域的概念与传统的全局变量有所不同。C#是一种面向对象的编程语言，它鼓励封装和模块化，因此并不直接支持传统意义上的全局变量。然而，可以通过以下几种方式来实现全局可访问的数据：</p><blockquote><p>静态成员变量和静态属性：<br>在C#中，可以通过静态类和静态成员来模拟全局变量的效果。静态成员属于类本身，而不是类的任何特定实例。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">csharp</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Global</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> GlobalValue = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在程序的任何地方都可以这样访问</span></span><br><span class="line"><span class="built_in">int</span> <span class="keyword">value</span> = Global.GlobalValue;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for语句学习笔记</title>
      <link href="/2024/11/12/for%E8%AF%AD%E5%8F%A5/"/>
      <url>/2024/11/12/for%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="for循环笔记"><a href="#for循环笔记" class="headerlink" title="for循环笔记"></a><font size="8"></b>for循环笔记</font></b></h1><blockquote><p>for循环输出执行循环次数<br>for(初始化；条件表达式；增量表达式)<br>{  &#x2F;&#x2F;循环体<br>}</p></blockquote><p><b><font size="5">1.fot循环的基本结构</font></b></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b><font size="5">2.fot语句的元素</font></b></p><blockquote><p>“初始化表达式”部分仅在进入循环前执行一次。 通常，在该部分中声明并初始化局部循环变量。 不能从 for 语句外部访问声明的变量。</p></blockquote><p>上例中的“初始化表达式”部分声明并初始化整数计数器变量：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>“条件”部分确定是否应执行循环中的下一个迭代。 如果计算结果为 true 或不存在，则执行下一个迭代；否则退出循环。 “条件”部分必须为布尔表达式。</p></blockquote><p>上例中的“条件”条件部分检查计数器值是否小于 10：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i&lt;<span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p>“迭代器”部分定义循环主体的每次执行后将执行的操作。</p></blockquote><p>上例中的“迭代器”部分增加计数器：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i++</span><br></pre></td></tr></table></figure><blockquote><p>循环体，必须是一个语句或一个语句块。</p></blockquote><h2 id="用for循环进行简单的计算"><a href="#用for循环进行简单的计算" class="headerlink" title="用for循环进行简单的计算"></a><font size="7">用for循环进行简单的计算</font></h2><p><font size="5"><b>1.进行计算整数1-100的和<font></b></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>;i&lt;<span class="number">101</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i; </span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(sum);</span><br><span class="line">                          </span><br></pre></td></tr></table></figure><p><font size="5"></b>2.求1-100的偶数</font></b></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>;i&lt;<span class="number">101</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="5"><b>3.输入俩个整数n和m，计算n和m（包括n和m)所有能被17整除的数的和，并输出和。</font></b> </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> n=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="built_in">int</span> m=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="built_in">int</span> i = n; i &lt;= m; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (i % <span class="number">17</span> == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         sum += i;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> Console.WriteLine(sum);</span><br></pre></td></tr></table></figure><p> <font size="5"><b>4.输入俩个整数n和m，利用for循环打印出n和m之间（包含n和m），所用的奇数和所用的偶数。<br> 奇数放一行，用空格分割。偶数放一行，用空格分割。</font></b></p><blockquote><p>应为要同时输出奇数和偶数，我们可以先定义俩个字符串(string)进行存储。<br> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">int</span> n=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="built_in">int</span> m=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"><span class="built_in">string</span> oddNumbers = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> numbered = <span class="string">&quot;&quot;</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="built_in">int</span> i = n; i &lt;= m; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         oddNumbers += i+<span class="string">&quot; &quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         numbered += i+<span class="string">&quot; &quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> Console.WriteLine(oddNumbers);</span><br><span class="line"> Console.WriteLine(numbered);</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a><font size="8"><b>break语句</font></b></h2><blockquote><p>break 语句：将终止最接近的封闭迭代语句（即 for、foreach、while 或 do 循环）或 switch 语句。 break 语句将控制权转交给已终止语句后面的语句</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( ; ; )</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine( i );</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>while循环语句</title>
      <link href="/2024/11/10/while%E8%AF%AD%E5%8F%A5/"/>
      <url>/2024/11/10/while%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a><font size="8"></b>while循环语句</font></b></h1><blockquote><p>在指定的布尔表达式的计算结果为 true 时，while 语句会执行一条语句或一个语句块。 由于在每次执行循环之前都会计算此表达式，所以 while 循环会执行零次或多次。</p></blockquote><h2 id="while语句基本结构"><a href="#while语句基本结构" class="headerlink" title="while语句基本结构"></a><font size="5"><b>while语句基本结构</font></b></h2><p><img src="/img%5Cyouxin%5Cwhile1.png"><br><b>1.while语句基本用法</b></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int x = 1;</span><br><span class="line">while (x&lt;10)    //条件判断</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(x);</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(&quot;x&gt;10&quot;);   //条件不满足，执行代码</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="while循环求和"><a href="#while循环求和" class="headerlink" title="while循环求和"></a><font size="5"><b>while循环求和</font></b></h2><p><b>1.控制循环次数？循环1-100。</b></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x=1;</span><br><span class="line">while(x&lt;100)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(x);</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>2.用while就1-100的整数和</b><br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> //第一种方式//局限性、固定的循环次数</span><br><span class="line"> int a = 1;</span><br><span class="line">int sum = 0;    //存放和</span><br><span class="line">while (a &lt; 101)</span><br><span class="line">&#123;</span><br><span class="line">    sum += a;  //sun=sum+a</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(sum);</span><br><span class="line"></span><br><span class="line">//第二种方式//可以设置你像输出的循环次数</span><br><span class="line"> int n=Convert.ToInt32(Console.ReadLine());</span><br><span class="line"> int a = 1;</span><br><span class="line"> int sum = 0;</span><br><span class="line"> while (a &lt; n+1)</span><br><span class="line"> &#123;</span><br><span class="line">     sum += a;</span><br><span class="line">     a++;</span><br><span class="line"> &#125;</span><br><span class="line"> Console.WriteLine(sum);</span><br></pre></td></tr></table></figure><br><b>3.输出1-100的偶数</b></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int n = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">int a = 1;</span><br><span class="line">while (a &lt; n+1)</span><br><span class="line">&#123;</span><br><span class="line">    if (a % 2 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(a);</span><br><span class="line">    &#125;</span><br><span class="line">    a++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><b>4.输入俩个整数n1,n2,输出n1-n2之间所有的偶数</b></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int n1=Convert.ToInt32(Console.ReadLine());</span><br><span class="line">int n2=Convert.ToInt32(Console.ReadLine());</span><br><span class="line">while (n1 &lt; n2 + 1)</span><br><span class="line">&#123;</span><br><span class="line">    if (n1 % 2 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(n1);</span><br><span class="line">    &#125;</span><br><span class="line">    n1++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>5.3n+1:对于任意大于1的自然数n，若n为奇数，将n编程3n+1，否则变成n的一半。经过若干次这样的变化，n一定会最终变成1，比如，7→22→11→34→17→52→26→13→40→20→10→5→16→8→4→2→1<br>输入n，输出变化次数。</b></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int num = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">int a = 0;</span><br><span class="line">while (num != 1)</span><br><span class="line">&#123;</span><br><span class="line">    if (num % 2 == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        num = 3 * num + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        num /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    a++;</span><br><span class="line">    Console.WriteLine(&quot;变换后的值&quot;+num);</span><br><span class="line">&#125; Console.WriteLine(&quot;变换的次数&quot;+a);</span><br></pre></td></tr></table></figure><h1 id="do-while循环学习笔记"><a href="#do-while循环学习笔记" class="headerlink" title="do-while循环学习笔记"></a><font size="8"><b>do-while循环学习笔记</font></b></h1><h2 id="do-while的基本结构"><a href="#do-while的基本结构" class="headerlink" title="do-while的基本结构"></a><font size="6"><b>do-while的基本结构</font></b></h2><blockquote><p>在指定的布尔表达式的计算结果为 true 时，do 语句会执行一条语句或一个语句块。 由于在每次执行循环之后都会计算此表达式，所以 do 循环会执行一次或多次。 do 循环不同于 while 循环（该循环执行零次或多次）。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(n);</span><br><span class="line">    n++;</span><br><span class="line">&#125; <span class="keyword">while</span> (n &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装AE插件</title>
      <link href="/2024/11/06/%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/"/>
      <url>/2024/11/06/%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="AE插件的安装"><a href="#AE插件的安装" class="headerlink" title="AE插件的安装"></a><font size="8">AE插件的安装</font></h1><blockquote><p>学剪辑想要有电影那样的好看特效就少不了插件的帮助，这期教大家下载插件</p></blockquote><h2 id="插件在哪下载呢？"><a href="#插件在哪下载呢？" class="headerlink" title="插件在哪下载呢？"></a><font size="6">插件在哪下载呢？</font></h2><p><font size="4"><b>1.还是有很多人不知道插件在哪下载，有很多人在b站搜AE插件安装，基本都是都是加微信，交钱进群啥的！浪费时间和钱插件还没拿到。</font></b></p><blockquote><p>这里我分享最全的下插件网站：<a href="https://www.lookae.com/">https://www.lookae.com/</a></p></blockquote><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a><font size="6">安装步骤</font></h2><p><font size="4"><b>1.打开looke.ae这个网站，在搜索框中输入你要安装的插件，博主就用<font color="red">Magic Bullet Suite v2023.2.1（红巨人）</font>这个插件来教大家安装：</font></b></p><blockquote><p>这个也是做剪辑常用的调色插件</p></blockquote><p><font size="4"><b>2.第一步，找到要下载的插件并看它是否支持你的AE的版本，选择下载方式。</font></b></p><blockquote><p>下面中文汉化是需要付费的且更新没有英文的快（推荐英文版）</p></blockquote><p><img src="/img%5Cyouxin%5CMan.png"><br><font size="4"><b>3.将我们下载的文件进行解压（推荐Bandizip这个解压软件，电脑自带的微软商店就可以下载到.）</font></b><br><img src="/img%5Cyouxin%5CMan1.png"></p><h2 id="按照步骤即可"><a href="#按照步骤即可" class="headerlink" title="按照步骤即可"></a>按照步骤即可</h2><p><font size="4"><b>4. 1..Maxon_App_2023.2.2_Win.exe，不要登录，安装完成之后关闭即可<br>2.安装Magic Bullet Suite Installer.exe，安装完成之后关闭即可<br>3.安装Unlocker 2023.2.1.exe，即可完成激活。</font></b></p>]]></content>
      
      
      <categories>
          
          <category> AE </category>
          
          <category> 插件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>素材补帧、4k</title>
      <link href="/2024/11/04/%E7%B4%A0%E6%9D%90%E8%A1%A5%E5%B8%A7%EF%BC%8C4k/"/>
      <url>/2024/11/04/%E7%B4%A0%E6%9D%90%E8%A1%A5%E5%B8%A7%EF%BC%8C4k/</url>
      
        <content type="html"><![CDATA[<h1 id="给素材补帧让视频变得丝滑"><a href="#给素材补帧让视频变得丝滑" class="headerlink" title="给素材补帧让视频变得丝滑"></a>给素材补帧让视频变得丝滑</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><blockquote><p>给视频补帧，先给视频进行抽帧在补帧效果更好，下面是操作步骤：</p></blockquote><p>1.将视频导入AE,抽帧就是以你要补帧的人物（主体）为第一要素，第一要素动了就裁剪一次：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;border-radius: 12px">    <iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113429784298208&bvid=BV1uTDhYTEBV&cid=26627605593&p=1" page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 80%; width: 100%;border-radius: 12px"> </iframe></div>2.将视频用Me导出来（也是looked.ae下载），在进行补帧。<blockquote><p>1.我在这里分享两个好用的补帧软件，让你的视频丝滑无比。</p></blockquote><h2 id="第一个：Flowframes"><a href="#第一个：Flowframes" class="headerlink" title="第一个：Flowframes"></a>第一个：<font color="blue">Flowframes</font></h2><p>2.第一步打开flow,如图：↓<br><img src="/img%5Cflow.png"><br>3.点击Browse(Video)，选择要补帧的片段，在选择你要补的帧数按interpolate开始补帧。</p><h2 id="第二个：SVFI"><a href="#第二个：SVFI" class="headerlink" title="第二个：SVFI"></a>第二个：<font color="blue">SVFI</font></h2><p>1.这个补帧软件是我用过最好的，唯一的缺点就是要钱但只补帧的话只需买社区服43元（steam上面购买），这个软件还可以补4K、8k、超分。（但要买专业版328）<br>我这有平替，他就是：<font size="5">VideoAIportable</font></p><h2 id="第二个：SVFI-1"><a href="#第二个：SVFI-1" class="headerlink" title="第二个：SVFI"></a>第二个：<font color="blue">SVFI</font></h2><p>1.这个补帧软件是我用过最好的，唯一的缺点就是要钱但只补帧的话只需买社区服43元（steam上面购买），这个软件还可以补4K、8k、超分。（但要买专业版328）<br>我这有平替，他就是：<font size="5">Topaz VideoAIportable</font></p><p>2.先用SVFI进行补帧。打开SVFI的高级设置先进行调试，可以参考我的来：<br>一.<img src="/img%5Cyouxin%5Csvfi.png"><br>二.<img src="/img%5Cyouxin%5Csvfi1.png"><br>三.<img src="/img%5Cyouxin%5Csvfi2.png"><br>四.<img src="/img%5Cyouxin%5Csvfi3.png"></p><h2 id="视频补4K"><a href="#视频补4K" class="headerlink" title="视频补4K"></a>视频补4K</h2><p>没有 <font size="4">Topaz VideoAIportable</font> 的在looke.ae也可以下载的。</p><p>1.打开<font size="4">Topaz VideoAIportable</font>导入素材可以按照我这样设置：<br><img src="/img%5Cyouxin%5CTopaz.png"><br><font size="4">请看对比</font></p><p><img src="/img%5Cyouxin%5CTopaz1.png"><br>2.导出即可</p>]]></content>
      
      
      <categories>
          
          <category> AE </category>
          
          <category> SVFI </category>
          
          <category> Topaz VideoAIportable </category>
          
          <category> Flowframes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日常</title>
      <link href="/2024/10/30/YOUXIANDEYU/"/>
      <url>/2024/10/30/YOUXIANDEYU/</url>
      
        <content type="html"><![CDATA[<h1 id="博主的随心日常"><a href="#博主的随心日常" class="headerlink" title="博主的随心日常"></a></b><em>博主的随心日常</em></b></h1><h2 id="2024年"><a href="#2024年" class="headerlink" title="2024年"></a>2024年</h2><h3 id="11月1日"><a href="#11月1日" class="headerlink" title="11月1日"></a>11月1日</h3><!-- <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;border-radius: 12px">    <iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113316101884629&bvid=BV1TRmAYSE94&cid=26314608616&p=1" page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 80%; width: 100%;border-radius: 12px"> </iframe></div> --><blockquote><p>今天明日方舟更新5.5周年了（有没有和博主玩一样的游戏啊），攒了70抽开开心心上线抽卡，出了俩个金，歪了个叔叔潜能+1。给我出个没有的都好啊！<br>说说我对这游戏的评价吧，21年那会儿我是被同学带入坑的那时第一次接触这种类型的游戏感觉很好玩很新颖，后面也玩过很多这种类型的二游但还是明日方舟更好，尽管现在不怎么玩了。<br>可能是新鲜感过了吧。关卡出的没意思，抽卡一直是非酋。如今每天上线就是刷体力完成每日就下了。<br>现在唯一好玩的的就是它出的危机合约了。🥱🥱🥱</p></blockquote><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;border-radius: 12px"><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113407286052207&bvid=BV1NgSRYbEAQ&cid=26564363331&p=1" page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 80%; width: 100%;border-radius: 12px"> </iframe></div><blockquote><p>新出的塑心皮肤还是很好看的。喜欢😍😍😍</p></blockquote><p><img src="/img/youxin/%E5%A1%91%E5%BF%83.jpg"><br><img src="/img/youxin/%E5%A1%91%E5%BF%831.jpg"></p><h3 id="11月3日"><a href="#11月3日" class="headerlink" title="11月3日"></a>11月3日</h3><blockquote><p>看完CS,2024BLAST全球总决赛。<br>恭喜G2夺冠</p></blockquote><p><img src="/img/youxin/G2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AE素材获取</title>
      <link href="/2024/10/30/AE%E7%B4%A0%E6%9D%90%E6%8F%90%E7%BA%AF/"/>
      <url>/2024/10/30/AE%E7%B4%A0%E6%9D%90%E6%8F%90%E7%BA%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="学习漫剪第一步：获取素材"><a href="#学习漫剪第一步：获取素材" class="headerlink" title="学习漫剪第一步：获取素材"></a><b>学习漫剪第一步：获取素材</b></h1><blockquote><p>我们下好软件之和就是去寻找素材，很多人都不知道或是用录频软件去录制带字幕的视频，这里我分享资源多可以下载生肉的网站。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mikanime.tv/</span><br></pre></td></tr></table></figure><p>1.这个网站只能下载种子到迅雷把视频下载下来。</p><blockquote><p>看到这就有人问博主博主网上不是有很多免费bit下载软件，博主为啥还是推荐迅雷呢？<br>因为迅雷不充钱也比这些免费bit下载速度快。</p></blockquote><p>2.下面是图片描述：<br><img src="/img/mingan.png" alt="图片描述"><br>3.然后搜索你要下载的动漫种子，点击种子自动跳转迅雷下载所选择的盘。<br><img src="/img/mangan1.png" alt="图片描述"><br>4.<b>博主前期出一些操作简单，内容不会很多且好理解的教程。</b></p>]]></content>
      
      
      <categories>
          
          <category> AE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蜜柑计划 </tag>
            
            <tag> 迅雷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# if、swatch学习笔记</title>
      <link href="/2024/10/30/%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
      <url>/2024/10/30/%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本人是一名初学者，欢迎各位大佬指正。<br>记录自己学习c#过程中的心得体会。</p></blockquote><p><font size="6"> C# if、switch的基本关系与使用 </font><br></p><blockquote><p>1.if语句有两种表达方式，第1种是包含 else 部分的 if 语句根据布尔表达式的值选择两个语句中的一个来执行，如以下示例所示：</p></blockquote><figure class="highlight c#"><figcaption><span>if else...</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">int</span> number=Convert.ToInt32(Console.ReadLine()); <span class="comment">//定义一个整数</span></span><br><span class="line">           <span class="keyword">if</span> (number &gt;= <span class="number">0</span>)  <span class="comment">//条件</span></span><br><span class="line">           &#123;</span><br><span class="line">                  Console.WriteLine(<span class="string">&quot;博主好帅&quot;</span>); <span class="comment">// 满足条件输出</span></span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">else</span>  </span><br><span class="line">             &#123;</span><br><span class="line">                  Console.WriteLine(<span class="string">&quot;博主最帅&quot;</span>); <span class="comment">//不满足条件输出</span></span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.第二种是else嵌套if语句可以判断多个条件：</p></blockquote><figure class="highlight c#"><figcaption><span>else-if...</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> number=Convert.ToInt32(Console.ReadLine());  <span class="comment">//定义一个整数</span></span><br><span class="line">            <span class="keyword">if</span> (number == <span class="number">0</span>)  <span class="comment">//条件1</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;YOU&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (number &gt; <span class="number">0</span>)  <span class="comment">//条件2</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;XIAN&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; <span class="number">0</span>)  <span class="comment">//条件3</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;YU&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (number != <span class="number">0</span>)  <span class="comment">//条件4</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;YOUXIANYU&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;XX&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.switch语句是根据与匹配表达式匹配的模式来选择要执行的语句列表，如以下示例所示：</p></blockquote><figure class="highlight c#"><figcaption><span>输入4个整数，判断最大值和最小值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Schema;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">switch</span>语句2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">int</span> a = Convert.ToInt32(Console.ReadLine());  <span class="comment">//定义一个整数</span></span><br><span class="line">            <span class="built_in">int</span> b = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">            <span class="built_in">int</span> c = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">            <span class="built_in">int</span> d = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> max = a, min = a;  <span class="comment">//赋值</span></span><br><span class="line">            <span class="keyword">if</span> (max &lt; b)  </span><br><span class="line">            &#123;</span><br><span class="line">                max = b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; c)</span><br><span class="line">            &#123;</span><br><span class="line">                max = c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; d)</span><br><span class="line">            &#123;</span><br><span class="line">                max = d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; b)</span><br><span class="line">            &#123;</span><br><span class="line">                min = b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; c)</span><br><span class="line">            &#123;</span><br><span class="line">                min = c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; d)</span><br><span class="line">            &#123;</span><br><span class="line">                min = d;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;最大的值&#123;0&#125;，最小的值&#123;1&#125;.&quot;</span>, max, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csharp编程基础 </category>
          
          <category> Visual Studio 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> Visual Studio 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何安装Adobe AfterEffects 2022</title>
      <link href="/2024/10/29/%E6%BC%AB%E5%89%AA/"/>
      <url>/2024/10/29/%E6%BC%AB%E5%89%AA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是我第一次写博客,就写一个自己热爱的漫剪。<br>1.所以就从安装Adobe AfterEffects 2022开始，分享一下软件的安装教程吧！<br>后续还会有更多的教程分享！</p></blockquote><h1 id="Adobe-AfterEffects-2022-安装教程"><a href="#Adobe-AfterEffects-2022-安装教程" class="headerlink" title="Adobe AfterEffects 2022 安装教程"></a><em><strong>Adobe AfterEffects 2022 安装教程</strong></em></h1><h2 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1.下载安装包"></a>1.下载安装包</h2><blockquote><p>2.首先，你需要到Adobe官网下载安装包，地址为：</p></blockquote><p> <a href="https://www.adobe.com/products/aftereffects.html">https://www.adobe.com/products/aftereffects.html</a></p><blockquote><p>哈哈，上面是正版Adobe软件，主要是给公司、和团队使用（如果不使用正版懂得懂得😜😜😜）<br>个人使用就用汉化版的就行啦↓<br><a href="https://www.rjctx.com/">https://www.rjctx.com/</a> </p></blockquote><p> 1.第一步进入网站，在搜索框里输入<b>Adobe After Efects</b>, 选择你喜欢的版本下载。</p><blockquote><p><b>温馨提示：版本上的不同软件上会有一定上的区别，还有就是后续的教学会使用到插件如果版本太高或太低就会出现插件上我有的效果你没有和效果不一样。</p></blockquote><p><img src="https://s2.loli.net/2024/10/31/WboNGvH9trF7xnQ.png" alt="AE.png"></p><p>2.随便选一个你喜欢的方式下载：<br>    <img src="https://s2.loli.net/2024/10/31/xFQiIahM61ly2SC.png" alt="AE.png"></p><blockquote><p><b>温馨提示2：下好的安装包可以放在除C盘的任意盘中但安装路径默认C盘就行，了解过AE的都知道经常会崩溃放在C盘会减少这种事情的发生（电脑好就不必理会）</b></p></blockquote><p>3.等它安装好就可以使用啦！！！😊😊😊</p>]]></content>
      
      
      <categories>
          
          <category> AE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Adobe After Effects 2022 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
